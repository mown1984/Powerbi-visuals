!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.loaded = !0, module.exports;
    }
    var installedModules = {};
    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
    __webpack_require__.p = "", __webpack_require__(0);
}([ function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(13);
}, , , , , , , , , , , , , function(module, exports, __webpack_require__) {
    function requireAll(requireContext) {
        return requireContext.keys().map(requireContext);
    }
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
    window.jsCommon = window.jsCommon || {}, window.powerbi = window.powerbi || {}, 
    window.debug = window.debug || {}, window.InJs = window.InJs || {}, requireAll(__webpack_require__(14)), 
    __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), 
    __webpack_require__(41), __webpack_require__(42), __webpack_require__(43), __webpack_require__(44), 
    __webpack_require__(45), __webpack_require__(46), __webpack_require__(47), __webpack_require__(48), 
    __webpack_require__(49), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), 
    __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), 
    __webpack_require__(57);
}, function(module, exports, __webpack_require__) {
    function webpackContext(req) {
        return __webpack_require__(webpackContextResolve(req));
    }
    function webpackContextResolve(req) {
        return map[req] || function() {
            throw new Error("Cannot find module '" + req + "'.");
        }();
    }
    var map = {
        "./styles/styles.less": 15,
        "./visuals/asterPlot/visual/styles/asterPlot.less": 17,
        "./visuals/bulletChart/visual/styles/bulletChart.less": 18,
        "./visuals/chicletSlicer/visual/styles/chicletSlicer.less": 19,
        "./visuals/chordChart/visual/styles/chordChart.less": 20,
        "./visuals/dotPlot/visual/styles/dotPlot.less": 21,
        "./visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less": 22,
        "./visuals/forceGraph/visual/styles/forceGraph.less": 23,
        "./visuals/gantt/visual/styles/gantt.less": 24,
        "./visuals/globeMap/visual/styles/globeMap.less": 25,
        "./visuals/histogram/visual/styles/histogram.less": 26,
        "./visuals/lineDotChart/visual/styles/lineDotChart.less": 27,
        "./visuals/mekkoChart/visual/styles/mekkoChart.less": 28,
        "./visuals/pulseChart/visual/styles/pulseChart.less": 29,
        "./visuals/radarChart/visual/styles/radarChart.less": 30,
        "./visuals/sankeyDiagram/visual/styles/sankeyDiagram.less": 31,
        "./visuals/streamGraph/visual/styles/streamGraph.less": 32,
        "./visuals/sunburst/visual/styles/sunburst.less": 33,
        "./visuals/timeline/visual/styles/timeline.less": 34,
        "./visuals/tornadoChart/visual/styles/tornadoChart.less": 35,
        "./visuals/wordCloud/visual/styles/wordCloud.less": 36
    };
    webpackContext.keys = function() {
        return Object.keys(map);
    }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
    webpackContext.id = 14;
}, function(module, exports) {}, , function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, ValueFormatter = powerbi.visuals.valueFormatter, AsterPlotVisualClassName = "asterPlot", AsterRadiusRatio = .9, AsterConflictRatio = .9, AsterPlotWebBehavior = function() {
                    function AsterPlotWebBehavior() {}
                    return AsterPlotWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.selection = options.selection, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.hasHighlights = options.hasHighlights, this.selection.on("click", function(d, i) {
                            selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        }), this.renderSelection(this.interactivityService.hasSelection());
                    }, AsterPlotWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var _this = this;
                        this.selection.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, _this.hasHighlights);
                        });
                    }, AsterPlotWebBehavior;
                }(), AsterPlotWarning = function() {
                    function AsterPlotWarning(message) {
                        this.message = message;
                    }
                    return Object.defineProperty(AsterPlotWarning.prototype, "code", {
                        get: function() {
                            return "AsterPlotWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlotWarning.prototype.getMessages = function(resourceProvider) {
                        return {
                            message: this.message,
                            title: resourceProvider.get(""),
                            detail: resourceProvider.get("")
                        };
                    }, AsterPlotWarning;
                }();
                samples.AsterPlotWarning = AsterPlotWarning;
                var VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            var _this = this;
                            this.previousOriginalViewportValue = _.clone(this.originalViewportValue), this.originalViewportValue = _.clone(value), 
                            this.setUpdateObject(value, function(v) {
                                return _this.viewportValue = v;
                            }, function(o) {
                                return VisualLayout.restrictToMinMax(o, _this.minViewport);
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
                        get: function() {
                            return _.clone(this.viewport);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.minViewportValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.marginValue = this.defaultMargin);
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.marginValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
                        get: function() {
                            return !(!this.originalViewportValue || this.previousOriginalViewportValue && this.previousOriginalViewportValue.height === this.originalViewportValue.height && this.previousOriginalViewportValue.width === this.originalViewportValue.width);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.prototype.setUpdateObject = function(object, setObjectFn, beforeUpdateFn) {
                        var _this = this;
                        object = _.clone(object), setObjectFn(VisualLayout.createNotifyChangedObject(object, function(o) {
                            beforeUpdateFn && beforeUpdateFn(object), _this.update();
                        })), beforeUpdateFn && beforeUpdateFn(object), this.update();
                    }, VisualLayout.createNotifyChangedObject = function(object, objectChanged) {
                        var result = {};
                        return _.keys(object).forEach(function(key) {
                            return Object.defineProperty(result, key, {
                                get: function() {
                                    return object[key];
                                },
                                set: function(value) {
                                    object[key] = value, objectChanged(object, key);
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                        }), result;
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        return _.keys(value).forEach(function(x) {
                            return value[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), value;
                    }, VisualLayout;
                }(), Helpers = function() {
                    function Helpers() {}
                    return Helpers.setAttrThroughTransitionIfNotResized = function(element, setTransision, attrName, attrValue, attrTransitionValue, viewportChanged) {
                        viewportChanged ? element.attr(attrName, attrValue) : setTransision(element.transition()).attrTween(attrName, attrTransitionValue);
                    }, Helpers.interpolateArc = function(arc) {
                        return function(data) {
                            if (!this.oldData) return this.oldData = data, function() {
                                return arc(data);
                            };
                            var interpolation = d3.interpolate(this.oldData, data);
                            return this.oldData = interpolation(0), function(x) {
                                return arc(interpolation(x));
                            };
                        };
                    }, Helpers.addContext = function(context, fn) {
                        return function() {
                            return fn.apply(context, [ this ].concat(_.toArray(arguments)));
                        };
                    }, Helpers;
                }(), AsterPlotSettings = function() {
                    function AsterPlotSettings() {
                        this.legend = {
                            show: !1,
                            position: visuals.LegendPosition[visuals.LegendPosition.Top],
                            showTitle: !0,
                            titleText: "",
                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                            fontSize: 8
                        }, this.labels = {
                            show: !1,
                            color: visuals.dataLabelUtils.defaultLabelColor,
                            displayUnits: 0,
                            precision: visuals.dataLabelUtils.defaultLabelPrecision,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt
                        }, this.outerLine = {
                            show: !1,
                            thickness: 1
                        };
                    }
                    return Object.defineProperty(AsterPlotSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlotSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, AsterPlotSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, AsterPlotSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, AsterPlotSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return powerbi.DataViewObjects.getFillColor;

                          default:
                            return powerbi.DataViewObjects.getValue;
                        }
                    }, AsterPlotSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new visuals.ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, AsterPlotSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, AsterPlotSettings;
                }();
                samples.AsterPlotSettings = AsterPlotSettings;
                var AsterPlotColumns = function() {
                    function AsterPlotColumns() {
                        this.Category = null, this.Y = null;
                    }
                    return AsterPlotColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, AsterPlotColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, AsterPlotColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, AsterPlotColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, AsterPlotColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return visuals.converterHelper.getSeriesName(x.source);
                        });
                    }, AsterPlotColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, AsterPlotColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, AsterPlotColumns.Roles = Object.freeze(_.mapValues(new AsterPlotColumns(), function(x, i) {
                        return i;
                    })), AsterPlotColumns;
                }();
                samples.AsterPlotColumns = AsterPlotColumns;
                var AsterPlot = function() {
                    function AsterPlot() {}
                    return AsterPlot.converter = function(dataView, colors) {
                        var categorical = AsterPlotColumns.getCategoricalColumns(dataView), catValues = AsterPlotColumns.getCategoricalValues(dataView);
                        if (categorical && categorical.Category && !_.isEmpty(categorical.Category.values) && !_.isEmpty(categorical.Y) && !_.isEmpty(categorical.Y[0].values)) {
                            for (var settings = AsterPlot.parseSettings(dataView, categorical.Category.source), properties = AsterPlotSettings.getProperties(AsterPlot.capabilities), dataPoints = [], highlightedDataPoints = [], legendData = {
                                dataPoints: [],
                                title: null,
                                fontSize: AsterPlotSettings.Default.legend.fontSize,
                                labelColor: visuals.LegendData.DefaultLegendLabelFillColor
                            }, colorHelper = new visuals.ColorHelper(colors), hasHighlights = !!categorical.Y[0].highlights, maxValue = Math.max(d3.min(categorical.Y[0].values)), minValue = Math.min(0, d3.min(categorical.Y[0].values)), labelFormatter = ValueFormatter.create({
                                format: ValueFormatter.getFormatString(categorical.Y[0].source, properties.general.formatString),
                                precision: settings.labels.precision,
                                value: 0 === settings.labels.displayUnits && null != maxValue ? maxValue : settings.labels.displayUnits
                            }), categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.Category.source, properties.general.formatString), fontSizeInPx = PixelConverter.fromPoint(settings.labels.fontSize), i = 0; i < catValues.Category.length; i++) {
                                var formattedCategoryValue = visuals.valueFormatter.format(catValues.Category[i], categorySourceFormatString), currentValue = categorical.Y[0].values[i], tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, currentValue, null, null, 0);
                                if (categorical.Y.length > 1) {
                                    var toolTip = visuals.TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, categorical.Y[1].values[i], null, null, 1)[1];
                                    toolTip && tooltipInfo.push(toolTip), currentValue += categorical.Y[1].values[i];
                                }
                                var identity = categorical.Category.identity[i], color = colorHelper.getColorForMeasure(categorical.Category.objects && categorical.Category.objects[i], identity.key), selector = visuals.SelectionId.createWithId(identity), sliceWidth = Math.max(0, categorical.Y.length > 1 ? categorical.Y[1].values[i] : 1);
                                if (sliceWidth > 0 && dataPoints.push({
                                    sliceHeight: categorical.Y[0].values[i] - minValue,
                                    sliceWidth: sliceWidth,
                                    label: labelFormatter.format(currentValue),
                                    color: color,
                                    identity: selector,
                                    selected: !1,
                                    tooltipInfo: tooltipInfo,
                                    labelFontSize: fontSizeInPx,
                                    highlight: !1
                                }), settings.legend.show && legendData.dataPoints.push({
                                    label: formattedCategoryValue,
                                    color: color,
                                    icon: visuals.LegendIcon.Box,
                                    selected: !1,
                                    identity: selector
                                }), hasHighlights) {
                                    var highlightIdentity = visuals.SelectionId.createWithHighlight(selector), notNull = null != categorical.Y[0].highlights[i];
                                    if (currentValue = notNull ? categorical.Y[0].highlights[i] : 0, tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, currentValue, null, null, 0), 
                                    categorical.Y.length > 1) {
                                        var toolTip = visuals.TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, categorical.Y[1].highlights[i], null, null, 1)[1];
                                        toolTip && tooltipInfo.push(toolTip), currentValue += null !== categorical.Y[1].highlights[i] ? categorical.Y[1].highlights[i] : 0;
                                    }
                                    highlightedDataPoints.push({
                                        sliceHeight: notNull ? categorical.Y[0].highlights[i] - minValue : null,
                                        sliceWidth: Math.max(0, categorical.Y.length > 1 && null !== categorical.Y[1].highlights[i] ? categorical.Y[1].highlights[i] : sliceWidth),
                                        label: labelFormatter.format(currentValue),
                                        color: color,
                                        identity: highlightIdentity,
                                        selected: !1,
                                        tooltipInfo: tooltipInfo,
                                        labelFontSize: fontSizeInPx,
                                        highlight: !0
                                    });
                                }
                            }
                            return dataPoints.length && {
                                dataPoints: dataPoints,
                                settings: settings,
                                hasHighlights: hasHighlights,
                                legendData: legendData,
                                highlightedDataPoints: highlightedDataPoints,
                                labelFormatter: labelFormatter,
                                centerText: categorical.Category.source.displayName
                            };
                        }
                    }, AsterPlot.parseSettings = function(dataView, categorySource) {
                        var settings = AsterPlotSettings.parse(dataView, AsterPlot.capabilities);
                        return settings.labels.precision = Math.min(17, Math.max(0, settings.labels.precision)), 
                        settings.outerLine.thickness = Math.min(300, Math.max(1, settings.outerLine.thickness)), 
                        settings.createOriginalSettings(), _.isEmpty(settings.legend.titleText) && (settings.legend.titleText = categorySource.displayName), 
                        settings;
                    }, Object.defineProperty(AsterPlot.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlot.prototype.init = function(options) {
                        this.hostServices = options.host, this.hostServices.canSelect = function(args) {
                            return !(args.data && args.data.length > 1 && args.data.some(function(value) {
                                return value && value.data && value.data.length > 1;
                            }));
                        }, this.layout = new VisualLayout(options.viewport, {
                            top: 10,
                            right: 10,
                            bottom: 15,
                            left: 10
                        });
                        var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(AsterPlotVisualClassName, !0).style("position", "absolute");
                        this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = svg.append("g"), 
                        this.mainLabelsElement = svg.append("g"), this.behavior = new AsterPlotWebBehavior(), 
                        this.clearCatcher = visuals.appendClearCatcher(this.mainGroupElement), this.slicesElement = this.mainGroupElement.append("g").classed(AsterPlot.AsterSlices["class"], !0);
                        var interactivity = options.interactivity;
                        this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                        this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, AsterPlot.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0]) {
                            this.layout.viewport = options.viewport;
                            var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration, data = AsterPlot.converter(options.dataViews[0], this.colors);
                            if (!data) return void this.clear();
                            this.data = data, this.interactivityService && (this.interactivityService.applySelectionStateToData(this.data.dataPoints), 
                            this.interactivityService.applySelectionStateToData(this.data.highlightedDataPoints)), 
                            this.renderLegend(), this.updateViewPortAccordingToLegend(), this.svg.attr(this.layout.viewport);
                            var transformX = (this.layout.viewportIn.width + this.layout.margin.right) / 2, transformY = (this.layout.viewportIn.height + this.layout.margin.bottom) / 2;
                            if (this.mainGroupElement.attr("transform", visuals.SVGUtil.translate(transformX, transformY)), 
                            this.mainLabelsElement.attr("transform", visuals.SVGUtil.translate(transformX, transformY)), 
                            this.clearCatcher.attr("transform", visuals.SVGUtil.translate(-transformX, -transformY)), 
                            visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0), this.renderArcsAndLabels(duration), 
                            this.data.hasHighlights ? this.renderArcsAndLabels(duration, !0) : this.slicesElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove(), 
                            this.interactivityService) {
                                var behaviorOptions = {
                                    selection: this.slicesElement.selectAll(AsterPlot.AsterSlice.selector + ", " + AsterPlot.AsterHighlightedSlice.selector),
                                    clearCatcher: this.clearCatcher,
                                    interactivityService: this.interactivityService,
                                    hasHighlights: this.data.hasHighlights
                                };
                                this.interactivityService.bind(this.data.dataPoints.concat(this.data.highlightedDataPoints), this.behavior, behaviorOptions);
                            }
                        }
                    }, AsterPlot.prototype.renderArcsAndLabels = function(duration, isHighlight) {
                        var _this = this;
                        void 0 === isHighlight && (isHighlight = !1);
                        var radius = Math.min(this.layout.viewportIn.width, this.layout.viewportIn.height) / 2, innerRadius = .3 * (this.settings.labels.show ? radius * AsterRadiusRatio : radius), maxScore = d3.max(this.data.dataPoints, function(d) {
                            return d.sliceHeight;
                        }), totalWeight = d3.sum(this.data.dataPoints, function(d) {
                            return d.sliceWidth;
                        }), pie = d3.layout.pie().sort(null).value(function(d) {
                            return (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight;
                        }), arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(function(d) {
                            var height = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore, heightIsLabelsOn = innerRadius + (_this.settings.labels.show ? height * AsterRadiusRatio : height);
                            return Math.max(heightIsLabelsOn, innerRadius);
                        }), arcDescriptorDataPoints = pie(isHighlight ? this.data.highlightedDataPoints : this.data.dataPoints), classSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice, selection = this.slicesElement.selectAll(classSelector.selector).data(arcDescriptorDataPoints, function(d, i) {
                            return d.data ? d.data.identity.getKey() : i;
                        });
                        if (selection.enter().append("path").classed(classSelector["class"], !0).attr("stroke", "#333"), 
                        selection.attr("fill", function(d) {
                            return d.data.color;
                        }).call(function(selection) {
                            return Helpers.setAttrThroughTransitionIfNotResized(selection, function(s) {
                                return s.duration(duration);
                            }, "d", arc, Helpers.interpolateArc(arc), _this.layout.viewportChanged);
                        }), selection.exit().remove(), visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.data.tooltipInfo;
                        }), this.settings.labels.show && (!this.data.hasHighlights || this.data.hasHighlights && isHighlight)) {
                            var labelRadCalc = function(d) {
                                var height = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;
                                return Math.max(height, innerRadius);
                            }, labelArc = d3.svg.arc().innerRadius(function(d) {
                                return labelRadCalc(d.data);
                            }).outerRadius(function(d) {
                                return labelRadCalc(d.data);
                            }), lineRadCalc = function(d) {
                                var height = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;
                                return height = innerRadius + height * AsterRadiusRatio, Math.max(height, innerRadius);
                            }, outlineArc = d3.svg.arc().innerRadius(function(d) {
                                return lineRadCalc(d.data);
                            }).outerRadius(function(d) {
                                return lineRadCalc(d.data);
                            }), labelLayout = this.getLabelLayout(labelArc, this.layout.viewport);
                            this.drawLabels(arcDescriptorDataPoints.filter(function(x) {
                                return !isHighlight || null !== x.data.sliceHeight;
                            }), this.mainLabelsElement, labelLayout, this.layout.viewport, outlineArc, labelArc);
                        } else visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0);
                        return isHighlight || (this.drawCenterText(innerRadius), this.drawOuterLine(innerRadius, _.max(arcDescriptorDataPoints.map(function(d) {
                            return arc.outerRadius()(d);
                        })), arcDescriptorDataPoints)), selection;
                    }, AsterPlot.prototype.getLabelLayout = function(arc, viewport) {
                        var midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        }, textProperties = {
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(this.settings.labels.fontSize),
                            text: ""
                        }, isLabelsHasConflict = function(d) {
                            var pos = arc.centroid(d);
                            textProperties.text = d.data.label;
                            var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties), verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);
                            return d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels, 
                            d.isLabelHasConflict;
                        };
                        return {
                            labelText: function(d) {
                                textProperties.text = d.data.label;
                                var pos = arc.centroid(d), xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0], spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);
                                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
                            },
                            labelLayout: {
                                x: function(d) {
                                    var pos = arc.centroid(d);
                                    textProperties.text = d.data.label;
                                    var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];
                                    return xPos;
                                },
                                y: function(d) {
                                    var pos = arc.centroid(d), yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];
                                    return yPos;
                                }
                            },
                            filter: function(d) {
                                return null != d && !_.isEmpty(d.data.label);
                            },
                            style: {
                                fill: this.settings.labels.color,
                                "font-size": textProperties.fontSize,
                                "text-anchor": function(d) {
                                    return midAngle(d) < Math.PI ? "start" : "end";
                                }
                            }
                        };
                    }, AsterPlot.prototype.drawLabels = function(data, context, layout, viewport, outlineArc, labelArc) {
                        var _this = this, dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, !0);
                        if (0 === filteredData.length) return void visuals.dataLabelUtils.cleanDataLabels(context, !0);
                        context.select(AsterPlot.labelGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.labelGraphicsContextClass["class"], !0);
                        var labels = context.select(AsterPlot.labelGraphicsContextClass.selector).selectAll(".data-labels").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        });
                        if (labels.enter().append("text").classed("data-labels", !0), labels) {
                            labels.attr({
                                x: function(d) {
                                    return d.labelX;
                                },
                                y: function(d) {
                                    return d.labelY;
                                },
                                dy: ".35em"
                            }).text(function(d) {
                                return d.labeltext;
                            }).style(layout.style), labels.exit().remove(), context.select(AsterPlot.linesGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.linesGraphicsContextClass["class"], !0), 
                            filteredData = _.filter(filteredData, function(d) {
                                return null !== d.data.sliceHeight && 0 !== d.data.sliceHeight;
                            });
                            var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll("polyline").data(filteredData, function(d) {
                                return d.data.identity.getKey();
                            }), labelLinePadding = 4, chartLinePadding = 1.02, midAngle = function(d) {
                                return d.startAngle + (d.endAngle - d.startAngle) / 2;
                            };
                            lines.enter().append("polyline").classed("line-label", !0), lines.attr("points", function(d) {
                                var textPoint = [ d.labelX, d.labelY ];
                                textPoint[0] = textPoint[0] + (midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding;
                                var chartPoint = outlineArc.centroid(d);
                                return chartPoint[0] *= chartLinePadding, chartPoint[1] *= chartLinePadding, [ chartPoint, textPoint ];
                            }).style({
                                opacity: .5,
                                "fill-opacity": 0,
                                stroke: function(d) {
                                    return _this.settings.labels.color;
                                }
                            }), lines.exit().remove();
                        }
                    }, AsterPlot.prototype.renderLegend = function() {
                        if (this.settings.legend.show) {
                            var legendObject = _.clone(this.settings.legend);
                            legendObject.labelColor = {
                                solid: {
                                    color: legendObject.labelColor
                                }
                            }, visuals.LegendData.update(this.data.legendData, legendObject), this.legend.changeOrientation(visuals.LegendPosition[this.settings.legend.position]);
                        }
                        this.legend.drawLegend(this.data.legendData, this.layout.viewportCopy), visuals.Legend.positionChartArea(this.svg, this.legend);
                    }, AsterPlot.prototype.updateViewPortAccordingToLegend = function() {
                        if (this.settings.legend.show) {
                            var legendMargins = this.legend.getMargins(), legendPosition = visuals.LegendPosition[this.settings.legend.position];
                            switch (legendPosition) {
                              case visuals.LegendPosition.Top:
                              case visuals.LegendPosition.TopCenter:
                              case visuals.LegendPosition.Bottom:
                              case visuals.LegendPosition.BottomCenter:
                                this.layout.viewport.height -= legendMargins.height;
                                break;

                              case visuals.LegendPosition.Left:
                              case visuals.LegendPosition.LeftCenter:
                              case visuals.LegendPosition.Right:
                              case visuals.LegendPosition.RightCenter:
                                this.layout.viewport.width -= legendMargins.width;
                            }
                        }
                    }, AsterPlot.prototype.drawOuterLine = function(innerRadius, radius, data) {
                        var mainGroup = this.mainGroupElement, outlineArc = d3.svg.arc().innerRadius(innerRadius).outerRadius(radius);
                        if (this.settings.outerLine.show) {
                            var OuterThickness = this.settings.outerLine.thickness + "px", outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
                            outerLine.enter().append("path"), outerLine.attr("fill", "none").attr({
                                stroke: "#333",
                                "stroke-width": OuterThickness,
                                d: outlineArc
                            }).style("opacity", 1).classed(AsterPlot.OuterLine["class"], !0), outerLine.exit().remove();
                        } else mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();
                    }, AsterPlot.prototype.drawCenterText = function(innerRadius) {
                        if (_.isEmpty(this.data.centerText)) return void this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
                        var centerTextProperties = {
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontWeight: "bold",
                            fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),
                            text: this.data.centerText
                        };
                        this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty() && (this.centerText = this.mainGroupElement.append("text").classed(AsterPlot.CenterLabelClass["class"], !0)), 
                        this.centerText.style({
                            "line-height": 1,
                            "font-weight": centerTextProperties.fontWeight,
                            "font-size": centerTextProperties.fontSize,
                            fill: this.settings.labels.color
                        }).attr({
                            dy: "0.35em",
                            "text-anchor": "middle"
                        }).text(powerbi.TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
                    }, AsterPlot.prototype.clear = function() {
                        this.mainGroupElement.selectAll("path").remove(), this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove(), 
                        visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0), this.legend.drawLegend({
                            dataPoints: []
                        }, this.layout.viewportCopy);
                    }, AsterPlot.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, AsterPlot.prototype.enumerateObjectInstances = function(options) {
                        var instances = AsterPlotSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, AsterPlot.capabilities);
                        return instances.complete();
                    }, AsterPlot.capabilities = {
                        dataRoles: [ {
                            displayName: "Category",
                            name: AsterPlotColumns.Roles.Category,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: "Y Axis",
                            name: AsterPlotColumns.Roles.Y,
                            kind: powerbi.VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Y: {
                                    max: 2
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                description: "Display legend options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            label: {
                                displayName: "Center Label",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Detail Labels",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                displayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            outerLine: {
                                displayName: "Outer line",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    thickness: {
                                        displayName: "Thickness",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, AsterPlot.AsterSlices = createClassAndSelector("asterSlices"), AsterPlot.AsterSlice = createClassAndSelector("asterSlice"), 
                    AsterPlot.AsterHighlightedSlice = createClassAndSelector("asterHighlightedSlice"), 
                    AsterPlot.OuterLine = createClassAndSelector("outerLine"), AsterPlot.labelGraphicsContextClass = createClassAndSelector("labels"), 
                    AsterPlot.linesGraphicsContextClass = createClassAndSelector("lines"), AsterPlot.CenterLabelClass = createClassAndSelector("centerLabel"), 
                    AsterPlot.CenterTextFontHeightCoefficient = .4, AsterPlot.CenterTextFontWidthCoefficient = 1.9, 
                    AsterPlot;
                }();
                samples.AsterPlot = AsterPlot;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function getTornadoChartWarning() {
                    return new TornadoChartWarning();
                }
                var PixelConverter = jsCommon.PixelConverter, TornadoWebBehavior = function() {
                    function TornadoWebBehavior() {}
                    return TornadoWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.columns.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, TornadoWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.columns.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, TornadoWebBehavior;
                }(), TornadoChartScrolling = function() {
                    function TornadoChartScrolling(getRoot, getViewport, getMargin, getPrefferedHeight, isScrollable) {
                        this.scrollYBrush = d3.svg.brush(), this.getRoot = getRoot, this.getViewport = getViewport, 
                        this.isScrollable = isScrollable, this.getPrefferedHeight = getPrefferedHeight;
                    }
                    return Object.defineProperty(TornadoChartScrolling.prototype, "scrollViewport", {
                        get: function() {
                            return {
                                height: this.viewport.height,
                                width: this.viewport.width - (this.isYScrollBarVisible && this.isScrollable ? TornadoChart.ScrollBarWidth : 0)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChartScrolling.prototype, "root", {
                        get: function() {
                            return this.getRoot();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
                        get: function() {
                            return this.getViewport();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChartScrolling.prototype.renderY = function(data, onScroll) {
                        var _this = this;
                        if (this.isYScrollBarVisible = this.isScrollable && this.getPrefferedHeight() > this.viewport.height && this.viewport.height > 0 && this.viewport.width > 0, 
                        this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, "y brush"), 
                        !this.isYScrollBarVisible) return void onScroll.call(this, jQuery.extend(!0, {}, data), 0, 1);
                        var scrollSpaceLength = this.viewport.height, extentData = this.getExtentData(this.getPrefferedHeight(), scrollSpaceLength), onRender = function(wheelDelta) {
                            void 0 === wheelDelta && (wheelDelta = 0);
                            var position = _this.scrollYBrush.extent();
                            if (0 !== wheelDelta) {
                                var halfScrollsize = (position[1] - position[0]) / 2;
                                if (position[0] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, position[1] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, 
                                position[0] < 0) {
                                    var offset = 0 - position[0];
                                    position[0] += offset, position[1] += offset;
                                }
                                if (position[1] > scrollSpaceLength) {
                                    var offset = position[1] - scrollSpaceLength;
                                    position[0] -= offset, position[1] -= offset;
                                }
                                _this.scrollYBrush.extent(position), _this.brushGraphicsContextY.select(".extent").attr("y", position[0]);
                            }
                            var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);
                            onScroll.call(_this, jQuery.extend(!0, {}, data), scrollPosition[0], scrollPosition[1]), 
                            _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], !0);
                        }, scrollYScale = d3.scale.ordinal().rangeBands([ 0, scrollSpaceLength ]);
                        this.scrollYBrush.y(scrollYScale).extent(extentData.value), this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender), 
                        onRender();
                    }, TornadoChartScrolling.prototype.createOrRemoveScrollbar = function(isVisible, brushGraphicsContext, brushClass) {
                        return isVisible && this.isScrollable ? brushGraphicsContext || this.root.append("g").classed(brushClass, !0) : brushGraphicsContext ? void brushGraphicsContext.remove() : void 0;
                    }, TornadoChartScrolling.prototype.renderScrollbar = function(brush, brushGraphicsContext, brushX, onRender) {
                        var _this = this;
                        brush.on("brush", function() {
                            return window.requestAnimationFrame(function() {
                                return onRender(0);
                            });
                        }), this.root.on("wheel", function() {
                            if (_this.isYScrollBarVisible) {
                                var wheelEvent = d3.event;
                                onRender(wheelEvent.deltaY);
                            }
                        }), brushGraphicsContext.attr({
                            transform: visuals.SVGUtil.translate(brushX, 0),
                            "drag-resize-disabled": "true"
                        }), brushGraphicsContext.call(brush), brushGraphicsContext.selectAll(".resize").remove(), 
                        brushGraphicsContext.select(".background").remove(), brushGraphicsContext.selectAll(".extent").style({
                            "fill-opacity": .125,
                            cursor: "default"
                        });
                    }, TornadoChartScrolling.prototype.setScrollBarSize = function(brushGraphicsContext, minExtent, isVertical) {
                        brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChart.ScrollBarWidth), 
                        brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
                    }, TornadoChartScrolling.prototype.getExtentData = function(svgLength, scrollSpaceLength) {
                        var value = scrollSpaceLength * scrollSpaceLength / svgLength, scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value ? 1 : value / TornadoChartScrolling.ScrollBarMinLength;
                        value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
                        var toScrollPosition = function(extent, scrollSpaceLength) {
                            var scrollSize = extent[1] - extent[0], scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
                            scrollSize *= scaleMultipler;
                            var start = scrollPosition * (scrollSpaceLength - scrollSize), end = start + scrollSize;
                            return [ start / scrollSpaceLength, end / scrollSpaceLength ];
                        };
                        return {
                            value: [ 0, value ],
                            toScrollPosition: toScrollPosition
                        };
                    }, TornadoChartScrolling.prototype.clearData = function() {
                        this.brushGraphicsContextY && this.brushGraphicsContextY.selectAll("*").remove();
                    }, TornadoChartScrolling.ScrollBarMinLength = 15, TornadoChartScrolling;
                }(), TornadoChartWarning = function() {
                    function TornadoChartWarning() {}
                    return Object.defineProperty(TornadoChartWarning.prototype, "code", {
                        get: function() {
                            return "TornadoChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChartWarning.prototype.getMessages = function(resourceProvider) {
                        var visualMessage, message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "";
                        return visualMessage = {
                            message: message,
                            title: resourceProvider.get(titleKey),
                            detail: resourceProvider.get(detailKey)
                        };
                    }, TornadoChartWarning;
                }();
                samples.TornadoChartWarning = TornadoChartWarning, samples.getTornadoChartWarning = getTornadoChartWarning;
                var TornadoChart = function() {
                    function TornadoChart(tornadoChartConstructorOptions) {
                        this.textOptions = {}, this.columnPadding = 5, this.leftLabelMargin = 4, this.InnerTextHeightDelta = 2, 
                        this.margin = {
                            top: 10,
                            right: 5,
                            bottom: 10,
                            left: 10
                        }, this.heightColumn = 0, tornadoChartConstructorOptions && (this.svg = tornadoChartConstructorOptions.svg || this.svg, 
                        this.margin = tornadoChartConstructorOptions.margin || this.margin, this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding, 
                        this.animator = tornadoChartConstructorOptions.animator);
                    }
                    return TornadoChart.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, TornadoChart.converter = function(dataView, textOptions, colors) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.values && dataView.categorical.values[0])) return null;
                        var categorical = dataView.categorical, categories = categorical.categories || [], values = categorical.values, category = categories[0], formatStringProp = TornadoChart.Properties.general.formatString, maxValue = d3.max(values[0].values), settings = TornadoChart.parseSettings(dataView.metadata.objects, maxValue, colors), hasDynamicSeries = !!values.source, hasHighlights = !!(values.length > 0 && values[0].highlights), labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight({
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize)
                        }), series = [], dataPoints = [], highlightedDataPoints = [], categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp), categoriesLabels = category.values.map(function(value) {
                            var formattedCategoryValue = visuals.valueFormatter.format(value, categorySourceFormatString);
                            return TornadoChart.getTextData(formattedCategoryValue, textOptions, !0);
                        }), groupedValues = values.grouped ? values.grouped() : null, minValue = Math.min(d3.min(values[0].values), 0);
                        values.length === TornadoChart.MaxSeries && (minValue = d3.min([ minValue, d3.min(values[1].values) ]), 
                        maxValue = d3.max([ maxValue, d3.max(values[1].values) ]));
                        for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {
                            var columnGroup = groupedValues && groupedValues.length > seriesIndex && groupedValues[seriesIndex].values ? groupedValues[seriesIndex] : null, parsedSeries = TornadoChart.parseSeries(values, seriesIndex, hasDynamicSeries, columnGroup, colors);
                            series.push(parsedSeries);
                            for (var currentSeries = values[seriesIndex], measureName = currentSeries.source.queryName, i = 0; i < category.values.length; i++) {
                                var tooltipInfo, value = null == currentSeries.values[i] || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i], identity = visuals.SelectionIdBuilder.builder().withCategory(category, i).withSeries(values, columnGroup).withMeasure(measureName).createSelectionId(), formattedCategoryValue = categoriesLabels[i].text;
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);
                                var currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue, formatString = dataView.categorical.values[seriesIndex].source.format;
                                if (dataPoints.push({
                                    value: value,
                                    minValue: minValue,
                                    maxValue: currentMaxValue,
                                    formatString: formatString,
                                    color: parsedSeries.fill,
                                    selected: !1,
                                    identity: identity,
                                    tooltipData: tooltipInfo,
                                    categoryIndex: i
                                }), hasHighlights) {
                                    var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlight = currentSeries.highlights[i], highlightedValue = null != highlight ? highlight : 0;
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue), 
                                    highlightedDataPoints.push({
                                        value: highlightedValue,
                                        minValue: minValue,
                                        maxValue: currentMaxValue,
                                        formatString: formatString,
                                        color: parsedSeries.fill,
                                        selected: !1,
                                        identity: highlightIdentity,
                                        tooltipData: tooltipInfo,
                                        categoryIndex: i,
                                        highlight: !0
                                    });
                                }
                            }
                        }
                        return {
                            categories: categoriesLabels,
                            series: series,
                            settings: settings,
                            legend: TornadoChart.getLegendData(series, hasDynamicSeries),
                            dataPoints: dataPoints,
                            highlightedDataPoints: highlightedDataPoints,
                            maxLabelsWidth: _.max(categoriesLabels.map(function(x) {
                                return x.width;
                            })),
                            hasDynamicSeries: hasDynamicSeries,
                            hasHighlights: hasHighlights,
                            labelHeight: labelHeight,
                            legendObjectProperties: powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})
                        };
                    }, TornadoChart.parseSeries = function(dataViewValueColumns, index, isGrouped, columnGroup, colors) {
                        var objects, categoryAxisObject, dataViewValueColumn = dataViewValueColumns ? dataViewValueColumns[index] : null, source = dataViewValueColumn ? dataViewValueColumn.source : null, identity = columnGroup ? columnGroup.identity : null, queryName = source ? source.queryName : null, selectionId = identity ? visuals.SelectionId.createWithId(identity) : visuals.SelectionIdBuilder.builder().withSeries(dataViewValueColumns, columnGroup).withMeasure(queryName).createSelectionId(), displayName = source ? source.groupName ? source.groupName : source.displayName : null;
                        isGrouped && columnGroup ? (categoryAxisObject = columnGroup.objects ? columnGroup.objects.categoryAxis : null, 
                        objects = columnGroup.objects) : source && (objects = source.objects, categoryAxisObject = objects ? objects.categoryAxis : null);
                        var color = TornadoChart.getColor(TornadoChart.Properties.dataPoint.fill, [ "purple", "teal" ][index], objects, colors), categoryAxisEnd = categoryAxisObject ? categoryAxisObject.end : null;
                        return {
                            fill: color,
                            name: displayName,
                            selectionId: selectionId,
                            categoryAxisEnd: categoryAxisEnd
                        };
                    }, TornadoChart.getColor = function(properties, defaultColor, objects, colors) {
                        var colorHelper = new visuals.ColorHelper(colors, properties, defaultColor);
                        return colorHelper.getColorForMeasure(objects, "");
                    }, TornadoChart.getTextData = function(text, textOptions, measureWidth, measureHeight, overrideFontSize) {
                        void 0 === measureWidth && (measureWidth = !1), void 0 === measureHeight && (measureHeight = !1);
                        var fontSize, textProperties, width = 0, height = 0;
                        return text = text || "", fontSize = overrideFontSize ? PixelConverter.fromPoint(overrideFontSize) : "" + textOptions.fontSize + textOptions.sizeUnit, 
                        textProperties = {
                            text: text,
                            fontFamily: textOptions.fontFamily,
                            fontSize: fontSize
                        }, measureWidth && (width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties)), 
                        measureHeight && (height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)), 
                        {
                            text: text,
                            width: width,
                            height: height,
                            textProperties: textProperties
                        };
                    }, Object.defineProperty(TornadoChart.prototype, "allLabelsWidth", {
                        get: function() {
                            return (this.dataView.settings.showCategories ? Math.min(this.dataView.maxLabelsWidth, this.scrolling.scrollViewport.width / 2) : 3) + TornadoChart.CategoryLabelMargin;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChart.prototype, "allColumnsWidth", {
                        get: function() {
                            return this.scrolling.scrollViewport.width - this.allLabelsWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChart.prototype, "columnWidth", {
                        get: function() {
                            return this.dataView.series.length === TornadoChart.MaxSeries ? this.allColumnsWidth / 2 : this.allColumnsWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChart.prototype.init = function(visualInitOptions) {
                        var fontSize, _this = this, style = visualInitOptions.style;
                        this.hostService = visualInitOptions.host;
                        var element = visualInitOptions.element;
                        this.colors = style.colorPalette.dataColors;
                        var interactivity = visualInitOptions.interactivity;
                        this.interactivityService = visuals.createInteractivityService(this.hostService);
                        var root;
                        this.svg ? this.root = root = this.svg : this.root = root = d3.select(element.get(0)).append("svg"), 
                        root.classed(TornadoChart.ClassName, !0).style("position", "absolute"), fontSize = root.style("font-size"), 
                        this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2), this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2)), 
                        this.textOptions.fontFamily = root.style("font-family"), this.viewport = visualInitOptions.viewport, 
                        this.scrolling = new TornadoChartScrolling(function() {
                            return root;
                        }, function() {
                            return _this.viewport;
                        }, function() {
                            return _this.margin;
                        }, function() {
                            return _this.dataView.categories.length * TornadoChart.CategoryMinHeight;
                        }, !0);
                        var main = this.main = root.append("g");
                        this.clearCatcher = visuals.appendClearCatcher(main), this.columns = main.append("g").classed(TornadoChart.Columns["class"], !0), 
                        this.axes = main.append("g").classed(TornadoChart.Axes["class"], !0), this.labels = main.append("g").classed(TornadoChart.Labels["class"], !0), 
                        this.categories = main.append("g").classed(TornadoChart.Categories["class"], !0), 
                        this.behavior = new TornadoWebBehavior(), this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, TornadoChart.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0]) {
                            if (this.viewport = {
                                height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),
                                width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)
                            }, this.animator ? this.durationAnimations = visuals.AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations) : this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250, 
                            this.dataView = TornadoChart.converter(this.validateDataView(visualUpdateOptions.dataViews[0]), this.textOptions, this.colors), 
                            !this.dataView || this.scrolling.scrollViewport.height < TornadoChart.CategoryMinHeight) return void this.clearData();
                            this.dataView && this.interactivityService && (this.interactivityService.applySelectionStateToData(this.dataView.dataPoints), 
                            this.interactivityService.applySelectionStateToData(this.dataView.highlightedDataPoints)), 
                            this.render();
                        }
                    }, TornadoChart.prototype.validateDataView = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values ? dataView.categorical.values.length > TornadoChart.MaxSeries ? (this.hostService.setWarnings([ getTornadoChartWarning() ]), 
                        null) : dataView : null;
                    }, TornadoChart.prototype.updateElements = function() {
                        var elementsTranslate = visuals.SVGUtil.translate(this.allLabelsWidth, 0);
                        this.root.attr({
                            height: this.viewport.height + this.margin.top + this.margin.bottom,
                            width: this.viewport.width + this.margin.left + this.margin.right
                        }), this.columns.attr("transform", elementsTranslate), this.labels.attr("transform", elementsTranslate), 
                        this.axes.attr("transform", elementsTranslate);
                    }, TornadoChart.parseSettings = function(objects, value, colors) {
                        var precision = TornadoChart.getPrecision(objects), displayUnits = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, TornadoChart.DefaultTornadoChartSettings.labelSettings.displayUnits), labelSettings = TornadoChart.DefaultTornadoChartSettings.labelSettings, getLabelValueFormatter = function(formatString) {
                            return visuals.valueFormatter.create({
                                format: formatString,
                                precision: precision,
                                value: 0 === displayUnits && null != value ? value : displayUnits
                            });
                        };
                        return {
                            labelOutsideFillColor: TornadoChart.getColor(TornadoChart.Properties.labels.outsideFill, TornadoChart.DefaultTornadoChartSettings.labelOutsideFillColor, objects, colors),
                            labelSettings: {
                                show: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
                                precision: precision,
                                fontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
                                displayUnits: displayUnits,
                                labelColor: TornadoChart.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects, colors)
                            },
                            showCategories: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, TornadoChart.DefaultTornadoChartSettings.showCategories),
                            showLegend: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, TornadoChart.DefaultTornadoChartSettings.showLegend),
                            legendFontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, TornadoChart.DefaultTornadoChartSettings.legendFontSize),
                            legendColor: TornadoChart.getColor(TornadoChart.Properties.legend.labelColor, TornadoChart.DefaultTornadoChartSettings.legendColor, objects, colors),
                            categoriesFillColor: TornadoChart.getColor(TornadoChart.Properties.categories.fill, TornadoChart.DefaultTornadoChartSettings.categoriesFillColor, objects, colors),
                            getLabelValueFormatter: getLabelValueFormatter
                        };
                    }, TornadoChart.getPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, TornadoChart.DefaultTornadoChartSettings.labelSettings.precision);
                        return Math.min(Math.max(0, precision), TornadoChart.MaxPrecision);
                    }, TornadoChart.getLegendData = function(series, hasDynamicSeries) {
                        var legendDataPoints = [];
                        return hasDynamicSeries && (legendDataPoints = series.map(function(series) {
                            return {
                                label: series.name,
                                color: series.fill,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: series.selectionId
                            };
                        })), {
                            dataPoints: legendDataPoints
                        };
                    }, TornadoChart.prototype.render = function() {
                        this.updateElements(), this.renderLegend(), this.scrolling.renderY(this.dataView, this.renderWithScrolling.bind(this));
                    }, TornadoChart.prototype.clearData = function() {
                        this.columns.selectAll("*").remove(), this.axes.selectAll("*").remove(), this.labels.selectAll("*").remove(), 
                        this.categories.selectAll("*").remove(), this.legend.drawLegend({
                            dataPoints: []
                        }, this.viewport), this.scrolling.clearData();
                    }, TornadoChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, TornadoChart.prototype.renderWithScrolling = function(tornadoChartDataView, scrollStart, scrollEnd) {
                        if (this.dataView && this.dataView.settings) {
                            var categoriesLength = tornadoChartDataView.categories.length, startIndex = scrollStart * categoriesLength, endIndex = scrollEnd * categoriesLength, startIndexRound = Math.floor(startIndex), endIndexRound = Math.floor(endIndex), maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
                            1 > scrollEnd - scrollStart && endIndexRound - startIndexRound > maxValues && (startIndex - startIndexRound > endIndex - endIndexRound ? startIndexRound++ : endIndex--), 
                            this.interactivityService && (this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints), 
                            this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints)), 
                            tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound), 
                            tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function(d) {
                                return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                            }), tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function(d) {
                                return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                            }), this.dataView = tornadoChartDataView, this.computeHeightColumn(), this.renderMiddleSection(), 
                            this.renderAxes(), this.renderCategories();
                        }
                    }, TornadoChart.prototype.updateViewport = function() {
                        var legendPosition, legendMargins = this.legend.getMargins();
                        switch (legendPosition = visuals.LegendPosition[this.dataView.legendObjectProperties[visuals.legendProps.position]]) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                        }
                    }, TornadoChart.prototype.computeHeightColumn = function() {
                        var length = this.dataView.categories.length;
                        this.heightColumn = (this.scrolling.scrollViewport.height - (length - 1) * this.columnPadding) / length;
                    }, TornadoChart.prototype.renderMiddleSection = function() {
                        var tornadoChartDataView = this.dataView;
                        this.calculateDataPoints(tornadoChartDataView.dataPoints), this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints);
                        var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);
                        this.renderColumns(dataPointsWithHighlights, 2 === tornadoChartDataView.series.length), 
                        this.renderLabels(this.dataView.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);
                    }, TornadoChart.prototype.calculateDataPoints = function(dataPoints) {
                        for (var categoriesLength = this.dataView.categories.length, settings = this.dataView.settings, heightColumn = Math.max(this.heightColumn, 0), py = heightColumn / 2, pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2, maxSeries = this.dataView.series.length === TornadoChart.MaxSeries, i = 0; i < dataPoints.length; i++) {
                            var dataPoint = dataPoints[i], shiftToMiddle = categoriesLength > i && maxSeries, shiftToRight = i > categoriesLength - 1, widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, this.columnWidth), dx = (this.columnWidth - widthOfColumn) * Number(shiftToMiddle) + this.columnWidth * Number(shiftToRight);
                            dx = Math.max(dx, 0);
                            var highlighted = this.dataView.hasHighlights && dataPoint.highlight, highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0, dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset, label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);
                            dataPoint.dx = dx, dataPoint.dy = dy, dataPoint.px = widthOfColumn / 2, dataPoint.py = highlighted ? pyHighlighted : py, 
                            dataPoint.angle = shiftToMiddle ? 180 : 0, dataPoint.width = widthOfColumn, dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn, 
                            dataPoint.label = label;
                        }
                    }, TornadoChart.prototype.renderColumns = function(columnsData, selectSecondSeries) {
                        var _this = this;
                        void 0 === selectSecondSeries && (selectSecondSeries = !1);
                        var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), columnsSelection = this.columns.selectAll(TornadoChart.Column.selector).data(columnsData);
                        columnsSelection.enter().append("svg:rect").classed(TornadoChart.Column["class"], !0), 
                        columnsSelection.style("fill", function(p) {
                            return p.color;
                        }).style("fill-opacity", function(p) {
                            return visuals.ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, _this.dataView.hasHighlights);
                        }).attr("transform", function(p) {
                            return visuals.SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle);
                        }).attr("height", function(p) {
                            return p.height;
                        }).attr("width", function(p) {
                            return p.width;
                        }), columnsSelection.exit().remove();
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(columnsData);
                            var behaviorOptions = {
                                columns: columnsSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            interactivityService.bind(columnsData, this.behavior, behaviorOptions);
                        }
                        this.renderTooltip(columnsSelection);
                    }, TornadoChart.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipData;
                        });
                    }, TornadoChart.prototype.getColumnWidth = function(value, minValue, maxValue, width) {
                        if (minValue === maxValue) return width;
                        var columnWidth = width * (value - minValue) / (maxValue - minValue);
                        return Math.max(0, Math.min(width, columnWidth));
                    }, TornadoChart.prototype.getLabelData = function(value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {
                        var dx, tornadoChartSettings = settings ? settings : this.dataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor, maxOutsideLabelWidth = isColumnPositionLeft ? dxColumn - this.leftLabelMargin : this.allColumnsWidth - (dxColumn + columnWidth + this.leftLabelMargin), maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin), textProperties = {
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(fontSize),
                            text: tornadoChartSettings.getLabelValueFormatter(formatStringProp).format(value)
                        }, valueAfterValueFormatter = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth), textDataAfterValueFormatter = TornadoChart.getTextData(valueAfterValueFormatter, this.textOptions, !0, !1, fontSize);
                        return columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding ? dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2 : (dx = isColumnPositionLeft ? dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width : dxColumn + columnWidth + this.leftLabelMargin, 
                        color = tornadoChartSettings.labelOutsideFillColor), {
                            dx: dx,
                            source: value,
                            value: valueAfterValueFormatter,
                            color: color
                        };
                    }, TornadoChart.prototype.renderAxes = function() {
                        var linesData, axesSelection, axesElements = this.main.select(TornadoChart.Axes.selector).selectAll(TornadoChart.Axis.selector);
                        return this.dataView.series.length !== TornadoChart.MaxSeries ? void axesElements.remove() : (linesData = this.generateAxesData(), 
                        axesSelection = axesElements.data(linesData), axesSelection.enter().append("svg:line").classed(TornadoChart.Axis["class"], !0), 
                        axesSelection.attr("x1", function(data) {
                            return data.x1;
                        }).attr("y1", function(data) {
                            return data.y1;
                        }).attr("x2", function(data) {
                            return data.x2;
                        }).attr("y2", function(data) {
                            return data.y2;
                        }), void axesSelection.exit().remove());
                    }, TornadoChart.prototype.generateAxesData = function() {
                        var x, y1, y2;
                        return x = this.allColumnsWidth / 2, y1 = 0, y2 = this.scrolling.scrollViewport.height, 
                        [ {
                            x1: x,
                            y1: y1,
                            x2: x,
                            y2: y2
                        } ];
                    }, TornadoChart.prototype.renderLabels = function(dataPoints, labelsSettings) {
                        var labelEnterSelection, _this = this, labelSelection = this.main.select(TornadoChart.Labels.selector).selectAll(TornadoChart.Label.selector).data(_.filter(dataPoints, function(p) {
                            return p.label.dx >= 0;
                        }));
                        if (!labelsSettings.show || this.dataView.labelHeight >= this.heightColumn) return void this.labels.selectAll("*").remove();
                        var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize), labelYOffset = this.heightColumn / 2 + this.dataView.labelHeight / 2 - this.InnerTextHeightDelta, categoriesLength = this.dataView.categories.length;
                        labelEnterSelection = labelSelection.enter().append("g"), labelEnterSelection.append("svg:title").classed(TornadoChart.LabelTitle["class"], !0), 
                        labelEnterSelection.append("svg:text").attr("dy", visuals.dataLabelUtils.DefaultDy).classed(TornadoChart.LabelText["class"], !0), 
                        labelSelection.attr("pointer-events", "none").classed(TornadoChart.Label["class"], !0), 
                        labelSelection.select(TornadoChart.LabelTitle.selector).text(function(p) {
                            return p.label.source;
                        }), labelSelection.attr("transform", function(p, index) {
                            var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);
                            return visuals.SVGUtil.translate(p.label.dx, dy + labelYOffset);
                        }), labelSelection.select(TornadoChart.LabelText.selector).attr("fill", function(p) {
                            return p.label.color;
                        }).attr("font-size", function(p) {
                            return fontSizeInPx;
                        }).text(function(p) {
                            return p.label.value;
                        }), labelSelection.exit().remove();
                    }, TornadoChart.prototype.renderCategories = function() {
                        var categoriesEnterSelection, categoriesSelection, _this = this, settings = this.dataView.settings, color = settings.categoriesFillColor, categoryElements = this.main.select(TornadoChart.Categories.selector).selectAll(TornadoChart.Category.selector);
                        return settings.showCategories ? (categoriesSelection = categoryElements.data(this.dataView.categories), 
                        categoriesEnterSelection = categoriesSelection.enter().append("g"), categoriesEnterSelection.append("svg:title").classed(TornadoChart.CategoryTitle["class"], !0), 
                        categoriesEnterSelection.append("svg:text").classed(TornadoChart.CategoryText["class"], !0), 
                        categoriesSelection.attr("transform", function(text, index) {
                            var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = TornadoChart.getTextData(text, _this.textOptions, !1, !0);
                            return shift = shift + textData.height / 2 - _this.InnerTextHeightDelta, visuals.SVGUtil.translate(0, shift);
                        }).classed(TornadoChart.Category["class"], !0), categoriesSelection.select(TornadoChart.CategoryTitle.selector).text(function(text) {
                            return text.text;
                        }), categoriesSelection.select(TornadoChart.CategoryText.selector).attr("fill", color).text(function(data) {
                            return _this.dataView.settings.showCategories ? powerbi.TextMeasurementService.getTailoredTextOrDefault(TornadoChart.getTextData(data.text, _this.textOptions).textProperties, _this.allLabelsWidth) : "";
                        }), void categoriesSelection.exit().remove()) : void categoryElements.remove();
                    }, TornadoChart.prototype.renderLegend = function() {
                        var legend = this.dataView.legend;
                        if (legend) {
                            var settings = this.dataView.settings, legendData = {
                                title: legend.title,
                                dataPoints: legend.dataPoints,
                                fontSize: settings.legendFontSize,
                                labelColor: settings.legendColor
                            };
                            if (this.dataView.legendObjectProperties) {
                                var position;
                                visuals.LegendData.update(legendData, this.dataView.legendObjectProperties), position = this.dataView.legendObjectProperties[visuals.legendProps.position], 
                                position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            }
                            var viewport = {
                                height: this.viewport.height + this.margin.top + this.margin.bottom,
                                width: this.viewport.width + this.margin.left + this.margin.right
                            };
                            this.legend.drawLegend(legendData, viewport), visuals.Legend.positionChartArea(this.root, this.legend), 
                            legendData.dataPoints.length > 0 && settings.showLegend && this.updateViewport();
                        }
                    }, TornadoChart.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.dataView || !this.dataView.settings) return [];
                        switch (settings = this.dataView.settings, options.objectName) {
                          case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxis(enumeration);
                            break;

                          case "labels":
                            var labelSettings = settings.labelSettings, labels = {
                                objectName: "labels",
                                displayName: "Labels",
                                selector: null,
                                properties: {
                                    show: labelSettings.show,
                                    fontSize: labelSettings.fontSize,
                                    labelPrecision: labelSettings.precision,
                                    labelDisplayUnits: labelSettings.displayUnits,
                                    insideFill: labelSettings.labelColor,
                                    outsideFill: settings.labelOutsideFillColor
                                }
                            };
                            enumeration.pushInstance(labels);
                            break;

                          case "legend":
                            if (!this.dataView.hasDynamicSeries) return;
                            var legend, showTitle = !0, titleText = "";
                            showTitle = powerbi.DataViewObject.getValue(this.dataView.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                            titleText = powerbi.DataViewObject.getValue(this.dataView.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                            legend = {
                                objectName: "legend",
                                displayName: "Legend",
                                selector: null,
                                properties: {
                                    show: settings.showLegend,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    fontSize: settings.legendFontSize,
                                    labelColor: settings.legendColor
                                }
                            }, enumeration.pushInstance(legend);
                            break;

                          case "categories":
                            var categories = {
                                objectName: "categories",
                                displayName: "Categories",
                                selector: null,
                                properties: {
                                    show: settings.showCategories,
                                    fill: settings.categoriesFillColor
                                }
                            };
                            enumeration.pushInstance(categories);
                        }
                        return enumeration.complete();
                    }, TornadoChart.prototype.enumerateDataPoint = function(enumeration) {
                        if (this.dataView && this.dataView.series) for (var series = this.dataView.series, i = 0, length = series.length; length > i; i++) enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: series[i].name,
                            selector: visuals.ColorHelper.normalizeSelector(series[i].selectionId.getSelector(), !1),
                            properties: {
                                fill: {
                                    solid: {
                                        color: series[i].fill
                                    }
                                }
                            }
                        });
                    }, TornadoChart.prototype.enumerateCategoryAxis = function(enumeration) {
                        if (this.dataView && this.dataView.series) for (var series = this.dataView.series, i = 0, length = series.length; length > i; i++) enumeration.pushInstance({
                            objectName: "categoryAxis",
                            displayName: series[i].name,
                            selector: series[i].selectionId ? series[i].selectionId.getSelector() : null,
                            properties: {
                                end: series[i].categoryAxisEnd
                            }
                        });
                    }, TornadoChart.prototype.destroy = function() {
                        this.root = null;
                    }, TornadoChart.ClassName = "tornado-chart", TornadoChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                },
                                Series: {
                                    min: 0,
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    min: 2,
                                    max: 2
                                },
                                Series: {
                                    max: 0
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data Colors",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    insideFill: {
                                        displayName: "Inside fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outsideFill: {
                                        displayName: "Outside fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "TextSize",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categories: {
                                displayName: "Group",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, TornadoChart.Properties = TornadoChart.getProperties(TornadoChart.capabilities), 
                    TornadoChart.Columns = {
                        "class": "columns",
                        selector: ".columns"
                    }, TornadoChart.Column = {
                        "class": "column",
                        selector: ".column"
                    }, TornadoChart.Axes = {
                        "class": "axes",
                        selector: ".axes"
                    }, TornadoChart.Axis = {
                        "class": "axis",
                        selector: ".axis"
                    }, TornadoChart.Labels = {
                        "class": "labels",
                        selector: ".labels"
                    }, TornadoChart.Label = {
                        "class": "label",
                        selector: ".label"
                    }, TornadoChart.LabelTitle = {
                        "class": "label-title",
                        selector: ".label-title"
                    }, TornadoChart.LabelText = {
                        "class": "label-text",
                        selector: ".label-text"
                    }, TornadoChart.Categories = {
                        "class": "categories",
                        selector: ".categories"
                    }, TornadoChart.Category = {
                        "class": "category",
                        selector: ".category"
                    }, TornadoChart.CategoryTitle = {
                        "class": "category-title",
                        selector: ".category-title"
                    }, TornadoChart.CategoryText = {
                        "class": "category-text",
                        selector: ".category-text"
                    }, TornadoChart.MaxSeries = 2, TornadoChart.MaxPrecision = 17, TornadoChart.LabelPadding = 2.5, 
                    TornadoChart.CategoryMinHeight = 25, TornadoChart.DefaultFontSize = 9, TornadoChart.DefaultLegendFontSize = 8, 
                    TornadoChart.HighlightedShapeFactor = .5, TornadoChart.CategoryLabelMargin = 10, 
                    TornadoChart.ScrollBarWidth = 22, TornadoChart.DefaultTornadoChartSettings = {
                        labelOutsideFillColor: visuals.dataLabelUtils.defaultLabelColor,
                        labelSettings: {
                            show: !0,
                            precision: null,
                            fontSize: TornadoChart.DefaultFontSize,
                            displayUnits: 0,
                            labelColor: visuals.dataLabelUtils.defaultInsideLabelColor
                        },
                        showCategories: !0,
                        showLegend: !0,
                        legendFontSize: TornadoChart.DefaultLegendFontSize,
                        legendColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        categoriesFillColor: "#777"
                    }, TornadoChart;
                }();
                samples.TornadoChart = TornadoChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                    var XLabelMaxAllowedOverflow = 35, xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2, xLabels = xAxisProperties.values, y1Labels = y1AxisProperties.values, leftOverflow = 0, rightOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0, scaleIsOrdinal = visuals.AxisHelper.isOrdinalScale(xAxisProperties.scale), xLabelOuterPadding = 0;
                    if (void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2)), 
                    0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) || 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height)) {
                        var rotation;
                        if (rotation = scrollbarVisible ? visuals.AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar : visuals.AxisHelper.LabelLayoutStrategy.DefaultRotation, 
                        renderY1Axis) for (var i = 0, len = y1Labels.length; len > i; i++) y1AxisTextProperties.text = y1Labels[i], 
                        maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));
                        if (y2AxisProperties && renderY2Axis) for (var y2Labels = y2AxisProperties.values, i = 0, len = y2Labels.length; len > i; i++) y2AxisTextProperties.text = y2Labels[i], 
                        maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));
                        var textHeight = textHeightMeasurer(xAxisTextProperties), maxNumLines = Math.floor(bottomMarginLimit / textHeight), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                        if (renderXAxis && xLabels.length > 0) {
                            for (var i = 0, len = xLabels.length; len > i; i++) {
                                var height;
                                xAxisTextProperties.text = xLabels[i];
                                var width = textWidthMeasurer(xAxisTextProperties);
                                if (xAxisProperties.willLabelsWordBreak) {
                                    var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                    height = wordBreaks.length * textHeight, width = xAxisProperties.xLabelMaxWidth;
                                } else !xAxisProperties.willLabelsFit && scaleIsOrdinal ? (height = width * rotation.sine, 
                                width *= rotation.cosine) : height = textHeight;
                                if (0 === i) {
                                    if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                                    leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                        var xPos = xScale(xDomain[0]);
                                        leftOverflow = width / 2 - xPos, leftOverflow = Math.max(leftOverflow, 0);
                                    }
                                } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                                rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                                    var xPos = xScale(xDomain[1]);
                                    rightOverflow = width / 2 - (viewport.width - xPos), rightOverflow = Math.max(rightOverflow, 0);
                                }
                                xMax = Math.max(xMax, height);
                            }
                            leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0, 
                            rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;
                        }
                    }
                    var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                    return showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), {
                        xMax: Math.ceil(bottomMargin),
                        yLeft: Math.ceil(leftMargin),
                        yRight: Math.ceil(rightMargin)
                    };
                }
                function getLayerData(dataViews, currentIdx, totalLayers) {
                    return totalLayers > 1 ? dataViews && dataViews.length > currentIdx ? [ dataViews[currentIdx] ] : [] : dataViews;
                }
                function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                    return 0 === layerNumber && !!valueAxisProperties && !!valueAxisProperties.showAxisTitle || 1 === layerNumber && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties.secShowAxisTitle;
                }
                function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {
                    var visualOptions = {
                        viewport: viewport,
                        margin: margin,
                        forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                        forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : visuals.axisScale.linear,
                        valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : visuals.axisScale.linear,
                        trimOrdinalDataOnOverflow: !1
                    }, yAxisWillMerge = !1;
                    valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain));
                    for (var result, layerNumber = 0, len = layers.length; len > layerNumber; layerNumber++) {
                        var currentlayer = layers[layerNumber];
                        visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                        var axes = currentlayer.calculateAxesProperties(visualOptions);
                        0 === layerNumber && (result = {
                            x: axes[0],
                            y1: axes[1]
                        }), result.x.willLabelsFit = !1, result.x.willLabelsWordBreak = !1;
                    }
                    return result;
                }
                function createLayers(type, objects, interactivityService, animator, isScrollable) {
                    void 0 === isScrollable && (isScrollable = !0);
                    var layers = [], cartesianOptions = {
                        isScrollable: isScrollable,
                        animator: animator,
                        interactivityService: interactivityService
                    };
                    return layers.push(createMekkoChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions)), 
                    layers;
                }
                function createMekkoChartLayer(type, defaultOptions) {
                    var options = {
                        animator: defaultOptions.animator,
                        interactivityService: defaultOptions.interactivityService,
                        isScrollable: defaultOptions.isScrollable,
                        chartType: type
                    };
                    return new MekkoColumnChart(options);
                }
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, MekkoDataWrapper = function() {
                    function MekkoDataWrapper(columnChartData, isScalar) {
                        this.data = columnChartData, this.isScalar = isScalar;
                    }
                    return MekkoDataWrapper.prototype.lookupXValue = function(index, type) {
                        var isDateTime = visuals.AxisHelper.isDateTime(type);
                        if (isDateTime && this.isScalar) return new Date(index);
                        var data = this.data;
                        if (type.text) return data.categories[index];
                        var firstSeries = data.series[0];
                        if (firstSeries) {
                            var seriesValues = firstSeries.data;
                            if (seriesValues) {
                                this.data.hasHighlights && (index = 2 * index);
                                var dataPoint = seriesValues[index];
                                if (dataPoint) return isDateTime ? new Date(dataPoint.categoryValue) : dataPoint.categoryValue;
                            }
                        }
                        return index;
                    }, MekkoDataWrapper;
                }();
                samples.MekkoDataWrapper = MekkoDataWrapper;
                var MekkoColumnChartStrategy = function() {
                    function MekkoColumnChartStrategy() {}
                    return MekkoColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                        this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                        this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                        this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                        this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                        this.viewportWidth = columnChartProps.viewportWidth;
                    }, MekkoColumnChartStrategy.prototype.setData = function(data) {
                        this.data = data;
                    }, MekkoColumnChartStrategy.createFormatter = function(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                        void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                        var formatter;
                        if (dataType.dateTime) if (isScalar) {
                            var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                            1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: value,
                                value2: value2,
                                tickCount: bestTickCount
                            });
                        } else {
                            var minDate = getValueFn(0, dataType), maxDate = getValueFn(scaleDomain.length - 1, dataType);
                            formatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: minDate,
                                value2: maxDate,
                                tickCount: bestTickCount
                            });
                        } else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                            var domainMin = tickValues[1] - tickValues[0], domainMax = 0;
                            formatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: domainMin,
                                value2: domainMax,
                                allowFormatBeautification: !0
                            });
                        } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                        return formatter;
                    }, MekkoColumnChartStrategy.formatAxisTickValues = function(axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                        var formattedTickValues = [];
                        return formatter ? !getValueFn || dataType.numeric && isScalar ? (axis.tickFormat(function(d) {
                            return formatter.format(d);
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(d);
                        })) : (axis.tickFormat(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        })) : formattedTickValues = tickValues.map(function(d) {
                            return getValueFn(d, dataType);
                        }), formattedTickValues;
                    }, MekkoColumnChartStrategy.prototype.createAxis = function(options) {
                        var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp), dataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn, isScalar), isLogScaleAllowed = visuals.AxisHelper.isLogScalePossible(dataDomain, dataType), scale = d3.scale.linear(), scaleDomain = [ 0, 1 ], bestTickCount = dataDomain.length || 1, borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings), chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
                        chartWidth < MekkoChart.MinOrdinalRectThickness && (chartWidth = MekkoChart.MinOrdinalRectThickness), 
                        scale.domain(scaleDomain).range([ 0, chartWidth ]);
                        var tickValues = dataDomain, formatter = MekkoColumnChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(dataDomain), formattedTickValues = [];
                        metaDataColumn && (formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn));
                        var xLabelMaxWidth;
                        if (!isScalar && categoryThickness) xLabelMaxWidth = Math.max(1, categoryThickness - 2 * visuals.CartesianChart.TickLabelPadding); else {
                            var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                            xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan, xLabelMaxWidth = Math.max(1, xLabelMaxWidth - 2 * visuals.CartesianChart.TickLabelPadding);
                        }
                        return {
                            scale: scale,
                            axis: axis,
                            formatter: formatter,
                            values: formattedTickValues,
                            axisType: dataType,
                            axisLabel: null,
                            isCategoryAxis: isCategoryAxis,
                            xLabelMaxWidth: xLabelMaxWidth,
                            categoryThickness: categoryThickness,
                            outerPadding: outerPadding,
                            usingDefaultDomain: !1,
                            isLogScaleAllowed: isLogScaleAllowed
                        };
                    }, MekkoColumnChartStrategy.prototype.getCategoryAxis = function(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
                        var categoryThickness = layout.categoryThickness, isScalar = layout.isScalar, outerPaddingRatio = layout.outerPaddingRatio, dw = new MekkoDataWrapper(data, isScalar), domain = [];
                        if (data.series && data.series.length > 0 && data.series[0].data && data.series[0].data.length > 0) {
                            var domainDoubles = data.series[0].data.map(function(item) {
                                return item.originalPosition + item.value / 2;
                            });
                            domain = domainDoubles.filter(function(item, pos) {
                                return domainDoubles.indexOf(item) === pos;
                            });
                        }
                        var axisProperties = this.createAxis({
                            pixelSpan: size,
                            dataDomain: domain,
                            metaDataColumn: data.categoryMetadata,
                            formatStringProp: visuals.columnChartProps.general.formatString,
                            outerPadding: categoryThickness * outerPaddingRatio,
                            isCategoryAxis: !0,
                            isScalar: isScalar,
                            isVertical: isVertical,
                            categoryThickness: categoryThickness,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: function(index, type) {
                                var domainIndex = domain.indexOf(index), value = dw.lookupXValue(domainIndex, type);
                                return value;
                            },
                            scaleType: axisScaleType,
                            borderSettings: data.borderSettings
                        });
                        return layout.categoryThickness = axisProperties.categoryThickness, axisProperties;
                    }, MekkoColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
                        var forcedXMin, forcedXMax, width = this.width;
                        forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                        var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType);
                        return props;
                    }, MekkoColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
                        var height = this.viewportHeight, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString), mekkoMekkoCreateAxisOptions = {
                            pixelSpan: height,
                            dataDomain: combinedDomain,
                            metaDataColumn: metadataColumn,
                            formatString: formatString,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !0,
                            forcedTickCount: forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: axisScaleType,
                            axisDisplayUnits: 0,
                            axisPrecision: 0,
                            is100Pct: is100Pct,
                            shouldClamp: shouldClamp,
                            formatStringProp: void 0
                        };
                        return this.yProps = visuals.AxisHelper.createAxis(mekkoMekkoCreateAxisOptions), 
                        this.yProps;
                    }, MekkoColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                        var data = this.data;
                        this.columnsCenters = null;
                        var result, shapes, axisOptions = {
                            columnWidth: 0,
                            xScale: this.xProps.scale,
                            yScale: this.yProps.scale,
                            isScalar: this.categoryLayout.isScalar,
                            margin: this.margin
                        }, stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions), labelDataPoints = this.createMekkoLabelDataPoints(), series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                        return this.animator && useAnimation && (result = this.animator.animate({
                            viewModel: data,
                            series: series,
                            layout: stackedColumnLayout,
                            itemCS: MekkoColumnChartStrategy.classes.item,
                            interactivityService: this.interactivityService,
                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                            viewPort: {
                                height: this.height,
                                width: this.width
                            }
                        }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = MekkoColumnChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                        visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                        {
                            shapesSelection: shapes,
                            viewport: {
                                height: this.height,
                                width: this.width
                            },
                            axisOptions: axisOptions,
                            labelDataPoints: labelDataPoints
                        };
                    }, MekkoColumnChartStrategy.drawDefaultShapes = function(data, series, layout, itemCS, filterZeros, hasSelection) {
                        var rectName = "rect";
                        filterZeros = !1;
                        var dataSelector;
                        dataSelector = filterZeros ? function(d) {
                            var filteredData = _.filter(d.data, function(datapoint) {
                                return !!datapoint.value;
                            });
                            return filteredData;
                        } : function(d) {
                            return d.data;
                        };
                        var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(dataSelector, function(d) {
                            return d.key;
                        });
                        shapes.enter().append(rectName).attr("class", function(d) {
                            return itemCS["class"].concat(d.highlight ? " highlight" : "");
                        }), shapes.style("fill", function(d) {
                            return d.color;
                        }).style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                        }).attr(layout.shapeLayout), shapes.exit().remove();
                        var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector), borders = borderSelection.data(dataSelector, function(d) {
                            return d.key;
                        }), borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
                        return borders.enter().append(rectName).classed(MekkoColumnChart.BorderClass["class"], !0), 
                        borders.style("fill", function(d) {
                            return borderColor;
                        }).style("fill-opacity", function(d) {
                            return data.hasHighlights ? visuals.ColumnUtil.DimmedOpacity : visuals.ColumnUtil.DefaultOpacity;
                        }).attr(layout.shapeBorder), borders.exit().remove(), shapes;
                    }, MekkoColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                        visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                        this.moveHandle(selectedColumnIndex);
                    }, MekkoColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                        return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                    }, MekkoColumnChartStrategy.prototype.getColumnsCenters = function() {
                        var _this = this;
                        if (!this.columnsCenters) {
                            var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                            if (this.data.series.length > 0) {
                                var xScaleOffset = 0;
                                this.categoryLayout.isScalar || (xScaleOffset = categoryWidth / 2);
                                var firstSeries = this.data.series[0];
                                firstSeries && firstSeries.data && (this.columnsCenters = firstSeries.data.map(function(d) {
                                    return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset;
                                }));
                            }
                        }
                        return this.columnsCenters;
                    }, MekkoColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                        var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex];
                        if (this.columnSelectionLineHandle) {
                            var handle = this.columnSelectionLineHandle;
                            handle.select("line").attr({
                                x1: x,
                                x2: x
                            }), handle.select("circle").attr({
                                cx: x
                            });
                        } else {
                            var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                            handle.append("line").classed("interactive-hover-line", !0).attr({
                                x1: x,
                                x2: x,
                                y1: 0,
                                y2: this.height
                            }), handle.append("circle").attr({
                                cx: x,
                                cy: this.height,
                                r: "6px"
                            }).classed("drag-handle", !0);
                        }
                    }, MekkoColumnChartStrategy.getLayout = function(data, axisOptions) {
                        var xScale = axisOptions.xScale, yScale = axisOptions.yScale, scaledY0 = yScale(0), scaledX0 = xScale(0), borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings), columnWidthScale = function(d) {
                            var value = visuals.AxisHelper.diffScaled(xScale, d.value, 0);
                            return value;
                        }, columnStart = function(d) {
                            var value = scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) + borderWidth * d.categoryIndex;
                            return value;
                        }, borderStart = function(d) {
                            var value = scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) + visuals.AxisHelper.diffScaled(xScale, d.value, 0) + borderWidth * d.categoryIndex;
                            return value;
                        };
                        return {
                            shapeLayout: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                }
                            },
                            shapeBorder: {
                                width: function(d) {
                                    return borderWidth;
                                },
                                x: borderStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                }
                            },
                            shapeLayoutWithoutHighlights: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute);
                                }
                            },
                            zeroShapeLayout: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                },
                                height: function(d) {
                                    return 0;
                                }
                            },
                            shapeXAxis: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                }
                            }
                        };
                    }, MekkoColumnChartStrategy.prototype.createMekkoLabelDataPoints = function() {
                        for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, i = 0, ilen = series.length; ilen > i; i++) {
                            var currentSeries = series[i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                            if (labelSettings.show && currentSeries.data) for (var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), j = 0; j < currentSeries.data.length; j++) {
                                var dataPoint = currentSeries.data[j];
                                if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                    var parentRect = {
                                        left: shapeLayout.x(dataPoint),
                                        top: shapeLayout.y(dataPoint),
                                        width: shapeLayout.width(dataPoint),
                                        height: shapeLayout.height(dataPoint)
                                    }, formatString = null, value = dataPoint.valueOriginal;
                                    labelSettings.displayUnits || (formatString = NewDataLabelUtils.hundredPercentFormat, 
                                    value = dataPoint.valueAbsolute);
                                    var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value)), properties = {
                                        text: text,
                                        fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                                        fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,
                                        fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight
                                    }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                                    labelDataPoints.push({
                                        isPreferred: !0,
                                        text: text,
                                        textSize: {
                                            width: textWidth,
                                            height: textHeight
                                        },
                                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,
                                        insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,
                                        isParentRect: !0,
                                        parentShape: {
                                            rect: parentRect,
                                            orientation: 1,
                                            validPositions: MekkoColumnChartStrategy.validLabelPositions
                                        },
                                        identity: dataPoint.identity,
                                        parentType: 1
                                    });
                                }
                            }
                        }
                        return labelDataPoints;
                    }, MekkoColumnChartStrategy.classes = {
                        item: createClassAndSelector("column"),
                        highlightItem: createClassAndSelector("highlightColumn")
                    }, MekkoColumnChartStrategy.validLabelPositions = [ 1 ], MekkoColumnChartStrategy;
                }();
                samples.MekkoColumnChartStrategy = MekkoColumnChartStrategy;
                var MekkoChart = function() {
                    function MekkoChart(options) {
                        this.isScrollable = !1, options ? (this.type = options.chartType, options.isScrollable && (this.isScrollable = options.isScrollable), 
                        this.animator = options.animator, options.cartesianSmallViewPortProperties && (this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties), 
                        options.behavior && (this.behavior = options.behavior)) : this.behavior = new MekkoChartBehavior([ new visuals.ColumnChartWebBehavior() ]);
                    }
                    return MekkoChart.getTextProperties = function(fontSize) {
                        return void 0 === fontSize && (fontSize = MekkoChart.FontSize), {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(fontSize)
                        };
                    }, MekkoChart.prototype.init = function(options) {
                        this.visualInitOptions = options, this.layers = [];
                        var element = this.element = options.element, viewport = this.currentViewport = options.viewport;
                        this.hostServices = options.host, this.brush = d3.svg.brush(), element.addClass(MekkoChart.ClassName), 
                        this.margin = {
                            top: 1,
                            right: 1,
                            bottom: 1,
                            left: 1
                        }, this.yAxisOrientation = visuals.yAxisPosition.left, this.adjustMargins(viewport), 
                        this.sharedColorPalette = new visuals.SharedColorPalette(options.style.colorPalette.dataColors);
                        var showLinesOnX = !0, showLinesOnY = !0, svg = this.svg = d3.select(element.get(0)).append("svg");
                        svg.style("position", "absolute");
                        var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                        this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                        var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                        this.labelGraphicsContextScrollable = this.svgScrollable.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                        this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable));
                        var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                        this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                        this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.y2AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), 
                        this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), 
                        this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), 
                        this.behavior && (this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                        this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, MekkoChart.prototype.renderAxesLabels = function(options) {
                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var margin = this.margin, width = options.viewport.width - (margin.left + margin.right), height = options.viewport.height, fontSize = MekkoChart.FontSize, heightOffset = fontSize, showOnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                        if (!options.hideXAxisTitle) {
                            var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.x).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "xAxisLabel",
                                        transform: visuals.SVGUtil.translate(width / 2, height - heightOffset)
                                    });
                                });
                            });
                            xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null), 
                            xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!options.hideYAxisTitle) {
                            var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showOnRight ? width + margin.right - fontSize : -margin.left,
                                        x: -((height - margin.top - options.legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null), 
                            yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                            var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y2).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showOnRight ? -margin.left : width + margin.right - fontSize,
                                        x: -((height - margin.top - options.legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null), 
                            y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }, MekkoChart.prototype.adjustMargins = function(viewport) {
                        var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), xAxis = this.element.find(".x.axis");
                        0 === visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) && 0 === visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) ? (this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, xAxis.hide()) : xAxis.show();
                    }, MekkoChart.prototype.translateAxes = function(viewport) {
                        this.adjustMargins(viewport);
                        var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), showY1OnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                        this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, height)), 
                        this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0)), 
                        this.y2AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0)), 
                        this.svg.attr({
                            width: viewport.width,
                            height: viewport.height
                        }), this.svg.style("top", this.legend.isVisible() ? this.legend.getMargins().height + "px" : 0), 
                        this.svgScrollable.attr({
                            width: viewport.width,
                            height: viewport.height
                        }), this.svgScrollable.attr({
                            x: 0
                        }), this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.labelGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.isXScrollBarVisible ? (this.svgScrollable.attr({
                            x: this.margin.left
                        }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                        this.labelGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                        this.svgScrollable.attr("width", width), this.svg.attr("width", viewport.width).attr("height", viewport.height + MekkoChart.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", height + margin.top), 
                        this.svg.attr("width", viewport.width + MekkoChart.ScrollBarWidth).attr("height", viewport.height));
                    }, MekkoChart.getIsScalar = function(objects, propertyId, type) {
                        var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                        return objects && void 0 !== axisTypeValue ? axisTypeValue === visuals.axisType.scalar && !visuals.AxisHelper.isOrdinal(type) : !visuals.AxisHelper.isOrdinal(type);
                    }, MekkoChart.prototype.populateObjectProperties = function(dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            if (dataViewMetadata ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}), 
                            this.borderObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "columnBorder", {})) : (this.legendObjectProperties = {}, 
                            this.borderObjectProperties = {}), this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                            this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata), 
                            dataViewMetadata && dataViewMetadata.objects) {
                                var categoryAxis = dataViewMetadata.objects.categoryAxis, valueAxis = dataViewMetadata.objects.valueAxis;
                                categoryAxis && (this.categoryAxisProperties.showBorder = categoryAxis.showBorder, 
                                this.categoryAxisProperties.fontSize = categoryAxis.fontSize), valueAxis && (this.valueAxisProperties.fontSize = valueAxis.fontSize);
                            }
                            var axisPosition = this.valueAxisProperties.position;
                            this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                        }
                    }, MekkoChart.prototype.update = function(options) {
                        var dataViews = this.dataViews = options.dataViews;
                        if (this.currentViewport = options.viewport, !dataViews) return void this.clearViewport();
                        if (this.currentViewport.width < MekkoChart.MinWidth || this.currentViewport.height < MekkoChart.MinHeight) return void this.clearViewport();
                        0 === this.layers.length && (this.layers = this.createAndInitLayers(dataViews));
                        var layers = this.layers;
                        if (dataViews && dataViews.length > 0) {
                            var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                            warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                        }
                        this.sharedColorPalette.clearPreferredScale();
                        for (var i = 0, len = layers.length; len > i; i++) layers[i].setData(getLayerData(dataViews, i, len)), 
                        len > 1 && this.sharedColorPalette.rotateScale();
                        this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend || this.renderLegend(), 
                        this.render(!this.hasSetData || options.suppressAnimations), this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0;
                    }, MekkoChart.prototype.clearViewport = function() {
                        this.legend.reset(), this.setVisibility(!1);
                    }, MekkoChart.prototype.setVisibility = function(status) {
                        void 0 === status && (status = !0), this.svg.style("display", status ? "block" : "none"), 
                        this.element.find(".legend").toggle(status);
                    }, MekkoChart.parseLabelSettings = function(objects) {
                        var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(!0), labelsObj = objects.labels, minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;
                        return visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings), 
                        labelSettings.precision < minPrecision && (labelSettings.precision = minPrecision), 
                        labelSettings.precision > maxPrecision && (labelSettings.precision = maxPrecision), 
                        labelSettings;
                    }, MekkoChart.parseBorderSettings = function(objects) {
                        var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                        return width > maxWidth ? width = maxWidth : 0 > width && (width = 0), show || (width = 0), 
                        {
                            show: show,
                            color: color,
                            width: width
                        };
                    }, MekkoChart.prototype.enumerateBorder = function(enumeration) {
                        var objects = {
                            columnBorder: this.borderObjectProperties
                        }, show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                        width > maxWidth ? width = maxWidth : 0 > width && (width = 0);
                        var instance = {
                            objectName: "columnBorder",
                            selector: null,
                            properties: {
                                show: show,
                                color: color,
                                width: width
                            }
                        };
                        enumeration.pushInstance(instance);
                    }, MekkoChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder(), layersLength = this.layers ? this.layers.length : 0;
                        if ("columnBorder" === options.objectName) this.enumerateBorder(enumeration); else if ("legend" === options.objectName) {
                            if (!this.shouldShowLegendCard()) return;
                            var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : ""), fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                            enumeration.pushInstance({
                                selector: null,
                                properties: {
                                    show: show,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    fontSize: fontSize
                                },
                                objectName: options.objectName
                            });
                        } else "categoryAxis" === options.objectName && this.hasCategoryAxis ? this.getCategoryAxisValues(enumeration) : "valueAxis" === options.objectName && this.getValueAxisValues(enumeration);
                        for (var i = 0, len = layersLength; len > i; i++) {
                            var layer = this.layers[i];
                            layer.enumerateObjectInstances && layer.enumerateObjectInstances(enumeration, options);
                        }
                        return enumeration.complete();
                    }, MekkoChart.prototype.shouldShowLegendCard = function() {
                        var layers = this.layers, dataViews = this.dataViews;
                        if (layers && dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; layersLength > i; i++) {
                            if (layers[i].hasLegend()) return !0;
                            var dataView = dataViews[i];
                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && (layersWithValuesCtr++, 
                            layersWithValuesCtr > 1)) return !0;
                        }
                        return !1;
                    }, MekkoChart.prototype.getCategoryAxisValues = function(enumeration) {
                        var supportedType = visuals.axisType.both, isScalar = !1, logPossible = !!this.axes.x.isLogScaleAllowed, scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ];
                        this.layers && this.layers[0].getSupportedCategoryAxisType && (supportedType = this.layers[0].getSupportedCategoryAxisType(), 
                        isScalar = supportedType === visuals.axisType.scalar ? !0 : visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties)), 
                        isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                        this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.categoryAxisProperties && null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                        this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                        instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null), 
                        instance.properties.showAxisTitle = this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !1, 
                        instance.properties.showBorder = this.categoryAxisProperties && null != this.categoryAxisProperties.showBorder ? this.categoryAxisProperties.showAxisTitle : !1, 
                        instance.properties.fontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null,
                                fontSize: this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                            },
                            objectName: "categoryAxis",
                            validValues: {
                                axisStyle: this.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        });
                    }, MekkoChart.prototype.getValueAxisValues = function(enumeration) {
                        var scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ], logPossible = !!this.axes.y1.isLogScaleAllowed, instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.valueAxisProperties && null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                        this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                        instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                        instance.properties.showAxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !1, 
                        instance.properties.fontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null,
                                fontSize: this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                            },
                            objectName: "valueAxis",
                            validValues: {
                                axisStyle: this.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        }), 2 === this.layers.length && (instance.properties.secShow = this.valueAxisProperties && null != this.valueAxisProperties.secShow ? this.valueAxisProperties.secShow : this.y2AxisExists, 
                        instance.properties.secShow && (instance.properties.axisLabel = ""));
                    }, MekkoChart.prototype.onClearSelection = function() {
                        if (this.hasSetData) for (var i = 0, len = this.layers.length; len > i; i++) {
                            var layer = this.layers[i];
                            layer.onClearSelection(), layer.render(!0);
                        }
                    }, MekkoChart.prototype.createAndInitLayers = function(dataViews) {
                        var objects, _this = this;
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            dataViewMetadata && (objects = dataViewMetadata.objects);
                        }
                        var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable), cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                        cartesianOptions.svg = this.axisGraphicsContextScrollable, cartesianOptions.cartesianHost = {
                            updateLegend: function(data) {
                                return _this.legend.drawLegend(data, _this.currentViewport);
                            },
                            getSharedColors: function() {
                                return _this.sharedColorPalette;
                            },
                            triggerRender: void 0
                        };
                        for (var i = 0, len = layers.length; len > i; i++) layers[i].init(cartesianOptions);
                        return layers;
                    }, MekkoChart.prototype.renderLegend = function() {
                        for (var layers = this.layers, legendData = {
                            title: "",
                            dataPoints: []
                        }, i = 0, len = layers.length; len > i; i++) this.layerLegendData = layers[i].calculateLegend(), 
                        this.layerLegendData && (legendData.title = 0 === i ? this.layerLegendData.title || "" : legendData.title, 
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                        this.layerLegendData.grouped && (legendData.grouped = !0));
                        var legendProperties = this.legendObjectProperties;
                        if (legendProperties) {
                            legendProperties.fontSize || (legendProperties.fontSize = NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            visuals.LegendData.update(legendData, legendProperties);
                            var position = legendProperties[visuals.legendProps.position];
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                        } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                        (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []), 
                        this.legend.drawLegend(legendData, this.currentViewport);
                    }, MekkoChart.prototype.hideLegends = function() {
                        return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                    }, MekkoChart.prototype.addUnitTypeToAxisLabel = function(axes) {
                        var unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.x;
                        });
                        if (axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        axes.x.axisLabel && unitType && (axes.x.isCategoryAxis ? axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType) : axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType)), 
                        unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.y1;
                        }), axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        axes.y1.axisLabel && unitType && (axes.y1.isCategoryAxis ? axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType) : axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType)), 
                        axes.y2) {
                            var unitType = MekkoChart.getUnitType(axes, function(axis) {
                                return axis.y2;
                            });
                            this.secValueAxisHasUnitType = null !== unitType, axes.y2.axisLabel && unitType && this.valueAxisProperties && this.valueAxisProperties.secAxisStyle && (this.valueAxisProperties.secAxisStyle === visuals.axisStyle.showBoth ? axes.y2.axisLabel = axes.y2.axisLabel + " (" + unitType + ")" : this.valueAxisProperties.secAxisStyle === visuals.axisStyle.showUnitOnly && (axes.y2.axisLabel = unitType));
                        }
                    }, MekkoChart.prototype.shouldRenderSecondaryAxis = function(axisProperties) {
                        return axisProperties && (!this.valueAxisProperties || null == this.valueAxisProperties.secShow || this.valueAxisProperties.secShow) ? axisProperties.values && axisProperties.values.length > 0 : !1;
                    }, MekkoChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                        return void 0 === propertyName && (propertyName = "show"), axisProperties ? (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName]) && (axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) ? !1 : axisProperties.values && axisProperties.values.length > 0 : !1;
                    }, MekkoChart.prototype.render = function(suppressAnimations) {
                        this.setVisibility(!0);
                        var legendMargins = this.legendMargins = this.legend.getMargins(), viewport = {
                            height: this.currentViewport.height - legendMargins.height,
                            width: this.currentViewport.width - legendMargins.width
                        }, maxMarginFactor = this.getMaxMarginFactor(), leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
                        this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
                        var xAxisTextProperties = MekkoChart.getTextProperties(this.categoryAxisProperties && parseFloat(this.categoryAxisProperties.fontSize) || void 0), y1AxisTextProperties = MekkoChart.getTextProperties(this.valueAxisProperties && parseFloat(this.valueAxisProperties.fontSize) || void 0), margin = this.margin;
                        margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2, margin.bottom = MekkoChart.MinBottomMargin, 
                        margin.right = 0;
                        var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                        this.yAxisIsCategorical = axes.y1.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                        var mainAxisScale, preferredViewport, renderXAxis = this.shouldRenderAxis(axes.x), renderY1Axis = this.shouldRenderAxis(axes.y1), renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2), width = viewport.width - (margin.left + margin.right), isScalar = !1;
                        this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        if (this.layers && (this.layers[0].getVisualCategoryAxisIsScalar && (isScalar = this.layers[0].getVisualCategoryAxisIsScalar()), 
                        !isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea)) {
                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness, categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness), 
                            this.scrollX && preferredViewport && preferredViewport.width > viewport.width && (this.isXScrollBarVisible = !0, 
                            viewport.height -= MekkoChart.ScrollBarWidth), this.scrollY && preferredViewport && preferredViewport.height > viewport.height && (this.isYScrollBarVisible = !0, 
                            viewport.width -= MekkoChart.ScrollBarWidth, width = viewport.width - (margin.left + margin.right));
                        }
                        this.isXScrollBarVisible || this.isYScrollBarVisible ? this.brushGraphicsContext || (this.brushGraphicsContext = this.svg.append("g").classed("x brush", !0)) : (this.svg.selectAll(".brush").remove(), 
                        this.brushGraphicsContext = void 0), axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                        for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0, tickLabelMargins = void 0, chartHasAxisLabels = void 0, axisLabels = void 0; !doneWithMargins && maxIterations > numIterations; ) {
                            numIterations++, tickLabelMargins = getTickLabelMargins({
                                width: width,
                                height: viewport.height
                            }, leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, !1, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? tickLabelMargins.xMax / 1.8 : 0;
                            maxMainYaxisSide += MekkoChart.LeftPadding, maxSecondYaxisSide += MekkoChart.RightPadding, 
                            xMax += MekkoChart.BottomPadding, this.hideAxisLabels(legendMargins) && (axes.x.axisLabel = null, 
                            axes.y1.axisLabel = null, axes.y2 && (axes.y2.axisLabel = null)), this.addUnitTypeToAxisLabel(axes), 
                            axisLabels = {
                                x: axes.x.axisLabel,
                                y: axes.y1.axisLabel,
                                y2: axes.y2 ? axes.y2.axisLabel : null
                            }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                            null != axisLabels.x && (xMax += MekkoChart.XAxisLabelPadding), null != axisLabels.y && (maxMainYaxisSide += MekkoChart.YAxisLabelPadding), 
                            null != axisLabels.y2 && (maxSecondYaxisSide += MekkoChart.YAxisLabelPadding), margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                            margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, margin.bottom = xMax, 
                            this.margin = margin, width = viewport.width - (margin.left + margin.right);
                            var previousTickCountY1 = axes.y1.values.length, previousTickCountY2 = axes.y2 && axes.y2.values.length;
                            axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes), 
                            axes.y1.values.length !== previousTickCountY1 || axes.y2 && axes.y2.values.length !== previousTickCountY2 || (doneWithMargins = !0);
                        }
                        this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
                    }, MekkoChart.prototype.hideAxisLabels = function(legendMargins) {
                        return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height + legendMargins.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.visualInitOptions.interactivity.isInteractiveLegend);
                    }, MekkoChart.getUnitType = function(axis, axisPropertiesLookup) {
                        return axisPropertiesLookup(axis).formatter && axisPropertiesLookup(axis).formatter.displayUnit && axisPropertiesLookup(axis).formatter.displayUnit.value > 1 ? axisPropertiesLookup(axis).formatter.displayUnit.title : null;
                    }, MekkoChart.prototype.getMaxMarginFactor = function() {
                        return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
                    }, MekkoChart.getChartViewport = function(viewport, margin) {
                        return {
                            width: viewport.width - margin.left - margin.right,
                            height: viewport.height - margin.top - margin.bottom
                        };
                    }, MekkoChart.wordBreak = function(text, axisProperties, columnsWidth, maxHeight, borderWidth) {
                        text.each(function(data, index) {
                            var width, allowedLength, node = d3.select(this);
                            columnsWidth.length >= index ? (width = columnsWidth[index], allowedLength = axisProperties.scale(width)) : allowedLength = axisProperties.xLabelMaxWidth, 
                            node.style("text-anchor", "middle").attr({
                                dx: "0em",
                                dy: "1em",
                                transform: "rotate(0)"
                            }), powerbi.TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);
                        });
                    }, MekkoChart.prototype.renderChart = function(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
                        var xLabelColor, yLabelColor, y2LabelColor, xFontSize, yFontSize, bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, layers = this.layers, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
                        if (this.shouldRenderAxis(axes.x)) {
                            axes.x.isCategoryAxis ? (xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                            xFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (xLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                            xFontSize = this.valueAxisProperties && this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            axes.x.axis.orient("bottom"), axes.x.willLabelsFit || axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
                            var xAxisGraphicsElement = this.xAxisGraphicsContext;
                            duration ? xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis) : xAxisGraphicsElement.call(axes.x.axis), 
                            xAxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, xLabelColor).call(MekkoChart.setAxisLabelFontSize, xFontSize);
                            var xAxisTextNodes = xAxisGraphicsElement.selectAll("text"), columnWidth = [], borderWidth = 0;
                            this.layers && this.layers.length && (columnWidth = this.layers[0].getColumnsWidth(), 
                            borderWidth = this.layers[0].getBorderWidth()), xAxisGraphicsElement.call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8), 
                            xAxisTextNodes.call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
                        } else this.xAxisGraphicsContext.selectAll("*").remove();
                        if (this.shouldRenderAxis(axes.y1)) {
                            axes.y1.isCategoryAxis ? (yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                            yFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (yLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                            yFontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                            var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                            axes.y1.axis.tickSize(-width).tickPadding(MekkoChart.TickPaddingY).orient(yAxisOrientation.toLowerCase());
                            var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                            duration ? y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis) : y1AxisGraphicsElement.call(axes.y1.axis), 
                            y1AxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, yLabelColor).call(MekkoChart.setAxisLabelFontSize, yFontSize), 
                            tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis), 
                            !axes.y2 || this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow ? this.y2AxisGraphicsContext.selectAll("*").remove() : (y2LabelColor = this.valueAxisProperties && this.valueAxisProperties.secLabelColor ? this.valueAxisProperties.secLabelColor : null, 
                            axes.y2.axis.tickPadding(MekkoChart.TickPaddingY).orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase()), 
                            duration ? this.y2AxisGraphicsContext.transition().duration(duration).call(axes.y2.axis) : this.y2AxisGraphicsContext.call(axes.y2.axis), 
                            this.y2AxisGraphicsContext.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, y2LabelColor), 
                            tickLabelMargins.yRight >= leftRightMarginLimit && this.y2AxisGraphicsContext.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.RightPadding, powerbi.TextMeasurementService.svgEllipsis));
                        } else this.y1AxisGraphicsContext.selectAll("*").remove(), this.y2AxisGraphicsContext.selectAll("*").remove();
                        if (chartHasAxisLabels) {
                            var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1, renderAxisOptions = {
                                axisLabels: axisLabels,
                                legendMargin: this.legendMargins.height,
                                viewport: viewport,
                                hideXAxisTitle: hideXAxisTitle,
                                hideYAxisTitle: hideYAxisTitle,
                                hideY2AxisTitle: hideY2AxisTitle,
                                xLabelColor: xLabelColor,
                                yLabelColor: yLabelColor,
                                y2LabelColor: y2LabelColor,
                                margin: void 0
                            };
                            this.renderAxesLabels(renderAxisOptions);
                        } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        this.translateAxes(viewport);
                        var dataPoints = [], layerBehaviorOptions = [], labelDataPointsGroup = [];
                        if (this.behavior) {
                            for (var i = 0, len = layers.length; len > i; i++) {
                                var result = layers[i].render(suppressAnimations);
                                if (result) if (dataPoints = dataPoints.concat(result.dataPoints), layerBehaviorOptions.push(result.behaviorOptions), 
                                result.labelDataPointGroups) for (var resultLabelDataPointsGroups = result.labelDataPointGroups, j = 0, jlen = resultLabelDataPointsGroups.length; jlen > j; j++) {
                                    var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
                                    labelDataPointsGroup.push({
                                        labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
                                        maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels
                                    });
                                } else {
                                    var resultsLabelDataPoints = result.labelDataPoints, reducedDataPoints = resultsLabelDataPoints;
                                    labelDataPointsGroup.push({
                                        labelDataPoints: reducedDataPoints,
                                        maxNumberOfLabels: reducedDataPoints.length
                                    });
                                }
                            }
                            var labelLayoutOptions = {
                                maximumOffset: NewDataLabelUtils.maxLabelOffset,
                                startingOffset: NewDataLabelUtils.startingLabelOffset
                            }, labelLayout = new powerbi.LabelLayout(labelLayoutOptions), dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
                            if (layers.length > 1 && NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", .7), 
                            this.animator && !suppressAnimations ? NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration()) : NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels), 
                            this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none"), 
                            this.interactivityService) {
                                var behaviorOptions = {
                                    layerOptions: layerBehaviorOptions,
                                    clearCatcher: this.clearCatcher
                                };
                                this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                            }
                        }
                    }, MekkoChart.darkenZeroLine = function(g) {
                        var zeroTick = g.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).node();
                        zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                    }, MekkoChart.setAxisLabelColor = function(g, fill) {
                        g.selectAll("g.tick text").style("fill", fill ? fill.solid.color : null);
                    }, MekkoChart.setAxisLabelFontSize = function(g, fontSize) {
                        var value = jsCommon.PixelConverter.toString(fontSize);
                        g.selectAll("g.tick text").attr("font-size", value);
                    }, MekkoChart.moveBorder = function(g, scale, borderWidth, yOffset) {
                        void 0 === yOffset && (yOffset = 0), g.selectAll("g.tick").attr("transform", function(value, index) {
                            return visuals.SVGUtil.translate(scale(value) + borderWidth * index, yOffset);
                        });
                    }, MekkoChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Series"
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Y Axis"
                        }, {
                            name: "Width",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Axis width"
                        } ],
                        objects: {
                            columnBorder: {
                                displayName: "Column Border",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showSeries: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                        placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    showAll: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_ShowAll"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        type: {
                                            formatting: {
                                                legendPosition: !0
                                            }
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Title text",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    axisType: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                                        type: {
                                            formatting: {
                                                axisType: !0
                                            }
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    intersection: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Intersection"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 0,
                                    max: 1
                                },
                                Series: {
                                    min: 0,
                                    max: 1
                                },
                                Y: {
                                    min: 0,
                                    max: 1
                                },
                                Width: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Y"
                                            }
                                        }, {
                                            "for": {
                                                "in": "Width"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1,
                                        max: 1
                                    },
                                    supported: {
                                        min: 0
                                    }
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            "default": {}
                        },
                        drilldown: {
                            roles: [ "Category" ]
                        }
                    }, MekkoChart.properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        columnBorder: {
                            show: {
                                objectName: "columnBorder",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "columnBorder",
                                propertyName: "color"
                            },
                            width: {
                                objectName: "columnBorder",
                                propertyName: "width"
                            }
                        }
                    }, MekkoChart.DefaultSettings = {
                        columnBorder: {
                            show: !0,
                            color: "#fff",
                            width: 2,
                            maxWidth: 5
                        },
                        labelSettings: {
                            maxPrecision: 4,
                            minPrecision: 0
                        }
                    }, MekkoChart.MinOrdinalRectThickness = 20, MekkoChart.MinScalarRectThickness = 2, 
                    MekkoChart.OuterPaddingRatio = .4, MekkoChart.InnerPaddingRatio = .2, MekkoChart.TickLabelPadding = 2, 
                    MekkoChart.ClassName = "cartesianChart", MekkoChart.AxisGraphicsContextClassName = "axisGraphicsContext", 
                    MekkoChart.MaxMarginFactor = .25, MekkoChart.MinBottomMargin = 50, MekkoChart.LeftPadding = 10, 
                    MekkoChart.RightPadding = 10, MekkoChart.BottomPadding = 16, MekkoChart.YAxisLabelPadding = 20, 
                    MekkoChart.XAxisLabelPadding = 20, MekkoChart.TickPaddingY = 10, MekkoChart.TickPaddingRotatedX = 5, 
                    MekkoChart.FontSize = 11, MekkoChart.MaxNumberOfLabels = 100, MekkoChart.MinWidth = 100, 
                    MekkoChart.MinHeight = 100, MekkoChart.ScrollBarWidth = 10, MekkoChart;
                }();
                samples.MekkoChart = MekkoChart, samples.createLayers = createLayers;
                var EnumExtensions = jsCommon.EnumExtensions, ArrayExtensions = jsCommon.ArrayExtensions, flagBar = 2, flagStacked = 16, RoleNames = {
                    category: "Category",
                    series: "Series",
                    y: "Y",
                    width: "Width"
                }, MekkoColumnChart = function() {
                    function MekkoColumnChart(options) {
                        var chartType = options.chartType;
                        this.chartType = chartType, this.categoryAxisType = null, this.animator = options.animator, 
                        this.isScrollable = options.isScrollable, this.interactivityService = options.interactivityService;
                    }
                    return MekkoColumnChart.prototype.init = function(options) {
                        this.svg = options.svg, this.unclippedGraphicsContext = this.svg.append("g").classed("columnChartUnclippedGraphicsContext", !0), 
                        this.mainGraphicsContext = this.unclippedGraphicsContext.append("svg").classed("columnChartMainGraphicsContext", !0), 
                        this.labelGraphicsContext = this.svg.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                        this.style = options.style, this.currentViewport = options.viewport, this.hostService = options.host, 
                        this.interactivity = options.interactivity, this.colors = this.style.colorPalette.dataColors, 
                        this.cartesianVisualHost = options.cartesianHost, this.options = options, this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                        var element = this.element = options.element;
                        element.addClass(MekkoColumnChart.ColumnChartClassName), this.columnChart = new MekkoColumnChartStrategy();
                    }, MekkoColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                        var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right), metaDataColumn = this.data ? this.data.categoryMetadata : void 0, categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isScalar = this.data ? this.data.scalarCategoryAxis : !1, domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                        return visuals.CartesianChart.getLayout(this.data, {
                            availableWidth: availableWidth,
                            categoryCount: numCategoryValues,
                            domain: domain,
                            isScalar: isScalar,
                            isScrollable: this.isScrollable,
                            trimOrdinalDataOnOverflow: !1
                        });
                    }, MekkoColumnChart.getBorderWidth = function(border) {
                        if (!border || !border.show || !border.width) return 0;
                        var width = border.width;
                        return 0 > width ? 0 : width > border.maxWidth ? border.maxWidth : width;
                    }, MekkoColumnChart.getBorderColor = function(border) {
                        return border ? border.color : MekkoChart.DefaultSettings.columnBorder.color;
                    }, MekkoColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                        void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                        void 0 === supportsOverflow && (supportsOverflow = !1), void 0 === dataViewMetadata && (dataViewMetadata = null);
                        var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                        isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties), dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                        var converterStrategy = new ColumnChartConverterHelper(dataView), categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString), categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : void 0, borderSettings = MekkoChart.DefaultSettings.columnBorder, labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(!0), defaultDataPointColor = void 0, showAllDataPoints = void 0;
                        if (dataViewMetadata && dataViewMetadata.objects) {
                            var objects = dataViewMetadata.objects;
                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                            showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints), 
                            labelSettings = MekkoChart.parseLabelSettings(objects), borderSettings = MekkoChart.parseBorderSettings(objects);
                        }
                        for (var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor), legend = legendAndSeriesInfo.legend.dataPoints, seriesSources = legendAndSeriesInfo.seriesSources, result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata), columnSeries = result.series, valuesMetadata = [], j = 0, jlen = legend.length; jlen > j; j++) valuesMetadata.push(seriesSources[j]);
                        var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                        return {
                            categories: categories,
                            categoriesWidth: result.categoriesWidth,
                            categoryFormatter: categoryFormatter,
                            series: columnSeries,
                            valuesMetadata: valuesMetadata,
                            legendData: legendAndSeriesInfo.legend,
                            hasHighlights: result.hasHighlights,
                            categoryMetadata: categoryMetadata,
                            scalarCategoryAxis: isScalar,
                            borderSettings: borderSettings,
                            labelSettings: labelSettings,
                            axesLabels: {
                                x: labels.xAxisLabel,
                                y: labels.yAxisLabel
                            },
                            hasDynamicSeries: result.hasDynamicSeries,
                            defaultDataPointColor: defaultDataPointColor,
                            showAllDataPoints: showAllDataPoints,
                            isMultiMeasure: !1
                        };
                    }, MekkoColumnChart.getStackedMultiplier = function(rawValues, rowIdx, seriesCount, categoryCount) {
                        for (var pos = 0, neg = 0, i = 0; seriesCount > i; i++) {
                            var value = rawValues[i][rowIdx];
                            value = visuals.AxisHelper.normalizeNonFiniteNumber(value), value > 0 ? pos += value : 0 > value && (neg -= value);
                        }
                        var absTotal = pos + neg;
                        return {
                            pos: pos ? pos / absTotal / pos : 1,
                            neg: neg ? neg / absTotal / neg : 1
                        };
                    }, MekkoColumnChart.createDataPoints = function(dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
                        void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                        void 0 === supportsOverflow && (supportsOverflow = !1);
                        var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : void 0, categoryCount = categories.length, seriesCount = legend.length, columnSeries = [];
                        if (1 > seriesCount || 1 > categoryCount || null === categories[0]) return {
                            series: columnSeries,
                            hasHighlights: !1,
                            hasDynamicSeries: !1,
                            categoriesWidth: []
                        };
                        var dvCategories = dataViewCat.categories;
                        categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata), isDateTime = visuals.AxisHelper.isDateTime(categoryType), baseValuesPos = [], baseValuesNeg = [], rawValues = [], rawHighlightValues = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source), widthColumns = [], widthIndex = -1, seriesIndex = 0, highlightsOverflow = !1, hasHighlights = converterStrategy.hasHighlightValues(0);
                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width] && !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
                            widthIndex = seriesIndex;
                            for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; valuesLen > i; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                        } else {
                            for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                                var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                                if (seriesValues[categoryIndex] = value, hasHighlights) {
                                    var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                    seriesHighlightValues[categoryIndex] = highlightValue, value >= 0 && highlightValue >= 0 && value >= highlightValue || 0 >= value && 0 >= highlightValue && highlightValue >= value || (highlightsOverflow = !0);
                                }
                            }
                            rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                        }
                        if (highlightsOverflow && !supportsOverflow && (highlightsOverflow = !1, hasHighlights = !1, 
                        rawValues = rawHighlightValues), widthColumns.length < 1) for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
                            widthIndex = seriesIndex;
                            for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; valuesLen > i; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                        } else ;
                        if (widthColumns.length < 1) for (seriesIndex = 0; categoryCount > seriesIndex; seriesIndex++) widthColumns.push(1);
                        var totalSum = d3.sum(widthColumns), linearScale = d3.scale.linear().domain([ 0, totalSum ]).range([ 0, 1 ]), columnStartX = [ 0 ], columnWidth = [];
                        for (seriesIndex = 0; categoryCount - 1 > seriesIndex; seriesIndex++) {
                            var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
                            columnStartX.push(stepWidth);
                        }
                        for (seriesIndex = 0; categoryCount > seriesIndex; seriesIndex++) columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]), 
                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
                        var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                        for (seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                            var seriesLabelSettings, seriesDataPoints = [], legendItem = legend[seriesIndex];
                            if (!hasDynamicSeries) {
                                var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                                labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                            }
                            var series = {
                                displayName: legendItem.label,
                                key: "series" + seriesIndex,
                                index: seriesIndex,
                                data: seriesDataPoints,
                                identity: legendItem.identity,
                                color: legendItem.color,
                                labelSettings: seriesLabelSettings
                            };
                            seriesCount > 1 && (dataPointObjects = seriesObjectsList[seriesIndex]);
                            for (var metadata = dataViewCat.values[seriesIndex].source, categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                                0 === seriesIndex && (baseValuesPos.push(0), baseValuesNeg.push(0));
                                var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                                if (!(null == value && seriesIndex > 0)) {
                                    var originalValue = value, categoryValue = categories[categoryIndex];
                                    if (isDateTime && categoryValue && (categoryValue = categoryValue.getTime()), !isScalar || null != categoryValue && !isNaN(categoryValue)) {
                                        var multipliers;
                                        is100PercentStacked && (multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount));
                                        var unadjustedValue = value, isNegative = 0 > value;
                                        multipliers && (value *= isNegative ? multipliers.neg : multipliers.pos);
                                        var position, valueAbsolute = Math.abs(value);
                                        isNegative ? (position = baseValuesNeg[categoryIndex], isNaN(valueAbsolute) || (baseValuesNeg[categoryIndex] -= valueAbsolute)) : (isNaN(valueAbsolute) || (baseValuesPos[categoryIndex] += valueAbsolute), 
                                        position = baseValuesPos[categoryIndex]);
                                        var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null, category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataViewCat.values, columnGroup).withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex)).createSelectionId(), rawCategoryValue = categories[categoryIndex], color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects), seriesData = [];
                                        if (columnGroup) {
                                            var seriesValueColumn = {
                                                values: [],
                                                source: dataViewCat.values.source
                                            };
                                            seriesData.push({
                                                value: columnGroup.name,
                                                metadata: seriesValueColumn
                                            });
                                            for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
                                                var columnValues = columnGroup.values[columnIndex];
                                                seriesData.push({
                                                    value: columnValues.values[categoryIndex],
                                                    metadata: columnValues
                                                });
                                            }
                                        }
                                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, rawCategoryValue, originalValue, [ category ], seriesData, null, categoryIndex), dataPointLabelSettings = series && series.labelSettings ? series.labelSettings : defaultLabelSettings, labelColor = dataPointLabelSettings.labelColor, lastValue = void 0;
                                        EnumExtensions.hasFlag(chartType, flagStacked) && (lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues), 
                                        labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor), 
                                        value = columnWidth[categoryIndex];
                                        var originalPosition = columnStartX[categoryIndex], dataPoint = {
                                            categoryValue: categoryValue,
                                            value: value,
                                            position: position,
                                            valueAbsolute: valueAbsolute,
                                            valueOriginal: unadjustedValue,
                                            seriesIndex: seriesIndex,
                                            labelSettings: dataPointLabelSettings,
                                            categoryIndex: categoryIndex,
                                            color: color,
                                            selected: !1,
                                            originalValue: value,
                                            originalPosition: originalPosition,
                                            originalValueAbsolute: valueAbsolute,
                                            identity: identity,
                                            key: identity.getKey(),
                                            tooltipInfo: tooltipInfo,
                                            labelFill: labelColor,
                                            labelFormatString: metadata.format,
                                            lastSeries: lastValue,
                                            chartType: chartType
                                        };
                                        if (seriesDataPoints.push(dataPoint), hasHighlights) {
                                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex], unadjustedValueHighlight = valueHighlight, highlightedTooltip = !0;
                                            null === valueHighlight && (valueHighlight = 0, highlightedTooltip = !1), is100PercentStacked && (valueHighlight *= multipliers.pos);
                                            var absoluteValueHighlight = Math.abs(valueHighlight), highlightPosition = position;
                                            valueHighlight > 0 ? highlightPosition -= valueAbsolute - absoluteValueHighlight : 0 === valueHighlight && value > 0 && (highlightPosition -= valueAbsolute);
                                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), rawCategoryValue = categories[categoryIndex];
                                            highlightedTooltip && (dataPoint.tooltipInfo = tooltipInfo);
                                            var highlightDataPoint = {
                                                categoryValue: categoryValue,
                                                value: value,
                                                position: highlightPosition,
                                                valueAbsolute: absoluteValueHighlight,
                                                valueOriginal: unadjustedValueHighlight,
                                                seriesIndex: seriesIndex,
                                                labelSettings: dataPointLabelSettings,
                                                categoryIndex: categoryIndex,
                                                color: color,
                                                selected: !1,
                                                highlight: !0,
                                                originalValue: value,
                                                originalPosition: originalPosition,
                                                originalValueAbsolute: valueAbsolute,
                                                drawThinner: highlightsOverflow,
                                                identity: highlightIdentity,
                                                key: highlightIdentity.getKey(),
                                                tooltipInfo: tooltipInfo,
                                                labelFormatString: metadata.format,
                                                labelFill: labelColor,
                                                lastSeries: lastValue,
                                                chartType: chartType
                                            };
                                            seriesDataPoints.push(highlightDataPoint);
                                        }
                                    }
                                }
                            }
                            columnSeries.push(series);
                        }
                        return {
                            series: columnSeries,
                            categoriesWidth: columnWidth,
                            hasHighlights: hasHighlights,
                            hasDynamicSeries: hasDynamicSeries
                        };
                    }, MekkoColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                        if (dataPointObjects) {
                            var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                            if (colorOverride) return colorOverride;
                        }
                        return legendItem.color;
                    }, MekkoColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                        for (var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && 1 !== seriesCount), i = seriesIndex + 1; seriesCount > i; i++) {
                            var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                            if (null !== nextValues && ((!isNegative || isNegative && 0 === seriesIndex) && nextValues > 0 || isNegative && 0 !== seriesIndex)) {
                                lastValue = !1;
                                break;
                            }
                        }
                        return lastValue;
                    }, MekkoColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                        void 0 === startIndex && (startIndex = 0);
                        var newSeries = [];
                        if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) {
                            var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                            iNewSeries.data = series[i].data.filter(function(d) {
                                return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                            });
                        }
                        return newSeries;
                    }, MekkoColumnChart.getInteractiveColumnChartDomElement = function(element) {
                        return element.children("svg").get(0);
                    }, MekkoColumnChart.prototype.getColumnsWidth = function() {
                        var data = this.data;
                        return data && data.series && data.series[0] && data.series[0].data ? data.categoriesWidth : [];
                    }, MekkoColumnChart.prototype.getBorderWidth = function() {
                        return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
                    }, MekkoColumnChart.prototype.setData = function(dataViews) {
                        var is100PctStacked = !0;
                        if (this.data = {
                            categories: [],
                            categoriesWidth: [],
                            categoryFormatter: null,
                            series: [],
                            valuesMetadata: [],
                            legendData: null,
                            hasHighlights: !1,
                            categoryMetadata: null,
                            scalarCategoryAxis: !1,
                            borderSettings: null,
                            labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                            axesLabels: {
                                x: null,
                                y: null
                            },
                            hasDynamicSeries: !1,
                            defaultDataPointColor: null,
                            isMultiMeasure: !1
                        }, dataViews.length > 0) {
                            var dataView = dataViews[0];
                            if (dataView && dataView.categorical) {
                                var dataViewCat = this.dataViewCat = dataView.categorical;
                                this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), !0, !1, this.supportsOverflow, dataView.metadata, this.chartType);
                                for (var series = this.data.series, i = 0, ilen = series.length; ilen > i; i++) {
                                    var currentSeries = series[i];
                                    this.interactivityService && this.interactivityService.applySelectionStateToData(currentSeries.data);
                                }
                            }
                        }
                    }, MekkoColumnChart.prototype.calculateLegend = function() {
                        if (this.interactivity && this.interactivity.isInteractiveLegend) return this.createInteractiveMekkoLegendDataPoints(0);
                        var legendData = this.data ? this.data.legendData : null, MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
                        return ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints) ? null : legendData;
                    }, MekkoColumnChart.prototype.hasLegend = function() {
                        return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
                    }, MekkoColumnChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                        switch (options.objectName) {
                          case "dataPoint":
                            visuals.GradientUtils.hasGradientRole(this.dataViewCat) || this.enumerateDataPoints(enumeration);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration);
                        }
                    }, MekkoColumnChart.prototype.enumerateDataLabels = function(enumeration) {
                        var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
                        if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !1)), 
                        0 !== seriesCount && !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) for (var i = 0; seriesCount > i; i++) {
                            var series = data.series[i], labelSettings = series.labelSettings ? series.labelSettings : this.data.labelSettings;
                            visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !0, series));
                        }
                    }, MekkoColumnChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, isSeries, series) {
                        var is100PctStacked = !0;
                        return {
                            enumeration: enumeration,
                            dataLabelsSettings: labelSettings,
                            show: !isSeries,
                            displayUnits: is100PctStacked,
                            precision: !0,
                            selector: series && series.identity ? series.identity.getSelector() : null
                        };
                    }, MekkoColumnChart.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data && data.series) {
                            var seriesCount = data.series.length;
                            if (0 !== seriesCount) if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) for (var i = 0; seriesCount > i; i++) {
                                var series = data.series[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: series.displayName,
                                    selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: series.color
                                            }
                                        }
                                    }
                                });
                            } else {
                                var singleSeriesData = data.series[0].data, categoryFormatter = data.categoryFormatter;
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        defaultColor: {
                                            solid: {
                                                color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                            }
                                        }
                                    }
                                }).pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        showAllDataPoints: !!data.showAllDataPoints
                                    }
                                });
                                for (var i = 0; i < singleSeriesData.length; i++) {
                                    var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                                    enumeration.pushInstance({
                                        objectName: "dataPoint",
                                        displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                        selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), !0),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: singleSeriesDataPoints.color
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }, MekkoColumnChart.prototype.calculateAxesProperties = function(options) {
                        var data = this.data;
                        this.currentViewport = options.viewport;
                        var margin = this.margin = options.margin, origCatgSize = data && data.categories ? data.categories.length : 0, chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                            categoryCount: 0,
                            categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                            outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                            isScalar: !1
                        };
                        this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null, this.columnChart.setData(data);
                        var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                        preferredPlotArea.width === this.currentViewport.width && (preferredPlotArea.width -= margin.left + margin.right), 
                        preferredPlotArea.height -= margin.top + margin.bottom;
                        var is100Pct = !0, chartContext = {
                            height: preferredPlotArea.height,
                            width: preferredPlotArea.width,
                            duration: 0,
                            hostService: this.hostService,
                            unclippedGraphicsContext: this.unclippedGraphicsContext,
                            mainGraphicsContext: this.mainGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            margin: this.margin,
                            layout: chartLayout,
                            animator: this.animator,
                            interactivityService: this.interactivityService,
                            viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                            viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                            is100Pct: is100Pct,
                            isComboChart: !0
                        };
                        this.ApplyInteractivity(chartContext), this.columnChart.setupVisualProps(chartContext);
                        var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                        if (isBarChart) {
                            var temp = options.forcedXDomain;
                            options.forcedXDomain = options.forcedYDomain, options.forcedYDomain = temp;
                        }
                        return this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType), 
                        this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType), 
                        options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis ? this.xAxisProperties.axisLabel = data.axesLabels.x : this.xAxisProperties.axisLabel = null, 
                        options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis ? this.yAxisProperties.axisLabel = data.axesLabels.y : this.yAxisProperties.axisLabel = null, 
                        [ this.xAxisProperties, this.yAxisProperties ];
                    }, MekkoColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                        var viewport = {
                            height: this.currentViewport.height,
                            width: this.currentViewport.width
                        };
                        if (this.isScrollable && !isScalar) {
                            var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                            EnumExtensions.hasFlag(this.chartType, flagBar) ? viewport.height = Math.max(preferredWidth, viewport.height) : viewport.width = Math.max(preferredWidth, viewport.width);
                        }
                        return viewport;
                    }, MekkoColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                        var _this = this, interactivity = this.interactivity;
                        if (interactivity && (interactivity.dragDataPoint && (chartContext.onDragStart = function(datum) {
                            datum.identity && _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        }), interactivity.isInteractiveLegend)) {
                            var dragMove = function() {
                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]), x = mousePoint[0], y = mousePoint[1], index = _this.columnChart.getClosestColumnIndex(x, y);
                                _this.selectColumn(index);
                            }, ColumnChartSvg = visuals.ColumnChart.getInteractiveColumnChartDomElement(this.element);
                            this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove);
                            var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                            this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                        }
                    }, MekkoColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                        if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== indexOfColumnSelected) {
                            var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected), MekkoLegendDataPoints = legendData.dataPoints;
                            this.cartesianVisualHost.updateLegend(legendData), MekkoLegendDataPoints.length > 0 && this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex), 
                            this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                        }
                    }, MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function(columnIndex) {
                        var data = this.data;
                        if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) return {
                            dataPoints: []
                        };
                        for (var formatStringProp = visuals.columnChartProps.general.formatString, MekkoLegendDataPoints = [], category = data.categories && data.categories[columnIndex], allSeries = data.series, dataPoints = data.legendData && data.legendData.dataPoints, converterStrategy = new ColumnChartConverterHelper(this.dataViewCat), i = 0, len = allSeries.length; len > i; i++) {
                            var dataPointColor, measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex), valueMetadata = data.valuesMetadata[i], formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                            if (1 === allSeries.length) {
                                var series = allSeries[0];
                                dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                            } else dataPointColor = dataPoints.length > i && dataPoints[i].color;
                            MekkoLegendDataPoints.push({
                                color: dataPointColor,
                                icon: visuals.LegendIcon.Box,
                                label: formattedLabel,
                                category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                                measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                                identity: visuals.SelectionId.createNull(),
                                selected: !1
                            });
                        }
                        return {
                            dataPoints: MekkoLegendDataPoints
                        };
                    }, MekkoColumnChart.prototype.overrideXScale = function(xProperties) {
                        this.xAxisProperties = xProperties;
                    }, MekkoColumnChart.prototype.render = function(suppressAnimations) {
                        var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations), data = this.data, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right);
                        this.mainGraphicsContext.attr("height", height).attr("width", width), visuals.TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                        var allDataPoints = [], behaviorOptions = void 0;
                        if (this.interactivityService) {
                            for (var i = 0, ilen = data.series.length; ilen > i; i++) allDataPoints = allDataPoints.concat(data.series[i].data);
                            behaviorOptions = {
                                datapoints: allDataPoints,
                                bars: MekkoColumnChartDrawInfo.shapesSelection,
                                hasHighlights: data.hasHighlights,
                                eventGroup: this.mainGraphicsContext,
                                mainGraphicsContext: this.mainGraphicsContext,
                                viewport: MekkoColumnChartDrawInfo.viewport,
                                axisOptions: MekkoColumnChartDrawInfo.axisOptions,
                                showLabel: data.labelSettings.show
                            };
                        }
                        return this.interactivity && this.interactivity.isInteractiveLegend && this.data.series.length > 0 && this.selectColumn(0, !0), 
                        visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                            dataPoints: allDataPoints,
                            behaviorOptions: behaviorOptions,
                            labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
                            labelsAreNumeric: !0
                        };
                    }, MekkoColumnChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                        return this.data ? this.data.scalarCategoryAxis : !1;
                    }, MekkoColumnChart.prototype.getSupportedCategoryAxisType = function() {
                        var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                        return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                    }, MekkoColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                        var data = powerbi.Prototype.inherit(this.data);
                        return data.series = visuals.ColumnChart.sliceSeries(data.series, endIndex, startIndex), 
                        data.categories = data.categories.slice(startIndex, endIndex), this.columnChart.setData(data), 
                        data;
                    }, MekkoColumnChart.ColumnChartClassName = "columnChart", MekkoColumnChart.SeriesClasses = createClassAndSelector("series"), 
                    MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder"), MekkoColumnChart;
                }();
                samples.MekkoColumnChart = MekkoColumnChart;
                var ColumnChartConverterHelper = function() {
                    function ColumnChartConverterHelper(dataView) {
                        this.dataView = dataView;
                    }
                    return ColumnChartConverterHelper.hasRole = function(column, name) {
                        var roles = column.roles;
                        return roles && roles[name];
                    }, ColumnChartConverterHelper.prototype.getLegend = function(colors, defaultColor) {
                        var legend = [], seriesSources = [], seriesObjects = [], grouped = !1, colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor), legendTitle = void 0;
                        if (this.dataView && this.dataView.values) {
                            for (var allValues = this.dataView.values, valueGroups = allValues.grouped(), hasDynamicSeries = !(!allValues || !allValues.source), formatStringProp = visuals.columnChartProps.general.formatString, valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsLen > valueGroupsIndex; valueGroupsIndex++) for (var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values, valueIndex = 0, valuesLen = values.length; valuesLen > valueIndex; valueIndex++) {
                                var series = values[valueIndex], source = series.source;
                                if (!ColumnChartConverterHelper.hasRole(source, "Width") || ColumnChartConverterHelper.hasRole(source, "Y")) {
                                    seriesSources.push(source), seriesObjects.push(series.objects);
                                    var selectionId = series.identity ? visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex)), label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                                    legend.push({
                                        icon: visuals.LegendIcon.Box,
                                        color: color,
                                        label: label,
                                        identity: selectionId,
                                        selected: !1
                                    }), series.identity && void 0 !== source.groupName && (grouped = !0);
                                }
                            }
                            var dvValues = this.dataView.values;
                            legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                        }
                        var legendData = {
                            title: legendTitle,
                            dataPoints: legend,
                            grouped: grouped
                        };
                        return {
                            legend: legendData,
                            seriesSources: seriesSources,
                            seriesObjects: seriesObjects
                        };
                    }, ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                        return this.dataView.values[series].values[category];
                    }, ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                        return this.dataView.values[index].source.queryName;
                    }, ColumnChartConverterHelper.prototype.hasHighlightValues = function(series) {
                        var column = this.dataView && this.dataView.values ? this.dataView.values[series] : void 0;
                        return column && !!column.highlights;
                    }, ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                        return this.dataView.values[series].highlights[category];
                    }, ColumnChartConverterHelper;
                }(), MekkoChartBehavior = function() {
                    function MekkoChartBehavior(behaviors) {
                        this.behaviors = behaviors;
                    }
                    return MekkoChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; ilen > i; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                        options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, MekkoChartBehavior.prototype.renderSelection = function(hasSelection) {
                        for (var i = 0; i < this.behaviors.length; i++) this.behaviors[i].renderSelection(hasSelection);
                    }, MekkoChartBehavior;
                }();
                samples.MekkoChartBehavior = MekkoChartBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, pixelConverterFromPoint = jsCommon.PixelConverter.fromPoint, SankeyDiagram = function() {
                    function SankeyDiagram(constructorOptions) {
                        this.margin = {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }, this.nodeWidth = 21.5, this.curvatureOfLinks = .5, constructorOptions && (this.svg = constructorOptions.svg, 
                        this.margin = constructorOptions.margin || this.margin, this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks);
                    }
                    return SankeyDiagram.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, Object.defineProperty(SankeyDiagram.prototype, "textProperties", {
                        get: function() {
                            return {
                                fontFamily: this.root.style("font-family"),
                                fontSize: pixelConverterFromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), SankeyDiagram.prototype.init = function(visualsInitOptions) {
                        this.svg ? this.root = this.svg : this.root = d3.select(visualsInitOptions.element.get(0)).append("svg"), 
                        this.selectionManager = new SelectionManager({
                            hostServices: visualsInitOptions.host
                        });
                        var style = visualsInitOptions.style;
                        this.colours = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                        this.root.classed(SankeyDiagram.ClassName, !0), this.main = this.root.append("g"), 
                        this.links = this.main.append("g").classed(SankeyDiagram.Links["class"], !0), this.nodes = this.main.append("g").classed(SankeyDiagram.Nodes["class"], !0);
                    }, SankeyDiagram.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews) {
                            var sankeyDiagramDataView, dataView = visualUpdateOptions.dataViews[0];
                            this.updateViewport(visualUpdateOptions.viewport), sankeyDiagramDataView = this.converter(dataView), 
                            this.computePositions(sankeyDiagramDataView), this.dataView = sankeyDiagramDataView, 
                            this.render(sankeyDiagramDataView);
                        }
                    }, SankeyDiagram.prototype.updateViewport = function(viewport) {
                        var height, width;
                        height = this.getPositiveNumber(viewport.height), width = this.getPositiveNumber(viewport.width), 
                        this.viewport = {
                            height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
                            width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
                        }, this.updateElements(height, width);
                    }, SankeyDiagram.prototype.getPositiveNumber = function(value) {
                        return 0 > value || isNaN(value) || null === value || value === 1 / 0 || value === -(1 / 0) ? 0 : value;
                    }, SankeyDiagram.prototype.updateElements = function(height, width) {
                        this.root.attr({
                            height: height,
                            width: width
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    }, SankeyDiagram.prototype.converter = function(dataView) {
                        var _this = this;
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[1] && dataView.categorical.categories[0].values && dataView.categorical.categories[1].values)) return {
                            nodes: [],
                            links: [],
                            columns: [],
                            settings: {
                                scale: {
                                    x: 1,
                                    y: 1
                                },
                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                                fontSize: SankeyDiagram.DefaultSettings.fontSize
                            }
                        };
                        var allCategories, valueFormatterForCategories, valuesFormatterForWeigth, objects, labelColour, settings, shiftOfColour, nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = [], formatOfWeigth = "g", linksObjects = dataView.categorical.categories[0].objects || [], identities = [];
                        return valuesColumn && valuesColumn.values && valuesColumn.values.map && (weightValues = valuesColumn.values.map(function(x) {
                            return x ? x : 0;
                        })), dataView.categorical.categories[0].identity && (identities = identities.concat(dataView.categorical.categories[0].identity)), 
                        dataView.categorical.categories[1].identity && (identities = identities.concat(dataView.categorical.categories[1].identity)), 
                        objects = this.getObjectsFromDataView(dataView), labelColour = this.getColour(SankeyDiagram.Properties.labels.fill, SankeyDiagram.DefaultSettings.colourOfLabels, objects), 
                        valuesColumn && valuesColumn.source && (formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties.general.formatString)), 
                        dataPoints = categories.map(function(item, index) {
                            return {
                                source: item,
                                destination: secondCategories[index],
                                weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1
                            };
                        }), allCategories = categories.concat(secondCategories), valueFormatterForCategories = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties.general.formatString),
                            value: allCategories[0],
                            value2: allCategories[allCategories.length - 1]
                        }), valuesFormatterForWeigth = ValueFormatter.create({
                            format: formatOfWeigth,
                            value: Math.max(d3.max(weightValues) || 1, 1)
                        }), allCategories.forEach(function(item, index) {
                            if (!nodes.some(function(node) {
                                return item === node.label.name ? (node.selectionIds.push(visuals.SelectionId.createWithId(identities[index])), 
                                !0) : !1;
                            })) {
                                var label, selectionId, formattedValue = valueFormatterForCategories.format(item), textProperties = {
                                    text: formattedValue,
                                    fontFamily: _this.textProperties.fontFamily,
                                    fontSize: _this.textProperties.fontSize
                                };
                                label = {
                                    name: item,
                                    formattedName: valueFormatterForCategories.format(item),
                                    width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
                                    colour: labelColour
                                }, selectionId = visuals.SelectionId.createWithId(identities[index]), nodes.push({
                                    label: label,
                                    links: [],
                                    inputWeight: 0,
                                    outputWeight: 0,
                                    width: _this.nodeWidth,
                                    height: 0,
                                    colour: SankeyDiagram.DefaultColourOfNode,
                                    tooltipData: [],
                                    selectionIds: [ selectionId ]
                                });
                            }
                        }), shiftOfColour = this.colours.getAllColors().length / nodes.length, nodes.forEach(function(node, index) {
                            node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
                        }), dataPoints.forEach(function(dataPoint, index) {
                            var sourceNode, destinationNode, link, linkColour;
                            dataPoint.source !== dataPoint.destination && (nodes.forEach(function(node) {
                                node.label.name === dataPoint.source && (sourceNode = node), node.label.name === dataPoint.destination && (destinationNode = node);
                            }), linkColour = _this.getColour(SankeyDiagram.Properties.links.fill, SankeyDiagram.DefaultColourOfLink, linksObjects[index]), 
                            link = {
                                source: sourceNode,
                                destination: destinationNode,
                                weigth: dataPoint.weigth,
                                height: dataPoint.weigth,
                                colour: linkColour,
                                tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
                                selectionId: visuals.SelectionId.createWithId(identities[index])
                            }, links.push(link), sourceNode.links.push(link), destinationNode.links.push(link), 
                            _this.updateValueOfNode(sourceNode), _this.updateValueOfNode(destinationNode), sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight), 
                            destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight));
                        }), settings = this.parseSettings(objects), settings.colourOfLabels = labelColour, 
                        {
                            nodes: nodes,
                            links: links,
                            settings: settings,
                            columns: []
                        };
                    }, SankeyDiagram.prototype.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, SankeyDiagram.prototype.getColour = function(properties, defaultColor, objects) {
                        var colorHelper;
                        return colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor), 
                        colorHelper.getColorForMeasure(objects, "");
                    }, SankeyDiagram.prototype.getTooltipDataForLink = function(valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
                        var formattedLinkWeight;
                        return formattedLinkWeight = valueFormatter && valueFormatter.format ? valueFormatter.format(linkWeight) : linkWeight.toString(), 
                        [ {
                            displayName: SankeyDiagram.RoleNames.rows,
                            value: sourceNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.columns,
                            value: destinationNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedLinkWeight
                        } ];
                    }, SankeyDiagram.prototype.updateValueOfNode = function(node) {
                        node.inputWeight = node.links.reduce(function(previousValue, currentValue) {
                            return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);
                        }, 0), node.outputWeight = node.links.reduce(function(previousValue, currentValue) {
                            return previousValue + (currentValue.source === node ? currentValue.weigth : 0);
                        }, 0);
                    }, SankeyDiagram.prototype.getTooltipForNode = function(valueFormatter, nodeName, nodeWeight) {
                        var formattedNodeWeigth;
                        return formattedNodeWeigth = valueFormatter && valueFormatter.format ? valueFormatter.format(nodeWeight) : nodeWeight.toString(), 
                        [ {
                            displayName: "Name",
                            value: nodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedNodeWeigth
                        } ];
                    }, SankeyDiagram.prototype.parseSettings = function(objects) {
                        var isVisibleLabels = !1;
                        return isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.show, SankeyDiagram.DefaultSettings.isVisibleLabels), 
                        {
                            isVisibleLabels: isVisibleLabels,
                            scale: {
                                x: SankeyDiagram.DefaultSettings.scale.x,
                                y: SankeyDiagram.DefaultSettings.scale.y
                            },
                            colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                            fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.fontSize, SankeyDiagram.DefaultSettings.fontSize)
                        };
                    }, SankeyDiagram.prototype.computePositions = function(sankeyDiagramDataView) {
                        var maxXPosition, maxColumn, columns;
                        maxXPosition = this.computeXPositions(sankeyDiagramDataView), this.sortNodesByX(sankeyDiagramDataView.nodes), 
                        columns = this.getColumns(sankeyDiagramDataView.nodes), maxColumn = this.getMaxColumn(columns), 
                        sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(maxXPosition), sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxColumn.sumValueOfNodes), 
                        this.scalePositionsByAxes(sankeyDiagramDataView.nodes, columns, sankeyDiagramDataView.settings.scale, this.viewport.height), 
                        this.computeYPosition(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.y);
                    }, SankeyDiagram.prototype.computeXPositions = function(sankeyDiagramDataView) {
                        for (var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = !1; nodes.length > 0; ) nextNodes = [], 
                        nodes.forEach(function(node) {
                            node.x = x, node.links.forEach(function(link) {
                                node === link.source && node !== link.destination && nextNodes.every(function(item) {
                                    return item !== link.destination;
                                }) && nextNodes.push(link.destination);
                            });
                        }), isRecursiveDependencies = nextNodes.length === previousNodes.length && previousNodes.every(function(previousNode) {
                            return nextNodes.some(function(nextNode) {
                                return nextNode === previousNode;
                            });
                        }), isRecursiveDependencies ? (previousNodes.forEach(function(element) {
                            element.x = x, x++;
                        }), nodes = []) : (nodes = nextNodes, previousNodes = nodes, x++);
                        return x - 1;
                    }, SankeyDiagram.prototype.getScaleByAxisX = function(numberOfColumns) {
                        return void 0 === numberOfColumns && (numberOfColumns = 1), this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
                    }, SankeyDiagram.prototype.sortNodesByX = function(nodes) {
                        return nodes.sort(function(firstNode, secondNode) {
                            return firstNode.x - secondNode.x;
                        });
                    }, SankeyDiagram.prototype.getColumns = function(nodes) {
                        var columns = [], currentX = -Number.MAX_VALUE;
                        return nodes.forEach(function(node, index) {
                            currentX !== node.x && (columns.push({
                                countOfNodes: 0,
                                sumValueOfNodes: 0
                            }), currentX = node.x), columns[node.x] && (columns[node.x].sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight), 
                            columns[node.x].countOfNodes++);
                        }), columns;
                    }, SankeyDiagram.prototype.getMaxColumn = function(columns) {
                        void 0 === columns && (columns = []);
                        var currentMaxColumn = {
                            sumValueOfNodes: 0,
                            countOfNodes: 0
                        };
                        return columns.forEach(function(column) {
                            column && column.sumValueOfNodes > currentMaxColumn.sumValueOfNodes && (currentMaxColumn = column);
                        }), currentMaxColumn;
                    }, SankeyDiagram.prototype.getScaleByAxisY = function(sumValueOfNodes) {
                        return this.getPositiveNumber((this.viewport.height - this.getAvailableSumNodeMarginByY()) / sumValueOfNodes);
                    }, SankeyDiagram.prototype.getAvailableSumNodeMarginByY = function() {
                        return this.viewport ? this.viewport.height * SankeyDiagram.NodeBottomMargin / 100 : 0;
                    }, SankeyDiagram.prototype.scalePositionsByAxes = function(nodes, columns, scale, viewportHeight) {
                        var shiftByAxisY = 0, currentX = 0, index = 0;
                        nodes.forEach(function(node) {
                            var offsetByY = 0, availableHeight = 0;
                            currentX !== node.x && (currentX = node.x, shiftByAxisY = 0, index = 0), columns[currentX] && (availableHeight = viewportHeight - columns[currentX].sumValueOfNodes * scale.y, 
                            offsetByY = availableHeight / columns[currentX].countOfNodes), node.x *= scale.x, 
                            node.height = Math.max(node.inputWeight, node.outputWeight) * scale.y, node.y = shiftByAxisY + offsetByY * index, 
                            shiftByAxisY += node.height, index++;
                        });
                    }, SankeyDiagram.prototype.computeYPosition = function(nodes, scale) {
                        nodes.forEach(function(node) {
                            node.links = node.links.sort(function(firstLink, secondLink) {
                                var firstY, secondY;
                                return firstY = firstLink.source === node ? firstLink.destination.y : firstLink.source.y, 
                                secondY = secondLink.source === node ? secondLink.destination.y : secondLink.source.y, 
                                firstY - secondY;
                            });
                            var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
                            node.links.forEach(function(link) {
                                var shiftByAxisY = 0;
                                link.height = link.weigth * scale, link.source.x < node.x || link.destination.x < node.x ? (shiftByAxisY = shiftByAxisYOfLeftLink, 
                                shiftByAxisYOfLeftLink += link.height) : (link.source.x > node.x || link.destination.x > node.x) && (shiftByAxisY = shiftByAxisYOfRightLink, 
                                shiftByAxisYOfRightLink += link.height), link.source === node ? link.dySource = shiftByAxisY : link.destination === node && (link.dyDestination = shiftByAxisY);
                            });
                        });
                    }, SankeyDiagram.prototype.render = function(sankeyDiagramDataView) {
                        var nodesSelection, linksSelection;
                        linksSelection = this.renderLinks(sankeyDiagramDataView), this.renderTooltip(linksSelection), 
                        nodesSelection = this.renderNodes(sankeyDiagramDataView), this.renderTooltip(nodesSelection), 
                        this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
                    }, SankeyDiagram.prototype.renderNodes = function(sankeyDiagramDataView) {
                        var nodesEnterSelection, nodesSelection, nodeElements, _this = this;
                        return nodeElements = this.main.select(SankeyDiagram.Nodes.selector).selectAll(SankeyDiagram.Node.selector), 
                        nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function(x) {
                            return x.height > 0;
                        })), nodesEnterSelection = nodesSelection.enter().append("g"), nodesSelection.attr("transform", function(node) {
                            return visuals.SVGUtil.translate(node.x, node.y);
                        }).classed(SankeyDiagram.Node["class"], !0), nodesEnterSelection.append("rect").classed(SankeyDiagram.NodeRect["class"], !0), 
                        nodesEnterSelection.append("text").classed(SankeyDiagram.NodeLabel["class"], !0), 
                        nodesSelection.select(SankeyDiagram.NodeRect.selector).style({
                            fill: function(node) {
                                return node.colour;
                            },
                            stroke: function(node) {
                                return d3.rgb(node.colour).darker(1.5);
                            }
                        }).attr({
                            x: 0,
                            y: 0,
                            height: function(node) {
                                return node.height;
                            },
                            width: function(node) {
                                return node.width;
                            }
                        }), nodesSelection.select(SankeyDiagram.NodeLabel.selector).attr({
                            x: function(node) {
                                return _this.getLabelPositionByAxisX(node);
                            },
                            y: function(node) {
                                return node.height / 2;
                            },
                            dy: "0.35em"
                        }).style("fill", function(node) {
                            return node.label.colour;
                        }).style("font-size", this.textProperties.fontSize).style("display", function(node) {
                            var isNotVisibleLabel = !1, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
                            return isNotVisibleLabel = labelPositionByAxisX >= _this.viewport.width || 0 >= labelPositionByAxisX || node.height + SankeyDiagram.NodeMargin < node.label.height, 
                            isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel ? "none" : null;
                        }).style("text-anchor", function(node) {
                            return _this.isLabelLargerThanWidth(node) ? "end" : null;
                        }).text(function(node) {
                            var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodeMargin;
                            return _this.getCurrentPositionOfLabelByAxisX(node) > maxWidth ? powerbi.TextMeasurementService.getTailoredTextOrDefault({
                                text: node.label.formattedName,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            }, maxWidth) : node.label.formattedName;
                        }), nodesSelection.exit().remove(), nodesSelection;
                    }, SankeyDiagram.prototype.getLabelPositionByAxisX = function(node) {
                        return this.isLabelLargerThanWidth(node) ? -SankeyDiagram.LabelMargin : node.width + SankeyDiagram.LabelMargin;
                    }, SankeyDiagram.prototype.isLabelLargerThanWidth = function(node) {
                        var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelMargin;
                        return shiftByAxisX + node.label.width > this.viewport.width;
                    }, SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function(node) {
                        var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
                        return labelPositionByAxisX = labelPositionByAxisX > 0 ? labelPositionByAxisX + node.x + node.label.width + node.width : node.x + labelPositionByAxisX - node.label.width - node.width;
                    }, SankeyDiagram.prototype.renderLinks = function(sankeyDiagramDataView) {
                        var linksSelection, linksElements, _this = this;
                        return linksElements = this.main.select(SankeyDiagram.Links.selector).selectAll(SankeyDiagram.Link.selector), 
                        linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function(x) {
                            return x.height > 0;
                        })), linksSelection.enter().append("path").classed(SankeyDiagram.Link["class"], !0), 
                        linksSelection.attr("d", function(link) {
                            return _this.getSvgPath(link);
                        }).style({
                            "stroke-width": function(link) {
                                return link.height;
                            },
                            stroke: function(link) {
                                return link.colour;
                            }
                        }), linksSelection.exit().remove(), linksSelection;
                    }, SankeyDiagram.prototype.getSvgPath = function(link) {
                        var x0, x1, xi, x2, x3, y0, y1;
                        return link.destination.x < link.source.x ? (x0 = link.source.x, x1 = link.destination.x + link.destination.width) : (x0 = link.source.x + link.source.width, 
                        x1 = link.destination.x), xi = d3.interpolateNumber(x0, x1), x2 = xi(this.curvatureOfLinks), 
                        x3 = xi(1 - this.curvatureOfLinks), y0 = link.source.y + link.dySource + link.height / 2, 
                        y1 = link.destination.y + link.dyDestination + link.height / 2, "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
                    }, SankeyDiagram.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipData;
                        });
                    }, SankeyDiagram.prototype.bindSelectionHandler = function(sankeyDiagramDataView, nodesSelection, linksSelection) {
                        var _this = this;
                        nodesSelection.on("click", function(node) {
                            var selectionIds = _.isEqual(node.selectionIds.map(function(x) {
                                return x.getKey();
                            }), _this.selectionManager.getSelectionIds().map(function(x) {
                                return x.getKey();
                            })) ? [] : node.selectionIds;
                            _this.selectMany(selectionIds, !0).then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            }), d3.event.stopPropagation();
                        }), linksSelection.on("click", function(link) {
                            _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            }), d3.event.stopPropagation();
                        }), this.root.on("click", function() {
                            _this.selectionManager.clear().then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            });
                        }), this.setSelection(nodesSelection, linksSelection);
                    }, SankeyDiagram.prototype.selectMany = function(selectionIds, clear) {
                        var _this = this;
                        if (void 0 === clear && (clear = !1), clear) return this.selectionManager.clear().then(function() {
                            return _this.selectMany(selectionIds, !1);
                        });
                        var selectionDeffered = selectionIds.map(function(id) {
                            return _this.selectionManager.select(id, !0);
                        });
                        return $.when.apply(null, selectionDeffered);
                    }, SankeyDiagram.prototype.setSelection = function(nodes, links) {
                        var selectionIds = this.selectionManager.getSelectionIds();
                        if (nodes.classed("selected", selectionIds.length > 0), links.classed("selected", !1), 
                        0 !== selectionIds.length) {
                            var selectedNodesSelection = nodes.filter(function(node) {
                                return selectionIds.some(function(selectedId) {
                                    return node.selectionIds.some(function(x) {
                                        return x.getKey() === selectedId.getKey();
                                    });
                                });
                            }), selectedLinksSelection = links.filter(function(link) {
                                return selectionIds.some(function(selectionId) {
                                    return selectionId.getKey() === link.selectionId.getKey();
                                });
                            });
                            selectedNodesSelection.classed("selected", !1), selectedLinksSelection.classed("selected", !0);
                        }
                    }, SankeyDiagram.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.dataView) return [];
                        switch (options.objectName) {
                          case "labels":
                            this.enumerateLabels(enumeration);
                            break;

                          case "links":
                            this.enumerateLinks(enumeration);
                        }
                        return enumeration.complete();
                    }, SankeyDiagram.prototype.enumerateLabels = function(enumeration) {
                        var labels, settings = this.dataView.settings;
                        settings && (labels = {
                            objectName: "labels",
                            displayName: "labels",
                            selector: null,
                            properties: {
                                show: settings.isVisibleLabels,
                                fill: settings.colourOfLabels,
                                fontSize: settings.fontSize
                            }
                        }, enumeration.pushInstance(labels));
                    }, SankeyDiagram.prototype.enumerateLinks = function(enumeration) {
                        var links = this.dataView.links;
                        links && links.length > 0 && links.forEach(function(link) {
                            enumeration.pushInstance({
                                objectName: "links",
                                displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
                                selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: link.colour
                                        }
                                    }
                                }
                            });
                        });
                    }, SankeyDiagram.ClassName = "sankeyDiagram", SankeyDiagram.Nodes = {
                        "class": "nodes",
                        selector: ".nodes"
                    }, SankeyDiagram.Node = {
                        "class": "node",
                        selector: ".node"
                    }, SankeyDiagram.NodeRect = {
                        "class": "nodeRect",
                        selector: ".nodeRect"
                    }, SankeyDiagram.NodeLabel = {
                        "class": "nodeLabel",
                        selector: ".nodeLabel"
                    }, SankeyDiagram.Links = {
                        "class": "links",
                        selector: ".links"
                    }, SankeyDiagram.Link = {
                        "class": "link",
                        selector: ".link"
                    }, SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)", SankeyDiagram.DefaultColourOfLink = "black", 
                    SankeyDiagram.DefaultSettings = {
                        isVisibleLabels: !0,
                        scale: {
                            x: 1,
                            y: 1
                        },
                        colourOfLabels: "black",
                        fontSize: 12
                    }, SankeyDiagram.MinWidthOfLabel = 35, SankeyDiagram.NodeBottomMargin = 5, SankeyDiagram.NodeMargin = 5, 
                    SankeyDiagram.LabelMargin = 4, SankeyDiagram.RoleNames = {
                        rows: "Source",
                        columns: "Destination",
                        values: "Weight"
                    }, SankeyDiagram.capabilities = {
                        dataRoles: [ {
                            name: SankeyDiagram.RoleNames.rows,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.rows
                        }, {
                            name: SankeyDiagram.RoleNames.columns,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.columns
                        }, {
                            name: SankeyDiagram.RoleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: SankeyDiagram.RoleNames.values
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Source: {
                                    min: 0,
                                    max: 1
                                },
                                Destination: {
                                    min: 0,
                                    max: 1
                                },
                                Weight: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Source: {
                                    min: 0,
                                    max: 1
                                },
                                Destination: {
                                    min: 0,
                                    max: 1
                                },
                                Weight: {
                                    min: 1,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": SankeyDiagram.RoleNames.rows
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: SankeyDiagram.RoleNames.columns
                                        }
                                    }, {
                                        bind: {
                                            to: SankeyDiagram.RoleNames.values
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            links: {
                                displayName: "Links",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities), 
                    SankeyDiagram;
                }();
                samples.SankeyDiagram = SankeyDiagram;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter;
                samples.bulletChartProps = {
                    values: {
                        targetValue: {
                            objectName: "values",
                            propertyName: "targetValue"
                        },
                        minimumPercent: {
                            objectName: "values",
                            propertyName: "minimumPercent"
                        },
                        needsImprovementPercent: {
                            objectName: "values",
                            propertyName: "needsImprovementPercent"
                        },
                        satisfactoryPercent: {
                            objectName: "values",
                            propertyName: "satisfactoryPercent"
                        },
                        goodPercent: {
                            objectName: "values",
                            propertyName: "goodPercent"
                        },
                        veryGoodPercent: {
                            objectName: "values",
                            propertyName: "veryGoodPercent"
                        },
                        maximumPercent: {
                            objectName: "values",
                            propertyName: "maximumPercent"
                        },
                        targetValue2: {
                            objectName: "values",
                            propertyName: "targetValue2"
                        },
                        secondTargetVisibility: {
                            objectName: "values",
                            propertyName: "secondTargetVisibility"
                        }
                    },
                    orientation: {
                        orientation: {
                            objectName: "orientation",
                            propertyName: "orientation"
                        }
                    },
                    colors: {
                        badColor: {
                            objectName: "colors",
                            propertyName: "badColor"
                        },
                        needsImprovementColor: {
                            objectName: "colors",
                            propertyName: "needsImprovementColor"
                        },
                        satisfactoryColor: {
                            objectName: "colors",
                            propertyName: "satisfactoryColor"
                        },
                        goodColor: {
                            objectName: "colors",
                            propertyName: "goodColor"
                        },
                        veryGoodColor: {
                            objectName: "colors",
                            propertyName: "veryGoodColor"
                        },
                        bulletColor: {
                            objectName: "colors",
                            propertyName: "bulletColor"
                        }
                    },
                    axis: {
                        axis: {
                            objectName: "axis",
                            propertyName: "axis"
                        },
                        axisColor: {
                            objectName: "axis",
                            propertyName: "axisColor"
                        },
                        measureUnits: {
                            objectName: "axis",
                            propertyName: "measureUnits"
                        },
                        unitsColor: {
                            objectName: "axis",
                            propertyName: "unitsColor"
                        }
                    },
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    },
                    labels: {
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        labelColor: {
                            objectName: "labels",
                            propertyName: "labelColor"
                        }
                    }
                }, samples.bulletChartRoleNames = {
                    value: "Value",
                    targetValue: "TargetValue",
                    minValue: "Minimum",
                    needsImprovementValue: "NeedsImprovement",
                    satisfactoryValue: "Satisfactory",
                    goodValue: "Good",
                    veryGoodValue: "VeryGood",
                    maxValue: "Maximum",
                    targetValue2: "TargetValue2"
                };
                var Orientation;
                !function(Orientation) {
                    Orientation.HORIZONTALLEFT = "Horizontal Left", Orientation.HORIZONTALRIGHT = "Horizontal Right", 
                    Orientation.VERTICALTOP = "Vertical Top", Orientation.VERTICALBOTTOM = "Vertical Bottom", 
                    Orientation.type = powerbi.createEnumType([ {
                        value: Orientation.HORIZONTALLEFT,
                        displayName: Orientation.HORIZONTALLEFT
                    }, {
                        value: Orientation.HORIZONTALRIGHT,
                        displayName: Orientation.HORIZONTALRIGHT
                    }, {
                        value: Orientation.VERTICALTOP,
                        displayName: Orientation.VERTICALTOP
                    }, {
                        value: Orientation.VERTICALBOTTOM,
                        displayName: Orientation.VERTICALBOTTOM
                    } ]);
                }(Orientation || (Orientation = {}));
                var BulletChart = function() {
                    function BulletChart() {
                        this.baselineDelta = 0;
                    }
                    return Object.defineProperty(BulletChart.prototype, "reverse", {
                        get: function() {
                            return this.model.bulletChartSettings.orientation.reverse;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "vertical", {
                        get: function() {
                            return this.model.bulletChartSettings.orientation.vertical;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BulletChart.DefaultStyleProperties = function() {
                        return {
                            values: {
                                targetValue: 0,
                                targetValue2: 0,
                                minimumPercent: 0,
                                needsImprovementPercent: 25,
                                satisfactoryPercent: 50,
                                goodPercent: 100,
                                veryGoodPercent: 125,
                                maximumPercent: 200,
                                secondTargetVisibility: !1
                            },
                            orientation: {
                                orientation: Orientation.HORIZONTALLEFT,
                                reverse: !1,
                                vertical: !1
                            },
                            colors: {
                                badColor: "Darkred",
                                needsImprovementColor: "Red",
                                satisfactoryColor: "Yellow",
                                goodColor: "Green",
                                veryGoodColor: "Darkgreen",
                                bulletColor: "Black"
                            },
                            axis: {
                                axis: !0,
                                axisColor: "Grey",
                                measureUnits: "",
                                unitsColor: "Grey"
                            },
                            labelSettings: {
                                fontSize: 11,
                                show: !0,
                                labelColor: "Black"
                            }
                        };
                    }, Object.defineProperty(BulletChart.prototype, "viewportIn", {
                        get: function() {
                            return {
                                width: this.viewport.width,
                                height: this.viewport.height
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "viewportScroll", {
                        get: function() {
                            var viewportIn = this.viewportIn;
                            return {
                                width: viewportIn.width - BulletChart.ScrollBarSize,
                                height: viewportIn.height - BulletChart.ScrollBarSize
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BulletChart.getTextProperties = function(text, fontSize) {
                        return {
                            fontFamily: BulletChart.FontFamily,
                            fontSize: PixelConverter.fromPoint(fontSize),
                            text: text
                        };
                    }, BulletChart.converter = function(dataView, options) {
                        var defaultSettings = BulletChart.DefaultStyleProperties(), bulletModel = {
                            bulletValueFormatString: null,
                            bulletChartSettings: defaultSettings,
                            bars: [],
                            barRects: [],
                            valueRects: [],
                            targetValues: [],
                            viewportLength: 0
                        };
                        if (!(dataView && dataView.categorical && dataView.categorical.values && 0 !== dataView.categorical.values.length && dataView.metadata && dataView.metadata.columns && 0 !== dataView.metadata.columns.length)) return bulletModel;
                        var objects = dataView.metadata.objects, settings = bulletModel.bulletChartSettings;
                        objects && (settings.values.targetValue = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue, defaultSettings.values.targetValue), 
                        settings.values.targetValue2 = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2), 
                        settings.values.secondTargetVisibility = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.secondTargetVisibility, defaultSettings.values.secondTargetVisibility), 
                        settings.values.minimumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent), 
                        settings.values.needsImprovementPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent), 
                        settings.values.satisfactoryPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent), 
                        settings.values.goodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent), 
                        settings.values.veryGoodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent), 
                        settings.values.maximumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent), 
                        settings.orientation.orientation = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation), 
                        settings.colors.badColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.badColor, defaultSettings.colors.badColor), 
                        settings.colors.needsImprovementColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor), 
                        settings.colors.satisfactoryColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor), 
                        settings.colors.goodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor), 
                        settings.colors.veryGoodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor), 
                        settings.colors.bulletColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor), 
                        settings.axis.axis = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.axis, defaultSettings.axis.axis), 
                        settings.axis.axisColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor), 
                        settings.axis.measureUnits = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth), 
                        settings.axis.unitsColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor), 
                        settings.labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize), 
                        settings.labelSettings.show = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.show, defaultSettings.labelSettings.show), 
                        settings.labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor)), 
                        settings.orientation.orientation !== Orientation.HORIZONTALRIGHT && settings.orientation.orientation !== Orientation.VERTICALBOTTOM || (settings.orientation.reverse = !0), 
                        settings.orientation.orientation !== Orientation.VERTICALTOP && settings.orientation.orientation !== Orientation.VERTICALBOTTOM || (settings.orientation.vertical = !0);
                        var categories, categoryValues, categoryFormatString, categoryValuesLen = 1;
                        dataView.categorical.categories && (categories = dataView.categorical.categories[0], 
                        categoryValues = categories.values, categoryValuesLen = categoryValues.length, categoryFormatString = visuals.valueFormatter.getFormatString(categories.source, samples.bulletChartProps.formatString)), 
                        bulletModel.labelHeight = (settings.labelSettings.show || 0) && parseFloat(PixelConverter.fromPoint(settings.labelSettings.fontSize)), 
                        bulletModel.labelHeightTop = (settings.labelSettings.show || 0) && parseFloat(PixelConverter.fromPoint(settings.labelSettings.fontSize)) / 1.4, 
                        bulletModel.spaceRequiredForBarHorizontally = Math.max(60, bulletModel.labelHeight + 20), 
                        bulletModel.bulletValueFormatString = visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps.formatString), 
                        bulletModel.viewportLength = (settings.orientation.vertical ? options.viewport.height - bulletModel.labelHeightTop - BulletChart.SubtitleMargin - 20 - 2 * BulletChart.YMarginVertical : options.viewport.width - BulletChart.MaxLabelWidth - 3 * BulletChart.XMarginHorizontal) - BulletChart.ScrollBarSize;
                        for (var idx = 0; categoryValuesLen > idx; idx++) {
                            var toolTipItems = [], category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0, highlight = !1, categoryIdentity = void 0;
                            if (categoryValues) {
                                var categoryValue = categoryValues[idx];
                                category = visuals.valueFormatter.format(categoryValue, categoryFormatString), categoryIdentity = categories.identity ? categories.identity[idx] : null;
                                var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);
                                category = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth);
                            }
                            var values = dataView.categorical.values;
                            targetValue = settings.values.targetValue, targetValue2 = settings.values.targetValue2, 
                            bulletModel.hasHighlights = !!(values.length > 0 && values[0].highlights);
                            for (var i = 0; i < values.length; i++) {
                                var col = values[i].source, currentVal = values[i].values[idx] || 0;
                                col && col.roles && (col.roles[samples.bulletChartRoleNames.value] ? (values[i].highlights && (highlight = null !== values[i].highlights[idx]), 
                                toolTipItems.push({
                                    value: currentVal,
                                    metadata: values[i]
                                }), value = currentVal) : col.roles[samples.bulletChartRoleNames.targetValue] ? (toolTipItems.push({
                                    value: currentVal,
                                    metadata: values[i]
                                }), targetValue = currentVal) : col.roles[samples.bulletChartRoleNames.targetValue2] ? (toolTipItems.push({
                                    value: currentVal,
                                    metadata: values[i]
                                }), targetValue2 = currentVal) : col.roles[samples.bulletChartRoleNames.minValue] ? minimum = currentVal : col.roles[samples.bulletChartRoleNames.needsImprovementValue] ? needsImprovement = currentVal : col.roles[samples.bulletChartRoleNames.satisfactoryValue] ? satisfactory = currentVal : col.roles[samples.bulletChartRoleNames.goodValue] ? good = currentVal : col.roles[samples.bulletChartRoleNames.veryGoodValue] ? veryGood = currentVal : col.roles[samples.bulletChartRoleNames.maxValue] && (maximum = currentVal));
                            }
                            minimum || (minimum = settings.values.minimumPercent * targetValue / 100), needsImprovement || (needsImprovement = settings.values.needsImprovementPercent * targetValue / 100), 
                            satisfactory || (satisfactory = settings.values.satisfactoryPercent * targetValue / 100), 
                            good || (good = settings.values.goodPercent * targetValue / 100), veryGood || (veryGood = settings.values.veryGoodPercent * targetValue / 100), 
                            maximum || (maximum = settings.values.maximumPercent * targetValue / 100);
                            var sortedRanges = [ minimum, needsImprovement, satisfactory, good, veryGood, maximum ].sort(d3.descending), scale = d3.scale.linear().clamp(!0).domain([ minimum, Math.max(sortedRanges[0], targetValue, value) ]).range(settings.orientation.vertical ? [ bulletModel.viewportLength, 0 ] : [ 0, bulletModel.viewportLength ]), firstScale = scale(minimum), secondScale = scale(needsImprovement), thirdScale = scale(satisfactory), fourthScale = scale(good), fifthScale = scale(veryGood), lastScale = scale(maximum), valueScale = scale(value), firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity, highlight), 
                            bulletModel.targetValues.push({
                                barIndex: idx,
                                value: scale(targetValue),
                                fill: settings.colors.bulletColor,
                                key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),
                                value2: scale(targetValue2)
                            });
                            var xAxis = null;
                            if (settings.axis.axis) {
                                xAxis = d3.svg.axis(), xAxis.orient(settings.orientation.vertical ? "left" : "bottom");
                                var minTickSize = Math.round(Math.max(3, bulletModel.viewportLength / 100)), axisValues = [ value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood ].filter(function(x) {
                                    return !isNaN(x);
                                });
                                xAxis.tickFormat(visuals.valueFormatter.create({
                                    format: bulletModel.bulletValueFormatString,
                                    value: axisValues.length ? Math.max.apply(null, axisValues) : 0
                                }).format), xAxis.ticks(minTickSize), xAxis.scale(scale);
                            }
                            var bar = {
                                scale: scale,
                                barIndex: idx,
                                categoryLabel: category,
                                x: settings.orientation.vertical ? BulletChart.XMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.XMarginHorizontal,
                                y: settings.orientation.vertical ? BulletChart.YMarginVertical : BulletChart.YMarginHorizontal + bulletModel.spaceRequiredForBarHorizontally * idx,
                                axis: xAxis,
                                key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey()
                            };
                            bulletModel.bars.push(bar);
                        }
                        return bulletModel;
                    }, BulletChart.addItemToBarArray = function(collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity, highlight) {
                        isNaN(start) || isNaN(end) || collection.push({
                            barIndex: barIndex,
                            start: start,
                            end: end,
                            fill: fill,
                            tooltipInfo: visuals.TooltipBuilder.createTooltipInfo(samples.bulletChartProps.formatString, null, null, null, null, tooltipInfo),
                            selected: !1,
                            identity: visuals.SelectionId.createWithId(categoryIdentity),
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, start + " " + end).getKey(),
                            highlight: highlight
                        });
                    }, BulletChart.prototype.init = function(options) {
                        var body = d3.select(options.element.get(0));
                        this.hostService = options.host, this.bulletBody = body.append("div").classed("bulletChart", !0).attr("drag-resize-disabled", !0), 
                        this.scrollContainer = this.bulletBody.append("svg").classed("bullet-scroll-region", !0), 
                        this.clearCatcher = visuals.appendClearCatcher(this.scrollContainer), this.labelGraphicsContext = this.scrollContainer.append("g"), 
                        this.bulletGraphicsContext = this.scrollContainer.append("g"), this.behavior = new BulletWebBehavior(), 
                        this.interactivityService = visuals.createInteractivityService(options.host);
                    }, BulletChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var dataView = options.dataViews[0];
                            this.viewport = options.viewport, this.model = BulletChart.converter(dataView, options), 
                            this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.model.bulletChartSettings.labelSettings.fontSize)), 
                            this.ClearViewport(), this.model && (this.interactivityService && this.interactivityService.applySelectionStateToData(this.model.barRects), 
                            this.bulletBody.style({
                                height: this.viewportIn.height + "px",
                                width: this.viewportIn.width + "px"
                            }), this.vertical ? this.scrollContainer.attr({
                                width: this.model.bars.length * BulletChart.SpaceRequiredForBarVertically + BulletChart.XMarginVertical + "px",
                                height: this.viewportScroll.height + "px"
                            }) : this.scrollContainer.attr({
                                height: this.model.bars.length * this.model.spaceRequiredForBarHorizontally + "px",
                                width: this.viewportScroll.width + "px"
                            }), this.vertical ? this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse) : this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse));
                        }
                    }, BulletChart.prototype.ClearViewport = function() {
                        this.labelGraphicsContext.selectAll("text").remove(), this.bulletGraphicsContext.selectAll("rect").remove(), 
                        this.bulletGraphicsContext.selectAll("text").remove(), this.bulletGraphicsContext.selectAll("axis").remove(), 
                        this.bulletGraphicsContext.selectAll("path").remove(), this.bulletGraphicsContext.selectAll("line").remove(), 
                        this.bulletGraphicsContext.selectAll("tick").remove(), this.bulletGraphicsContext.selectAll("g").remove();
                    }, BulletChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, BulletChart.prototype.calculateLabelWidth = function(barData, bar, reversed) {
                        return (reversed ? 0 : barData.x + BulletChart.MaxLabelWidth) + BulletChart.XMarginHorizontal + (bar ? bar.start : 0);
                    }, BulletChart.prototype.calculateLabelHeight = function(barData, bar, reversed) {
                        return BulletChart.YMarginVertical + (reversed ? 5 : barData.y + this.model.labelHeightTop + BulletChart.BarMargin + BulletChart.SubtitleMargin) + (bar ? bar.end : 0);
                    }, BulletChart.prototype.setUpBulletsHorizontally = function(bulletBody, model, reveresed) {
                        var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                            return d.key;
                        }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                            return d.key;
                        }), hasSelection = this.interactivityService && this.interactivityService.hasSelection(), hasHighlights = model.hasHighlights, bullets = rectSelection.enter().append("rect").attr({
                            x: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed);
                            },
                            y: function(d) {
                                return bars[d.barIndex].y - BulletChart.BulletSize / 2;
                            },
                            width: function(d) {
                                return d.end - d.start;
                            },
                            height: BulletChart.BulletSize
                        }).classed("range", !0).style({
                            fill: function(d) {
                                return d.fill;
                            },
                            opacity: function(d) {
                                return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                            }
                        });
                        rectSelection.exit();
                        var valueSelection = this.bulletGraphicsContext.selectAll("rect").data(valueRects, function(d) {
                            return d.key;
                        });
                        valueSelection.enter().append("rect").attr({
                            x: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed);
                            },
                            y: function(d) {
                                return bars[d.barIndex].y - BulletChart.BulletSize / 8;
                            },
                            width: function(d) {
                                return d.end - d.start;
                            },
                            height: 1 * BulletChart.BulletSize / 4
                        }).classed("value", !0).style({
                            fill: function(d) {
                                return d.fill;
                            },
                            opacity: function(d) {
                                return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                            }
                        }), valueSelection.exit();
                        var markerSelection = this.bulletGraphicsContext.selectAll("values").data(targetValues, function(d) {
                            return isNaN(d.value) || isNaN(d.value2) ? void 0 : d.key;
                        });
                        if (markerSelection.enter().append("line").attr({
                            x1: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                            },
                            x2: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                            },
                            y1: function(d) {
                                return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                            },
                            y2: function(d) {
                                return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        }), model.bulletChartSettings.values.secondTargetVisibility && this.drawSecondTarget(markerSelection.enter(), function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                        }, function(d) {
                            return bars[d.barIndex].y;
                        }), markerSelection.exit(), model.bulletChartSettings.axis.axis) for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                transform: function() {
                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed), yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return "translate(" + xLocation + "," + yLocation + ")";
                                }
                            }).classed("axis", !0).call(bar.axis.scale(bar.scale)).style({
                                fill: model.bulletChartSettings.axis.axisColor,
                                "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll("line").style({
                                stroke: model.bulletChartSettings.axis.axisColor
                            });
                        }
                        model.bulletChartSettings.labelSettings.show && barSelection.enter().append("text").classed("title", !0).attr({
                            x: function(d) {
                                return reveresed ? 2 * BulletChart.XMarginHorizontal + model.viewportLength : d.x;
                            },
                            y: function(d) {
                                return d.y + _this.baselineDelta;
                            },
                            fill: model.bulletChartSettings.labelSettings.labelColor,
                            "font-size": PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize)
                        }).text(function(d) {
                            return d.categoryLabel;
                        });
                        var measureUnitsText = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(model.bulletChartSettings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxMeasureUnitWidth);
                        if (model.bulletChartSettings.axis.measureUnits && barSelection.enter().append("text").attr({
                            x: function(d) {
                                return reveresed ? 2 * BulletChart.XMarginHorizontal + model.viewportLength + BulletChart.SubtitleMargin : d.x - BulletChart.SubtitleMargin;
                            },
                            y: function(d) {
                                return d.y + _this.model.labelHeight / 2 + 12;
                            },
                            fill: model.bulletChartSettings.axis.unitsColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(measureUnitsText), this.interactivityService) {
                            var behaviorOptions = {
                                rects: bullets,
                                valueRects: valueSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService,
                                bulletChartSettings: this.model.bulletChartSettings,
                                hasHighlights: !1
                            }, targetCollection = this.model.barRects.concat(this.model.valueRects);
                            this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                        }
                        barSelection.exit(), visuals.TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), visuals.TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    }, BulletChart.prototype.setUpBulletsVertically = function(bulletBody, model, reveresed) {
                        var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                            return d.key;
                        }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                            return d.key;
                        }), hasSelection = this.interactivityService && this.interactivityService.hasSelection(), hasHighlights = model.hasHighlights, bullets = rectSelection.enter().append("rect").attr({
                            x: function(d) {
                                return bars[d.barIndex].x;
                            },
                            y: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed);
                            },
                            height: function(d) {
                                return d.start - d.end;
                            },
                            width: BulletChart.BulletSize
                        }).classed("range", !0).style({
                            fill: function(d) {
                                return d.fill;
                            },
                            opacity: function(d) {
                                return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                            }
                        });
                        rectSelection.exit();
                        var valueSelection = this.bulletGraphicsContext.selectAll("rect").data(valueRects, function(d) {
                            return d.key;
                        });
                        valueSelection.enter().append("rect").attr({
                            x: function(d) {
                                return bars[d.barIndex].x + BulletChart.BulletSize / 3;
                            },
                            y: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed);
                            },
                            height: function(d) {
                                return d.start - d.end;
                            },
                            width: 1 * BulletChart.BulletSize / 4
                        }).classed("value", !0).style({
                            fill: function(d) {
                                return d.fill;
                            },
                            opacity: function(d) {
                                return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                            }
                        }), valueSelection.exit();
                        var markerSelection = this.bulletGraphicsContext.selectAll("values").data(targetValues, function(d) {
                            return isNaN(d.value) || isNaN(d.value2) ? void 0 : d.key;
                        });
                        if (markerSelection.enter().append("line").attr({
                            x2: function(d) {
                                return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                            },
                            x1: function(d) {
                                return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                            },
                            y2: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                            },
                            y1: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        }), model.bulletChartSettings.values.secondTargetVisibility && this.drawSecondTarget(markerSelection.enter(), function(d) {
                            return bars[d.barIndex].x + BulletChart.BulletSize / 3 + BulletChart.BulletSize / 8;
                        }, function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                        }), markerSelection.exit(), model.bulletChartSettings.axis.axis) for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                transform: function() {
                                    var xLocation = bar.x, yLocation = _this.calculateLabelHeight(bar, null, reveresed);
                                    return "translate(" + xLocation + "," + yLocation + ")";
                                }
                            }).classed("axis", !0).call(bar.axis.scale(bar.scale)).style({
                                fill: model.bulletChartSettings.axis.axisColor,
                                "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll("line").style({
                                stroke: model.bulletChartSettings.axis.axisColor
                            });
                        }
                        var labelsStartPos = BulletChart.YMarginVertical + (reveresed ? model.viewportLength + 15 : 0) + this.model.labelHeightTop;
                        model.bulletChartSettings.labelSettings.show && barSelection.enter().append("text").classed("title", !0).attr({
                            x: function(d) {
                                return d.x;
                            },
                            y: function(d) {
                                return labelsStartPos;
                            },
                            fill: model.bulletChartSettings.labelSettings.labelColor,
                            "font-size": PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize)
                        }).text(function(d) {
                            return d.categoryLabel;
                        });
                        var measureUnitsText = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(model.bulletChartSettings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxMeasureUnitWidth);
                        if (model.bulletChartSettings.axis.measureUnits && barSelection.enter().append("text").attr({
                            x: function(d) {
                                return d.x + BulletChart.BulletSize;
                            },
                            y: function(d) {
                                return labelsStartPos + BulletChart.SubtitleMargin + 12;
                            },
                            fill: model.bulletChartSettings.axis.unitsColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(measureUnitsText), this.interactivityService) {
                            var behaviorOptions = {
                                rects: bullets,
                                valueRects: valueSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService,
                                bulletChartSettings: this.model.bulletChartSettings,
                                hasHighlights: !1
                            }, targetCollection = this.model.barRects.concat(this.model.valueRects);
                            this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                        }
                        barSelection.exit(), visuals.TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), visuals.TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    }, BulletChart.prototype.drawSecondTarget = function(selection, getX, getY) {
                        var targetStyle = {
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        };
                        selection.append("line").attr({
                            x1: function(d) {
                                return getX(d) - BulletChart.SecondTargetLineSize;
                            },
                            y1: function(d) {
                                return getY(d) - BulletChart.SecondTargetLineSize;
                            },
                            x2: function(d) {
                                return getX(d) + BulletChart.SecondTargetLineSize;
                            },
                            y2: function(d) {
                                return getY(d) + BulletChart.SecondTargetLineSize;
                            }
                        }).style(targetStyle), selection.append("line").attr({
                            x1: function(d) {
                                return getX(d) + BulletChart.SecondTargetLineSize;
                            },
                            y1: function(d) {
                                return getY(d) - BulletChart.SecondTargetLineSize;
                            },
                            x2: function(d) {
                                return getX(d) - BulletChart.SecondTargetLineSize;
                            },
                            y2: function(d) {
                                return getY(d) + BulletChart.SecondTargetLineSize;
                            }
                        }).style(targetStyle);
                    }, BulletChart.prototype.destroy = function() {}, BulletChart.prototype.enumerateObjectInstances = function(options) {
                        var data = this.model;
                        if (data) {
                            var objectName = options.objectName;
                            switch (objectName) {
                              case "labels":
                                return this.enumerateLabels(data);

                              case "values":
                                return this.enumerateValues(data);

                              case "orientation":
                                return this.enumerateOrientation(data);

                              case "axis":
                                return this.enumerateAxis(data);

                              case "colors":
                                return this.enumerateColors(data);
                            }
                        }
                    }, BulletChart.prototype.enumerateLabels = function(data) {
                        return [ {
                            selector: null,
                            objectName: "labels",
                            properties: {
                                show: this.model.bulletChartSettings.labelSettings.show,
                                labelColor: this.model.bulletChartSettings.labelSettings.labelColor,
                                fontSize: this.model.bulletChartSettings.labelSettings.fontSize
                            }
                        } ];
                    }, BulletChart.prototype.enumerateValues = function(data) {
                        return [ {
                            selector: null,
                            objectName: "values",
                            properties: {
                                targetValue: this.model.bulletChartSettings.values.targetValue,
                                targetValue2: this.model.bulletChartSettings.values.targetValue2,
                                secondTargetVisibility: this.model.bulletChartSettings.values.secondTargetVisibility,
                                minimumPercent: this.model.bulletChartSettings.values.minimumPercent,
                                needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,
                                satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,
                                goodPercent: this.model.bulletChartSettings.values.goodPercent,
                                veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,
                                maximumPercent: this.model.bulletChartSettings.values.maximumPercent
                            }
                        } ];
                    }, BulletChart.prototype.enumerateOrientation = function(data) {
                        return [ {
                            selector: null,
                            objectName: "orientation",
                            properties: {
                                orientation: this.model.bulletChartSettings.orientation.orientation
                            }
                        } ];
                    }, BulletChart.prototype.enumerateAxis = function(data) {
                        return [ {
                            selector: null,
                            objectName: "axis",
                            properties: {
                                axis: this.model.bulletChartSettings.axis.axis,
                                axisColor: this.model.bulletChartSettings.axis.axisColor,
                                measureUnits: this.model.bulletChartSettings.axis.measureUnits,
                                unitsColor: this.model.bulletChartSettings.axis.unitsColor
                            }
                        } ];
                    }, BulletChart.prototype.enumerateColors = function(data) {
                        return [ {
                            selector: null,
                            objectName: "colors",
                            properties: {
                                badColor: this.model.bulletChartSettings.colors.badColor,
                                needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,
                                satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,
                                goodColor: this.model.bulletChartSettings.colors.goodColor,
                                veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,
                                bulletColor: this.model.bulletChartSettings.colors.bulletColor
                            }
                        } ];
                    }, BulletChart.ScrollBarSize = 22, BulletChart.SpaceRequiredForBarVertically = 100, 
                    BulletChart.XMarginHorizontal = 20, BulletChart.YMarginHorizontal = 30, BulletChart.XMarginVertical = 50, 
                    BulletChart.YMarginVertical = 10, BulletChart.BulletSize = 25, BulletChart.DefaultSubtitleFontSizeInPt = 9, 
                    BulletChart.BarMargin = 10, BulletChart.MaxLabelWidth = 80, BulletChart.MaxMeasureUnitWidth = BulletChart.MaxLabelWidth - 20, 
                    BulletChart.SubtitleMargin = 10, BulletChart.AxisFontSizeInPt = 8, BulletChart.SecondTargetLineSize = 7, 
                    BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3, BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4, 
                    BulletChart.FontFamily = "Segoe UI", BulletChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Value",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Value"
                        }, {
                            name: "TargetValue",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Target Value"
                        }, {
                            name: "Minimum",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Minimum"
                        }, {
                            name: "NeedsImprovement",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Needs Improvement"
                        }, {
                            name: "Satisfactory",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Satisfactory"
                        }, {
                            name: "Good",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Good"
                        }, {
                            name: "VeryGood",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Very Good"
                        }, {
                            name: "Maximum",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Maximum"
                        }, {
                            name: "TargetValue2",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Target Value 2"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            values: {
                                displayName: "Data values",
                                properties: {
                                    targetValue: {
                                        displayName: "Target Value",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    targetValue2: {
                                        displayName: "Target Value 2",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    secondTargetVisibility: {
                                        displayName: "Second Target Visibility",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    minimumPercent: {
                                        displayName: "Minimum %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    needsImprovementPercent: {
                                        displayName: "Needs Improvement %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    satisfactoryPercent: {
                                        displayName: "Satisfactory %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    goodPercent: {
                                        displayName: "Good %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    veryGoodPercent: {
                                        displayName: "Very Good %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maximumPercent: {
                                        displayName: "Maximum %",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Category labels",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            orientation: {
                                displayName: "Orientation",
                                properties: {
                                    orientation: {
                                        displayName: "Orientation",
                                        type: {
                                            enumeration: Orientation.type
                                        }
                                    }
                                }
                            },
                            colors: {
                                displayName: "Colors",
                                properties: {
                                    badColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Bad Color"
                                    },
                                    needsImprovementColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Needs Improvement Color"
                                    },
                                    satisfactoryColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Satisfactory Color"
                                    },
                                    goodColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Good Color"
                                    },
                                    veryGoodColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Very Good Color"
                                    },
                                    bulletColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Bullet Color"
                                    }
                                }
                            },
                            axis: {
                                displayName: "Axis",
                                properties: {
                                    axis: {
                                        displayName: "Axis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Axis Color"
                                    },
                                    measureUnits: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Measure Units "
                                    },
                                    unitsColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Units Color"
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Value: {
                                    max: 1
                                },
                                TargetValue: {
                                    max: 1
                                },
                                Minimum: {
                                    max: 1
                                },
                                NeedsImprovement: {
                                    max: 1
                                },
                                Satisfactory: {
                                    max: 1
                                },
                                Good: {
                                    max: 1
                                },
                                VeryGood: {
                                    max: 1
                                },
                                Maximum: {
                                    max: 1
                                },
                                TargetValue2: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Value"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetValue"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetValue2"
                                        }
                                    }, {
                                        bind: {
                                            to: "Minimum"
                                        }
                                    }, {
                                        bind: {
                                            to: "NeedsImprovement"
                                        }
                                    }, {
                                        bind: {
                                            to: "Satisfactory"
                                        }
                                    }, {
                                        bind: {
                                            to: "Good"
                                        }
                                    }, {
                                        bind: {
                                            to: "VeryGood"
                                        }
                                    }, {
                                        bind: {
                                            to: "Maximum"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            "default": {}
                        },
                        drilldown: {
                            roles: [ "Category" ]
                        }
                    }, BulletChart;
                }();
                samples.BulletChart = BulletChart;
                var TextMeasurementHelper;
                !function(TextMeasurementHelper) {
                    function estimateSvgTextBaselineDelta(textProperties) {
                        var rect = estimateSvgTextRect(textProperties);
                        return rect.y + rect.height;
                    }
                    function ensureDOM() {
                        spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                            height: "0px",
                            width: "0px",
                            position: "absolute"
                        }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                    }
                    function measureSvgTextRect(textProperties) {
                        return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                            visibility: "hidden",
                            "font-family": textProperties.fontFamily,
                            "font-size": textProperties.fontSize,
                            "font-weight": textProperties.fontWeight,
                            "font-style": textProperties.fontStyle,
                            "white-space": textProperties.whiteSpace || "nowrap"
                        }), svgTextElement.node().getBBox();
                    }
                    function estimateSvgTextRect(textProperties) {
                        var estimatedTextProperties = {
                            fontFamily: textProperties.fontFamily,
                            fontSize: textProperties.fontSize,
                            text: "M"
                        }, rect = measureSvgTextRect(estimatedTextProperties);
                        return rect;
                    }
                    var spanElement, svgTextElement, canvasCtx;
                    TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                }(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
                var BulletWebBehavior = function() {
                    function BulletWebBehavior() {}
                    return BulletWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var clearCatcher = options.clearCatcher;
                        options.valueRects.on("click", function(d, i) {
                            d3.event.stopPropagation(), selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), options.rects.on("click", function(d, i) {
                            d3.event.stopPropagation(), selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, BulletWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var options = this.options, hasHighlights = options.hasHighlights;
                        options.valueRects.style("opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        }), options.rects.style("opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, BulletWebBehavior;
                }();
                samples.BulletWebBehavior = BulletWebBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
                !function(WordCloudScaleType) {
                    WordCloudScaleType[WordCloudScaleType.logn = 0] = "logn", WordCloudScaleType[WordCloudScaleType.sqrt = 1] = "sqrt", 
                    WordCloudScaleType[WordCloudScaleType.value = 2] = "value";
                }(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
                var WordCloudScaleType = samples.WordCloudScaleType, VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.margin = this.defaultMargin);
                        },
                        set: function(value) {
                            this.marginValue = VisualLayout.restrictToMinMax(value), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            this.viewportValue = VisualLayout.restrictToMinMax(value), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        });
                    }, VisualLayout.restrictToMinMax = function(value) {
                        var result = $.extend({}, value);
                        return d3.keys(value).forEach(function(x) {
                            return result[x] = Math.max(0, value[x]);
                        }), result;
                    }, VisualLayout;
                }(), WordCloud = function() {
                    function WordCloud(options) {
                        this.durationAnimations = 500, this.fakeViewport = {
                            width: 1500,
                            height: 1e3
                        }, this.canvasViewport = {
                            width: 128,
                            height: 2048
                        }, options && (this.svg = options.svg || this.svg, this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin), 
                        options.animator && (this.animator = options.animator)), this.isUpdating = !1;
                    }
                    return WordCloud.prototype.init = function(options) {
                        var _this = this;
                        this.svg ? this.root = this.svg : this.root = d3.select(options.element.get(0)).append("svg"), 
                        WordCloud.colors = options.style.colorPalette.dataColors, this.hostService = options.host, 
                        this.selectionManager = new visuals.utility.SelectionManager({
                            hostServices: this.hostService
                        }), this.layout || (this.layout = new VisualLayout(null, WordCloud.DefaultMargin)), 
                        this.root.classed(WordCloud.ClassName, !0), this.root.on("click", function() {
                            _this.selectionManager.clear(), _this.setSelection(_this.wordsSelection);
                        }), this.fontFamily = this.root.style("font-family"), this.main = this.root.append("g"), 
                        this.wordsContainerSelection = this.main.append("g").classed(WordCloud.Words["class"], !0), 
                        this.canvas = document.createElement("canvas");
                    }, WordCloud.prototype.converter = function(dataView) {
                        var _this = this;
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length && dataView.categorical.categories[0].values.length > 0)) return null;
                        var frequencies, texts, categories = dataView.categorical.categories[0].values, settings = WordCloud.parseSettings(dataView, categories[0]);
                        return settings ? (_.isEmpty(dataView.categorical.values) || _.isEmpty(dataView.categorical.values[0]) || _.isEmpty(dataView.categorical.values[0].values) || (frequencies = dataView.categorical.values[0].values), 
                        texts = categories.map(function(item, index) {
                            var color, categoryObject = dataView.categorical.categories[0];
                            return color = categoryObject.objects && categoryObject.objects[index] ? _this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]) : _this.wordCloudTexts && _this.wordCloudTexts[index] ? _this.wordCloudTexts[index].color : explore.util.getRandomColor(), 
                            {
                                text: item,
                                count: frequencies && frequencies[index] && !isNaN(frequencies[index]) ? frequencies[index] : 1,
                                index: index,
                                selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),
                                color: color
                            };
                        }), {
                            settings: settings,
                            texts: texts
                        }) : null;
                    }, WordCloud.prototype.getColor = function(properties, defaultColor, objects) {
                        var colorHelper;
                        return colorHelper = new visuals.ColorHelper(WordCloud.colors, properties, defaultColor), 
                        explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, ""));
                    }, WordCloud.parseSettings = function(dataView, value) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var valueFormatter, minFontSize, maxFontSize, minAngle, maxAngle, maxNumberOfOrientations, stopWords, stopWordsArray, maxNumberOfWords, objects = dataView.metadata.objects, isRotateText = !1, isBrokenText = !0, isRemoveStopWords = !0, isDefaultStopWords = !1;
                        return maxNumberOfWords = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords), 
                        minFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.minFontSize, WordCloud.DefaultSettings.minFontSize), 
                        maxFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxFontSize, WordCloud.DefaultSettings.maxFontSize), 
                        minAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.minAngle, WordCloud.DefaultSettings.minAngle), 
                        maxAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxAngle, WordCloud.DefaultSettings.maxAngle), 
                        isRotateText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.rotateText.show, WordCloud.DefaultSettings.isRotateText), 
                        maxNumberOfOrientations = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxNumberOfOrientations, WordCloud.DefaultSettings.maxNumberOfOrientations), 
                        valueFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, WordCloud.Properties.general.formatString),
                            value: value
                        }), isBrokenText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.general.isBrokenText, WordCloud.DefaultSettings.isBrokenText), 
                        isRemoveStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.show, WordCloud.DefaultSettings.isRemoveStopWords), 
                        stopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.words, WordCloud.DefaultSettings.stopWords), 
                        stopWordsArray = "string" == typeof stopWords ? stopWords.split(WordCloud.StopWordsDelemiter) : WordCloud.DefaultSettings.stopWordsArray, 
                        isDefaultStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.isDefaultStopWords, WordCloud.DefaultSettings.isDefaultStopWords), 
                        {
                            minFontSize: minFontSize,
                            maxFontSize: maxFontSize,
                            minAngle: minAngle,
                            maxAngle: maxAngle,
                            maxNumberOfOrientations: maxNumberOfOrientations,
                            valueFormatter: valueFormatter,
                            isRotateText: isRotateText,
                            isBrokenText: isBrokenText,
                            isRemoveStopWords: isRemoveStopWords,
                            stopWords: stopWords,
                            stopWordsArray: stopWordsArray,
                            isDefaultStopWords: isDefaultStopWords,
                            maxNumberOfWords: maxNumberOfWords
                        };
                    }, WordCloud.getNumberFromObjects = function(objects, properties, defaultValue) {
                        return objects ? powerbi.DataViewObjects.getValue(objects, properties, defaultValue) : defaultValue;
                    }, WordCloud.prototype.parseNumber = function(value, defaultValue, minValue, maxValue) {
                        void 0 === defaultValue && (defaultValue = 0), void 0 === minValue && (minValue = -Number.MAX_VALUE), 
                        void 0 === maxValue && (maxValue = Number.MAX_VALUE);
                        var parsedValue = Number(value);
                        return isNaN(parsedValue) || "string" == typeof value && 0 === value.length ? defaultValue : minValue > parsedValue ? minValue : parsedValue > maxValue ? maxValue : parsedValue;
                    }, WordCloud.prototype.computePositions = function(words, onPositionsComputed) {
                        var maxNumberOfWords, _this = this, context = this.getCanvasContext(), surface = [], borders = null;
                        if (!(words && words.length > 0)) return null;
                        maxNumberOfWords = Math.abs(this.parseNumber(this.settings.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords, -1 * words.length, words.length)), 
                        words.length > maxNumberOfWords && (words = words.slice(0, maxNumberOfWords));
                        for (var i = void 0; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) surface[i] = 0;
                        setTimeout(function() {
                            return _this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0);
                        }, 0);
                    }, WordCloud.prototype.computeCycle = function(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
                        void 0 === wordsForDraw && (wordsForDraw = []), void 0 === index && (index = 0);
                        var word = words[index], ratio = 1;
                        words.length <= 10 ? ratio = 5 : words.length <= 25 ? ratio = 3 : words.length <= 75 ? ratio = 1.5 : words.length <= 100 && (ratio = 1.25), 
                        word.x = this.specialViewport.width / ratio * (Math.random() + .5) >> 1, word.y = this.specialViewport.height / ratio * (Math.random() + .5) >> 1, 
                        this.generateSprites(context, word, words, index), word.sprite && this.findPosition(surface, word, borders) && (wordsForDraw.push(word), 
                        borders = this.updateBorders(word, borders), word.x -= this.specialViewport.width >> 1, 
                        word.y -= this.specialViewport.height >> 1), ++index < words.length && this.root ? this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) : onPositionsComputed({
                            data: wordsForDraw,
                            leftBorder: borders && borders[0],
                            rightBorder: borders && borders[1]
                        });
                    }, WordCloud.prototype.updateBorders = function(word, borders) {
                        if (borders && 2 === borders.length) {
                            var leftBorder = borders[0], rightBorder = borders[1];
                            word.x + word.x0 < leftBorder.x && (leftBorder.x = word.x + word.x0), word.y + word.y0 < leftBorder.y && (leftBorder.y = word.y + word.y0), 
                            word.x + word.x1 > rightBorder.x && (rightBorder.x = word.x + word.x1), word.y + word.y1 > rightBorder.y && (rightBorder.y = word.y + word.y1);
                        } else borders = [ {
                            x: word.x + word.x0,
                            y: word.y + word.y0
                        }, {
                            x: word.x + word.x1,
                            y: word.y + word.y1
                        } ];
                        return borders;
                    }, WordCloud.prototype.generateSprites = function(context, currentWord, words, index) {
                        if (!currentWord.sprite) {
                            context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
                            for (var pixels, x = 0, y = 0, maxHeight = 0, quantityOfWords = words.length, sprite = [], i = index; quantityOfWords > i; i++) {
                                var currentWordData = words[i], widthOfWord = 0, heightOfWord = 0;
                                if (context.save(), context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily, 
                                widthOfWord = context.measureText(currentWordData.text + "m").width, heightOfWord = currentWordData.size << 1, 
                                currentWordData.rotate) {
                                    var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
                                    widthOfWord = Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31 >> 5 << 5, 
                                    heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
                                } else widthOfWord = widthOfWord + 31 >> 5 << 5;
                                heightOfWord > maxHeight && (maxHeight = heightOfWord), x + widthOfWord >= this.canvasViewport.width << 5 && (x = 0, 
                                y += maxHeight, maxHeight = 0), context.translate(x + (widthOfWord >> 1), y + (heightOfWord >> 1)), 
                                currentWordData.rotate && context.rotate(currentWordData.rotate * WordCloud.Radians), 
                                context.fillText(currentWordData.text, 0, 0), currentWordData.padding && (context.lineWidth = 2 * currentWordData.padding, 
                                context.strokeText(currentWordData.text, 0, 0)), context.restore(), currentWordData.width = widthOfWord, 
                                currentWordData.height = heightOfWord, currentWordData.xOff = x, currentWordData.yOff = y, 
                                currentWordData.x1 = widthOfWord >> 1, currentWordData.y1 = heightOfWord >> 1, currentWordData.x0 = -currentWordData.x1, 
                                currentWordData.y0 = -currentWordData.y1, x += widthOfWord;
                            }
                            pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data, 
                            sprite = [];
                            for (var i = quantityOfWords - 1; i >= 0; i--) {
                                var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x_1 = 0, y_1 = 0, seen = 0, seenRow = 0;
                                if (currentWordData.xOff + width >= this.canvasViewport.width << 5 || currentWordData.yOff + height >= this.canvasViewport.height) currentWordData.sprite = null; else {
                                    for (var j = 0; height * width32 > j; j++) sprite[j] = 0;
                                    if (null === currentWordData.xOff) return;
                                    x_1 = currentWordData.xOff, y_1 = currentWordData.yOff, seen = 0, seenRow = -1;
                                    for (var j = 0; height > j; j++) {
                                        for (var k = 0; width > k; k++) {
                                            var l = width32 * j + (k >> 5), index_1 = (y_1 + j) * (this.canvasViewport.width << 5) + (x_1 + k) << 2, m = pixels[index_1] ? 1 << 31 - k % 32 : 0;
                                            sprite[l] |= m, seen |= m;
                                        }
                                        seen ? seenRow = j : (currentWordData.y0++, height--, j--, y_1++);
                                    }
                                    currentWordData.y1 = currentWordData.y0 + seenRow, currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
                                }
                            }
                        }
                    }, WordCloud.prototype.findPosition = function(surface, word, borders) {
                        for (var point, dx, dy, startPoint = {
                            x: word.x,
                            y: word.y
                        }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), dt = Math.random() < .5 ? 1 : -1, shift = -dt; ;) {
                            if (shift += dt, point = this.archimedeanSpiral(shift), dx = Math.floor(point.x), 
                            dy = Math.floor(point.y), Math.min(Math.abs(dx), Math.abs(dy)) >= delta) break;
                            if (word.x = startPoint.x + dx, word.y = startPoint.y + dy, !(word.x + word.x0 < 0 || word.y + word.y0 < 0 || word.x + word.x1 > this.specialViewport.width || word.y + word.y1 > this.specialViewport.height) && (!borders || !this.checkIntersect(word, surface)) && (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1]))) {
                                for (var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = 127 & lx, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; height > i; i++) {
                                    for (var lastSprite = 0, j = 0; width >= j; j++) {
                                        var leftMask = lastSprite << msx, rightMask = void 0;
                                        width > j && (lastSprite = sprite[i * width + j]), rightMask = width > j ? lastSprite >>> sx : 0, 
                                        surface[x + j] |= leftMask | rightMask;
                                    }
                                    x += shiftWidth;
                                }
                                return word.sprite = null, !0;
                            }
                        }
                        return !1;
                    }, WordCloud.prototype.archimedeanSpiral = function(value) {
                        var ratio = this.specialViewport.width / this.specialViewport.height;
                        return value = .1 * value, {
                            x: ratio * value * Math.cos(value),
                            y: value * Math.sin(value)
                        };
                    }, WordCloud.prototype.checkIntersect = function(word, surface) {
                        for (var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = 127 & lx, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; heightOfWord > i; i++) {
                            for (var lastSprite = 0, j = 0; widthOfWord >= j; j++) {
                                var mask = 0, leftMask = void 0, intersectMask = 0;
                                if (leftMask = lastSprite << msx, widthOfWord > j && (lastSprite = sprite[i * widthOfWord + j]), 
                                mask = widthOfWord > j ? lastSprite >>> sx : 0, intersectMask = (leftMask | mask) & surface[x + j]) return !0;
                            }
                            x += shiftWidth;
                        }
                        return !1;
                    }, WordCloud.prototype.checkIntersectOfRectangles = function(word, leftBorder, rightBorder) {
                        return word.x + word.x1 > leftBorder.x && word.x + word.x0 < rightBorder.x && word.y + word.y1 > leftBorder.y && word.y + word.y0 < rightBorder.y;
                    }, WordCloud.prototype.getCanvasContext = function() {
                        if (!this.canvasViewport) return null;
                        this.canvas.width = 1, this.canvas.height = 1;
                        var context = this.canvas.getContext("2d");
                        return this.canvas.width = this.canvasViewport.width << 5, this.canvas.height = this.canvasViewport.height, 
                        context = this.canvas.getContext("2d"), context.fillStyle = context.strokeStyle = "red", 
                        context.textAlign = "center", context;
                    }, WordCloud.prototype.getReducedText = function(texts) {
                        var brokenStrings = [];
                        return 1 === texts.length ? this.isSingleSentence = !0 : this.isSingleSentence = !1, 
                        brokenStrings = this.getBrokenWords(texts), brokenStrings.reduce(function(previousValue, currentValue) {
                            return previousValue.some(function(value) {
                                return value.index !== currentValue.index && value.text === currentValue.text ? (value.count += currentValue.count, 
                                !0) : !1;
                            }) || previousValue.push(currentValue), previousValue;
                        }, []);
                    }, WordCloud.prototype.getBrokenWords = function(words) {
                        var punctuatuinRegExp, _this = this, brokenStrings = [], whiteSpaceRegExp = /\s/;
                        return this.settings.isBrokenText ? (punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim"), 
                        words.forEach(function(item) {
                            if ("string" == typeof item.text) {
                                var words_1;
                                if (words_1 = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp), 
                                _this.settings.isRemoveStopWords) {
                                    var stopWords_1 = _this.settings.stopWordsArray;
                                    _this.settings.isDefaultStopWords && (stopWords_1 = stopWords_1.concat(WordCloud.StopWords)), 
                                    words_1 = words_1.filter(function(value) {
                                        return value.length > 0 && !stopWords_1.some(function(removeWord) {
                                            return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
                                        });
                                    });
                                }
                                words_1.forEach(function(element) {
                                    element.length > 0 && !whiteSpaceRegExp.test(element) && brokenStrings.push({
                                        text: element,
                                        count: item.count,
                                        index: item.index,
                                        selectionId: item.selectionId,
                                        color: item.color
                                    });
                                });
                            } else brokenStrings.push(item);
                        }), brokenStrings) : words;
                    }, WordCloud.prototype.getWords = function(values) {
                        var sortedValues, _this = this, minValue = 0, maxValue = 0, valueFormatter = this.settings.valueFormatter;
                        if (!(values && values.length >= 1)) return [];
                        sortedValues = values.sort(function(a, b) {
                            return b.count - a.count;
                        }), minValue = sortedValues[sortedValues.length - 1].count, maxValue = sortedValues[0].count;
                        var returnValues = values.map(function(value) {
                            return {
                                text: valueFormatter.format(value.text),
                                size: _this.getFontSize(value.count, minValue, maxValue),
                                x: 0,
                                y: 0,
                                rotate: _this.getAngle(),
                                padding: 1,
                                width: 0,
                                height: 0,
                                xOff: 0,
                                yOff: 0,
                                x0: 0,
                                y0: 0,
                                x1: 0,
                                y1: 0,
                                color: value.color,
                                selectionId: value.selectionId,
                                wordIndex: value.index
                            };
                        });
                        return this.dataBeforeRender = returnValues, returnValues;
                    }, WordCloud.prototype.getFontSize = function(value, minValue, maxValue, scaleType) {
                        void 0 === scaleType && (scaleType = WordCloudScaleType.value);
                        var weight, fontSize, maxFontSize, minFontSize;
                        if (minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize)), 
                        maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize)), 
                        maxFontSize > this.layout.viewportIn.width / 2 && (maxFontSize = this.layout.viewportIn.width / 2), 
                        this.isSingleSentence) return maxFontSize;
                        if (minFontSize > maxFontSize) {
                            var buffer = minFontSize;
                            minFontSize = maxFontSize, maxFontSize = buffer;
                        }
                        switch (scaleType) {
                          case WordCloudScaleType.logn:
                            weight = Math.log(value);

                          case WordCloudScaleType.sqrt:
                            weight = Math.sqrt(value);

                          case WordCloudScaleType.value:
                            weight = value;
                        }
                        return fontSize = weight > minValue && maxValue - minValue !== 0 ? maxFontSize * (weight - minValue) / (maxValue - minValue) : 0, 
                        fontSize = 100 * fontSize / maxFontSize, fontSize = fontSize * (maxFontSize - minFontSize) / 100 + minFontSize;
                    }, WordCloud.prototype.getAngle = function() {
                        if (!this.settings || !this.settings.isRotateText) return 0;
                        var minAngle, maxAngle, maxNumberOfOrientations, angle;
                        if (maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0)), 
                        minAngle = this.parseNumber(this.settings.minAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle), 
                        maxAngle = this.parseNumber(this.settings.maxAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle), 
                        minAngle > maxAngle) {
                            var buffer = minAngle;
                            minAngle = maxAngle, maxAngle = buffer;
                        }
                        return angle = Math.abs((maxAngle - minAngle) / maxNumberOfOrientations * Math.floor(Math.random() * maxNumberOfOrientations)), 
                        0 !== maxNumberOfOrientations ? minAngle + angle : 0;
                    }, WordCloud.prototype.update = function(visualUpdateOptions) {
                        var _this = this;
                        if (visualUpdateOptions && visualUpdateOptions.viewport && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0] && visualUpdateOptions.viewport && visualUpdateOptions.viewport.height >= 0 && visualUpdateOptions.viewport.width >= 0 && (visualUpdateOptions !== this.visualUpdateOptions && (this.incomingUpdateOptions = visualUpdateOptions), 
                        !this.isUpdating && this.incomingUpdateOptions !== this.visualUpdateOptions)) {
                            this.visualUpdateOptions = this.incomingUpdateOptions, this.layout.viewport = this.visualUpdateOptions.viewport;
                            var dataView = visualUpdateOptions.dataViews[0];
                            if (this.layout.viewportInIsZero) return;
                            if (this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                            this.UpdateSize(), this.data = this.converter(dataView), !this.data) return;
                            this.settings = this.data.settings, this.wordCloudTexts = this.data.texts, this.computePositions(this.getWords(this.getReducedText(this.data.texts)), function(wordCloudDataView) {
                                return _this.render(wordCloudDataView);
                            });
                        }
                    }, WordCloud.prototype.UpdateSize = function() {
                        var fakeWidth, fakeHeight, ratio;
                        ratio = Math.sqrt(this.fakeViewport.width * this.fakeViewport.height / (this.layout.viewportIn.width * this.layout.viewportIn.height)), 
                        isNaN(ratio) ? fakeHeight = fakeWidth = 1 : (fakeHeight = this.layout.viewportIn.height * ratio, 
                        fakeWidth = this.layout.viewportIn.width * ratio), this.specialViewport = {
                            height: fakeHeight,
                            width: fakeWidth
                        }, this.root.attr({
                            height: this.layout.viewport.height,
                            width: this.layout.viewport.width
                        });
                    }, WordCloud.prototype.render = function(wordCloudDataView) {
                        var _this = this;
                        if (wordCloudDataView && wordCloudDataView.data) {
                            this.wordCloudDataView = wordCloudDataView;
                            var animatedWordSelection, wordElements = this.main.select(WordCloud.Words.selector).selectAll(WordCloud.Word.selector);
                            this.wordsSelection = wordElements.data(wordCloudDataView.data), this.animation(this.wordsSelection, this.durationAnimations).attr("transform", function(item) {
                                return visuals.SVGUtil.translate(item.x, item.y) + " rotate(" + item.rotate + ")";
                            }).style({
                                "font-size": function(item) {
                                    return "" + item.size + WordCloud.Size;
                                },
                                fill: function(item) {
                                    return item.color;
                                }
                            }), animatedWordSelection = this.wordsSelection.enter().append("svg:text").attr("transform", function(item) {
                                return visuals.SVGUtil.translate(item.x, item.y) + " rotate(" + item.rotate + ")";
                            }).style("font-size", "1px"), this.wordsSelection.on("click", function(item) {
                                _this.selectionManager.select(item.selectionId, d3.event.ctrlKey).then(function() {
                                    return _this.setSelection(_this.wordsSelection);
                                }), d3.event.stopPropagation();
                            }), this.animation(animatedWordSelection, this.durationAnimations).style({
                                "font-size": function(item) {
                                    return "" + item.size + WordCloud.Size;
                                },
                                fill: function(item) {
                                    return item.color;
                                }
                            }), this.wordsSelection.text(function(item) {
                                return item.text;
                            }).classed(WordCloud.Word["class"], !0), this.wordsSelection.exit().remove(), this.setSelection(this.wordsSelection), 
                            setTimeout(function() {
                                _this.root && _this.scaleMainView(wordCloudDataView, wordElements[0].length && _this.durationAnimations), 
                                _this.isUpdating = !1, _this.incomingUpdateOptions !== _this.visualUpdateOptions && _this.update(_this.incomingUpdateOptions);
                            }, this.durationAnimations + WordCloud.RenderDelay);
                        }
                    }, WordCloud.prototype.setSelection = function(selection) {
                        var selectionIds = this.selectionManager.getSelectionIds();
                        if (selectionIds.some(function(x) {
                            return !selection.data().some(function(d) {
                                return d.selectionId.getKey() === x.getKey();
                            });
                        }) && (this.selectionManager.clear(), selectionIds = []), !selectionIds.length) return void this.setOpacity(selection, WordCloud.MaxOpacity, !0);
                        var selectedColumns = selection.filter(function(x) {
                            return selectionIds.some(function(y) {
                                return y.getKey() === x.selectionId.getKey();
                            });
                        });
                        this.setOpacity(selection, WordCloud.MinOpacity), this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
                    }, WordCloud.prototype.setOpacity = function(element, opacityValue, disableAnimation) {
                        void 0 === disableAnimation && (disableAnimation = !1);
                        var elementAnimation = disableAnimation ? element : this.animation(element);
                        elementAnimation.style("fill-opacity", opacityValue), this.main && (this.main.style("line-height", "14px"), 
                        this.animation(this.main, 0, this.durationAnimations + WordCloud.MinDelay).style("line-height", "15px"));
                    }, WordCloud.prototype.scaleMainView = function(wordCloudDataView, durationAnimation) {
                        if (void 0 === durationAnimation && (durationAnimation = 0), wordCloudDataView && wordCloudDataView.leftBorder && wordCloudDataView.rightBorder) {
                            var width2, height2, scaleByX, scaleByY, scale = 1, mainSVGRect = this.main.node().getBBox(), leftBorder = wordCloudDataView.leftBorder, rightBorder = wordCloudDataView.rightBorder;
                            scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x), 
                            scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y), 
                            scale = Math.min(scaleByX, scaleByY), width2 = this.layout.margin.left + mainSVGRect.x * scale * -1 + (this.layout.viewportIn.width - mainSVGRect.width * scale) / 2, 
                            height2 = this.layout.margin.top + mainSVGRect.y * scale * -1 + (this.layout.viewportIn.height - mainSVGRect.height * scale) / 2, 
                            this.main.style("line-height", "5px"), this.animation(this.main, durationAnimation).attr("transform", visuals.SVGUtil.translate(width2, height2) + " scale(" + scale + ")").style("line-height", "10px");
                        }
                    }, WordCloud.prototype.enumerateObjectInstances = function(options) {
                        var _this = this, instances = [];
                        if (!this.settings) return instances;
                        switch (options.objectName) {
                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    maxNumberOfWords: this.settings.maxNumberOfWords,
                                    minFontSize: this.settings.minFontSize,
                                    maxFontSize: this.settings.maxFontSize,
                                    isBrokenText: this.settings.isBrokenText
                                }
                            };
                            instances.push(general);
                            break;

                          case "dataPoint":
                            if (!this.wordCloudDataView || !this.wordCloudDataView.data) return;
                            var dataPoints = this.dataBeforeRender, wordCategoriesIndex_1 = [];
                            dataPoints.forEach(function(item) {
                                -1 === wordCategoriesIndex_1.indexOf(item.wordIndex) && (wordCategoriesIndex_1.push(item.wordIndex), 
                                instances.push({
                                    objectName: "dataPoint",
                                    displayName: _this.data.texts[item.wordIndex].text,
                                    selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), !1),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: item.color
                                            }
                                        }
                                    }
                                }));
                            });
                            break;

                          case "rotateText":
                            var rotateText = {
                                objectName: "rotateText",
                                displayName: "Rotate Text",
                                selector: null,
                                properties: {
                                    show: this.settings.isRotateText,
                                    minAngle: this.settings.minAngle,
                                    maxAngle: this.settings.maxAngle,
                                    maxNumberOfOrientations: this.settings.maxNumberOfOrientations
                                }
                            };
                            instances.push(rotateText);
                            break;

                          case "stopWords":
                            var stopWords = {
                                objectName: "stopWords",
                                displayName: "Stop Words",
                                selector: null,
                                properties: {
                                    show: this.settings.isRemoveStopWords,
                                    isDefaultStopWords: this.settings.isDefaultStopWords,
                                    words: this.settings.stopWords || this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)
                                }
                            };
                            instances.push(stopWords);
                        }
                        return instances;
                    }, WordCloud.prototype.animation = function(element, duration, delay, callback) {
                        return void 0 === duration && (duration = 0), void 0 === delay && (delay = 0), element.transition().delay(delay).duration(duration).each("end", callback);
                    }, WordCloud.prototype.destroy = function() {
                        this.root = null, this.canvas = null;
                    }, WordCloud.ClassName = "wordCloud", WordCloud.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            },
                            maxNumberOfWords: {
                                objectName: "general",
                                propertyName: "maxNumberOfWords"
                            },
                            minFontSize: {
                                objectName: "general",
                                propertyName: "minFontSize"
                            },
                            maxFontSize: {
                                objectName: "general",
                                propertyName: "maxFontSize"
                            },
                            isBrokenText: {
                                objectName: "general",
                                propertyName: "isBrokenText"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        stopWords: {
                            show: {
                                objectName: "stopWords",
                                propertyName: "show"
                            },
                            isDefaultStopWords: {
                                objectName: "stopWords",
                                propertyName: "isDefaultStopWords"
                            },
                            words: {
                                objectName: "stopWords",
                                propertyName: "words"
                            }
                        },
                        rotateText: {
                            show: {
                                objectName: "rotateText",
                                propertyName: "show"
                            },
                            minAngle: {
                                objectName: "rotateText",
                                propertyName: "minAngle"
                            },
                            maxAngle: {
                                objectName: "rotateText",
                                propertyName: "maxAngle"
                            },
                            maxNumberOfOrientations: {
                                objectName: "rotateText",
                                propertyName: "maxNumberOfOrientations"
                            }
                        }
                    }, WordCloud.Words = {
                        "class": "words",
                        selector: ".words"
                    }, WordCloud.Word = {
                        "class": "word",
                        selector: ".word"
                    }, WordCloud.Size = "px", WordCloud.StopWordsDelemiter = " ", WordCloud.Radians = Math.PI / 180, 
                    WordCloud.MinAngle = -180, WordCloud.MaxAngle = 180, WordCloud.MaxNumberOfWords = 2500, 
                    WordCloud.MinOpacity = .2, WordCloud.MaxOpacity = 1, WordCloud.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 1,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: WordCloud.MaxNumberOfWords
                                        }
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": "Values"
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: "Values",
                                    direction: 2
                                } ]
                            }
                        },
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    maxNumberOfWords: {
                                        displayName: "Max number of words",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    minFontSize: {
                                        displayName: "Min Font",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxFontSize: {
                                        displayName: "Max Font",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    isBrokenText: {
                                        displayName: "Word-breaking",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isRemoveStopWords: {
                                        displayName: "Stop Words",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            stopWords: {
                                displayName: "Stop Words",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isDefaultStopWords: {
                                        displayName: "Default Stop Words",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    words: {
                                        displayName: "Words",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            rotateText: {
                                displayName: "Rotate Text",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    minAngle: {
                                        displayName: "Min Angle",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxAngle: {
                                        displayName: "Max Angle",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxNumberOfOrientations: {
                                        displayName: "Max number of orientations",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, WordCloud.Punctuation = [ "!", ".", ":", "'", ";", ",", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "[", "]", '"', "\\", "/", "-", "_", "+", "=" ], 
                    WordCloud.StopWords = [ "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an", "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot", "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get", "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i", "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may", "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often", "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should", "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these", "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what", "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet", "you", "your" ], 
                    WordCloud.DefaultSettings = {
                        minFontSize: 20,
                        maxFontSize: 100,
                        minAngle: -60,
                        maxAngle: 90,
                        maxNumberOfOrientations: 2,
                        isRotateText: !1,
                        isBrokenText: !0,
                        isRemoveStopWords: !1,
                        stopWordsArray: [],
                        stopWords: void 0,
                        isDefaultStopWords: !1,
                        maxNumberOfWords: 200
                    }, WordCloud.RenderDelay = 50, WordCloud.MinDelay = 10, WordCloud.DefaultMargin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }, WordCloud;
                }();
                samples.WordCloud = WordCloud;
                var explore;
                !function(explore) {
                    var util;
                    !function(util) {
                        function hexToRgb(hex) {
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
                        }
                        function getRandomColor() {
                            var red = Math.floor(255 * Math.random()), green = Math.floor(255 * Math.random()), blue = Math.floor(255 * Math.random());
                            return "rgb(" + red + "," + green + "," + blue + ")";
                        }
                        util.hexToRgb = hexToRgb, util.getRandomColor = getRandomColor;
                    }(util = explore.util || (explore.util = {}));
                }(explore || (explore = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var TableViewFactory, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, SQExprConverter = powerbi.data.SQExprConverter, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
                !function(TableViewFactory) {
                    function createTableView(options) {
                        return new TableView(options);
                    }
                    TableViewFactory.createTableView = createTableView;
                }(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
                var TableView = function() {
                    function TableView(options) {
                        this.options = $.extend(!0, {}, options), this.options.baseContainer.style("overflow-y", "auto").attr("drag-resize-disabled", !0), 
                        this.scrollContainer = options.baseContainer.append("div").attr("class", "scrollRegion"), 
                        this.visibleGroupContainer = this.scrollContainer.append("div").attr("class", "visibleGroup"), 
                        TableView.SetDefaultOptions(options);
                    }
                    return TableView.SetDefaultOptions = function(options) {
                        options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
                    }, TableView.prototype.rowHeight = function(rowHeight) {
                        return this.options.rowHeight = Math.ceil(rowHeight), this;
                    }, TableView.prototype.columnWidth = function(columnWidth) {
                        return this.options.columnWidth = Math.ceil(columnWidth), this;
                    }, TableView.prototype.orientation = function(orientation) {
                        return this.options.orientation = orientation, this;
                    }, TableView.prototype.rows = function(rows) {
                        return this.options.rows = Math.ceil(rows), this;
                    }, TableView.prototype.columns = function(columns) {
                        return this.options.columns = Math.ceil(columns), this;
                    }, TableView.prototype.data = function(data, getDatumIndex, dataReset) {
                        return void 0 === dataReset && (dataReset = !1), this._data = data, this.getDatumIndex = getDatumIndex, 
                        this.setTotalRows(), dataReset && $(this.options.baseContainer.node()).scrollTop(0), 
                        this;
                    }, TableView.prototype.viewport = function(viewport) {
                        return this.options.viewport = viewport, this;
                    }, TableView.prototype.empty = function() {
                        this._data = [], this.render();
                    }, TableView.prototype.setTotalRows = function() {
                        var count = this._data.length, rows = Math.min(this.options.rows, count), columns = Math.min(this.options.columns, count);
                        columns > 0 && rows > 0 ? (this._totalColumns = columns, this._totalRows = rows) : rows > 0 ? (this._totalRows = rows, 
                        this._totalColumns = Math.ceil(count / rows)) : columns > 0 ? (this._totalColumns = columns, 
                        this._totalRows = Math.ceil(count / columns)) : (this._totalColumns = TableView.defaultColumns, 
                        this._totalRows = Math.ceil(count / TableView.defaultColumns));
                    }, TableView.prototype.render = function() {
                        var options = this.options, visibleGroupContainer = this.visibleGroupContainer, rowHeight = options.rowHeight || TableView.defaultRowHeight, groupedData = [], totalRows = options.rows, totalColumns = options.columns, totalItems = this._data.length, totalRows = options.rows > totalItems ? totalItems : options.rows, totalColumns = options.columns > totalItems ? totalItems : options.columns;
                        if (0 === totalColumns && 0 === totalRows ? options.orientation === Orientation.HORIZONTAL ? (totalColumns = totalItems, 
                        totalRows = 1) : (totalColumns = 1, totalRows = totalItems) : 0 === totalColumns && totalRows > 0 ? totalColumns = Math.ceil(totalItems / totalRows) : totalColumns > 0 && 0 === totalRows && (totalRows = Math.ceil(totalItems / totalColumns)), 
                        this.options.orientation === Orientation.VERTICAL) {
                            var n = totalRows;
                            totalRows = totalColumns, totalColumns = n;
                        } else this.options.orientation === Orientation.HORIZONTAL && (0 === totalRows && (totalRows = this._totalRows), 
                        0 === totalColumns && (totalColumns = this._totalColumns));
                        for (var m = 0, k = 0, i = 0; totalRows > i; i++) if (this.options.orientation === Orientation.VERTICAL && 0 === options.rows && totalItems % options.columns > 0 && options.columns <= totalItems) totalItems % options.columns > i ? (m = i * Math.ceil(totalItems / options.columns), 
                        k = m + Math.ceil(totalItems / options.columns), groupedData.push(this._data.slice(m, k))) : (groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns))), 
                        k += Math.floor(totalItems / options.columns)); else if (this.options.orientation === Orientation.HORIZONTAL && 0 === options.columns && totalItems % options.rows > 0 && options.rows <= totalItems) totalItems % options.rows > i ? (m = i * Math.ceil(totalItems / options.rows), 
                        k = m + Math.ceil(totalItems / options.rows), groupedData.push(this._data.slice(m, k))) : (groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows))), 
                        k += Math.floor(totalItems / options.rows)); else {
                            var k = i * totalColumns;
                            groupedData.push(this._data.slice(k, k + totalColumns));
                        }
                        visibleGroupContainer.selectAll(".row").remove();
                        var cellSelection = visibleGroupContainer.selectAll(".row").data(groupedData).enter().append("div").classed("row", !0).selectAll(".cell").data(function(d) {
                            return d;
                        });
                        cellSelection.enter().append("div").classed("cell", !0).call(function(d) {
                            return options.enter(d);
                        }), cellSelection.order();
                        var cellUpdateSelection = visibleGroupContainer.selectAll(".cell:not(.transitioning)");
                        if (cellUpdateSelection.call(function(d) {
                            return options.update(d);
                        }), cellUpdateSelection.style({
                            height: rowHeight > 0 ? rowHeight + "px" : "auto"
                        }), this.options.orientation === Orientation.VERTICAL) {
                            for (var realColumnNumber = 0, i = 0; i < groupedData.length; i++) 0 !== groupedData[i].length && (realColumnNumber = i + 1);
                            cellUpdateSelection.style({
                                width: "100%"
                            });
                            var rowUpdateSelection = visibleGroupContainer.selectAll("div.row");
                            rowUpdateSelection.style({
                                width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / realColumnNumber + "%"
                            });
                        } else cellUpdateSelection.style({
                            width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / totalColumns + "%"
                        });
                        cellSelection.exit().call(function(d) {
                            return options.exit(d);
                        }).remove();
                    }, TableView.defaultRowHeight = 0, TableView.defaultColumns = 1, TableView;
                }();
                samples.chicletSlicerProps = {
                    general: {
                        orientation: {
                            objectName: "general",
                            propertyName: "orientation"
                        },
                        columns: {
                            objectName: "general",
                            propertyName: "columns"
                        },
                        rows: {
                            objectName: "general",
                            propertyName: "rows"
                        },
                        showDisabled: {
                            objectName: "general",
                            propertyName: "showDisabled"
                        },
                        multiselect: {
                            objectName: "general",
                            propertyName: "multiselect"
                        },
                        selection: {
                            objectName: "general",
                            propertyName: "selection"
                        },
                        selfFilterEnabled: {
                            objectName: "general",
                            propertyName: "selfFilterEnabled"
                        }
                    },
                    header: {
                        show: {
                            objectName: "header",
                            propertyName: "show"
                        },
                        title: {
                            objectName: "header",
                            propertyName: "title"
                        },
                        fontColor: {
                            objectName: "header",
                            propertyName: "fontColor"
                        },
                        background: {
                            objectName: "header",
                            propertyName: "background"
                        },
                        outline: {
                            objectName: "header",
                            propertyName: "outline"
                        },
                        textSize: {
                            objectName: "header",
                            propertyName: "textSize"
                        },
                        outlineColor: {
                            objectName: "header",
                            propertyName: "outlineColor"
                        },
                        outlineWeight: {
                            objectName: "header",
                            propertyName: "outlineWeight"
                        }
                    },
                    rows: {
                        fontColor: {
                            objectName: "rows",
                            propertyName: "fontColor"
                        },
                        textSize: {
                            objectName: "rows",
                            propertyName: "textSize"
                        },
                        height: {
                            objectName: "rows",
                            propertyName: "height"
                        },
                        width: {
                            objectName: "rows",
                            propertyName: "width"
                        },
                        background: {
                            objectName: "rows",
                            propertyName: "background"
                        },
                        transparency: {
                            objectName: "rows",
                            propertyName: "transparency"
                        },
                        selectedColor: {
                            objectName: "rows",
                            propertyName: "selectedColor"
                        },
                        hoverColor: {
                            objectName: "rows",
                            propertyName: "hoverColor"
                        },
                        unselectedColor: {
                            objectName: "rows",
                            propertyName: "unselectedColor"
                        },
                        disabledColor: {
                            objectName: "rows",
                            propertyName: "disabledColor"
                        },
                        outline: {
                            objectName: "rows",
                            propertyName: "outline"
                        },
                        outlineColor: {
                            objectName: "rows",
                            propertyName: "outlineColor"
                        },
                        outlineWeight: {
                            objectName: "rows",
                            propertyName: "outlineWeight"
                        },
                        borderStyle: {
                            objectName: "rows",
                            propertyName: "borderStyle"
                        }
                    },
                    images: {
                        imageSplit: {
                            objectName: "images",
                            propertyName: "imageSplit"
                        },
                        stretchImage: {
                            objectName: "images",
                            propertyName: "stretchImage"
                        },
                        bottomImage: {
                            objectName: "images",
                            propertyName: "bottomImage"
                        }
                    },
                    selectedPropertyIdentifier: {
                        objectName: "general",
                        propertyName: "selected"
                    },
                    filterPropertyIdentifier: {
                        objectName: "general",
                        propertyName: "filter"
                    },
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    },
                    hasSavedSelection: !0
                };
                var ChicletBorderStyle;
                !function(ChicletBorderStyle) {
                    ChicletBorderStyle.ROUNDED = "Rounded", ChicletBorderStyle.CUT = "Cut", ChicletBorderStyle.SQUARE = "Square", 
                    ChicletBorderStyle.type = powerbi.createEnumType([ {
                        value: ChicletBorderStyle.ROUNDED,
                        displayName: ChicletBorderStyle.ROUNDED
                    }, {
                        value: ChicletBorderStyle.CUT,
                        displayName: ChicletBorderStyle.CUT
                    }, {
                        value: ChicletBorderStyle.SQUARE,
                        displayName: ChicletBorderStyle.SQUARE
                    } ]);
                }(ChicletBorderStyle || (ChicletBorderStyle = {}));
                var ChicletSlicerShowDisabled;
                !function(ChicletSlicerShowDisabled) {
                    ChicletSlicerShowDisabled.INPLACE = "Inplace", ChicletSlicerShowDisabled.BOTTOM = "Bottom", 
                    ChicletSlicerShowDisabled.HIDE = "Hide", ChicletSlicerShowDisabled.type = powerbi.createEnumType([ {
                        value: ChicletSlicerShowDisabled.INPLACE,
                        displayName: ChicletSlicerShowDisabled.INPLACE
                    }, {
                        value: ChicletSlicerShowDisabled.BOTTOM,
                        displayName: ChicletSlicerShowDisabled.BOTTOM
                    }, {
                        value: ChicletSlicerShowDisabled.HIDE,
                        displayName: ChicletSlicerShowDisabled.HIDE
                    } ]);
                }(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
                var Orientation;
                !function(Orientation) {
                    Orientation.HORIZONTAL = "Horizontal", Orientation.VERTICAL = "Vertical", Orientation.type = powerbi.createEnumType([ {
                        value: Orientation.HORIZONTAL,
                        displayName: Orientation.HORIZONTAL
                    }, {
                        value: Orientation.VERTICAL,
                        displayName: Orientation.VERTICAL
                    } ]);
                }(Orientation || (Orientation = {}));
                var ChicletSlicer = function() {
                    function ChicletSlicer(options) {
                        options && options.behavior && (this.behavior = options.behavior), this.behavior || (this.behavior = new ChicletSlicerWebBehavior());
                    }
                    return ChicletSlicer.DefaultStyleProperties = function() {
                        return {
                            general: {
                                orientation: Orientation.VERTICAL,
                                columns: 3,
                                rows: 0,
                                multiselect: !0,
                                showDisabled: ChicletSlicerShowDisabled.INPLACE,
                                selection: null,
                                selfFilterEnabled: !1
                            },
                            margin: {
                                top: 50,
                                bottom: 50,
                                right: 50,
                                left: 50
                            },
                            header: {
                                borderBottomWidth: 1,
                                show: !0,
                                outline: "BottomOnly",
                                fontColor: "#a6a6a6",
                                background: null,
                                textSize: 10,
                                outlineColor: "#a6a6a6",
                                outlineWeight: 1,
                                title: ""
                            },
                            headerText: {
                                marginLeft: 8,
                                marginTop: 0
                            },
                            slicerText: {
                                textSize: 10,
                                height: 0,
                                width: 0,
                                fontColor: "#666666",
                                hoverColor: "#212121",
                                selectedColor: "#BDD7EE",
                                unselectedColor: "#ffffff",
                                disabledColor: "grey",
                                marginLeft: 8,
                                outline: "Frame",
                                background: null,
                                transparency: 0,
                                outlineColor: "#000000",
                                outlineWeight: 1,
                                borderStyle: "Cut"
                            },
                            slicerItemContainer: {
                                marginTop: 5,
                                marginLeft: 0
                            },
                            images: {
                                imageSplit: 50,
                                stretchImage: !1,
                                bottomImage: !1
                            }
                        };
                    }, ChicletSlicer.converter = function(dataView, localizedSelectAllText, searchText, interactivityService) {
                        if (dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0) {
                            var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
                            converter.convert();
                            var slicerData, defaultSettings = this.DefaultStyleProperties(), objects = dataView.metadata.objects;
                            objects && (defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation), 
                            defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns), 
                            defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows), 
                            defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect), 
                            defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled), 
                            defaultSettings.general.selection = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection), 
                            defaultSettings.general.selfFilterEnabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.selfFilterEnabled, defaultSettings.general.selfFilterEnabled), 
                            defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show), 
                            defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title), 
                            defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor), 
                            defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background), 
                            defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize), 
                            defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline), 
                            defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor), 
                            defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight), 
                            defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize), 
                            defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height), 
                            defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width), 
                            defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor), 
                            defaultSettings.slicerText.hoverColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.hoverColor, defaultSettings.slicerText.hoverColor), 
                            defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor), 
                            defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor), 
                            defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background), 
                            defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency), 
                            defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor), 
                            defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline), 
                            defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor), 
                            defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight), 
                            defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle), 
                            defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit), 
                            defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage), 
                            defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage)), 
                            defaultSettings.general.selfFilterEnabled && searchText && (searchText = searchText.toLowerCase(), 
                            converter.dataPoints.forEach(function(x) {
                                return x.filtered = x.category.toLowerCase().indexOf(searchText) < 0;
                            }));
                            var categories = dataView.categorical.categories[0];
                            return slicerData = {
                                categorySourceName: categories.source.displayName,
                                formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
                                slicerSettings: defaultSettings,
                                slicerDataPoints: converter.dataPoints
                            }, slicerData.hasSelectionOverride = converter.hasSelectionOverride, slicerData;
                        }
                    }, ChicletSlicer.prototype.init = function(options) {
                        this.element = options.element, this.currentViewport = options.viewport, this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                        this.hostServices = options.host, this.hostServices.canSelect = ChicletSlicer.canSelect, 
                        this.settings = ChicletSlicer.DefaultStyleProperties(), this.initContainer();
                    }, ChicletSlicer.canSelect = function(args) {
                        var selectors = args.data;
                        return !(selectors && selectors.length > 1 && selectors.some(function(value) {
                            return value && value.data && value.data.length > 1;
                        }));
                    }, ChicletSlicer.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.viewport) {
                            var existingDataView = this.dataView;
                            this.dataView = options.dataViews[0];
                            var resetScrollbarPosition = !0;
                            existingDataView && (resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView)), 
                            options.viewport.height === this.currentViewport.height && options.viewport.width === this.currentViewport.width ? this.waitingForData = !1 : this.currentViewport = options.viewport, 
                            this.updateInternal(resetScrollbarPosition);
                        }
                    }, ChicletSlicer.prototype.onResizing = function(finalViewport) {
                        this.currentViewport = finalViewport, this.updateInternal(!1);
                    }, ChicletSlicer.prototype.enumerateObjectInstances = function(options) {
                        var data = this.slicerData;
                        if (data) {
                            var objectName = options.objectName;
                            switch (objectName) {
                              case "rows":
                                return this.enumerateRows(data);

                              case "header":
                                return this.enumerateHeader(data);

                              case "general":
                                return this.enumerateGeneral(data);

                              case "images":
                                return this.enumerateImages(data);
                            }
                        }
                    }, ChicletSlicer.prototype.enumerateHeader = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "header",
                            properties: {
                                show: slicerSettings.header.show,
                                title: slicerSettings.header.title,
                                fontColor: slicerSettings.header.fontColor,
                                background: slicerSettings.header.background,
                                textSize: slicerSettings.header.textSize,
                                outline: slicerSettings.header.outline,
                                outlineColor: slicerSettings.header.outlineColor,
                                outlineWeight: slicerSettings.header.outlineWeight
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateRows = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "rows",
                            properties: {
                                textSize: slicerSettings.slicerText.textSize,
                                height: slicerSettings.slicerText.height,
                                width: slicerSettings.slicerText.width,
                                background: slicerSettings.slicerText.background,
                                transparency: slicerSettings.slicerText.transparency,
                                selectedColor: slicerSettings.slicerText.selectedColor,
                                hoverColor: slicerSettings.slicerText.hoverColor,
                                unselectedColor: slicerSettings.slicerText.unselectedColor,
                                disabledColor: slicerSettings.slicerText.disabledColor,
                                outline: slicerSettings.slicerText.outline,
                                outlineColor: slicerSettings.slicerText.outlineColor,
                                outlineWeight: slicerSettings.slicerText.outlineWeight,
                                fontColor: slicerSettings.slicerText.fontColor,
                                borderStyle: slicerSettings.slicerText.borderStyle
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateGeneral = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "general",
                            properties: {
                                orientation: slicerSettings.general.orientation,
                                columns: slicerSettings.general.columns,
                                rows: slicerSettings.general.rows,
                                showDisabled: slicerSettings.general.showDisabled,
                                multiselect: slicerSettings.general.multiselect,
                                selfFilterEnabled: slicerSettings.general.selfFilterEnabled
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateImages = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "images",
                            properties: {
                                imageSplit: slicerSettings.images.imageSplit,
                                stretchImage: slicerSettings.images.stretchImage,
                                bottomImage: slicerSettings.images.bottomImage
                            }
                        } ];
                    }, ChicletSlicer.prototype.updateInternal = function(resetScrollbarPosition) {
                        var _this = this;
                        this.updateSlicerBodyDimensions();
                        var localizedSelectAllText = "Select All", data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.searchInput.val(), this.interactivityService);
                        if (!data) return void this.tableView.empty();
                        this.interactivityService && this.interactivityService.applySelectionStateToData(data.slicerDataPoints), 
                        data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight, 
                        data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight, 
                        data.slicerSettings.slicerText.height = data.slicerSettings.slicerText.height < 0 ? 0 : data.slicerSettings.slicerText.height, 
                        data.slicerSettings.slicerText.width = data.slicerSettings.slicerText.width < 0 ? 0 : data.slicerSettings.slicerText.width, 
                        data.slicerSettings.images.imageSplit = data.slicerSettings.images.imageSplit < 0 ? 0 : data.slicerSettings.images.imageSplit, 
                        data.slicerSettings.general.columns = data.slicerSettings.general.columns < 0 ? 0 : data.slicerSettings.general.columns, 
                        data.slicerSettings.general.rows = data.slicerSettings.general.rows < 0 ? 0 : data.slicerSettings.general.rows, 
                        data.slicerSettings.general.getSavedSelection = function() {
                            try {
                                return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];
                            } catch (ex) {
                                return [];
                            }
                        }, data.slicerSettings.general.setSavedSelection = function(filter, selectionIds) {
                            _this.isSelectionSaved = !0, _this.hostServices.persistProperties({
                                merge: [ {
                                    objectName: "general",
                                    selector: null,
                                    properties: {
                                        filter: filter,
                                        selection: selectionIds && JSON.stringify(selectionIds) || ""
                                    }
                                } ]
                            });
                        }, this.slicerData ? this.isSelectionSaved ? this.isSelectionLoaded = !0 : this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection : this.isSelectionLoaded = !1, 
                        this.slicerData = data, this.settings = this.slicerData.slicerSettings, this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM ? data.slicerDataPoints.sort(function(a, b) {
                            return a.selectable === b.selectable ? 0 : a.selectable && !b.selectable ? -1 : 1;
                        }) : this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE && (data.slicerDataPoints = data.slicerDataPoints.filter(function(x) {
                            return x.selectable;
                        }));
                        var height = this.settings.slicerText.height;
                        if (0 === height) {
                            var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders, textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
                            height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;
                            var hasImage = _.any(data.slicerDataPoints, function(x) {
                                return "" !== x.imageURL && "undefined" != typeof x.imageURL;
                            });
                            hasImage && (height += 100);
                        }
                        this.tableView.rowHeight(height).columnWidth(this.settings.slicerText.width).orientation(this.settings.general.orientation).rows(this.settings.general.rows).columns(this.settings.general.columns).data(data.slicerDataPoints.filter(function(x) {
                            return !x.filtered;
                        }), function(d) {
                            return $.inArray(d, data.slicerDataPoints);
                        }, resetScrollbarPosition).viewport(this.getSlicerBodyViewport(this.currentViewport)).render(), 
                        this.updateSearchHeader();
                    }, ChicletSlicer.prototype.initContainer = function() {
                        var _this = this, settings = this.settings, slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport), slicerContainer = d3.select(this.element.get(0)).append("div").classed(ChicletSlicer.Container["class"], !0);
                        this.slicerHeader = slicerContainer.append("div").classed(ChicletSlicer.Header["class"], !0), 
                        this.slicerHeader.append("span").classed(ChicletSlicer.Clear["class"], !0).attr("title", "Clear"), 
                        this.slicerHeader.append("div").classed(ChicletSlicer.HeaderText["class"], !0).style({
                            "margin-left": PixelConverter.toString(settings.headerText.marginLeft),
                            "margin-top": PixelConverter.toString(settings.headerText.marginTop),
                            "border-style": this.getBorderStyle(settings.header.outline),
                            "border-color": settings.header.outlineColor,
                            "border-width": this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                            "font-size": PixelConverter.fromPoint(settings.header.textSize)
                        }), this.createSearchHeader($(slicerContainer.node())), this.slicerBody = slicerContainer.append("div").classed(ChicletSlicer.Body["class"], !0).classed("slicerBody-horizontal", settings.general.orientation === Orientation.HORIZONTAL).classed("slicerBody-vertical", settings.general.orientation === Orientation.VERTICAL).style({
                            height: PixelConverter.toString(slicerBodyViewport.height),
                            width: "100%"
                        });
                        var rowEnter = function(rowSelection) {
                            var settings = _this.settings, listItemElement = rowSelection.append("li").classed(ChicletSlicer.ItemContainer["class"], !0).style({
                                "margin-left": PixelConverter.toString(settings.slicerItemContainer.marginLeft)
                            });
                            listItemElement.append("div").classed("slicer-img-wrapper", !0), listItemElement.append("div").classed("slicer-text-wrapper", !0).append("span").classed(ChicletSlicer.LabelText["class"], !0).style({
                                "font-size": PixelConverter.fromPoint(settings.slicerText.textSize)
                            });
                        }, rowUpdate = function(rowSelection) {
                            var settings = _this.settings, data = _this.slicerData;
                            if (data && settings) {
                                _this.slicerHeader.classed("hidden", !settings.header.show), _this.slicerHeader.select(ChicletSlicer.HeaderText.selector).text("" !== settings.header.title.trim() ? settings.header.title.trim() : _this.slicerData.categorySourceName).style({
                                    "border-style": _this.getBorderStyle(settings.header.outline),
                                    "border-color": settings.header.outlineColor,
                                    "border-width": _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                                    color: settings.header.fontColor,
                                    "background-color": settings.header.background,
                                    "font-size": PixelConverter.fromPoint(settings.header.textSize)
                                }), _this.slicerBody.classed("slicerBody-horizontal", settings.general.orientation === Orientation.HORIZONTAL).classed("slicerBody-vertical", settings.general.orientation === Orientation.VERTICAL);
                                var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector), textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize), formatString = data.formatString;
                                slicerText.text(function(d) {
                                    var text = visuals.valueFormatter.format(d.category, formatString);
                                    return textProperties.text = text, 0 === _this.settings.slicerText.width ? powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.currentViewport.width / _this.settings.general.columns - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight) : powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
                                });
                                var slicerImg = rowSelection.selectAll(".slicer-img-wrapper");
                                if (slicerImg.style("height", settings.images.imageSplit + "%").classed("hidden", function(d) {
                                    return d.imageURL ? settings.images.imageSplit < 10 ? !0 : void 0 : !0;
                                }).style("display", function(d) {
                                    return d.imageURL ? "flex" : "none";
                                }).classed("stretchImage", settings.images.stretchImage).classed("bottomImage", settings.images.bottomImage).style("background-image", function(d) {
                                    return d.imageURL ? "url(" + d.imageURL + ")" : "";
                                }), rowSelection.selectAll(".slicer-text-wrapper").style("height", function(d) {
                                    return d.imageURL ? 100 - settings.images.imageSplit + "%" : "100%";
                                }).classed("hidden", function(d) {
                                    return settings.images.imageSplit > 90 ? !0 : void 0;
                                }), rowSelection.selectAll(".slicerItemContainer").style({
                                    color: settings.slicerText.fontColor,
                                    "border-style": _this.getBorderStyle(settings.slicerText.outline),
                                    "border-color": settings.slicerText.outlineColor,
                                    "border-width": _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
                                    "font-size": PixelConverter.fromPoint(settings.slicerText.textSize),
                                    "border-radius": _this.getBorderRadius(settings.slicerText.borderStyle)
                                }), settings.slicerText.background ? _this.slicerBody.style("background-color", explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100)) : _this.slicerBody.style("background-color", null), 
                                _this.interactivityService && _this.slicerBody) {
                                    _this.interactivityService.applySelectionStateToData(data.slicerDataPoints);
                                    var slicerBody = _this.slicerBody.attr("width", _this.currentViewport.width), slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector), slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector), slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector), slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector), behaviorOptions = {
                                        dataPoints: data.slicerDataPoints,
                                        slicerItemContainers: slicerItemContainers,
                                        slicerItemLabels: slicerItemLabels,
                                        slicerItemInputs: slicerItemInputs,
                                        slicerClear: slicerClear,
                                        interactivityService: _this.interactivityService,
                                        slicerSettings: data.slicerSettings,
                                        isSelectionLoaded: _this.isSelectionLoaded
                                    };
                                    _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {
                                        overrideSelectionFromData: !0,
                                        hasSelectionOverride: data.hasSelectionOverride
                                    }), _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());
                                } else _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), !1);
                            }
                        }, rowExit = function(rowSelection) {
                            rowSelection.remove();
                        }, tableViewOptions = {
                            rowHeight: this.getRowHeight(),
                            columnWidth: this.settings.slicerText.width,
                            orientation: this.settings.general.orientation,
                            rows: this.settings.general.rows,
                            columns: this.settings.general.columns,
                            enter: rowEnter,
                            exit: rowExit,
                            update: rowUpdate,
                            loadMoreData: function() {
                                return _this.onLoadMoreData();
                            },
                            scrollEnabled: !0,
                            viewport: this.getSlicerBodyViewport(this.currentViewport),
                            baseContainer: this.slicerBody
                        };
                        this.tableView = TableViewFactory.createTableView(tableViewOptions);
                    }, ChicletSlicer.prototype.createSearchHeader = function(container) {
                        var _this = this;
                        this.searchHeader = $("<div>").appendTo(container).addClass("searchHeader").addClass("collapsed"), 
                        $("<div>").appendTo(this.searchHeader).attr("title", "Search").addClass("search");
                        var counter = 0;
                        this.searchInput = $("<input>").appendTo(this.searchHeader).attr("type", "text").attr("drag-resize-disabled", "true").addClass("searchInput").on("input", function() {
                            return _this.hostServices.persistProperties({
                                merge: [ {
                                    objectName: "general",
                                    selector: null,
                                    properties: {
                                        counter: counter++
                                    }
                                } ]
                            });
                        });
                    }, ChicletSlicer.prototype.updateSearchHeader = function() {
                        this.searchHeader.toggleClass("show", this.slicerData.slicerSettings.general.selfFilterEnabled), 
                        this.searchHeader.toggleClass("collapsed", !this.slicerData.slicerSettings.general.selfFilterEnabled);
                    }, ChicletSlicer.prototype.onLoadMoreData = function() {
                        !this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment && (this.hostServices.loadMoreData(), 
                        this.waitingForData = !0);
                    }, ChicletSlicer.prototype.getSlicerBodyViewport = function(currentViewport) {
                        var settings = this.settings, headerHeight = settings.header.show ? this.getHeaderHeight() : 0, slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                        return {
                            height: slicerBodyHeight,
                            width: currentViewport.width
                        };
                    }, ChicletSlicer.prototype.updateSlicerBodyDimensions = function() {
                        var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                        this.slicerBody.style({
                            height: PixelConverter.toString(slicerViewport.height),
                            width: "100%"
                        });
                    }, ChicletSlicer.getChicletTextProperties = function(textSize) {
                        return {
                            fontFamily: ChicletSlicer.DefaultFontFamily,
                            fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt)
                        };
                    }, ChicletSlicer.prototype.getHeaderHeight = function() {
                        return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
                    }, ChicletSlicer.prototype.getRowHeight = function() {
                        var textSettings = this.settings.slicerText;
                        return 0 !== textSettings.height ? textSettings.height : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
                    }, ChicletSlicer.prototype.getBorderStyle = function(outlineElement) {
                        return "0px" === outlineElement ? "none" : "solid";
                    }, ChicletSlicer.prototype.getBorderWidth = function(outlineElement, outlineWeight) {
                        switch (outlineElement) {
                          case "None":
                            return "0px";

                          case "BottomOnly":
                            return "0px 0px " + outlineWeight + "px 0px";

                          case "TopOnly":
                            return outlineWeight + "px 0px 0px 0px";

                          case "TopBottom":
                            return outlineWeight + "px 0px " + outlineWeight + "px 0px";

                          case "LeftRight":
                            return "0px " + outlineWeight + "px 0px " + outlineWeight + "px";

                          case "Frame":
                            return outlineWeight + "px";

                          default:
                            return outlineElement.replace("1", outlineWeight.toString());
                        }
                    }, ChicletSlicer.prototype.getBorderRadius = function(borderType) {
                        switch (borderType) {
                          case ChicletBorderStyle.ROUNDED:
                            return "10px";

                          case ChicletBorderStyle.SQUARE:
                            return "0px";

                          default:
                            return "5px";
                        }
                    }, ChicletSlicer.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        }, {
                            name: "Image",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Image"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    selection: {
                                        displayName: "Selection",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    orientation: {
                                        displayName: "Orientation",
                                        type: {
                                            enumeration: Orientation.type
                                        }
                                    },
                                    columns: {
                                        displayName: "Columns",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    rows: {
                                        displayName: "Rows",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showDisabled: {
                                        displayName: "Show Disabled",
                                        type: {
                                            enumeration: ChicletSlicerShowDisabled.type
                                        }
                                    },
                                    multiselect: {
                                        displayName: "Multiple selection",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    selected: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    filter: {
                                        type: {
                                            filter: {}
                                        }
                                    },
                                    selfFilter: {
                                        type: {
                                            filter: {
                                                selfFilter: !0
                                            }
                                        }
                                    },
                                    selfFilterEnabled: {
                                        type: {
                                            operations: {
                                                searchEnabled: !0
                                            }
                                        }
                                    },
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            header: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Header"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_FontColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    background: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outline: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                        type: {
                                            formatting: {
                                                outline: !0
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    outlineColor: {
                                        displayName: "Outline Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outlineWeight: {
                                        displayName: "Outline Weight",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            rows: {
                                displayName: "Chiclets",
                                properties: {
                                    fontColor: {
                                        displayName: "Text color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    height: {
                                        displayName: "Height",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    selectedColor: {
                                        displayName: "Selected Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    hoverColor: {
                                        displayName: "Hover Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    unselectedColor: {
                                        displayName: "Unselected Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    disabledColor: {
                                        displayName: "Disabled Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    background: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    transparency: {
                                        displayName: "Transparency",
                                        description: "Set transparency for background color",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    outline: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                        type: {
                                            formatting: {
                                                outline: !0
                                            }
                                        }
                                    },
                                    outlineColor: {
                                        displayName: "Outline Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outlineWeight: {
                                        displayName: "Outline Weight",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    borderStyle: {
                                        displayName: "Outline Style",
                                        type: {
                                            enumeration: ChicletBorderStyle.type
                                        }
                                    }
                                }
                            },
                            images: {
                                displayName: "Images",
                                properties: {
                                    imageSplit: {
                                        displayName: "Image Split",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    stretchImage: {
                                        displayName: "Stretch image",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    bottomImage: {
                                        displayName: "Bottom image",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Image: {
                                    min: 0,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 1e4
                                        }
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Image",
                                        select: [ {
                                            bind: {
                                                to: "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {
                                                count: 1e4
                                            }
                                        }
                                    }
                                },
                                includeEmptyGroups: !0
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            "default": {}
                        },
                        suppressDefaultTitle: !0
                    }, ChicletSlicer.DefaultFontFamily = "Segoe UI, Tahoma, Verdana, Geneva, sans-serif", 
                    ChicletSlicer.DefaultFontSizeInPt = 11, ChicletSlicer.cellTotalInnerPaddings = 8, 
                    ChicletSlicer.cellTotalInnerBorders = 2, ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14, 
                    ChicletSlicer.ItemContainer = createClassAndSelector("slicerItemContainer"), ChicletSlicer.HeaderText = createClassAndSelector("headerText"), 
                    ChicletSlicer.Container = createClassAndSelector("chicletSlicer"), ChicletSlicer.LabelText = createClassAndSelector("slicerText"), 
                    ChicletSlicer.Header = createClassAndSelector("slicerHeader"), ChicletSlicer.Input = createClassAndSelector("slicerCheckbox"), 
                    ChicletSlicer.Clear = createClassAndSelector("clear"), ChicletSlicer.Body = createClassAndSelector("slicerBody"), 
                    ChicletSlicer;
                }();
                samples.ChicletSlicer = ChicletSlicer;
                var ChicletSlicerChartConversion;
                !function(ChicletSlicerChartConversion) {
                    var ChicletSlicerConverter = function() {
                        function ChicletSlicerConverter(dataView, interactivityService) {
                            var dataViewCategorical = dataView.categorical;
                            this.dataViewCategorical = dataViewCategorical, this.dataViewMetadata = dataView.metadata, 
                            dataViewCategorical.categories && dataViewCategorical.categories.length > 0 && (this.category = dataViewCategorical.categories[0], 
                            this.categoryIdentities = this.category.identity, this.categoryValues = this.category.values, 
                            this.categoryColumnRef = this.category.identityFields, this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString)), 
                            this.dataPoints = [], this.interactivityService = interactivityService, this.hasSelectionOverride = !1;
                        }
                        return ChicletSlicerConverter.prototype.convert = function() {
                            if (this.dataPoints = [], this.numberOfCategoriesSelectedInData = 0, this.categoryValues) {
                                var numberOfScopeIds, objects = this.dataViewMetadata ? this.dataViewMetadata.objects : void 0, isInvertedSelectionMode = void 0;
                                if (objects && objects.general && objects.general.filter) {
                                    if (!this.categoryColumnRef) return;
                                    var filter = objects.general.filter, scopeIds = SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
                                    scopeIds ? (isInvertedSelectionMode = scopeIds.isNot, numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0) : isInvertedSelectionMode = !1;
                                }
                                this.interactivityService && (void 0 === isInvertedSelectionMode ? isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted() : this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode));
                                for (var hasSelection = void 0, idx = 0; idx < this.categoryValues.length; idx++) {
                                    var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
                                    if (null != selected) {
                                        hasSelection = selected;
                                        break;
                                    }
                                }
                                for (var dataViewCategorical = this.dataViewCategorical, formatStringProp = samples.chicletSlicerProps.formatString, value = -(1 / 0), imageURL = "", categoryIndex = 0, categoryCount = this.categoryValues.length; categoryCount > categoryIndex; categoryIndex++) {
                                    var categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex), selectable = !0;
                                    null != hasSelection && (isInvertedSelectionMode ? (null == this.category.objects && (categoryIsSelected = void 0), 
                                    null != categoryIsSelected ? categoryIsSelected = hasSelection : null == categoryIsSelected && (categoryIsSelected = !hasSelection)) : null == categoryIsSelected && (categoryIsSelected = !hasSelection)), 
                                    categoryIsSelected && this.numberOfCategoriesSelectedInData++;
                                    var categoryValue = this.categoryValues[categoryIndex], categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                                    if (this.dataViewCategorical.values) for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
                                        var seriesData = dataViewCategorical.values[seriesIndex];
                                        null != seriesData.values[categoryIndex] && (value = seriesData.values[categoryIndex], 
                                        seriesData.highlights && (selectable = !(null === seriesData.highlights[categoryIndex])), 
                                        seriesData.source.groupName && "" !== seriesData.source.groupName && (imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp), 
                                        /^(ftp|http|https):\/\/[^ "]+$/.test(imageURL) || (imageURL = void 0)));
                                    }
                                    var categorySelectionId = SelectionIdBuilder.builder().withCategory(this.category, categoryIndex).createSelectionId();
                                    this.dataPoints.push({
                                        identity: categorySelectionId,
                                        category: categoryLabel,
                                        imageURL: imageURL,
                                        value: value,
                                        selected: categoryIsSelected,
                                        selectable: selectable
                                    });
                                }
                                null != numberOfScopeIds && numberOfScopeIds > this.numberOfCategoriesSelectedInData && (this.hasSelectionOverride = !0);
                            }
                        }, ChicletSlicerConverter;
                    }();
                    ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
                }(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
                var ChicletSlicerTextMeasurementHelper;
                !function(ChicletSlicerTextMeasurementHelper) {
                    function estimateSvgTextBaselineDelta(textProperties) {
                        var rect = estimateSvgTextRect(textProperties);
                        return rect.y + rect.height;
                    }
                    function ensureDOM() {
                        spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                            height: "0px",
                            width: "0px",
                            position: "absolute"
                        }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                    }
                    function measureSvgTextRect(textProperties) {
                        return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                            visibility: "hidden",
                            "font-family": textProperties.fontFamily,
                            "font-size": textProperties.fontSize,
                            "font-weight": textProperties.fontWeight,
                            "font-style": textProperties.fontStyle,
                            "white-space": textProperties.whiteSpace || "nowrap"
                        }), svgTextElement.node().getBBox();
                    }
                    function estimateSvgTextRect(textProperties) {
                        var estimatedTextProperties = {
                            fontFamily: textProperties.fontFamily,
                            fontSize: textProperties.fontSize,
                            text: "M"
                        }, rect = measureSvgTextRect(estimatedTextProperties);
                        return rect;
                    }
                    var spanElement, svgTextElement, canvasCtx;
                    ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                }(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
                var ChicletSlicerWebBehavior = function() {
                    function ChicletSlicerWebBehavior() {}
                    return ChicletSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var _this = this, slicers = this.slicers = options.slicerItemContainers;
                        this.slicerItemLabels = options.slicerItemLabels, this.slicerItemInputs = options.slicerItemInputs;
                        var slicerClear = options.slicerClear;
                        this.dataPoints = options.dataPoints, this.interactivityService = options.interactivityService, 
                        this.slicerSettings = options.slicerSettings, this.options = options, this.options.isSelectionLoaded || this.loadSelection(selectionHandler), 
                        slicers.on("mouseover", function(d) {
                            d.selectable && (d.mouseOver = !0, d.mouseOut = !1, _this.renderMouseover());
                        }), slicers.on("mouseout", function(d) {
                            d.selectable && (d.mouseOver = !1, d.mouseOut = !0, _this.renderMouseover());
                        }), slicers.on("click", function(d, index) {
                            if (d.selectable) {
                                var settings = _this.slicerSettings;
                                if (d3.event.preventDefault(), d3.event.altKey && settings.general.multiselect) {
                                    var selectedIndexes = jQuery.map(_this.dataPoints, function(d, index) {
                                        return d.selected ? index : void 0;
                                    }), selIndex = selectedIndexes.length > 0 ? selectedIndexes[selectedIndexes.length - 1] : 0;
                                    if (selIndex > index) {
                                        var temp = index;
                                        index = selIndex, selIndex = temp;
                                    }
                                    selectionHandler.handleClearSelection();
                                    for (var i = selIndex; index >= i; i++) selectionHandler.handleSelection(_this.dataPoints[i], !0);
                                } else d3.event.ctrlKey && settings.general.multiselect ? selectionHandler.handleSelection(d, !0) : selectionHandler.handleSelection(d, !1);
                                _this.saveSelection(selectionHandler);
                            }
                        }), slicerClear.on("click", function(d) {
                            selectionHandler.handleClearSelection(), _this.saveSelection(selectionHandler);
                        });
                    }, ChicletSlicerWebBehavior.prototype.loadSelection = function(selectionHandler) {
                        selectionHandler.handleClearSelection();
                        var savedSelectionIds = this.slicerSettings.general.getSavedSelection();
                        if (savedSelectionIds.length) {
                            var selectedDataPoints = this.dataPoints.filter(function(d) {
                                return savedSelectionIds.some(function(x) {
                                    return d.identity.getKey() === x;
                                });
                            });
                            selectedDataPoints.forEach(function(x) {
                                return selectionHandler.handleSelection(x, !0);
                            }), selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);
                        }
                    }, ChicletSlicerWebBehavior.getFilterFromSelectors = function(selectionHandler, isSelectionModeInverted) {
                        var selectors = [], selectedIds = selectionHandler.selectedIds;
                        selectedIds.length > 0 && (selectors = _.chain(selectedIds).filter(function(value) {
                            return value.hasIdentity();
                        }).map(function(value) {
                            return value.getSelector();
                        }).value());
                        var filter = powerbi.data.Selector.filterFromSelector(selectors, isSelectionModeInverted);
                        return filter;
                    }, ChicletSlicerWebBehavior.prototype.saveSelection = function(selectionHandler) {
                        var filter = ChicletSlicerWebBehavior.getFilterFromSelectors(selectionHandler, this.interactivityService.isSelectionModeInverted()), selectionIdKeys = selectionHandler.selectedIds.map(function(x) {
                            return x.getKey();
                        });
                        this.slicerSettings.general.setSavedSelection(filter, selectionIdKeys);
                    }, ChicletSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                        hasSelection || this.interactivityService.isSelectionModeInverted() ? this.styleSlicerInputs(this.slicers, hasSelection) : this.slicers.style("background", this.slicerSettings.slicerText.unselectedColor);
                    }, ChicletSlicerWebBehavior.prototype.renderMouseover = function() {
                        var _this = this;
                        this.slicerItemLabels.style({
                            color: function(d) {
                                return d.mouseOver ? _this.slicerSettings.slicerText.hoverColor : d.mouseOut ? d.selected ? _this.slicerSettings.slicerText.fontColor : _this.slicerSettings.slicerText.fontColor : void 0;
                            }
                        });
                    }, ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function(slicers, hasSelection) {
                        var settings = this.slicerSettings, selectedItems = [];
                        slicers.each(function(d) {
                            d.selectable && d.selected && selectedItems.push(d), d3.select(this).style({
                                background: d.selectable ? d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor : settings.slicerText.disabledColor
                            }), d3.select(this).classed("slicerItem-disabled", !d.selectable);
                        });
                    }, ChicletSlicerWebBehavior;
                }();
                samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
                var explore;
                !function(explore) {
                    var util;
                    !function(util) {
                        function hexToRGBString(hex, transparency) {
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex), rgb = result ? {
                                r: parseInt(result[1], 16),
                                g: parseInt(result[2], 16),
                                b: parseInt(result[3], 16)
                            } : null;
                            return null === rgb ? "" : transparency || 0 === transparency ? "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")" : "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        }
                        util.hexToRGBString = hexToRGBString;
                    }(util = explore.util || (explore.util = {}));
                }(explore || (explore = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.margin = this.defaultMargin);
                        },
                        set: function(value) {
                            this.marginValue = VisualLayout.restrictToMinMax(value), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            this.viewportValue = VisualLayout.restrictToMinMax(value, this.minViewport), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue;
                        },
                        set: function(value) {
                            this.minViewportValue = value;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        var result = $.extend({}, value);
                        return _.keys(value).forEach(function(x) {
                            return result[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), result;
                    }, VisualLayout;
                }(), ChordChartHelpers = function() {
                    function ChordChartHelpers() {}
                    return ChordChartHelpers.interpolateArc = function(arc) {
                        return function(data) {
                            if (!this.oldData) return this.oldData = data, function() {
                                return arc(data);
                            };
                            var interpolation = d3.interpolate(this.oldData, data);
                            return this.oldData = interpolation(0), function(x) {
                                return arc(interpolation(x));
                            };
                        };
                    }, ChordChartHelpers.addContext = function(context, fn) {
                        return function() {
                            return fn.apply(context, [ this ].concat(_.toArray(arguments)));
                        };
                    }, ChordChartHelpers;
                }(), ChordChartSettings = function() {
                    function ChordChartSettings() {
                        this.dataPoint = {
                            defaultColor: null,
                            showAllDataPoints: !1
                        }, this.axis = {
                            show: !0
                        }, this.labels = {
                            show: !0,
                            color: visuals.dataLabelUtils.defaultLabelColor,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt
                        };
                    }
                    return Object.defineProperty(ChordChartSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ChordChartSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, ChordChartSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, ChordChartSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, ChordChartSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return powerbi.DataViewObjects.getFillColor;

                          default:
                            return powerbi.DataViewObjects.getValue;
                        }
                    }, ChordChartSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        var enumeration = new visuals.ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, ChordChartSettings;
                }();
                samples.ChordChartSettings = ChordChartSettings;
                var ChordChartColumns = function() {
                    function ChordChartColumns() {
                        this.Category = null, this.Series = null, this.Y = null;
                    }
                    return ChordChartColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, ChordChartColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, ChordChartColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, ChordChartColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, ChordChartColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return visuals.converterHelper.getSeriesName(x.source);
                        });
                    }, ChordChartColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, ChordChartColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, ChordChartColumns.Roles = Object.freeze(_.mapValues(new ChordChartColumns(), function(x, i) {
                        return i;
                    })), ChordChartColumns;
                }();
                samples.ChordChartColumns = ChordChartColumns;
                var ChordChart = function() {
                    function ChordChart() {}
                    return Object.defineProperty(ChordChart.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ChordChart.prototype, "innerRadius", {
                        get: function() {
                            return this.radius * ChordChart.InnerArcRadiusRatio;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ChordChart.prototype, "outerRadius", {
                        get: function() {
                            return this.radius * ChordChart.OuterArcRadiusRatio;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ChordChart.converter = function(dataView, colors, prevAxisVisible) {
                        var properties = ChordChartSettings.getProperties(ChordChart.capabilities), settings = ChordChart.parseSettings(dataView), columns = ChordChartColumns.getCategoricalColumns(dataView), sources = ChordChartColumns.getColumnSources(dataView), catValues = ChordChartColumns.getCategoricalValues(dataView);
                        if (!catValues || _.isEmpty(catValues.Category) || _.isEmpty(catValues.Y)) return null;
                        catValues.Series = catValues.Series || ChordChartColumns.getSeriesValues(dataView);
                        var dataMatrix = [], legendData = {
                            dataPoints: [],
                            title: sources.Y.displayName || ""
                        }, toolTipData = [], sliceTooltipData = [], max = 1e3, seriesIndex = _.mapValues(_.invert(catValues.Series), parseFloat), catIndex = _.mapValues(_.invert(catValues.Category), parseFloat), isDiffFromTo = !1, labelData = [], colorHelper = new visuals.ColorHelper(colors, properties.dataPoint.fill, settings.dataPoint.defaultColor), totalFields = this.union_arrays(catValues.Category, catValues.Series).reverse();
                        ChordChart.getValidArrayLength(totalFields) === ChordChart.getValidArrayLength(catValues.Category) + ChordChart.getValidArrayLength(catValues.Series) && (isDiffFromTo = !0);
                        for (var categoryColumnFormatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(sources.Category, properties.general.formatString, !0) || sources.Category.format
                        }), valueColumnFormatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(sources.Y, properties.general.formatString, !0) || sources.Y.format
                        }), i = 0, iLen = totalFields.length; iLen > i; i++) {
                            var id = null, color = "", isCategory = !1;
                            if (void 0 !== catIndex[totalFields[i]]) {
                                var index = catIndex[totalFields[i]];
                                id = visuals.SelectionIdBuilder.builder().withCategory(columns.Category, catIndex[totalFields[i]]).createSelectionId(), 
                                isCategory = !0;
                                var thisCategoryObjects = columns.Category.objects ? columns.Category.objects[index] : void 0;
                                color = colorHelper.getColorForSeriesValue(thisCategoryObjects, void 0, catValues.Category[index]);
                            } else if (void 0 !== seriesIndex[totalFields[i]]) {
                                var index = seriesIndex[totalFields[i]], seriesData = columns.Y[index], seriesObjects = seriesData && seriesData.objects && seriesData.objects[0], seriesNameStr = visuals.converterHelper.getSeriesName(seriesData.source);
                                id = visuals.SelectionId.createWithId(seriesData.identity), isCategory = !1, color = colorHelper.getColorForSeriesValue(seriesObjects, void 0, seriesNameStr);
                            }
                            labelData.push({
                                label: totalFields[i],
                                labelColor: settings.labels.color,
                                barColor: color,
                                isCategory: isCategory,
                                identity: id,
                                selected: !1,
                                labelFontSize: PixelConverter.fromPointToPixel(settings.labels.fontSize)
                            }), dataMatrix.push([]), toolTipData.push([]);
                            for (var j = 0, jLen = totalFields.length; jLen > j; j++) {
                                var elementValue = 0, tooltipInfo = [];
                                if (void 0 !== catIndex[totalFields[i]] && void 0 !== seriesIndex[totalFields[j]]) {
                                    var row = catIndex[totalFields[i]], col = seriesIndex[totalFields[j]];
                                    null !== columns.Y[col].values[row] && (elementValue = columns.Y[col].values[row], 
                                    elementValue > max && (max = elementValue), tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, categoryColumnFormatter.format(catValues.Category[i]), valueColumnFormatter.format(elementValue), null, null, col, row));
                                } else if (isDiffFromTo && void 0 !== catIndex[totalFields[j]] && void 0 !== seriesIndex[totalFields[i]]) {
                                    var row = catIndex[totalFields[j]], col = seriesIndex[totalFields[i]];
                                    null !== columns.Y[col].values[row] && (elementValue = columns.Y[col].values[row]);
                                }
                                dataMatrix[i].push(elementValue || 0), toolTipData[i].push({
                                    tooltipInfo: tooltipInfo
                                });
                            }
                            var totalSum = d3.sum(dataMatrix[i]);
                            sliceTooltipData.push({
                                tooltipInfo: [ {
                                    displayName: totalFields[i],
                                    value: valueColumnFormatter.format(totalSum)
                                } ]
                            });
                        }
                        var chordLayout = d3.layout.chord().padding(.1).matrix(dataMatrix), unitLength = Math.round(max / 5).toString().length - 1;
                        return {
                            dataMatrix: dataMatrix,
                            dataView: dataView,
                            settings: settings,
                            labelDataPoints: ChordChart.getChordArcDescriptors(chordLayout.groups(), labelData),
                            legendData: legendData,
                            tooltipData: toolTipData,
                            sliceTooltipData: sliceTooltipData,
                            tickUnit: Math.pow(10, unitLength),
                            differentFromTo: isDiffFromTo,
                            prevAxisVisible: void 0 === prevAxisVisible ? settings.axis.show : prevAxisVisible
                        };
                    }, ChordChart.parseSettings = function(dataView) {
                        return ChordChartSettings.parse(dataView, ChordChart.capabilities);
                    }, ChordChart.getValidArrayLength = function(array) {
                        for (var len = 0, i = 0, iLen = array.length; iLen > i; i++) void 0 !== array[i] && len++;
                        return len;
                    }, ChordChart.getChordArcDescriptors = function(groups, datum) {
                        var labelDataPoints = groups;
                        return labelDataPoints.forEach(function(x, i) {
                            return x.data = datum[i];
                        }), labelDataPoints;
                    }, ChordChart.prototype.init = function(options) {
                        var element = this.element = options.element;
                        this.selectionManager = new visuals.utility.SelectionManager({
                            hostServices: options.host
                        }), this.layout = new VisualLayout(options.viewport, ChordChart.DefaultMargin), 
                        this.layout.minViewport = {
                            width: 150,
                            height: 150
                        }, this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(ChordChart.VisualClassName, !0), 
                        this.mainGraphicsContext = this.svg.append("g"), this.mainGraphicsContext.append("g").classed("chords", !0), 
                        this.slices = this.mainGraphicsContext.append("g").classed("slices", !0), this.mainGraphicsContext.append("g").classed("ticks", !0), 
                        this.labels = this.mainGraphicsContext.append("g").classed(ChordChart.labelGraphicsContextClass["class"], !0), 
                        this.lines = this.mainGraphicsContext.append("g").classed(ChordChart.linesGraphicsContextClass["class"], !0), 
                        this.colors = options.style.colorPalette.dataColors;
                    }, ChordChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            if (this.layout.viewport = options.viewport, this.duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration, 
                            this.data = ChordChart.converter(options.dataViews[0], this.colors, this.settings && this.settings.axis.show), 
                            !this.data) return void this.clear();
                            this.layout.resetMargin(), this.layout.margin.top = this.layout.margin.bottom = PixelConverter.fromPointToPixel(this.settings.labels.fontSize) / 2, 
                            this.render();
                        }
                    }, ChordChart.prototype.enumerateObjectInstances = function(options) {
                        var instances = ChordChartSettings.enumerateObjectInstances(this.settings, options, ChordChart.capabilities);
                        if (this.settings && "dataPoint" === options.objectName && !_.isEmpty(this.data.labelDataPoints) && this.settings.dataPoint.showAllDataPoints) for (var i = 0, length = this.data.labelDataPoints.length; length > i; i++) {
                            var labelDataPoint = this.data.labelDataPoints[i].data;
                            if (labelDataPoint.isCategory) {
                                var colorInstance = {
                                    objectName: "dataPoint",
                                    displayName: labelDataPoint.label,
                                    selector: visuals.ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: labelDataPoint.barColor
                                            }
                                        }
                                    }
                                };
                                instances.pushInstance(colorInstance);
                            }
                        }
                        return instances.complete();
                    }, ChordChart.prototype.calculateRadius = function() {
                        if (this.settings.labels.show) {
                            var hw = this.layout.viewportIn.height / this.layout.viewportIn.width, denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                            return Math.min(this.layout.viewportIn.height, this.layout.viewportIn.width) / denom;
                        }
                        return Math.min(this.layout.viewportIn.height, this.layout.viewportIn.width) / 2;
                    }, ChordChart.prototype.drawCategoryLabels = function() {
                        var arc = d3.svg.arc().innerRadius(0).outerRadius(this.innerRadius), outerArc = d3.svg.arc().innerRadius(this.outerRadius).outerRadius(this.outerRadius);
                        if (this.settings.labels.show) {
                            var labelLayout = this.getChordChartLabelLayout(outerArc), filteredData = this.getDataLabelManager().hideCollidedLabels(this.layout.viewportIn, this.data.labelDataPoints, labelLayout, !0);
                            this.renderLabels(filteredData, labelLayout, !0), this.renderLines(filteredData, arc, outerArc);
                        } else visuals.dataLabelUtils.cleanDataLabels(this.labels), visuals.dataLabelUtils.cleanDataLabels(this.lines, !0);
                    }, ChordChart.prototype.getDataLabelManager = function() {
                        function hasCollisions(arrangeGrid, info, position, size) {
                            if (arrangeGrid.hasConflict(position)) return !0;
                            var intersection = {
                                left: 0,
                                top: position.height / 2,
                                width: size.width,
                                height: size.height
                            };
                            return intersection = visuals.shapes.Rect.inflate(intersection, {
                                left: powerbi.DataLabelManager.InflateAmount,
                                top: 0,
                                right: powerbi.DataLabelManager.InflateAmount,
                                bottom: 0
                            }), intersection = visuals.shapes.Rect.intersect(intersection, position), visuals.shapes.Rect.isEmpty(intersection) ? !0 : powerbi.Double.lessWithPrecision(intersection.height, position.height / 2);
                        }
                        var dataLabelManager = new powerbi.DataLabelManager();
                        return dataLabelManager.hasCollisions = hasCollisions.bind(dataLabelManager), dataLabelManager;
                    }, ChordChart.prototype.render = function() {
                        var _this = this;
                        this.chordLayout = d3.layout.chord().padding(.1).matrix(this.data.dataMatrix), this.radius = this.calculateRadius();
                        var arc = d3.svg.arc().innerRadius(this.radius).outerRadius(this.innerRadius);
                        this.svg.attr({
                            width: this.layout.viewport.width,
                            height: this.layout.viewport.height
                        }), this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(this.layout.viewport.width / 2, this.layout.viewport.height / 2));
                        var sliceShapes = this.slices.selectAll("path" + ChordChart.sliceClass.selector).data(this.getChordTicksArcDescriptors());
                        sliceShapes.enter().insert("path").classed(ChordChart.sliceClass["class"], !0), 
                        sliceShapes.style("fill", function(d, i) {
                            return _this.data.labelDataPoints[i].data.barColor;
                        }).style("stroke", function(d, i) {
                            return _this.data.labelDataPoints[i].data.barColor;
                        }).on("click", ChordChartHelpers.addContext(this, function(context, d, i) {
                            _this.selectionManager.select(_this.data.labelDataPoints[i].data.identity).then(function(ids) {
                                ids.length > 0 ? (_this.mainGraphicsContext.selectAll(".chords path.chord").style("opacity", 1), 
                                _this.slices.selectAll("path.slice").style("opacity", .3), _this.mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                    return d.source.index !== i && d.target.index !== i;
                                }).style("opacity", .3), d3.select(context).style("opacity", 1)) : (sliceShapes.style("opacity", 1), 
                                _this.mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                    return d.source.index !== i && d.target.index !== i;
                                }).style("opacity", 1));
                            }), d3.event.stopPropagation();
                        })).transition().duration(this.duration).attrTween("d", ChordChartHelpers.interpolateArc(arc)), 
                        sliceShapes.exit().remove(), visuals.TooltipManager.addTooltip(sliceShapes, function(tooltipEvent) {
                            return _this.data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
                        });
                        var chordShapes = this.svg.select(".chords").selectAll("path" + ChordChart.chordClass.selector).data(this.chordLayout.chords);
                        chordShapes.enter().insert("path").classed(ChordChart.chordClass["class"], !0), 
                        chordShapes.style("fill", function(d, i) {
                            return _this.data.labelDataPoints[d.target.index].data.barColor;
                        }).style("opacity", 1).transition().duration(this.duration).attr("d", d3.svg.chord().radius(this.radius)), 
                        chordShapes.exit().remove(), this.svg.on("click", function() {
                            return _this.selectionManager.clear().then(function() {
                                sliceShapes.style("opacity", 1), chordShapes.style("opacity", 1);
                            });
                        }), this.drawTicks(), this.drawCategoryLabels(), visuals.TooltipManager.addTooltip(chordShapes, function(tooltipEvent) {
                            var tooltipInfo = [];
                            return _this.data.differentFromTo ? tooltipInfo = _this.data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].tooltipInfo : (tooltipInfo.push({
                                displayName: _this.data.labelDataPoints[tooltipEvent.data.source.index].data.label + "->" + _this.data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
                                value: _this.data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
                            }), tooltipInfo.push({
                                displayName: _this.data.labelDataPoints[tooltipEvent.data.target.index].data.label + "->" + _this.data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
                                value: _this.data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
                            })), tooltipInfo;
                        });
                    }, ChordChart.prototype.clear = function() {
                        this.mainGraphicsContext.selectAll(ChordChart.sliceClass.selector).remove(), this.mainGraphicsContext.selectAll(ChordChart.sliceTicksClass.selector).remove(), 
                        this.mainGraphicsContext.selectAll(ChordChart.chordClass.selector).remove(), this.mainGraphicsContext.selectAll(ChordChart.labelsClass.selector).remove(), 
                        this.mainGraphicsContext.selectAll(ChordChart.lineClass.selector).remove();
                    }, ChordChart.prototype.clearTicks = function() {
                        var empty = [], tickLines = this.mainGraphicsContext.selectAll(ChordChart.tickLineClass.selector).data(empty);
                        tickLines.exit().remove();
                        var tickTexts = this.mainGraphicsContext.selectAll(ChordChart.tickTextClass.selector).data(empty);
                        tickTexts.exit().remove(), this.mainGraphicsContext.selectAll(ChordChart.tickPairClass.selector).remove(), 
                        this.mainGraphicsContext.selectAll(ChordChart.sliceTicksClass.selector).remove();
                    }, ChordChart.prototype.getChordTicksArcDescriptors = function() {
                        var groups = this.chordLayout.groups(), maxValue = !_.isEmpty(groups) && _.max(groups, function(x) {
                            return x.value;
                        }).value || 0, minValue = !_.isEmpty(groups) && _.min(groups, function(x) {
                            return x.value;
                        }).value || 0, radiusCoeff = this.radius / Math.abs(maxValue - minValue) * 1.25, formatter = visuals.valueFormatter.create({
                            format: "0.##",
                            value: maxValue
                        });
                        return groups.forEach(function(x) {
                            var k = (x.endAngle - x.startAngle) / x.value, absValue = Math.abs(x.value), range = d3.range(0, absValue, .15 > absValue - 1 ? .15 : absValue - 1);
                            x.value < 0 && (range = range.map(function(x) {
                                return -1 * x;
                            }).reverse());
                            for (var i = 1; i < range.length; i++) {
                                var gapSize = Math.abs(range[i] - range[i - 1]) * radiusCoeff;
                                gapSize < ChordChart.TicksFontSize && (range.length > 2 && i === range.length - 1 ? range.splice(--i, 1) : range.splice(i--, 1));
                            }
                            x.angleLabels = range.map(function(v, i) {
                                return {
                                    angle: v * k + x.startAngle,
                                    label: formatter.format(v)
                                };
                            });
                        }), groups;
                    }, ChordChart.prototype.drawTicks = function() {
                        var _this = this;
                        if (this.settings.axis.show) {
                            var tickShapes = this.mainGraphicsContext.select(".ticks").selectAll("g" + ChordChart.sliceTicksClass.selector).data(this.chordLayout.groups), animDuration = this.data.prevAxisVisible === this.settings.axis.show ? this.duration : 0;
                            tickShapes.enter().insert("g").classed(ChordChart.sliceTicksClass["class"], !0);
                            var tickPairs = tickShapes.selectAll("g" + ChordChart.tickPairClass.selector).data(function(d) {
                                return d.angleLabels;
                            });
                            tickPairs.enter().insert("g").classed(ChordChart.tickPairClass["class"], !0), tickPairs.transition().duration(animDuration).attr("transform", function(d) {
                                return "rotate(" + (180 * d.angle / Math.PI - 90) + ")translate(" + _this.innerRadius + ",0)";
                            }), tickPairs.selectAll("line" + ChordChart.tickLineClass.selector).data(function(d) {
                                return [ d ];
                            }).enter().insert("line").classed(ChordChart.tickLineClass["class"], !0).style("stroke", "#000").attr("x1", 1).attr("y1", 0).attr("x2", 5).attr("y2", 0), 
                            tickPairs.selectAll("text" + ChordChart.tickTextClass.selector).data(function(d) {
                                return [ d ];
                            }).enter().insert("text").classed(ChordChart.tickTextClass["class"], !0).style("pointer-events", "none").attr("x", 8).attr("dy", ".35em"), 
                            tickPairs.selectAll("text" + ChordChart.tickTextClass.selector).text(function(d) {
                                return d.label;
                            }).style("text-anchor", function(d) {
                                return d.angle > Math.PI ? "end" : null;
                            }).attr("transform", function(d) {
                                return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
                            }), tickPairs.exit().remove(), tickShapes.exit().remove();
                        } else this.clearTicks();
                    }, ChordChart.prototype.renderLabels = function(filteredData, layout, isDonut, forAnimation) {
                        if (void 0 === isDonut && (isDonut = !1), void 0 === forAnimation && (forAnimation = !1), 
                        0 === filteredData.length) return visuals.dataLabelUtils.cleanDataLabels(this.labels, !0), 
                        null;
                        var hasKey = null !== filteredData[0].key, hasDataPointIdentity = null !== filteredData[0].identity, getIdentifier = hasKey ? function(d) {
                            return d.key;
                        } : hasDataPointIdentity ? function(d) {
                            return d.identity.getKey();
                        } : void 0, dataLabels = isDonut ? this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }) : null !== getIdentifier ? this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier) : this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData), newLabels = dataLabels.enter().append("text").classed(ChordChart.labelsClass["class"], !0);
                        forAnimation && newLabels.style("opacity", 0), dataLabels.attr({
                            x: function(d) {
                                return d.labelX;
                            },
                            y: function(d) {
                                return d.labelY;
                            },
                            dy: ".35em"
                        }).text(function(d) {
                            return d.labeltext;
                        }).style(layout.style), dataLabels.exit().remove();
                    }, ChordChart.prototype.renderLines = function(filteredData, arc, outerArc) {
                        var _this = this, lines = this.lines.selectAll("polyline").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }), innerLinePointMultiplier = 2.05, midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        };
                        lines.enter().append("polyline").classed(ChordChart.lineClass["class"], !0), lines.attr("points", function(d) {
                            var textPoint = outerArc.centroid(d);
                            textPoint[0] = (_this.radius + ChordChart.LabelMargin / 2) * (midAngle(d) < Math.PI ? 1 : -1);
                            var midPoint = outerArc.centroid(d), chartPoint = arc.centroid(d);
                            return chartPoint[0] *= innerLinePointMultiplier, chartPoint[1] *= innerLinePointMultiplier, 
                            [ chartPoint, midPoint, textPoint ];
                        }).style({
                            opacity: function(d) {
                                return ChordChart.PolylineOpacity;
                            },
                            stroke: function(d) {
                                return d.data.labelColor;
                            },
                            "pointer-events": "none"
                        }), lines.exit().remove();
                    }, ChordChart.prototype.getChordChartLabelLayout = function(outerArc) {
                        var _this = this, midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        }, maxLabelWidth = (this.layout.viewportIn.width - 2 * this.radius - 2 * ChordChart.LabelMargin) / 1.6;
                        return {
                            labelText: function(d) {
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: d.data.label,
                                    maxWidth: maxLabelWidth,
                                    fontSize: PixelConverter.fromPointToPixel(_this.settings.labels.fontSize)
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return (_this.radius + ChordChart.LabelMargin) * (midAngle(d) < Math.PI ? 1 : -1);
                                },
                                y: function(d) {
                                    var pos = outerArc.centroid(d);
                                    return pos[1];
                                }
                            },
                            filter: function(d) {
                                return null !== d && null !== d.data && null !== d.data.label;
                            },
                            style: {
                                fill: function(d) {
                                    return d.data.labelColor;
                                },
                                "text-anchor": function(d) {
                                    return midAngle(d) < Math.PI ? "start" : "end";
                                },
                                "font-size": function(d) {
                                    return PixelConverter.fromPoint(_this.settings.labels.fontSize);
                                }
                            }
                        };
                    }, ChordChart.union_arrays = function(x, y) {
                        for (var obj = {}, i = 0; i < x.length; i++) obj[x[i]] = x[i];
                        for (var i = 0; i < y.length; i++) obj[y[i]] = y[i];
                        var res = [];
                        for (var k in obj) obj.hasOwnProperty(k) && res.push(obj[k]);
                        return res;
                    }, ChordChart.capabilities = {
                        dataRoles: [ {
                            name: ChordChartColumns.Roles.Category,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "From"
                        }, {
                            name: ChordChartColumns.Roles.Series,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "To"
                        }, {
                            name: ChordChartColumns.Roles.Y,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    min: 1,
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                Y: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    },
                                    supported: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        objects: {
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            axis: {
                                displayName: "Axis",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Labels",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, ChordChart.PolylineOpacity = .5, ChordChart.OuterArcRadiusRatio = .9, ChordChart.InnerArcRadiusRatio = .8, 
                    ChordChart.LabelMargin = 10, ChordChart.DefaultMargin = {
                        left: 10,
                        right: 10,
                        top: 10,
                        bottom: 10
                    }, ChordChart.VisualClassName = "chordChart", ChordChart.TicksFontSize = 12, ChordChart.sliceClass = {
                        "class": "slice",
                        selector: ".slice"
                    }, ChordChart.chordClass = {
                        "class": "chord",
                        selector: ".chord"
                    }, ChordChart.sliceTicksClass = {
                        "class": "slice-ticks",
                        selector: ".slice-ticks"
                    }, ChordChart.tickPairClass = {
                        "class": "tick-pair",
                        selector: ".tick-pair"
                    }, ChordChart.tickLineClass = {
                        "class": "tick-line",
                        selector: ".tick-line"
                    }, ChordChart.tickTextClass = {
                        "class": "tick-text",
                        selector: ".tick-text"
                    }, ChordChart.labelGraphicsContextClass = {
                        "class": "labels",
                        selector: ".labels"
                    }, ChordChart.labelsClass = {
                        "class": "data-labels",
                        selector: ".data-labels"
                    }, ChordChart.linesGraphicsContextClass = {
                        "class": "lines",
                        selector: ".lines"
                    }, ChordChart.lineClass = {
                        "class": "line-label",
                        selector: ".line-label"
                    }, ChordChart;
                }();
                samples.ChordChart = ChordChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, Lazy = jsCommon.Lazy, getCategoryIndexOfRole = powerbi.data.DataRoleHelper.getCategoryIndexOfRole, getMeasureIndexOfRole = powerbi.data.DataRoleHelper.getMeasureIndexOfRole, EnhancedScatterChart = function() {
                    function EnhancedScatterChart() {
                        this.ScrollBarWidth = 10, this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: PixelConverter.toString(EnhancedScatterChart.AxisFontSize)
                        };
                    }
                    return Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
                        get: function() {
                            return this._margin || {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                        },
                        set: function(value) {
                            this._margin = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
                        get: function() {
                            return this._viewport || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            this._viewport = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
                        get: function() {
                            return this._viewportIn || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
                        get: function() {
                            return this.legend.getMargins();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), EnhancedScatterChart.substractMargin = function(viewport, margin) {
                        return {
                            width: Math.max(viewport.width - (margin.left + margin.right), 0),
                            height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                        };
                    }, EnhancedScatterChart.getCustomSymbolType = function(shape) {
                        var customSymbolTypes = d3.map({
                            circle: function(size) {
                                var r = Math.sqrt(size / Math.PI);
                                return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
                            },
                            cross: function(size) {
                                var r = Math.sqrt(size / 5) / 2;
                                return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                            },
                            diamond: function(size) {
                                var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
                                return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
                            },
                            square: function(size) {
                                var r = Math.sqrt(size) / 2;
                                return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
                            },
                            "triangle-up": function(size) {
                                var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                                return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                            },
                            "triangle-down": function(size) {
                                var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                                return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                            },
                            star: function(size) {
                                for (var outerRadius = Math.sqrt(size / 2), innerRadius = Math.sqrt(size / 10), results = "", angle = Math.PI / 5, i = 0; 10 > i; i++) {
                                    var r = 0 === (1 & i) ? outerRadius : innerRadius, currX = Math.cos(i * angle) * r, currY = Math.sin(i * angle) * r;
                                    0 === i ? results = "M" + currX + "," + currY + "L" : results += " " + currX + "," + currY;
                                }
                                return results + "Z";
                            },
                            hexagon: function(size) {
                                var r = Math.sqrt(size / (6 * Math.sqrt(3))), r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
                                return "M0," + 2 * r + "L" + -r2 + "," + r + " " + -r2 + "," + -r + " 0," + -2 * r + " " + r2 + "," + -r + " " + r2 + "," + r + "Z";
                            },
                            x: function(size) {
                                var r = Math.sqrt(size / 10);
                                return "M0," + r + "L" + -r + "," + 2 * r + " " + -2 * r + "," + r + " " + -r + ",0 " + -2 * r + "," + -r + " " + -r + "," + -2 * r + " 0," + -r + " " + r + "," + -2 * r + " " + 2 * r + "," + -r + " " + r + ",0 " + 2 * r + "," + r + " " + r + "," + 2 * r + "Z";
                            },
                            uparrow: function(size) {
                                var r = Math.sqrt(size / 12);
                                return "M" + r + "," + 3 * r + "L" + -r + "," + 3 * r + " " + -r + "," + -r + " " + -2 * r + "," + -r + " 0," + -3 * r + " " + 2 * r + "," + -r + " " + r + "," + -r + "Z";
                            },
                            downarrow: function(size) {
                                var r = Math.sqrt(size / 12);
                                return "M0," + 3 * r + "L" + -2 * r + "," + r + " " + -r + "," + r + " " + -r + "," + -3 * r + " " + r + "," + -3 * r + " " + r + "," + r + " " + 2 * r + "," + r + "Z";
                            }
                        }), defaultValue = customSymbolTypes.entries()[0].value;
                        if (shape) {
                            if (isNaN(shape)) return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
                            var result = customSymbolTypes.entries()[Math.floor(shape)];
                            return result ? result.value : defaultValue;
                        }
                        return defaultValue;
                    }, EnhancedScatterChart.prototype.init = function(options) {
                        this.options = options, this.animator = new visuals.BaseAnimator(), this.behavior = new visuals.CartesianChartBehavior([ new visuals.ScatterChartWebBehavior() ]);
                        var element = this.element = options.element;
                        this.viewport = _.clone(options.viewport), this.style = options.style, this.hostServices = options.host, 
                        this.colors = this.style.colorPalette.dataColors, this.interactivity = options.interactivity, 
                        this.margin = {
                            top: 1,
                            right: 1,
                            bottom: 1,
                            left: 1
                        }, this.yAxisOrientation = visuals.yAxisPosition.left, this.adjustMargins();
                        var showLinesOnX = this.scrollY = !0, showLinesOnY = this.scrollX = !0, svg = this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(EnhancedScatterChart.ClassName, !0), axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(EnhancedScatterChart.AxisGraphicsContextClassName, !0);
                        this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                        var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(EnhancedScatterChart.AxisGraphicsContextClassName, !0);
                        this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                        var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                        this.backgroundGraphicsContext = axisGraphicsContext.append("svg:image"), this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                        this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                        this.legend = visuals.createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, !0), 
                        this.mainGraphicsG = this.axisGraphicsContextScrollable.append("g").classed(EnhancedScatterChart.MainGraphicsContextClassName, !0), 
                        this.mainGraphicsSVGSelection = this.mainGraphicsG.append("svg"), this.mainGraphicsContext = this.mainGraphicsSVGSelection.append("g"), 
                        this.svgDefaultImage = "", this.keyArray = [];
                    }, EnhancedScatterChart.prototype.adjustMargins = function() {
                        var xAxis = this.element.find(".x.axis");
                        0 === visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) && 0 === visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) ? (this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, xAxis.hide()) : xAxis.show();
                    }, EnhancedScatterChart.prototype.getValueAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var valueAxisObject = objects.valueAxis;
                            valueAxisObject && (toReturn = {
                                show: valueAxisObject.show,
                                position: valueAxisObject.position,
                                axisScale: valueAxisObject.axisScale,
                                start: valueAxisObject.start,
                                end: valueAxisObject.end,
                                showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                                axisStyle: valueAxisObject.axisStyle,
                                axisColor: valueAxisObject.axisColor,
                                secShow: valueAxisObject.secShow,
                                secPosition: valueAxisObject.secPosition,
                                secAxisScale: valueAxisObject.secAxisScale,
                                secStart: valueAxisObject.secStart,
                                secEnd: valueAxisObject.secEnd,
                                secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                                secAxisStyle: valueAxisObject.secAxisStyle,
                                labelDisplayUnits: valueAxisObject.labelDisplayUnits
                            });
                        }
                        return toReturn;
                    }, EnhancedScatterChart.prototype.getCategoryAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var categoryAxisObject = objects.categoryAxis;
                            categoryAxisObject && (toReturn = {
                                show: categoryAxisObject.show,
                                axisType: categoryAxisObject.axisType,
                                axisScale: categoryAxisObject.axisScale,
                                axisColor: categoryAxisObject.axisColor,
                                start: categoryAxisObject.start,
                                end: categoryAxisObject.end,
                                showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                                axisStyle: categoryAxisObject.axisStyle,
                                labelDisplayUnits: categoryAxisObject.labelDisplayUnits
                            });
                        }
                        return toReturn;
                    }, EnhancedScatterChart.converter = function(dataView, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                        if (!dataView) return EnhancedScatterChart.getDefaultData();
                        var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, dataViewCategorical = dataView.categorical, dataViewMetadata = dataView.metadata, categories = dataViewCategorical.categories || [], dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), dvSource = dataValues.source, scatterMetadata = EnhancedScatterChart.getMetadata(categories, grouped, dvSource), categoryIndex = scatterMetadata.idx.category, useShape = scatterMetadata.idx.image >= 0, useCustomColor = scatterMetadata.idx.colorFill >= 0;
                        if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0 && dataViewCategorical.categories[categoryIndex]) {
                            var mainCategory = dataViewCategorical.categories[categoryIndex];
                            categoryValues = mainCategory.values, categoryFormatter = visuals.valueFormatter.create({
                                format: visuals.valueFormatter.getFormatString(mainCategory.source, visuals.scatterChartProps.general.formatString),
                                value: categoryValues[0],
                                value2: categoryValues[categoryValues.length - 1]
                            }), categoryIdentities = mainCategory.identity, categoryObjects = mainCategory.objects, 
                            categoryQueryName = mainCategory.source ? mainCategory.source.queryName : null;
                        } else categoryValues = [ null ], categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);
                        var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), fillPoint = !1, backdrop = {
                            show: !1,
                            url: ""
                        }, crosshair = !1, outline = !1, defaultDataPointColor = "", showAllDataPoints = !0;
                        if (dataViewMetadata && dataViewMetadata.objects) {
                            var objects = dataViewMetadata.objects;
                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                            showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                            var labelsObj = objects.categoryLabels;
                            labelsObj && (dataLabelsSettings.show = void 0 !== labelsObj.show ? labelsObj.show : dataLabelsSettings.show, 
                            dataLabelsSettings.fontSize = void 0 !== labelsObj.fontSize ? labelsObj.fontSize : dataLabelsSettings.fontSize, 
                            void 0 !== labelsObj.color && (dataLabelsSettings.labelColor = labelsObj.color.solid.color)), 
                            fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, fillPoint);
                            var backdropObject = objects.backdrop;
                            void 0 !== backdropObject && (backdrop.show = backdropObject.show, backdrop.show && (backdrop.url = backdropObject.url));
                            var crosshairObject = objects.crosshair;
                            void 0 !== crosshairObject && (crosshair = crosshairObject.show);
                            var outlineObject = objects.outline;
                            void 0 !== outlineObject && (outline = outlineObject.show);
                        }
                        var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
                        interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                        var legendItems = hasDynamicSeries ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor) : [], legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                        legendTitle || (legendTitle = categories && categories[categoryIndex] && categories[categoryIndex].source && categories[categoryIndex].source.displayName ? categories[categoryIndex].source.displayName : "");
                        var legendData = {
                            title: legendTitle,
                            dataPoints: legendItems
                        }, sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                        if (categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && categoryAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.x = null), 
                        valueAxisProperties && null !== valueAxisProperties.showAxisTitle && valueAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.y = null), 
                        dataPoints && dataPoints[0]) {
                            var point = dataPoints[0];
                            null != point.backdrop && (backdrop.show = !0, backdrop.url = point.backdrop), null != point.xStart && (categoryAxisProperties.start = point.xStart), 
                            null != point.xEnd && (categoryAxisProperties.end = point.xEnd), null != point.yStart && (valueAxisProperties.start = point.yStart), 
                            null != point.yEnd && (valueAxisProperties.end = point.yEnd);
                        }
                        return {
                            xCol: scatterMetadata.cols.x,
                            yCol: scatterMetadata.cols.y,
                            dataPoints: dataPoints,
                            legendData: legendData,
                            axesLabels: scatterMetadata.axesLabels,
                            selectedIds: [],
                            size: scatterMetadata.cols.size,
                            sizeRange: sizeRange,
                            dataLabelsSettings: dataLabelsSettings,
                            defaultDataPointColor: defaultDataPointColor,
                            hasDynamicSeries: hasDynamicSeries,
                            showAllDataPoints: showAllDataPoints,
                            fillPoint: fillPoint,
                            useShape: useShape,
                            useCustomColor: useCustomColor,
                            backdrop: backdrop,
                            crosshair: crosshair,
                            outline: outline
                        };
                    }, EnhancedScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                        for (var grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), legendItems = [], i = 0, len = grouped.length; len > i; i++) {
                            var grouping = grouped[i], color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                            legendItems.push({
                                color: color,
                                icon: visuals.LegendIcon.Circle,
                                label: visuals.valueFormatter.format(grouping.name, formatString),
                                identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                                selected: !1
                            });
                        }
                        return legendItems;
                    }, EnhancedScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                        var result = {};
                        return dataViewValueGroups && dataViewValueGroups.forEach(function(group) {
                            var sizeColumn = visuals.ScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                            (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                            (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                        }), result;
                    }, EnhancedScatterChart.getMetadata = function(categories, grouped, source) {
                        var xCol, yCol, sizeCol, categoryIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnCategory), colorFillIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnColorFill), imageIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnImage), backdropIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnBackdrop), xIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnX), yIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnY), sizeIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnSize), shapeIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnShape), rotationIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnRotation), xStartIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnXStart), xEndIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnXEnd), yStartIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnYStart), yEndIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnYEnd), xAxisLabel = "", yAxisLabel = "";
                        if (grouped && grouped.length) {
                            var firstGroup = grouped[0];
                            xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                            yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                            sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source);
                        }
                        return {
                            idx: {
                                category: categoryIndex,
                                x: xIndex,
                                y: yIndex,
                                size: sizeIndex,
                                colorFill: colorFillIndex,
                                shape: shapeIndex,
                                image: imageIndex,
                                rotation: rotationIndex,
                                backdrop: backdropIndex,
                                xStart: xStartIndex,
                                xEnd: xEndIndex,
                                yStart: yStartIndex,
                                yEnd: yEndIndex
                            },
                            cols: {
                                x: xCol,
                                y: yCol,
                                size: sizeCol
                            },
                            axesLabels: {
                                x: xAxisLabel,
                                y: yAxisLabel
                            }
                        };
                    }, EnhancedScatterChart.createLazyFormattedCategory = function(formatter, value) {
                        return new Lazy(function() {
                            return formatter.format(value);
                        });
                    }, EnhancedScatterChart.createDataPoints = function(dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
                        for (var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped(), fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), categoryIdx = 0, ilen = categoryValues.length; ilen > categoryIdx; categoryIdx++) for (var categoryValue = categoryValues[categoryIdx], seriesIdx = 0, len = grouped.length; len > seriesIdx; seriesIdx++) {
                            var measureColorFill = categories[indicies.colorFill], measureImage = categories[indicies.image], measureBackdrop = categories[indicies.backdrop], grouping = grouped[seriesIdx], seriesValues = grouping.values, measureX = visuals.ScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = visuals.ScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = visuals.ScatterChart.getMeasureValue(indicies.size, seriesValues), measureShape = visuals.ScatterChart.getMeasureValue(indicies.shape, seriesValues), measureRotation = visuals.ScatterChart.getMeasureValue(indicies.rotation, seriesValues), measureXStart = visuals.ScatterChart.getMeasureValue(indicies.xStart, seriesValues), measureXEnd = visuals.ScatterChart.getMeasureValue(indicies.xEnd, seriesValues), measureYStart = visuals.ScatterChart.getMeasureValue(indicies.yStart, seriesValues), measureYEnd = visuals.ScatterChart.getMeasureValue(indicies.yEnd, seriesValues), xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null, yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0, hasNullValue = null == xVal || null == yVal;
                            if (!hasNullValue) {
                                var size, colorFill, shapeSymbolType, image, rotation, backdrop, xStart, xEnd, yStart, yEnd, color;
                                if (size = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureSize, categoryIdx), 
                                colorFill = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureColorFill, categoryIdx), 
                                shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(EnhancedScatterChart.getValueFromDataViewValueColumnById(measureShape, categoryIdx)), 
                                image = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureImage, categoryIdx), 
                                rotation = EnhancedScatterChart.getNumberFromDataViewValueColumnById(measureRotation, categoryIdx), 
                                backdrop = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureBackdrop, categoryIdx), 
                                xStart = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureXStart, categoryIdx), 
                                xEnd = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureXEnd, categoryIdx), 
                                yStart = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureYStart, categoryIdx), 
                                yEnd = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureYEnd, categoryIdx), 
                                hasDynamicSeries) color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else {
                                    var measureSource = null != measureSize ? measureSize.source.queryName : "";
                                    color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                                }
                                var category = categories && categories.length > 0 ? categories[indicies.category] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIdx).withSeries(dataValues, grouping).createSelectionId(), seriesData = [];
                                dataValueSource && seriesData.push({
                                    value: grouping.name,
                                    metadata: {
                                        source: dataValueSource,
                                        values: []
                                    }
                                }), measureX && seriesData.push({
                                    value: xVal,
                                    metadata: measureX
                                }), measureY && seriesData.push({
                                    value: yVal,
                                    metadata: measureY
                                }), measureSize && measureSize.values && measureSize.values.length > 0 && seriesData.push({
                                    value: measureSize.values[categoryIdx],
                                    metadata: measureSize
                                }), measureColorFill && measureColorFill.values && measureColorFill.values.length > 0 && seriesData.push({
                                    value: measureColorFill.values[categoryIdx],
                                    metadata: measureColorFill
                                }), measureShape && measureShape.values && measureShape.values.length > 0 && seriesData.push({
                                    value: measureShape.values[categoryIdx],
                                    metadata: measureShape
                                }), measureImage && measureImage.values && measureImage.values.length > 0 && seriesData.push({
                                    value: measureImage.values[categoryIdx],
                                    metadata: measureImage
                                }), measureRotation && measureRotation.values && measureRotation.values.length > 0 && seriesData.push({
                                    value: measureRotation.values[categoryIdx],
                                    metadata: measureRotation
                                }), measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0 && seriesData.push({
                                    value: measureBackdrop.values[categoryIdx],
                                    metadata: measureBackdrop
                                }), measureXStart && measureXStart.values && measureXStart.values.length > 0 && seriesData.push({
                                    value: measureXStart.values[categoryIdx],
                                    metadata: measureXStart
                                }), measureXEnd && measureXEnd.values && measureXEnd.values.length > 0 && seriesData.push({
                                    value: measureXEnd.values[categoryIdx],
                                    metadata: measureXEnd
                                }), measureYStart && measureYStart.values && measureYStart.values.length > 0 && seriesData.push({
                                    value: measureYStart.values[categoryIdx],
                                    metadata: measureYStart
                                }), measureYEnd && measureYEnd.values && measureYEnd.values.length > 0 && seriesData.push({
                                    value: measureYEnd.values[categoryIdx],
                                    metadata: measureYEnd
                                });
                                var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, void 0, categoryValue, null, category ? [ category ] : void 0, seriesData, void 0), dataPoint = {
                                    x: xVal,
                                    y: yVal,
                                    size: size,
                                    radius: {
                                        sizeMeasure: measureSize,
                                        index: categoryIdx
                                    },
                                    fill: color,
                                    formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),
                                    selected: !1,
                                    identity: identity,
                                    tooltipInfo: tooltipInfo,
                                    labelFill: labelSettings.labelColor,
                                    labelFontSize: fontSizeInPx,
                                    contentPosition: 8,
                                    colorFill: colorFill,
                                    shapeSymbolType: shapeSymbolType,
                                    svgurl: image,
                                    rotation: rotation,
                                    backdrop: backdrop,
                                    xStart: xStart,
                                    xEnd: xEnd,
                                    yStart: yStart,
                                    yEnd: yEnd
                                };
                                dataPoints.push(dataPoint);
                            }
                        }
                        return dataPoints;
                    }, EnhancedScatterChart.getNumberFromDataViewValueColumnById = function(dataViewValueColumn, index) {
                        var value = EnhancedScatterChart.getValueFromDataViewValueColumnById(dataViewValueColumn, index);
                        return value && !isNaN(value) ? value : 0;
                    }, EnhancedScatterChart.getValueFromDataViewValueColumnById = function(dataViewValueColumn, index) {
                        return dataViewValueColumn && dataViewValueColumn.values ? dataViewValueColumn.values[index] : null;
                    }, EnhancedScatterChart.getDefaultData = function() {
                        return {
                            xCol: void 0,
                            yCol: void 0,
                            dataPoints: [],
                            legendData: {
                                dataPoints: []
                            },
                            axesLabels: {
                                x: "",
                                y: ""
                            },
                            selectedIds: [],
                            sizeRange: [],
                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                            defaultDataPointColor: null,
                            hasDynamicSeries: !1,
                            useShape: !1,
                            useCustomColor: !1
                        };
                    }, EnhancedScatterChart.prototype.setData = function(dataViews) {
                        if (this.data = EnhancedScatterChart.getDefaultData(), dataViews && dataViews.length > 0) {
                            var dataView = dataViews[0];
                            dataView && (this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, !0), 
                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, !0), this.dataView = dataView, 
                            dataView.categorical && dataView.categorical.values && (this.data = EnhancedScatterChart.converter(dataView, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties)));
                        }
                    }, EnhancedScatterChart.prototype.update = function(options) {
                        var dataViews = this.dataViews = options.dataViews;
                        if (this.viewport = _.clone(options.viewport), dataViews) {
                            if (dataViews && dataViews.length > 0) {
                                var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                                warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                            }
                            this.setData(dataViews), this.options.interactivity && this.options.interactivity.isInteractiveLegend || this.renderLegend(), 
                            this.render(options.suppressAnimations);
                        }
                    }, EnhancedScatterChart.prototype.populateObjectProperties = function(dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            dataViewMetadata ? this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}) : this.legendObjectProperties = {}, 
                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata), 
                            this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
                            var axisPosition = this.valueAxisProperties.position;
                            this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                        }
                    }, EnhancedScatterChart.prototype.renderLegend = function() {
                        var legendData = {
                            title: "",
                            dataPoints: []
                        }, legend = this.legend;
                        this.layerLegendData = this.data.legendData, this.layerLegendData && (legendData.title = this.layerLegendData.title || "", 
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault, 
                        this.layerLegendData.grouped && (legendData.grouped = !0));
                        var legendProperties = this.legendObjectProperties;
                        if (legendProperties) {
                            visuals.LegendData.update(legendData, legendProperties);
                            var position = legendProperties[visuals.legendProps.position];
                            position && legend.changeOrientation(visuals.LegendPosition[position]);
                        } else legend.changeOrientation(visuals.LegendPosition.Top);
                        (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []);
                        var viewport = this.viewport;
                        legend.drawLegend(legendData, {
                            height: viewport.height,
                            width: viewport.width
                        }), visuals.Legend.positionChartArea(this.svg, legend);
                    }, EnhancedScatterChart.prototype.hideLegends = function() {
                        return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                    }, EnhancedScatterChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                        return void 0 === propertyName && (propertyName = "show"), axisProperties ? (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName]) && (axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) ? !1 : axisProperties.values && axisProperties.values.length > 0 : !1;
                    }, EnhancedScatterChart.prototype.getMaxMarginFactor = function() {
                        return this.options.style.maxMarginFactor || .25;
                    }, EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function() {
                        var img = new Image(), that = this;
                        if (img.src = this.data.backdrop.url, img.onload = function() {
                            that.oldBackdrop !== this.src && (that.render(!0), that.oldBackdrop = this.src);
                        }, img.width > 0 && img.height > 0) if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
                            this.viewport = {
                                width: this.viewport.width - deltaWidth,
                                height: this.viewport.height
                            };
                        } else {
                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
                            this.viewport = {
                                width: this.viewport.width,
                                height: this.viewport.height - deltaHeight
                            };
                        }
                    }, EnhancedScatterChart.prototype.render = function(suppressAnimations) {
                        if (this.viewport.height -= this.legendViewport.height, this.viewport.width -= this.legendViewport.width, 
                        0 !== this.viewportIn.width && 0 !== this.viewportIn.height) {
                            var maxMarginFactor = this.getMaxMarginFactor();
                            this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
                            var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
                            this.margin.top = 8, this.margin.bottom = bottomMarginLimit, this.margin.right = 0, 
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                            this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
                            var mainAxisScale, renderXAxis = this.shouldRenderAxis(this.xAxisProperties), renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
                            this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                            var tickLabelMargins, axisLabels, chartHasAxisLabels, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0);
                            for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && maxIterations > numIterations; ) {
                                numIterations++, tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                                    width: this.viewportIn.width,
                                    height: this.viewport.height
                                }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, {
                                    x: this.xAxisProperties,
                                    y1: this.yAxisProperties
                                }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                                maxMainYaxisSide += 10, maxSecondYaxisSide += 10, xMax += 12, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 20), 
                                !showY1OnRight && renderY1Axis && (maxMainYaxisSide += 20), this.hideAxisLabels() && (this.xAxisProperties.axisLabel = null, 
                                this.yAxisProperties.axisLabel = null), this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), 
                                axisLabels = {
                                    x: this.xAxisProperties.axisLabel,
                                    y: this.yAxisProperties.axisLabel,
                                    y2: null
                                }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                                null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                                null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                                var previousTickCountY1 = this.yAxisProperties.values.length;
                                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                                this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                            }
                            if (this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url) for (this.adjustViewportbyBackdrop(), 
                            doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && maxIterations > numIterations; ) {
                                numIterations++, tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                                    width: this.viewportIn.width,
                                    height: this.viewport.height
                                }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, {
                                    x: this.xAxisProperties,
                                    y1: this.yAxisProperties
                                }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                                maxMainYaxisSide += 10, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 15), 
                                xMax += 12, this.hideAxisLabels() && (this.xAxisProperties.axisLabel = null, this.yAxisProperties.axisLabel = null), 
                                this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), axisLabels = {
                                    x: this.xAxisProperties.axisLabel,
                                    y: this.yAxisProperties.axisLabel,
                                    y2: null
                                }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                                null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                                null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                                var previousTickCountY1 = this.yAxisProperties.values.length;
                                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                                this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                            }
                            if (this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations), 
                            this.updateAxis(), this.data) {
                                var data = this.data, dataPoints = this.data.dataPoints, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                                this.mainGraphicsSVGSelection.attr("width", this.viewportIn.width).attr("height", this.viewportIn.height);
                                var sortedData = dataPoints.sort(function(a, b) {
                                    return b.radius.sizeMeasure ? b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index] : 0;
                                }), duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration), dataLabelsSettings = this.data.dataLabelsSettings;
                                if (dataLabelsSettings.show) {
                                    var layout, clonedDataPoints, labels;
                                    layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange), 
                                    clonedDataPoints = this.cloneDataPoints(dataPoints), labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn), 
                                    labels && labels.attr("transform", function(d) {
                                        var dx, dy, size = d.size;
                                        return dx = size.width / EnhancedScatterChart.DataLabelXOffset, dy = size.height / EnhancedScatterChart.DataLabelYOffset, 
                                        visuals.SVGUtil.translate(dx, dy);
                                    });
                                } else visuals.dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
                                this.renderCrosshair();
                                var behaviorOptions;
                                if (this.interactivityService && (behaviorOptions = {
                                    dataPointsSelection: scatterMarkers,
                                    data: this.data,
                                    plotContext: this.mainGraphicsSVGSelection
                                }), visuals.TooltipManager.addTooltip(scatterMarkers, function(tooltipEvent) {
                                    return tooltipEvent.data.tooltipInfo;
                                }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), this.behavior) {
                                    var layerBehaviorOptions = [];
                                    if (layerBehaviorOptions.push(behaviorOptions), this.interactivityService) {
                                        var cbehaviorOptions = {
                                            layerOptions: layerBehaviorOptions,
                                            clearCatcher: this.clearCatcher
                                        };
                                        this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
                                    }
                                }
                            }
                        }
                    }, EnhancedScatterChart.prototype.cloneDataPoints = function(dataPoints) {
                        return dataPoints.map(function(dataPoint) {
                            return _.clone(dataPoint);
                        });
                    }, EnhancedScatterChart.prototype.darkenZeroLine = function(g) {
                        var zeroTick = g.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).node();
                        zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                    }, EnhancedScatterChart.prototype.getCategoryAxisFill = function() {
                        if (this.dataView && this.dataView.metadata.objects) {
                            var label = this.dataView.metadata.objects.categoryAxis;
                            if (label) return label.axisColor;
                        }
                        return {
                            solid: {
                                color: "#333"
                            }
                        };
                    }, EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function(labelSettings, viewport, sizeRange) {
                        var xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), fontFamily = visuals.dataLabelUtils.LabelTextProperties.fontFamily;
                        return {
                            labelText: function(d) {
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: d.formattedCategory.getValue(),
                                    fontSize: labelSettings.fontSize,
                                    maxWidth: viewport.width
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return xScale(d.x);
                                },
                                y: function(d) {
                                    var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + visuals.dataLabelUtils.labelMargin;
                                    return 0 === labelSettings.position ? yScale(d.y) - margin : yScale(d.y) + margin;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.formattedCategory.getValue();
                            },
                            style: {
                                fill: function(d) {
                                    return d.labelFill;
                                },
                                "font-size": fontSizeInPx,
                                "font-family": fontFamily
                            }
                        };
                    }, EnhancedScatterChart.prototype.getValueAxisFill = function() {
                        if (this.dataView && this.dataView.metadata.objects) {
                            var label = this.dataView.metadata.objects.valueAxis;
                            if (label) return label.axisColor;
                        }
                        return {
                            solid: {
                                color: "#333"
                            }
                        };
                    }, EnhancedScatterChart.prototype.renderCrosshair = function() {
                        return this.mainGraphicsSVGSelection ? (this.crosshairCanvasSelection = this.addCrosshairCanvasToDOM(this.mainGraphicsSVGSelection), 
                        this.data && this.data.crosshair && (this.crosshairVerticalLineSelection = this.addCrosshairLineToDOM(this.crosshairCanvasSelection, EnhancedScatterChart.CrosshairVerticalLineSelector), 
                        this.crosshairHorizontalLineSelection = this.addCrosshairLineToDOM(this.crosshairCanvasSelection, EnhancedScatterChart.CrosshairHorizontalLineSelector), 
                        this.crosshairTextSelection = this.addCrosshairTextToDOM(this.crosshairCanvasSelection), 
                        this.bindCrosshairEvents()), this.crosshairCanvasSelection) : void 0;
                    }, EnhancedScatterChart.prototype.addCrosshairCanvasToDOM = function(rootElement) {
                        var crosshairCanvasSelector = EnhancedScatterChart.CrosshairCanvasSelector;
                        return this.addElementToDOM(rootElement, {
                            name: "g",
                            selector: crosshairCanvasSelector.selector,
                            className: crosshairCanvasSelector["class"],
                            styles: {
                                display: "none"
                            }
                        });
                    }, EnhancedScatterChart.prototype.addCrosshairLineToDOM = function(rootElement, elementSelector) {
                        var crosshairLineSelector = EnhancedScatterChart.CrosshairLineSelector;
                        return this.addElementToDOM(rootElement, {
                            name: "line",
                            selector: elementSelector.selector,
                            className: crosshairLineSelector["class"] + " " + elementSelector["class"],
                            attributes: {
                                x1: 0,
                                y1: 0,
                                x2: 0,
                                y2: 0
                            }
                        });
                    }, EnhancedScatterChart.prototype.addCrosshairTextToDOM = function(rootElement) {
                        var crosshairTextSelector = EnhancedScatterChart.CrosshairTextSelector;
                        return this.addElementToDOM(rootElement, {
                            name: "text",
                            selector: crosshairTextSelector.selector,
                            className: crosshairTextSelector["class"]
                        });
                    }, EnhancedScatterChart.prototype.bindCrosshairEvents = function() {
                        var _this = this;
                        this.axisGraphicsContextScrollable && this.axisGraphicsContextScrollable.on("mousemove", function() {
                            var currentTarget = d3.event.currentTarget, coordinates = d3.mouse(currentTarget), svgNode = currentTarget.viewportElement, scaledRect = svgNode.getBoundingClientRect(), domRect = svgNode.getBBox(), ratioX = scaledRect.width / domRect.width, ratioY = scaledRect.height / domRect.height, x = coordinates[0], y = coordinates[1];
                            domRect.width > 0 && !powerbi.Double.equalWithPrecision(ratioX, 1, 1e-5) && (x /= ratioX), 
                            domRect.height > 0 && !powerbi.Double.equalWithPrecision(ratioY, 1, 1e-5) && (y /= ratioY), 
                            _this.updateCrosshair(x, y);
                        }).on("mouseover", function() {
                            _this.crosshairCanvasSelection.style("display", "block");
                        }).on("mouseout", function() {
                            _this.crosshairCanvasSelection.style("display", "none");
                        });
                    }, EnhancedScatterChart.prototype.updateCrosshair = function(x, y) {
                        if (this.viewportIn && this.crosshairHorizontalLineSelection && this.crosshairVerticalLineSelection && this.crosshairTextSelection && this.xAxisProperties) {
                            var xFormated, yFormated, crosshairTextMargin = EnhancedScatterChart.CrosshairTextMargin, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale;
                            this.crosshairHorizontalLineSelection.attr({
                                x1: 0,
                                y1: y,
                                x2: this.viewportIn.width,
                                y2: y
                            }), this.crosshairVerticalLineSelection.attr({
                                x1: x,
                                y1: 0,
                                x2: x,
                                y2: this.viewportIn.height
                            }), xFormated = Math.round(100 * xScale.invert(x)) / 100, yFormated = Math.round(100 * yScale.invert(y)) / 100, 
                            this.crosshairTextSelection.attr({
                                x: x + crosshairTextMargin,
                                y: y - crosshairTextMargin
                            }).text("(" + xFormated + ", " + yFormated + ")");
                        }
                    }, EnhancedScatterChart.prototype.addElementToDOM = function(rootElement, properties) {
                        if (!rootElement || !properties) return null;
                        var elementSelection, elementUpdateSelection;
                        return elementSelection = rootElement.selectAll(properties.selector), elementUpdateSelection = elementSelection.data(properties.data || [ [] ]), 
                        elementUpdateSelection.enter().append(properties.name).attr(properties.attributes).style(properties.styles).classed(properties.className, !0), 
                        elementUpdateSelection.exit().remove(), elementUpdateSelection;
                    }, EnhancedScatterChart.prototype.renderBackground = function() {
                        this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url ? this.backgroundGraphicsContext.attr("xlink:href", this.data.backdrop.url).attr("x", 0).attr("y", 0).attr("width", this.viewportIn.width).attr("height", this.viewportIn.height) : this.backgroundGraphicsContext.attr("width", 0).attr("height", 0);
                    }, EnhancedScatterChart.prototype.renderChart = function(mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
                        var bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                        if (this.renderBackground(), this.shouldRenderAxis(xAxis)) {
                            xAxis.axis.orient("bottom"), xAxis.willLabelsFit || xAxis.axis.tickPadding(5);
                            var xAxisGraphicsElement = this.xAxisGraphicsContext;
                            duration ? xAxisGraphicsElement.transition().duration(duration).call(xAxis.axis).call(this.darkenZeroLine) : xAxisGraphicsElement.call(xAxis.axis).call(this.darkenZeroLine);
                            var xZeroTick = xAxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                                return 0 === data;
                            });
                            if (xZeroTick) {
                                var xZeroColor = this.getValueAxisFill();
                                xZeroColor && xZeroTick.selectAll("line").style({
                                    stroke: xZeroColor.solid.color
                                });
                            }
                            var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
                            xAxis.willLabelsWordBreak ? xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit) : xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, visuals.CartesianChart.AxisTextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                        } else this.xAxisGraphicsContext.selectAll("*").remove();
                        if (this.shouldRenderAxis(yAxis)) {
                            var yAxisOrientation = this.yAxisOrientation;
                            yAxis.axis.tickSize(-this.viewportIn.width).tickPadding(10).orient(yAxisOrientation.toLowerCase());
                            var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                            duration ? y1AxisGraphicsElement.transition().duration(duration).call(yAxis.axis).call(this.darkenZeroLine) : y1AxisGraphicsElement.call(yAxis.axis).call(this.darkenZeroLine);
                            var yZeroTick = y1AxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                                return 0 === data;
                            });
                            if (yZeroTick) {
                                var yZeroColor = this.getCategoryAxisFill();
                                yZeroColor && yZeroTick.selectAll("line").style({
                                    stroke: yZeroColor.solid.color
                                });
                            }
                            tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - 10, powerbi.TextMeasurementService.svgEllipsis);
                        } else this.y1AxisGraphicsContext.selectAll("*").remove();
                        if (chartHasAxisLabels) {
                            var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1;
                            this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                        } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    }, EnhancedScatterChart.prototype.renderAxesLabels = function(axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var margin = this.margin, width = this.viewportIn.width, height = this.viewport.height, fontSize = EnhancedScatterChart.AxisFontSize, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        if (!hideXAxisTitle) {
                            var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.x).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "xAxisLabel",
                                        transform: visuals.SVGUtil.translate(width / 2, height - fontSize - 2)
                                    });
                                });
                            });
                            xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!hideYAxisTitle) {
                            var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showY1OnRight ? width + margin.right - fontSize : -margin.left,
                                        x: -((height - margin.top - legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!hideY2AxisTitle && axisLabels.y2) {
                            var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y2).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showY1OnRight ? -margin.left : width + margin.right - fontSize,
                                        x: -((height - margin.top - legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }, EnhancedScatterChart.prototype.updateAxis = function() {
                        this.adjustMargins();
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, this.viewportIn.height)), 
                        this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0)), 
                        this.svg.attr({
                            width: this.viewport.width,
                            height: this.viewport.height
                        }), this.svgScrollable.attr({
                            width: this.viewport.width,
                            height: this.viewport.height
                        }), this.svgScrollable.attr({
                            x: 0
                        });
                        var left = this.margin.left, top = this.margin.top;
                        this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(left, top)), 
                        this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(left, top)), 
                        this.clearCatcher.attr("transform", visuals.SVGUtil.translate(-left, -top)), this.isXScrollBarVisible ? (this.svgScrollable.attr({
                            x: left
                        }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, top)), 
                        this.svgScrollable.attr("width", this.viewportIn.width), this.svg.attr("width", this.viewport.width).attr("height", this.viewport.height + this.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", this.viewportIn.height + top), 
                        this.svg.attr("width", this.viewport.width + this.ScrollBarWidth).attr("height", this.viewport.height));
                    }, EnhancedScatterChart.prototype.getUnitType = function(xAxis) {
                        return xAxis.formatter && xAxis.formatter.displayUnit && xAxis.formatter.displayUnit.value > 1 ? xAxis.formatter.displayUnit.title : null;
                    }, EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function(xAxis, yAxis) {
                        var unitType = this.getUnitType(xAxis);
                        xAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        xAxis.axisLabel && unitType && (xAxis.isCategoryAxis ? xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType) : xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType)), 
                        unitType = this.getUnitType(yAxis), yAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        yAxis.axisLabel && unitType && (yAxis.isCategoryAxis ? yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType) : yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType));
                    }, EnhancedScatterChart.prototype.hideAxisLabels = function() {
                        return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.viewport.height + this.legendViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.options.interactivity.isInteractiveLegend);
                    }, EnhancedScatterChart.prototype.drawScatterMarkers = function(scatterData, hasSelection, sizeRange, duration) {
                        var markers, _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint, useCustomColor = this.data.useCustomColor;
                        this.data.useShape ? (this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove(), 
                        markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function(d) {
                            return d.identity.getKey();
                        }), markers.enter().append("svg:image").classed(EnhancedScatterChart.ImageClasses["class"], !0).attr("id", "markerimage"), 
                        markers.attr("xlink:href", function(d) {
                            return void 0 !== d.svgurl && null != d.svgurl && "" !== d.svgurl ? d.svgurl : _this.svgDefaultImage;
                        }).attr("width", function(d) {
                            return 2 * visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        }).attr("height", function(d) {
                            return 2 * visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        }).transition().duration(function(d) {
                            return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                        }).attr("transform", function(d) {
                            var radius = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
                        })) : (this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove(), 
                        markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function(d) {
                            return d.identity.getKey();
                        }), markers.enter().append("path").classed(EnhancedScatterChart.DotClasses["class"], !0).attr("id", "markershape"), 
                        markers.style({
                            "stroke-opacity": function(d) {
                                return visuals.ScatterChart.getBubbleOpacity(d, hasSelection);
                            },
                            "stroke-width": "1px",
                            stroke: function(d) {
                                var color = useCustomColor ? d.colorFill : d.fill;
                                return _this.data.outline ? d3.rgb(color).darker() : d3.rgb(color);
                            },
                            fill: function(d) {
                                return d3.rgb(useCustomColor ? d.colorFill : d.fill);
                            },
                            "fill-opacity": function(d) {
                                return null != d.size || shouldEnableFill ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0;
                            }
                        }).attr("d", function(d) {
                            var r = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport), area = 4 * r * r;
                            return d.shapeSymbolType(area);
                        }).transition().duration(function(d) {
                            return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                        }).attr("transform", function(d) {
                            return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")";
                        })), markers.exit().remove(), this.keyArray = [];
                        for (var i = 0; i < scatterData.length; i++) this.keyArray.push(scatterData[i].identity.getKey());
                        return markers;
                    }, EnhancedScatterChart.prototype.calculateAxes = function(categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                            forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : null,
                            valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : null,
                            valueAxisDisplayUnits: valueAxisProperties && null != valueAxisProperties.labelDisplayUnits ? valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                            categoryAxisDisplayUnits: categoryAxisProperties && null != categoryAxisProperties.labelDisplayUnits ? categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                            trimOrdinalDataOnOverflow: !1
                        };
                        valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain)), 
                        visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = !0;
                        var width = this.viewport.width - (this.margin.left + this.margin.right), axes = this.calculateAxesProperties(visualOptions);
                        return axes[0].willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes[0].willLabelsWordBreak = !axes[0].willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, EnhancedScatterChart.prototype.calculateAxesProperties = function(options) {
                        var data = this.data, dataPoints = data.dataPoints;
                        this.margin = options.margin, this.viewport = options.viewport;
                        var minY = 0, maxY = 10, minX = 0, maxX = 10;
                        dataPoints.length > 0 && (minY = d3.min(dataPoints, function(d) {
                            return d.y;
                        }), maxY = d3.max(dataPoints, function(d) {
                            return d.y;
                        }), minX = d3.min(dataPoints, function(d) {
                            return d.x;
                        }), maxX = d3.max(dataPoints, function(d) {
                            return d.x;
                        }));
                        var combinedXDomain, combinedYDomain, xDomain = [ minX, maxX ];
                        return combinedXDomain = visuals.AxisHelper.combineDomain(this.optimizeTranslateValues(options.forcedXDomain), xDomain), 
                        this.xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewportIn.width,
                            dataDomain: combinedXDomain,
                            metaDataColumn: data.xCol,
                            formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        }), this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0), this.xAxisProperties.axisLabel = this.data.axesLabels.x, 
                        combinedYDomain = visuals.AxisHelper.combineDomain(this.optimizeTranslateValues(options.forcedYDomain), [ minY, maxY ]), 
                        this.yAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewportIn.height,
                            dataDomain: combinedYDomain,
                            metaDataColumn: data.yCol,
                            formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !0,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: options.valueAxisScaleType,
                            axisDisplayUnits: options.valueAxisDisplayUnits
                        }), this.yAxisProperties.axisLabel = this.data.axesLabels.y, [ this.xAxisProperties, this.yAxisProperties ];
                    }, EnhancedScatterChart.prototype.optimizeTranslateValues = function(values) {
                        var _this = this;
                        return values && values.map ? values.map(function(value) {
                            return _this.optimizeTranslateValue(value);
                        }) : values;
                    }, EnhancedScatterChart.prototype.optimizeTranslateValue = function(value) {
                        if (value) {
                            var numberSign = value >= 0 ? 1 : -1, absoluteValue = Math.abs(value);
                            if (absoluteValue > EnhancedScatterChart.MaxTranslateValue) return EnhancedScatterChart.MaxTranslateValue * numberSign;
                            if (absoluteValue < EnhancedScatterChart.MinTranslateValue) return EnhancedScatterChart.MinTranslateValue * numberSign;
                        }
                        return value;
                    }, EnhancedScatterChart.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data) {
                            var seriesCount = data.dataPoints.length;
                            if (data.hasDynamicSeries) for (var legendDataPointLength = data.legendData.dataPoints.length, i = 0; legendDataPointLength > i; i++) {
                                var series = data.legendData.dataPoints[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: series.label,
                                    selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: series.color
                                            }
                                        }
                                    }
                                });
                            } else {
                                var showAllDataPoints = data.showAllDataPoints;
                                if (enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        defaultColor: {
                                            solid: {
                                                color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                            }
                                        }
                                    }
                                }).pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        showAllDataPoints: showAllDataPoints
                                    }
                                }), showAllDataPoints) for (var i = 0; seriesCount > i; i++) {
                                    var seriesDataPoints = data.dataPoints[i];
                                    enumeration.pushInstance({
                                        objectName: "dataPoint",
                                        displayName: seriesDataPoints.formattedCategory.getValue(),
                                        selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), !0),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: seriesDataPoints.fill
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }, EnhancedScatterChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "dataPoint":
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            visuals.GradientUtils.hasGradientRole(categoricalDataView) || this.enumerateDataPoints(enumeration);
                            break;

                          case "categoryAxis":
                            this.getCategoryAxisValues(enumeration);
                            break;

                          case "valueAxis":
                            this.getValueAxisValues(enumeration);
                            break;

                          case "categoryLabels":
                            this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, !0) : visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, !0);
                            break;

                          case "fillPoint":
                            var sizeRange = this.data.sizeRange;
                            if (sizeRange && sizeRange.min) break;
                            enumeration.pushInstance({
                                objectName: "fillPoint",
                                selector: null,
                                properties: {
                                    show: this.data.fillPoint
                                }
                            });
                            break;

                          case "backdrop":
                            enumeration.pushInstance({
                                objectName: "backdrop",
                                displayName: "Backdrop",
                                selector: null,
                                properties: {
                                    show: this.data.backdrop ? this.data.backdrop.show : !1,
                                    url: this.data.backdrop ? this.data.backdrop.url : null
                                }
                            });
                            break;

                          case "crosshair":
                            enumeration.pushInstance({
                                objectName: "crosshair",
                                selector: null,
                                properties: {
                                    show: this.data.crosshair
                                }
                            });
                            break;

                          case "outline":
                            enumeration.pushInstance({
                                objectName: "outline",
                                selector: null,
                                properties: {
                                    show: this.data.outline
                                }
                            });
                            break;

                          case "legend":
                            this.getLegendValue(enumeration);
                        }
                        return enumeration.complete();
                    }, EnhancedScatterChart.prototype.hasLegend = function() {
                        return this.data && this.data.hasDynamicSeries;
                    }, EnhancedScatterChart.prototype.getLegendValue = function(enumeration) {
                        if (this.hasLegend()) {
                            var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : ""), legendLabelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                            this.legendLabelFontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault), 
                            enumeration.pushInstance({
                                selector: null,
                                properties: {
                                    show: show,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    labelColor: legendLabelColor,
                                    fontSize: this.legendLabelFontSize
                                },
                                objectName: "legend"
                            });
                        }
                    }, EnhancedScatterChart.prototype.getCategoryAxisValues = function(enumeration) {
                        var supportedType = visuals.axisType.both, isScalar = !0, logPossible = !1, scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ];
                        isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                        this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.categoryAxisProperties && null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                        this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                        instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null, 
                        instance.properties.labelDisplayUnits = this.categoryAxisProperties && null != this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault), 
                        instance.properties.showAxisTitle = this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !0, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null
                            },
                            objectName: "categoryAxis",
                            validValues: {
                                axisStyle: this.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        });
                    }, EnhancedScatterChart.prototype.getValueAxisValues = function(enumeration) {
                        var scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ], logPossible = !1, instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.valueAxisProperties && null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                        this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                        instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                        instance.properties.showAxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !0, 
                        instance.properties.labelDisplayUnits = this.valueAxisProperties && null != this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null
                            },
                            objectName: "valueAxis",
                            validValues: {
                                axisStyle: this.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        });
                    }, EnhancedScatterChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, EnhancedScatterChart.AxisGraphicsContextClassName = "axisGraphicsContext", EnhancedScatterChart.ClassName = "enhancedScatterChart", 
                    EnhancedScatterChart.MainGraphicsContextClassName = "mainGraphicsContext", EnhancedScatterChart.LegendLabelFontSizeDefault = 9, 
                    EnhancedScatterChart.LabelDisplayUnitsDefault = 0, EnhancedScatterChart.AxisFontSize = 11, 
                    EnhancedScatterChart.CrosshairTextMargin = 5, EnhancedScatterChart.DataLabelXOffset = 2, 
                    EnhancedScatterChart.DataLabelYOffset = 1.8, EnhancedScatterChart.DotClasses = createClassAndSelector("dot"), 
                    EnhancedScatterChart.ImageClasses = createClassAndSelector("img"), EnhancedScatterChart.CrosshairCanvasSelector = createClassAndSelector("crosshairCanvas"), 
                    EnhancedScatterChart.CrosshairLineSelector = createClassAndSelector("crosshairLine"), 
                    EnhancedScatterChart.CrosshairVerticalLineSelector = createClassAndSelector("crosshairVerticalLine"), 
                    EnhancedScatterChart.CrosshairHorizontalLineSelector = createClassAndSelector("crosshairHorizontalLine"), 
                    EnhancedScatterChart.CrosshairTextSelector = createClassAndSelector("crosshairText"), 
                    EnhancedScatterChart.MaxTranslateValue = 1e25, EnhancedScatterChart.MinTranslateValue = 1e-25, 
                    EnhancedScatterChart.DefaultBubbleOpacity = .85, EnhancedScatterChart.DimmedBubbleOpacity = .4, 
                    EnhancedScatterChart.ColumnCategory = "Category", EnhancedScatterChart.ColumnSeries = "Series", 
                    EnhancedScatterChart.ColumnX = "X", EnhancedScatterChart.ColumnY = "Y", EnhancedScatterChart.ColumnSize = "Size", 
                    EnhancedScatterChart.ColumnGradient = "Gradient", EnhancedScatterChart.ColumnColorFill = "ColorFill", 
                    EnhancedScatterChart.ColumnShape = "Shape", EnhancedScatterChart.ColumnImage = "Image", 
                    EnhancedScatterChart.ColumnRotation = "Rotation", EnhancedScatterChart.ColumnBackdrop = "Backdrop", 
                    EnhancedScatterChart.ColumnXStart = "X Start", EnhancedScatterChart.ColumnXEnd = "X End", 
                    EnhancedScatterChart.ColumnYStart = "Y Start", EnhancedScatterChart.ColumnYEnd = "Y End", 
                    EnhancedScatterChart.capabilities = {
                        dataRoles: [ {
                            name: EnhancedScatterChart.ColumnCategory,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
                        }, {
                            name: EnhancedScatterChart.ColumnSeries,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                        }, {
                            name: EnhancedScatterChart.ColumnX,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_X")
                        }, {
                            name: EnhancedScatterChart.ColumnY,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y")
                        }, {
                            name: EnhancedScatterChart.ColumnSize,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size")
                        }, {
                            name: EnhancedScatterChart.ColumnGradient,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
                        }, {
                            name: EnhancedScatterChart.ColumnColorFill,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Customized Color"
                        }, {
                            name: EnhancedScatterChart.ColumnShape,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Shape"
                        }, {
                            name: EnhancedScatterChart.ColumnImage,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Image"
                        }, {
                            name: EnhancedScatterChart.ColumnRotation,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Rotation"
                        }, {
                            name: EnhancedScatterChart.ColumnBackdrop,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Backdrop"
                        }, {
                            name: EnhancedScatterChart.ColumnXStart,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "X Start"
                        }, {
                            name: EnhancedScatterChart.ColumnXEnd,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "X End"
                        }, {
                            name: EnhancedScatterChart.ColumnYStart,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Y Start"
                        }, {
                            name: EnhancedScatterChart.ColumnYEnd,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Y End"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 1
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 1
                                },
                                ColorFill: {
                                    max: 1
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 0
                                },
                                Image: {
                                    max: 1
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 1
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 0
                                },
                                Image: {
                                    max: 1
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": EnhancedScatterChart.ColumnCategory
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: EnhancedScatterChart.ColumnSeries,
                                        select: [ {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnX
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnY
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnSize
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnGradient
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnColorFill
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnShape
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnImage
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnRotation
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnBackdrop
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnXStart
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnXEnd
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnYStart
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnYEnd
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    }
                                }
                            }
                        } ],
                        objects: {
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    useShape: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_UseImage"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: EnhancedScatterChart.ColumnGradient,
                                            output: {
                                                property: "fill",
                                                selector: [ EnhancedScatterChart.ColumnCategory ]
                                            }
                                        }
                                    }
                                }
                            },
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    start: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    end: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    start: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    end: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryLabels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            fillPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_FillPoint"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            backdrop: {
                                displayName: "Backdrop",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    url: {
                                        displayName: "Image URL",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            crosshair: {
                                displayName: "Crosshair",
                                properties: {
                                    show: {
                                        displayName: "Crosshair",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            outline: {
                                displayName: "Outline",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, EnhancedScatterChart;
                }();
                samples.EnhancedScatterChart = EnhancedScatterChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    function loadGlobeMapLibs() {}
    var THREE, WebGLHeatmap, GlobeMapCanvasLayers, powerbi, powerbi = (window.jsCommon, 
    window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var DataRoleHelper = powerbi.data.DataRoleHelper, GlobeMap = function() {
                    function GlobeMap() {
                        this.data = [], this.locationsToLoad = 0, this.locationsLoaded = 0, this.renderLoopEnabled = !0, 
                        this.needsRender = !1;
                    }
                    return GlobeMap.converter = function(dataView) {
                        return {};
                    }, GlobeMap.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "dataPoint":
                            this.enumerateDataPoints(enumeration);
                        }
                        return enumeration.complete();
                    }, GlobeMap.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data) for (var dataPoints = this.dataPointsToEnumerate, dataPointsLength = dataPoints.length, i = 0; dataPointsLength > i; i++) {
                            var dataPoint = dataPoints[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: dataPoint.label,
                                selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: dataPoint.color
                                        }
                                    }
                                }
                            });
                        }
                    }, GlobeMap.prototype.init = function(options) {
                        this.container = options.element, this.viewport = options.viewport, this.readyToRender = !1, 
                        this.globeMapLocationCache || (this.globeMapLocationCache = {}), this.style = options.style, 
                        this.colors = this.style.colorPalette.dataColors, this.colorHelper = new visuals.ColorHelper(this.colors, GlobeMap.Properties.dataPoint.fill), 
                        THREE || loadGlobeMapLibs(), THREE && this.setup();
                    }, GlobeMap.prototype.setup = function() {
                        this.initSettings(), this.initTextures(), this.initMercartorSphere(), this.initZoomControl(), 
                        this.initScene(), this.initHeatmap(), this.readyToRender = !0, this.composeRenderData(), 
                        this.initRayCaster();
                    }, GlobeMap.prototype.initSettings = function() {
                        var settings = this.settings = {};
                        settings.autoRotate = !1, settings.earthRadius = 30, settings.cameraRadius = 100, 
                        settings.earthSegments = 100, settings.heatmapSize = 1e3, settings.heatPointSize = 7, 
                        settings.heatIntensity = 10, settings.heatmapScaleOnZoom = .95, settings.barWidth = .3, 
                        settings.barHeight = 5, settings.rotateSpeed = .5, settings.zoomSpeed = .8, settings.cameraAnimDuration = 1e3, 
                        settings.clickInterval = 200;
                    }, GlobeMap.prototype.initScene = function() {
                        var viewport = this.viewport, settings = this.settings, clock = new THREE.Clock(), renderer = this.renderer = new THREE.WebGLRenderer({
                            antialias: !0,
                            preserveDrawingBuffer: !0
                        });
                        this.container.append(renderer.domElement), this.domElement = renderer.domElement;
                        var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, .1, 1e4), orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement), scene = this.scene = new THREE.Scene();
                        renderer.setSize(viewport.width, viewport.height), renderer.setClearColor(12240082, 1), 
                        camera.position.z = settings.cameraRadius, orbitControls.maxDistance = settings.cameraRadius, 
                        orbitControls.minDistance = settings.earthRadius + 1, orbitControls.rotateSpeed = settings.rotateSpeed, 
                        orbitControls.zoomSpeed = settings.zoomSpeed, orbitControls.autoRotate = settings.autoRotate;
                        var ambientLight = new THREE.AmbientLight(0), light1 = new THREE.DirectionalLight(16777215, .4), light2 = new THREE.DirectionalLight(16777215, .4), earth = this.earth = this.createEarth();
                        scene.add(ambientLight), scene.add(light1), scene.add(light2), scene.add(earth), 
                        light1.position.set(20, 20, 20), light2.position.set(0, 0, -20);
                        var _zis = this;
                        requestAnimationFrame(function render() {
                            try {
                                if (_zis.renderLoopEnabled && requestAnimationFrame(render), !_zis.shouldRender()) return;
                                orbitControls.update(clock.getDelta()), _zis.setEarthTexture(), _zis.intersectBars(), 
                                _zis.heatmap && _zis.heatmap.display && _zis.heatmap.display(), renderer.render(scene, camera), 
                                _zis.needsRender = !1;
                            } catch (e) {}
                        });
                    }, GlobeMap.prototype.shouldRender = function() {
                        return this.readyToRender && this.needsRender;
                    }, GlobeMap.prototype.createEarth = function() {
                        var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments), material = new THREE.MeshPhongMaterial({
                            map: this.mapTextures[0],
                            side: THREE.DoubleSide,
                            shininess: 1,
                            emissive: 11184810
                        });
                        return new THREE.Mesh(geometry, material);
                    }, GlobeMap.prototype.zoomClicked = function(zoomDirection) {
                        this.orbitControls.enabled !== !1 && this.orbitControls.enableZoom !== !1 && (-1 === zoomDirection ? this.orbitControls.constraint.dollyOut(Math.pow(.95, this.settings.zoomSpeed)) : 1 === zoomDirection && this.orbitControls.constraint.dollyIn(Math.pow(.95, this.settings.zoomSpeed)), 
                        this.orbitControls.update(), this.animateCamera(this.camera.position));
                    }, GlobeMap.prototype.rotateCam = function(deltaX, deltaY) {
                        this.orbitControls.enabled !== !1 && this.orbitControls.enableRotate !== !1 && (this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed), 
                        this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed), 
                        this.orbitControls.update(), this.animateCamera(this.camera.position));
                    }, GlobeMap.prototype.initTextures = function() {
                        var _this = this;
                        if (!GlobeMapCanvasLayers) {
                            GlobeMapCanvasLayers = [];
                            for (var level = 2; 5 >= level; ++level) {
                                var canvas = this.getBingMapCanvas(level);
                                GlobeMapCanvasLayers.push(canvas);
                            }
                        }
                        var createTexture = function(canvas) {
                            var texture = new THREE.Texture(canvas.get(0));
                            return texture.needsUpdate = !0, canvas.on("ready", function(e, resolution) {
                                texture.needsUpdate = !0, _this.needsRender = !0;
                            }), texture;
                        };
                        this.mapTextures = [];
                        for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
                    }, GlobeMap.prototype.initHeatmap = function() {
                        var settings = this.settings;
                        try {
                            var heatmap = this.heatmap = new WebGLHeatmap({
                                width: settings.heatmapSize,
                                height: settings.heatmapSize,
                                intensityToAlpha: !0
                            });
                        } catch (e) {}
                        var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
                        texture.needsUpdate = !0;
                        var material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: !0
                        }), geometry = new THREE.SphereGeometry(settings.earthRadius + .01, settings.earthSegments, settings.earthSegments), mesh = new THREE.Mesh(geometry, material);
                        window.heatmap = heatmap, window.heatmapTexture = texture, this.scene.add(mesh);
                    }, GlobeMap.prototype.setEarthTexture = function() {
                        if (this.camera) {
                            var texture, maxDistance = this.settings.cameraRadius - this.settings.earthRadius, distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;
                            texture = .2 >= distance ? this.mapTextures[3] : .4 >= distance ? this.mapTextures[2] : .6 >= distance ? this.mapTextures[1] : this.mapTextures[0], 
                            this.earth.material.map !== texture && (this.earth.material.map = texture), this.selectedBar ? this.orbitControls.rotateSpeed = this.settings.rotateSpeed : this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;
                        }
                    }, GlobeMap.prototype.update = function(options) {
                        if (this.needsRender = !0, options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {
                            var viewport = this.viewport = options.viewport;
                            return void (this.camera && this.renderer && (this.camera.aspect = viewport.width / viewport.height, 
                            this.camera.updateProjectionMatrix(), this.renderer.setSize(viewport.width, viewport.height)));
                        }
                        this.cleanHeatAndBar(), options.dataViews[0] && (options.dataViews[0].categorical || options.dataViews[0].metadata) && this.composeRenderData(options.dataViews[0].categorical, options.dataViews[0].metadata);
                    }, GlobeMap.prototype.cleanHeatAndBar = function() {
                        this.heatmap.clear(), this.heatTexture.needsUpdate = !0, this.barsGroup && this.scene.remove(this.barsGroup);
                    }, GlobeMap.prototype.renderMagic = function() {
                        if (!this.readyToRender) return void this.defferedRender();
                        var renderData = this.data, heatmap = this.heatmap, settings = this.settings;
                        heatmap.clear(), this.barsGroup && this.scene.remove(this.barsGroup), this.barsGroup = new THREE.Object3D(), 
                        this.scene.add(this.barsGroup), this.averageBarVector = new THREE.Vector3();
                        for (var i = 0, len = renderData.length; len > i; ++i) {
                            var renderDatum = renderData[i];
                            if (renderDatum.lat && renderDatum.lng) {
                                if (renderDatum.heat > .001) {
                                    renderDatum.heat < .1 && (renderDatum.heat = .1);
                                    var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize, y = (1 - (90 + renderDatum.lat) / 180) * settings.heatmapSize;
                                    heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);
                                }
                                if (renderDatum.height >= 0) {
                                    renderDatum.height < .01 && (renderDatum.height = .01);
                                    var latRadians = renderDatum.lat / 180 * Math.PI, lngRadians = renderDatum.lng / 180 * Math.PI, x = Math.cos(lngRadians) * Math.cos(latRadians), z = -Math.sin(lngRadians) * Math.cos(latRadians), y = Math.sin(latRadians), v = new THREE.Vector3(x, y, z);
                                    this.averageBarVector.add(v);
                                    var barHeight = settings.barHeight * renderDatum.height, measuresBySeries = [], dataPointToolTip = [];
                                    if (renderDatum.heightBySeries) for (var c = 0; c < renderDatum.heightBySeries.length; c++) renderDatum.heightBySeries[c] && measuresBySeries.push(renderDatum.heightBySeries[c]), 
                                    dataPointToolTip.push(renderDatum.seriesToolTipData[c]); else measuresBySeries.push(1);
                                    for (var previousMeasureValue = 0, j = 0; j < measuresBySeries.length; j++) {
                                        previousMeasureValue += measuresBySeries[j];
                                        var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]), bar = new THREE.Mesh(geometry, this.getBarMaterialByIndex(j));
                                        bar.position = v.clone().multiplyScalar(settings.earthRadius + barHeight / 2 * previousMeasureValue), 
                                        bar.lookAt(v), bar.toolTipData = 0 === dataPointToolTip.length ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]), 
                                        this.barsGroup.add(bar), previousMeasureValue += measuresBySeries[j];
                                    }
                                }
                            }
                        }
                        this.barsGroup.children.length > 0 && this.camera && (this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length), 
                        this.locationsLoaded === this.locationsToLoad && this.animateCamera(this.averageBarVector)), 
                        heatmap.update(), heatmap.blur(), this.heatTexture.needsUpdate = !0, this.needsRender = !0;
                    }, GlobeMap.prototype.getBarMaterialByIndex = function(index) {
                        return new THREE.MeshPhongMaterial({
                            color: this.dataPointsToEnumerate[index].color
                        });
                    }, GlobeMap.prototype.getToolTipDataForSeries = function(toolTipData, dataPointToolTip) {
                        var result = jQuery.extend(!0, {
                            series: {
                                displayName: dataPointToolTip.displayName,
                                value: dataPointToolTip.value
                            }
                        }, toolTipData);
                        return result.height.value = dataPointToolTip.dataPointValue, result;
                    }, GlobeMap.prototype.createDataPointForEnumeration = function(seriesData, valueIndex, seriesIndex, metaData) {
                        var source = seriesData.values[valueIndex].source, label = visuals.converterHelper.getFormattedLegendLabel(source, seriesData.values, null), identity = visuals.SelectionId.createWithId(seriesData.identity), category = visuals.converterHelper.getSeriesName(source), color = seriesData.objects && seriesData.objects.dataPoint ? seriesData.objects.dataPoint.fill.solid.color : metaData && metaData.objects ? this.colorHelper.getColorForMeasure(metaData.objects, "") : this.colors.getColorByIndex(seriesIndex).value;
                        return {
                            label: label,
                            identity: identity,
                            category: category,
                            color: color,
                            selected: null
                        };
                    }, GlobeMap.prototype.composeRenderData = function(categoricalView, metadataView) {
                        categoricalView ? this.categoricalView = categoricalView : categoricalView = this.categoricalView, 
                        this.data = [], this.dataPointsToEnumerate = [];
                        var locations = [], globeMapLocationCache = this.globeMapLocationCache;
                        if (categoricalView) {
                            var heightIndex = 0, intensityIndex = 0, categories = [];
                            try {
                                categoricalView.categories && (categories = categoricalView.categories);
                                var grouped = categoricalView.values.grouped();
                                heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Height"), intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Heat");
                                var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                            } catch (e) {}
                            var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;
                            if (categories && categories.length > 0 && categories[0].values) {
                                var locationCategory = categories[0];
                                locations = locationCategory.values, locationDispName = locationCategory.source.displayName, 
                                locationType = locationCategory.source.type.category ? locationCategory.source.type.category.toLowerCase() : "";
                            } else locations = [];
                            if (void 0 !== heightIndex && categoricalView.values[heightIndex] && void 0 !== categoricalView.values) if (heightDispName = categoricalView.values[heightIndex].source.displayName, 
                            heightFormat = categoricalView.values[heightIndex].source.format, grouped.length > 1) {
                                heights = new Array(locations.length), heightsBySeries = new Array(locations.length), 
                                toolTipDataBySeries = new Array(locations.length), this.dataPointsToEnumerate = new Array(grouped.length);
                                for (var i = 0; i < grouped.length; i++) {
                                    var values = grouped[i].values[heightIndex].values;
                                    this.dataPointsToEnumerate[i] = this.createDataPointForEnumeration(grouped[i], heightIndex, i);
                                    for (var j = 0; j < values.length; j++) heights[j] || (heights[j] = 0), heights[j] += values[j] ? values[j] : 0, 
                                    heightsBySeries[j] || (heightsBySeries[j] = []), heightsBySeries[j][i] = values[j], 
                                    toolTipDataBySeries[j] || (toolTipDataBySeries[j] = []), toolTipDataBySeries[j][i] = {
                                        displayName: categoricalView.values.source.displayName,
                                        value: grouped[i].name,
                                        dataPointValue: values[j]
                                    };
                                }
                                for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[heightIndex].values, j = 0; j < values.length; j++) heightsBySeries[j][i] = values[j] / heights[j];
                            } else heights = categoricalView.values[heightIndex].values, heightsBySeries = new Array(grouped.length), 
                            this.dataPointsToEnumerate[0] = this.createDataPointForEnumeration(grouped[0], heightIndex, 0, metadataView); else heightsBySeries = new Array(locations.length), 
                            heights = new Array(locations.length);
                            if (void 0 !== intensityIndex && categoricalView.values[intensityIndex]) {
                                if (grouped.length > 1) {
                                    heats = new Array(locations.length);
                                    for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[intensityIndex].values, j = 0; j < values.length; j++) heats[j] || (heats[j] = 0), 
                                    heats[j] += values[j] ? values[j] : 0;
                                } else heats = categoricalView.values[intensityIndex].values;
                                heatDispName = categoricalView.values[intensityIndex].source.displayName, heatFormat = categoricalView.values[intensityIndex].source.format;
                            } else heats = new Array(locations.length);
                            void 0 !== longitudeIndex && categoricalView.values[longitudeIndex] && void 0 !== latitudeIndex && categoricalView.values[latitudeIndex] ? (longitudes = categoricalView.values[longitudeIndex].values, 
                            latitudes = categoricalView.values[latitudeIndex].values) : (longitudes = null, 
                            latitudes = null);
                            for (var maxHeight = Math.max.apply(null, heights) || 1, maxHeat = Math.max.apply(null, heats) || 1, heatFormatter = visuals.valueFormatter.create({
                                format: heatFormat,
                                value: heats[0],
                                value2: heats[1]
                            }), heightFormatter = visuals.valueFormatter.create({
                                format: heightFormat,
                                value: heights[0],
                                value2: heights[1]
                            }), i = 0, len = locations.length; len > i; ++i) {
                                var lat, lng, latlng, height, heat, place = locations[i];
                                if (place && "string" == typeof place) {
                                    place = place.toLowerCase();
                                    var placeKey = place + "/" + locationType;
                                    !longitudes && globeMapLocationCache[placeKey] ? (latlng = globeMapLocationCache[placeKey], 
                                    lat = latlng.latitude, lng = latlng.longitude) : longitudes && (lat = latitudes[i], 
                                    lng = longitudes[i]), height = heights[i] / maxHeight, heat = heats[i] / maxHeat;
                                    var renderDatum = {
                                        lat: lat,
                                        lng: lng,
                                        height: height ? height || .01 : void 0,
                                        heightBySeries: heightsBySeries[i],
                                        seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : void 0,
                                        heat: heat || 0,
                                        toolTipData: {
                                            location: {
                                                displayName: locationDispName,
                                                value: locations[i]
                                            },
                                            height: {
                                                displayName: heightDispName,
                                                value: heightFormatter.format(heights[i])
                                            },
                                            heat: {
                                                displayName: heatDispName,
                                                value: heatFormatter.format(heats[i])
                                            }
                                        }
                                    };
                                    this.data.push(renderDatum), longitudes || latlng || this.geocodeRenderDatum(renderDatum, place, locationType);
                                }
                            }
                            try {
                                this.renderMagic();
                            } catch (e) {}
                        }
                    }, GlobeMap.prototype.geocodeRenderDatum = function(renderDatum, place, locationType) {
                        var _this = this, placeKey = place + "/" + locationType;
                        this.globeMapLocationCache[placeKey] = {}, this.locationsToLoad++;
                        try {
                            var geocoder = powerbi.visuals.BI.Services.GeocodingManager.geocode;
                        } catch (e) {
                            geocoder = visuals.services.geocode;
                        }
                        geocoder && geocoder(place, locationType).always(function(latlng) {
                            _this.globeMapLocationCache[placeKey] = latlng, _this.locationsLoaded++, latlng.latitude && latlng.longitude && (renderDatum.lat = latlng.latitude, 
                            renderDatum.lng = latlng.longitude, _this.defferedRender());
                        });
                    }, GlobeMap.prototype.defferedRender = function() {
                        var _this = this;
                        this.deferredRenderTimerId || (this.deferredRenderTimerId = setTimeout(function() {
                            _this.deferredRenderTimerId = null, _this.composeRenderData();
                        }, 500));
                    }, GlobeMap.prototype.initRayCaster = function() {
                        var _this = this;
                        this.rayCaster = new THREE.Raycaster();
                        var mouseDownTime, settings = this.settings, mousePosNormalized = this.mousePosNormalized = new THREE.Vector2(), mousePos = this.mousePos = new THREE.Vector2(), element = this.container.get(0);
                        $(this.domElement).on("mousemove", function(event) {
                            var rect = element.getBoundingClientRect();
                            mousePos.x = event.clientX, mousePos.y = event.clientY, mousePosNormalized.x = (event.clientX - rect.left) / rect.width * 2 - 1, 
                            mousePosNormalized.y = 2 * -((event.clientY - rect.top) / rect.height) + 1, _this.needsRender = !0;
                        }).on("mousedown", function(event) {
                            mouseDownTime = Date.now();
                        }).on("mouseup", function(event) {
                            Date.now() - mouseDownTime > settings.clickInterval || (_this.hoveredBar && event.shiftKey ? (_this.selectedBar = _this.hoveredBar, 
                            _this.animateCamera(_this.selectedBar.position, function() {
                                _this.selectedBar && (_this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius)), 
                                _this.orbitControls.minDistance = 1);
                            })) : _this.selectedBar && (_this.animateCamera(_this.selectedBar.position, function() {
                                _this.orbitControls.center.set(0, 0, 0), _this.orbitControls.minDistance = settings.earthRadius + 1;
                            }), _this.selectedBar = null));
                        }).on("mousewheel DOMMouseScroll", function(e) {
                            if (_this.needsRender = !0, _this.orbitControls.enabled && _this.orbitControls.enableZoom) {
                                _this.heatTexture.needsUpdate = !0, e = e.originalEvent;
                                var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1, scale = delta > 0 ? _this.settings.heatmapScaleOnZoom : 1 / _this.settings.heatmapScaleOnZoom;
                                _this.heatmap.multiply(scale), _this.heatmap.update();
                            }
                        });
                    }, GlobeMap.prototype.intersectBars = function() {
                        if (this.rayCaster && this.barsGroup) {
                            var rayCaster = this.rayCaster;
                            rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
                            var intersects = rayCaster.intersectObjects(this.barsGroup.children);
                            if (intersects && intersects.length > 0) {
                                var object = intersects[0].object;
                                if (!object || !object.toolTipData) return;
                                var toolTipData = object.toolTipData, toolTipItems = [];
                                toolTipData.location.displayName && toolTipItems.push(toolTipData.location), toolTipData.series && toolTipItems.push(toolTipData.series), 
                                toolTipData.height.displayName && toolTipItems.push(toolTipData.height), toolTipData.heat.displayName && toolTipItems.push(toolTipData.heat), 
                                this.hoveredBar = object, visuals.TooltipManager.ToolTipInstance.show(toolTipItems, {
                                    x: this.mousePos.x,
                                    y: this.mousePos.y,
                                    width: 0,
                                    height: 0
                                });
                            } else this.hoveredBar = null, visuals.TooltipManager.ToolTipInstance.hide();
                        }
                    }, GlobeMap.prototype.animateCamera = function(to, done) {
                        var _this = this;
                        if (this.camera) {
                            var startTime = Date.now(), duration = this.settings.cameraAnimDuration, endTime = startTime + duration, startPos = this.camera.position.clone().normalize(), endPos = to.clone().normalize(), length = this.camera.position.length(), easeInOut = function(t) {
                                return t *= 2, 1 > t ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
                            }, onUpdate = function() {
                                var now = Date.now(), t = (now - startTime) / duration;
                                t > 1 && (t = 1), t = easeInOut(t);
                                var pos = new THREE.Vector3().add(startPos.clone().multiplyScalar(1 - t)).add(endPos.clone().multiplyScalar(t)).normalize().multiplyScalar(length);
                                _this.camera.position = pos, endTime > now ? requestAnimationFrame(onUpdate) : done && done(), 
                                _this.needsRender = !0;
                            };
                            requestAnimationFrame(onUpdate);
                        }
                    }, GlobeMap.prototype.destroy = function() {
                        if (clearTimeout(this.deferredRenderTimerId), this.renderLoopEnabled = !1, this.scene = null, 
                        this.heatmap = null, this.heatTexture = null, this.camera = null, this.renderer) {
                            if (this.renderer.context) {
                                var extension = this.renderer.context.getExtension("WEBGL_lose_context");
                                extension && extension.loseContext(), this.renderer.context = null;
                            }
                            this.renderer.domElement = null;
                        }
                        this.renderer = null, this.data = null, this.barsGroup = null, this.orbitControls && this.orbitControls.dispose(), 
                        this.orbitControls = null, this.domElement && $(this.domElement).off("mousemove mouseup mousedown mousewheel DOMMouseScroll"), 
                        this.domElement = null, this.container && this.container.empty();
                    }, GlobeMap.prototype.initZoomControl = function() {
                        var _this = this, radius = 17, zoomControlWidth = 8.5 * radius, zoomControlHeight = 8.5 * radius, startX = 3 * radius, startY = radius + 3, gap = 2 * radius, zoomCss = {
                            position: "absolute",
                            left: "calc(100% - " + zoomControlWidth + "px)",
                            top: "calc(100% - " + zoomControlHeight + "px)",
                            zIndex: "1000"
                        }, zoomContainer = d3.select(this.container[0]).append("div").style(zoomCss);
                        this.zoomControl = zoomContainer.append("svg").attr({
                            width: zoomControlWidth,
                            height: zoomControlHeight
                        });
                        var bottom = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(0, -5);
                        });
                        bottom.append("circle").attr({
                            cx: startX + gap,
                            cy: startY + 2 * gap,
                            r: radius,
                            fill: "white",
                            opacity: .5,
                            stroke: "gray"
                        }), bottom.append("path").attr({
                            d: "M" + (startX + 2 * radius) + " " + (startY + 4.7 * radius) + " l12 -20 a40,70 0 0,1 -24,0z",
                            fill: "gray"
                        });
                        var left = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(5, 0);
                        });
                        left.append("circle").attr({
                            cx: startX,
                            cy: startY + gap,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), left.append("path").attr({
                            d: "M" + (startX - radius / 1.5) + " " + (startY + 2 * radius) + " l20 -12 a70,40 0 0,0 0,24z",
                            fill: "gray"
                        });
                        var top = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(0, 5);
                        });
                        top.append("circle").attr({
                            cx: startX + gap,
                            cy: startY,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), top.append("path").attr({
                            d: "M" + (startX + 2 * radius) + " " + (startY - radius / 1.5) + " l12 20 a40,70 0 0,0 -24,0z",
                            fill: "gray"
                        });
                        var right = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(-5, 0);
                        });
                        right.append("circle").attr({
                            cx: startX + 2 * gap,
                            cy: startY + gap,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), right.append("path").attr({
                            d: "M" + (startX + 4.7 * radius) + " " + (startY + 2 * radius) + " l-20 -12 a70,40 0 0,1 0,24z",
                            fill: "gray"
                        });
                        var zoomIn = this.zoomControl.append("g").on("click", function() {
                            return _this.zoomClicked(-1);
                        });
                        zoomIn.append("circle").attr({
                            cx: startX + 4 * radius,
                            cy: startY + 6 * radius,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), zoomIn.append("rect").attr({
                            x: startX + 3.5 * radius,
                            y: startY + 5.9 * radius,
                            width: radius,
                            height: radius / 3,
                            fill: "gray"
                        }), zoomIn.append("rect").attr({
                            x: startX + 4 * radius - radius / 6,
                            y: startY + 5.55 * radius,
                            width: radius / 3,
                            height: radius,
                            fill: "gray"
                        });
                        var zoomOut = this.zoomControl.append("g").on("click", function() {
                            return _this.zoomClicked(1);
                        });
                        zoomOut.append("circle").attr({
                            cx: startX,
                            cy: startY + 6 * radius,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: "0.50"
                        }), zoomOut.append("rect").attr({
                            x: startX - radius / 2,
                            y: startY + 5.9 * radius,
                            width: radius,
                            height: radius / 3,
                            fill: "gray"
                        });
                    }, GlobeMap.prototype.initMercartorSphere = function() {
                        if (!GlobeMap.MercartorSphere) {
                            var MercartorSphere = function(radius, widthSegments, heightSegments) {
                                function interplolate(a, b, t) {
                                    return (1 - t) * a + t * b;
                                }
                                function interpolateVertex(u, v, t) {
                                    var maxLng = 2 * Math.PI, maxLat = Math.PI, radius = this.radius, sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat), sphereY = -radius * Math.cos(v * maxLat), sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat), planeX = u * radius * 2 - radius, planeY = v * radius * 2 - radius, planeZ = 0, x = interplolate(sphereX, planeX, t), y = interplolate(sphereY, planeY, t), z = interplolate(sphereZ, planeZ, t);
                                    return new THREE.Vector3(x, y, z);
                                }
                                function interpolateUV(u, v, t) {
                                    var lat = 90 * (v - .5) * 2 / 180 * Math.PI, sin = Math.sin(lat), normalizedV = .5 + .25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
                                    return new THREE.Vector2(u, normalizedV);
                                }
                                THREE.Geometry.call(this), this.radius = radius, this.widthSegments = widthSegments, 
                                this.heightSegments = heightSegments, this.t = 0;
                                var x, y, vertices = [], uvs = [];
                                for (y = 0; heightSegments >= y; y++) {
                                    var verticesRow = [], uvsRow = [];
                                    for (x = 0; widthSegments >= x; x++) {
                                        var u = x / widthSegments, v = y / heightSegments;
                                        this.vertices.push(interpolateVertex.call(this, u, v, this.t)), uvsRow.push(interpolateUV.call(this, u, v, this.t)), 
                                        verticesRow.push(this.vertices.length - 1);
                                    }
                                    vertices.push(verticesRow), uvs.push(uvsRow);
                                }
                                for (y = 0; y < this.heightSegments; y++) for (x = 0; x < this.widthSegments; x++) {
                                    var v1 = vertices[y][x + 1], v2 = vertices[y][x], v3 = vertices[y + 1][x], v4 = vertices[y + 1][x + 1], n1 = this.vertices[v1].clone().normalize(), n2 = this.vertices[v2].clone().normalize(), n3 = this.vertices[v3].clone().normalize(), n4 = this.vertices[v4].clone().normalize(), uv1 = uvs[y][x + 1].clone(), uv2 = uvs[y][x].clone(), uv3 = uvs[y + 1][x].clone(), uv4 = uvs[y + 1][x + 1].clone(), normals = [ n1, n2, n3, n4 ];
                                    this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals)), this.faceVertexUvs[0].push([ uv1, uv2, uv3, uv4 ]);
                                }
                                this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
                            };
                            MercartorSphere.prototype = Object.create(THREE.Geometry.prototype), GlobeMap.MercartorSphere = MercartorSphere;
                        }
                    }, GlobeMap.prototype.getBingMapCanvas = function(resolution) {
                        function generateQuads(res, quad) {
                            resolution >= res && (res === resolution && loadTile(quad), generateQuads(res + 1, quad + "0"), 
                            generateQuads(res + 1, quad + "1"), generateQuads(res + 1, quad + "2"), generateQuads(res + 1, quad + "3"));
                        }
                        function loadTile(quad) {
                            var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}", numServers = 7, server = Math.round(Math.random() * numServers), language = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language, url = template.replace("{server}", server).replace("{quad}", quad).replace("{language}", language), coords = getCoords(quad), tile = new Image();
                            tile.onload = function() {
                                tilesLoaded++, canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize), 
                                tilesLoaded === numTiles && canvas.trigger("ready", resolution);
                            }, tile.crossOrigin = "", tile.src = url;
                        }
                        function getCoords(quad) {
                            for (var x = 0, y = 0, last = quad.length - 1, i = last; i >= 0; i--) {
                                var chr = quad.charAt(i), pow = Math.pow(2, last - i);
                                "1" === chr ? x += pow : "2" === chr ? y += pow : "3" === chr && (x += pow, y += pow);
                            }
                            return {
                                x: x,
                                y: y
                            };
                        }
                        var tileSize = 256, numSegments = Math.pow(2, resolution), numTiles = numSegments * numSegments, tilesLoaded = 0, canvasSize = tileSize * numSegments, canvas = $("<canvas/>").attr({
                            width: canvasSize,
                            height: canvasSize
                        }), canvasElem = canvas.get(0), canvasContext = canvasElem.getContext("2d");
                        return generateQuads(0, ""), canvas;
                    }, GlobeMap.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                            preferredTypes: [ {
                                geography: {
                                    address: !0
                                }
                            }, {
                                geography: {
                                    city: !0
                                }
                            }, {
                                geography: {
                                    continent: !0
                                }
                            }, {
                                geography: {
                                    country: !0
                                }
                            }, {
                                geography: {
                                    county: !0
                                }
                            }, {
                                geography: {
                                    place: !0
                                }
                            }, {
                                geography: {
                                    postalCode: !0
                                }
                            }, {
                                geography: {
                                    region: !0
                                }
                            }, {
                                geography: {
                                    stateOrProvince: !0
                                }
                            } ]
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "X",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Longitude",
                            description: "Use to override the longitude of locations",
                            preferredTypes: [ {
                                geography: {
                                    longitude: !0
                                }
                            } ]
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Latitude",
                            description: "Use to override the latitude of locations",
                            preferredTypes: [ {
                                geography: {
                                    latitude: !0
                                }
                            } ]
                        }, {
                            name: "Height",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Bar Height"
                        }, {
                            name: "Heat",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Heat Intensity"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        type: {
                                            formatting: {
                                                legendPosition: !0
                                            }
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            },
                            categoryLabels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                Height: {
                                    max: 1
                                },
                                Heat: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Height"
                                            }
                                        }, {
                                            bind: {
                                                to: "Heat"
                                            }
                                        }, {
                                            bind: {
                                                to: "X"
                                            }
                                        }, {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            custom: {}
                        }
                    }, GlobeMap.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        }
                    }, GlobeMap;
                }();
                samples.GlobeMap = GlobeMap;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, RadarChartWebBehavior = function() {
                    function RadarChartWebBehavior() {}
                    return RadarChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var selection = this.selection = options.selection, clearCatcher = options.clearCatcher;
                        selection.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, RadarChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                        this.selection.style("opacity", function(d) {
                            return hasSelection && !d.selected ? RadarChart.DimmedAreaFillOpacity : RadarChart.NodeFillOpacity;
                        });
                    }, RadarChartWebBehavior;
                }();
                samples.RadarChartWebBehavior = RadarChartWebBehavior;
                var RadarChart = function() {
                    function RadarChart(options) {
                        options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                        options.margin && (this.margin = options.margin));
                    }
                    return RadarChart.converter = function(dataView, colors) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories.length > 0 && dataView.categorical.categories[0] && dataView.categorical.values && dataView.categorical.values.length > 0 && colors)) return {
                            legendData: {
                                dataPoints: []
                            },
                            settings: {
                                showLegend: !0
                            },
                            series: [],
                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings()
                        };
                        for (var catDv = dataView.categorical, values = catDv.values, grouped = catDv && catDv.values ? catDv.values.grouped() : null, series = [], colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill), legendData = {
                            fontSize: 8.25,
                            dataPoints: [],
                            title: ""
                        }, legendSettings = RadarChart.parseSettings(dataView), dataLabelsSettings = RadarChart.parseLabelSettings(dataView), i = 0, iLen = values.length; iLen > i; i++) {
                            var serieIdentity, queryName, displayName, color = colors.getColorByIndex(i).value, dataPoints = [], columnGroup = grouped && grouped.length > i && grouped[i].values ? grouped[i] : null;
                            if (values[i].source) {
                                var source = values[i].source;
                                if (source.queryName && (queryName = source.queryName, serieIdentity = visuals.SelectionId.createWithMeasure(queryName)), 
                                source.displayName && (displayName = source.displayName), source.objects) {
                                    var objects = source.objects;
                                    color = colorHelper.getColorForMeasure(objects, queryName);
                                }
                            }
                            legendData.dataPoints.push({
                                label: displayName,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: serieIdentity
                            });
                            for (var k = 0, kLen = values[i].values.length; kLen > k; k++) {
                                var dataPointIdentity = visuals.SelectionIdBuilder.builder().withMeasure(queryName).withCategory(catDv.categories[0], k).withSeries(dataView.categorical.values, columnGroup).createSelectionId(), tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i), labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp), fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                                dataPoints.push({
                                    x: k,
                                    y: values[i].values[k],
                                    color: color,
                                    identity: dataPointIdentity,
                                    selected: !1,
                                    tooltipInfo: tooltipInfo,
                                    value: values[i].values[k],
                                    labelFormatString: labelFormatString,
                                    labelFontSize: fontSizeInPx
                                });
                            }
                            dataPoints.length > 0 && series.push({
                                fill: color,
                                name: displayName,
                                data: dataPoints,
                                identity: serieIdentity
                            });
                        }
                        return {
                            legendData: legendData,
                            settings: legendSettings,
                            series: series,
                            dataLabelsSettings: dataLabelsSettings
                        };
                    }, RadarChart.prototype.init = function(options) {
                        var element = options.element;
                        this.svg || (this.svg = d3.select(element.get(0)).append("svg"), this.svg.style("position", "absolute")), 
                        this.margin || (this.margin = RadarChart.DefaultMargin), this.svg.classed(RadarChart.VisualClassName, !0), 
                        this.interactivityService = visuals.createInteractivityService(options.host), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                        this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top), 
                        this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = this.svg.append("g"), 
                        this.segments = this.mainGroupElement.append("g").classed(RadarChart.Segments["class"], !0), 
                        this.zeroSegment = this.mainGroupElement.append("g").classed(RadarChart.ZeroSegment["class"], !0), 
                        this.axis = this.mainGroupElement.append("g").classed(RadarChart.Axis["class"], !0), 
                        this.chart = this.mainGroupElement.append("g").classed(RadarChart.Chart["class"], !0);
                    }, RadarChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var dataView = options.dataViews[0];
                            this.radarChartData = RadarChart.converter(dataView, this.colors);
                            var dataViewMetadataColumn, categories = [], series = this.radarChartData.series, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
                            dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && (categories = dataView.categorical.categories[0].values), 
                            dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0 && (dataViewMetadataColumn = dataView.metadata.columns[0]), 
                            this.viewport = {
                                height: options.viewport.height > 0 ? options.viewport.height : 0,
                                width: options.viewport.width > 0 ? options.viewport.width : 0
                            }, this.parseLegendProperties(dataView), this.renderLegend(this.radarChartData), 
                            this.updateViewport(), this.svg.attr({
                                height: this.viewport.height,
                                width: this.viewport.width
                            });
                            var mainGroup = this.mainGroupElement;
                            mainGroup.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                            var width = this.viewport.width - this.margin.left - this.margin.right, height = this.viewport.height - this.margin.top - this.margin.bottom;
                            this.angle = RadarChart.Radians / categories.length, this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2, 
                            this.drawCircularSegments(categories), this.drawAxes(categories), this.drawAxesLabels(categories, dataViewMetadataColumn), 
                            this.drawChart(series, duration), this.drawDataLabels(series), this.drawZeroCircularSegment(categories), 
                            0 !== this.zeroPointRadius ? this.drawZeroLabel() : this.mainGroupElement.selectAll(RadarChart.ZeroLabel.selector).remove();
                        }
                    }, RadarChart.prototype.getRadarChartLabelLayout = function(labelSettings, allDataPoints) {
                        var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), angle = this.angle, viewport = this.viewport, halfHeight = this.viewport.height / 2, halfWidth = this.viewport.width / 2, y = this.calculateChartDomain(this.radarChartData.series);
                        return {
                            labelText: function(d) {
                                var formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);
                                if (0 === labelSettings.displayUnits) {
                                    var maxDataPoint = _.max(allDataPoints, function(d) {
                                        return d.value;
                                    }), maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;
                                    formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);
                                }
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: formmater.format(d.value),
                                    maxWidth: viewport.width,
                                    fontSize: labelSettings.fontSize
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth;
                                },
                                y: function(d) {
                                    return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 7;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.value;
                            },
                            style: {
                                fill: labelSettings.labelColor,
                                "font-size": function(d) {
                                    return PixelConverter.fromPoint(labelSettings.fontSize);
                                }
                            }
                        };
                    }, RadarChart.prototype.drawCircularSegments = function(values) {
                        for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius, level = 0; levels - 1 > level; level++) for (var levelFactor = radius * ((level + 1) / levels), transform = -1 * levelFactor, i = 0; i < values.length; i++) data.push({
                            x1: levelFactor * (1 - factor * Math.sin(i * angle)),
                            y1: levelFactor * (1 - factor * Math.cos(i * angle)),
                            x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
                            y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
                            translate: visuals.SVGUtil.translate(transform, transform)
                        });
                        var selection = this.mainGroupElement.select(RadarChart.Segments.selector).selectAll(RadarChart.SegmentNode.selector).data(data);
                        selection.enter().append("svg:line").classed(RadarChart.SegmentNode["class"], !0), 
                        selection.attr({
                            x1: function(item) {
                                return item.x1;
                            },
                            y1: function(item) {
                                return item.y1;
                            },
                            x2: function(item) {
                                return item.x2;
                            },
                            y2: function(item) {
                                return item.y2;
                            },
                            transform: function(item) {
                                return item.translate;
                            }
                        }), selection.exit().remove();
                    }, RadarChart.prototype.drawDataLabels = function(series) {
                        var allDataPoints = this.getAllDataPointsList(series);
                        if (this.radarChartData.dataLabelsSettings.show) {
                            var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints), viewport = this.viewport, labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);
                            labels.attr("transform", visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));
                        } else visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);
                    }, RadarChart.prototype.drawAxes = function(values) {
                        var angle = this.angle, radius = -1 * this.radius, selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisNode.selector), axis = selection.data(values);
                        axis.enter().append("svg:line"), axis.attr({
                            x1: 0,
                            y1: 0,
                            x2: function(name, i) {
                                return radius * Math.sin(i * angle);
                            },
                            y2: function(name, i) {
                                return radius * Math.cos(i * angle);
                            }
                        }).classed(RadarChart.AxisNode["class"], !0), axis.exit().remove();
                    }, RadarChart.prototype.drawAxesLabels = function(values, dataViewMetadataColumn) {
                        var _this = this, angle = this.angle, radius = -1 * this.radius, length = values.length, formatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, !0),
                            value: values[0],
                            value2: values[length - 1]
                        }), selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisLabel.selector), labels = selection.data(values);
                        labels.enter().append("svg:text"), labels.attr({
                            "text-anchor": "middle",
                            dy: "1.5em",
                            transform: visuals.SVGUtil.translate(0, -10),
                            x: function(name, i) {
                                return (radius - 30) * Math.sin(i * angle);
                            },
                            y: function(name, i) {
                                return (radius - 20) * Math.cos(i * angle);
                            }
                        }).text(function(item) {
                            var properties = {
                                fontFamily: RadarChart.AxesLabelsFontFamily,
                                fontSize: RadarChart.AxesLabelsfontSize,
                                text: formatter.format(item)
                            };
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, Math.min(RadarChart.AxesLabelsMaxWidth, _this.viewport.width));
                        }).classed(RadarChart.AxisLabel["class"], !0), labels.exit().remove();
                    }, RadarChart.prototype.drawChart = function(series, duration) {
                        var angle = this.angle, dotRadius = 5, dataPoints = this.getDataPoints(series), stack = d3.layout.stack(), layers = stack(dataPoints), y = this.calculateChartDomain(series), calculatePoints = function(points) {
                            return points.map(function(value) {
                                var x1 = -1 * y(value.y) * Math.sin(value.x * angle), y1 = -1 * y(value.y) * Math.cos(value.x * angle);
                                return x1 + "," + y1;
                            }).join(" ");
                        }, areas = this.chart.selectAll(RadarChart.ChartArea.selector).data(layers);
                        areas.enter().append("g").classed(RadarChart.ChartArea["class"], !0);
                        var polygon = areas.selectAll(RadarChart.ChartPolygon.selector).data(function(d) {
                            return d && d.length > 0 ? [ d ] : [];
                        });
                        polygon.enter().append("polygon").classed(RadarChart.ChartPolygon["class"], !0), 
                        polygon.style("fill", function(d) {
                            return d[0].color;
                        }).style("opacity", RadarChart.DimmedAreaFillOpacity).on("mouseover", function(d) {
                            d3.select(this).transition().duration(duration).style("opacity", RadarChart.AreaFillOpacity);
                        }).on("mouseout", function(d) {
                            d3.select(this).transition().duration(duration).style("opacity", RadarChart.DimmedAreaFillOpacity);
                        }).attr("points", calculatePoints), polygon.exit().remove(), areas.exit().remove();
                        var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
                        selection.enter().append("g").classed(RadarChart.ChartNode["class"], !0);
                        var dots = selection.selectAll(RadarChart.ChartDot.selector).data(function(d) {
                            return d.filter(function(d) {
                                return null != d.y;
                            });
                        });
                        dots.enter().append("svg:circle").classed(RadarChart.ChartDot["class"], !0), dots.attr("r", dotRadius).attr({
                            cx: function(value) {
                                return -1 * y(value.y) * Math.sin(value.x * angle);
                            },
                            cy: function(value) {
                                return -1 * y(value.y) * Math.cos(value.x * angle);
                            }
                        }).style("fill", function(d) {
                            return d.color;
                        }), dots.exit().remove(), visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), selection.exit().remove();
                        var behaviorOptions = void 0;
                        if (this.interactivityService) {
                            var dataPointsToBind = this.getAllDataPointsList(series);
                            behaviorOptions = {
                                selection: dots,
                                clearCatcher: this.svg
                            }, this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);
                        }
                    }, RadarChart.prototype.calculateChartDomain = function(series) {
                        var radius = this.radius, dataPointsList = this.getAllDataPointsList(series), minValue = d3.min(dataPointsList, function(d) {
                            return d.y;
                        }), maxValue = d3.max(dataPointsList, function(d) {
                            return d.y;
                        });
                        this.isPercentChart(dataPointsList) && (minValue = minValue >= 0 ? 0 : -1, maxValue = 0 >= maxValue ? 0 : 1);
                        var y = d3.scale.linear().domain([ minValue, maxValue ]).range([ 0, radius ]);
                        return this.zeroPointRadius = 0 > minValue && maxValue > 0 ? y(0) : 0, y;
                    }, RadarChart.prototype.renderLegend = function(radarChartData) {
                        if (radarChartData.legendData) {
                            var legendData = radarChartData.legendData;
                            if (this.legendObjectProperties) {
                                visuals.LegendData.update(legendData, this.legendObjectProperties);
                                var position = this.legendObjectProperties[visuals.legendProps.position];
                                position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                            var viewport = this.viewport;
                            this.legend.drawLegend(legendData, {
                                height: viewport.height,
                                width: viewport.width
                            }), visuals.Legend.positionChartArea(this.svg, this.legend);
                        }
                    }, RadarChart.prototype.drawZeroCircularSegment = function(values) {
                        for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, radius = this.zeroPointRadius, transform = -1 * radius, i = 0; i < values.length; i++) data.push({
                            x1: radius * (1 - factor * Math.sin(i * angle)),
                            y1: radius * (1 - factor * Math.cos(i * angle)),
                            x2: radius * (1 - factor * Math.sin((i + 1) * angle)),
                            y2: radius * (1 - factor * Math.cos((i + 1) * angle)),
                            translate: visuals.SVGUtil.translate(transform, transform)
                        });
                        var selection = this.mainGroupElement.select(RadarChart.ZeroSegment.selector).selectAll(RadarChart.ZeroSegmentNode.selector).data(data);
                        selection.enter().append("svg:line").classed(RadarChart.ZeroSegmentNode["class"], !0), 
                        selection.attr({
                            x1: function(item) {
                                return item.x1;
                            },
                            y1: function(item) {
                                return item.y1;
                            },
                            x2: function(item) {
                                return item.x2;
                            },
                            y2: function(item) {
                                return item.y2;
                            },
                            transform: function(item) {
                                return item.translate;
                            }
                        }), selection.exit().remove();
                    }, RadarChart.prototype.drawZeroLabel = function() {
                        var data = [];
                        data.push({
                            x: this.zeroPointRadius * (1 - RadarChart.SegmentFactor) + 5,
                            y: -1 * this.zeroPointRadius
                        });
                        var zeroLabel = this.mainGroupElement.select(RadarChart.ZeroSegment.selector).selectAll(RadarChart.ZeroLabel.selector).data(data);
                        zeroLabel.enter().append("text").classed(RadarChart.ZeroLabel["class"], !0).text("0"), 
                        zeroLabel.attr({
                            x: function(item) {
                                return item.x;
                            },
                            y: function(item) {
                                return item.y;
                            }
                        });
                    }, RadarChart.prototype.getDataPoints = function(series) {
                        for (var dataPoints = [], i = 0; i < series.length; i++) dataPoints.push(series[i].data);
                        return dataPoints;
                    }, RadarChart.prototype.getAllDataPointsList = function(series) {
                        for (var dataPoints = [], i = 0; i < series.length; i++) dataPoints = dataPoints.concat(series[i].data);
                        return dataPoints;
                    }, RadarChart.prototype.isPercentChart = function(dataPointsList) {
                        for (var i = 0; i < dataPointsList.length; i++) if (-1 === dataPointsList[i].labelFormatString.indexOf("%")) return !1;
                        return !0;
                    }, RadarChart.prototype.parseLegendProperties = function(dataView) {
                        return dataView && dataView.metadata ? void (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})) : void (this.legendObjectProperties = {});
                    }, RadarChart.parseSettings = function(dataView) {
                        var objects;
                        return objects = dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null, 
                        {
                            showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, !0)
                        };
                    }, RadarChart.parseLabelSettings = function(dataView) {
                        var objects;
                        objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null;
                        var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), labelsObj = {
                            show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),
                            displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),
                            precision: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),
                            fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),
                            position: dataLabelsSettings.position
                        };
                        return labelsObj;
                    }, RadarChart.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.radarChartData || !this.radarChartData.settings) return [];
                        switch (settings = this.radarChartData.settings, options.objectName) {
                          case "legend":
                            enumeration.pushInstance(this.enumerateLegend(settings));
                            break;

                          case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration);
                        }
                        return enumeration.complete();
                    }, RadarChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings) {
                        return {
                            enumeration: enumeration,
                            dataLabelsSettings: labelSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0,
                            fontSize: !0
                        };
                    }, RadarChart.prototype.enumerateDataLabels = function(enumeration) {
                        var labelSettings = this.radarChartData.dataLabelsSettings;
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));
                    }, RadarChart.prototype.enumerateLegend = function(settings) {
                        var legend, labelColor, showTitle = !0, titleText = "", fontSize = 8;
                        return showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                        titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                        labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor), 
                        fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize), 
                        legend = {
                            objectName: "legend",
                            displayName: "legend",
                            selector: null,
                            properties: {
                                show: settings.showLegend,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                labelColor: labelColor,
                                fontSize: fontSize
                            }
                        };
                    }, RadarChart.prototype.enumerateDataPoint = function(enumeration) {
                        if (this.radarChartData && this.radarChartData.series) for (var series = this.radarChartData.series, i = 0; i < series.length; i++) {
                            var serie = series[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: serie.name,
                                selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: serie.fill
                                        }
                                    }
                                }
                            });
                        }
                    }, RadarChart.prototype.updateViewport = function() {
                        var legendPosition, legendMargins = this.legend.getMargins();
                        switch (legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]]) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                        }
                    }, RadarChart.capabilities = {
                        dataRoles: [ {
                            displayName: "Category",
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: "Y Axis",
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 1,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                        placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, RadarChart.formatStringProp = {
                        objectName: "general",
                        propertyName: "formatString"
                    }, RadarChart.Properties = {
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            displayUnits: {
                                objectName: "labels",
                                propertyName: "labelDisplayUnits"
                            },
                            precision: {
                                objectName: "labels",
                                propertyName: "labelPrecision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        }
                    }, RadarChart.VisualClassName = "radarChart", RadarChart.Segments = CreateClassAndSelector("segments"), 
                    RadarChart.SegmentNode = CreateClassAndSelector("segmentNode"), RadarChart.ZeroSegment = CreateClassAndSelector("zeroSegment"), 
                    RadarChart.ZeroSegmentNode = CreateClassAndSelector("zeroSegmentNode"), RadarChart.ZeroLabel = CreateClassAndSelector("zeroLabel"), 
                    RadarChart.Axis = CreateClassAndSelector("axis"), RadarChart.AxisNode = CreateClassAndSelector("axisNode"), 
                    RadarChart.AxisLabel = CreateClassAndSelector("axisLabel"), RadarChart.Chart = CreateClassAndSelector("chart"), 
                    RadarChart.ChartNode = CreateClassAndSelector("chartNode"), RadarChart.ChartArea = CreateClassAndSelector("chartArea"), 
                    RadarChart.ChartPolygon = CreateClassAndSelector("chartPolygon"), RadarChart.ChartDot = CreateClassAndSelector("chartDot"), 
                    RadarChart.DefaultMargin = {
                        top: 50,
                        bottom: 50,
                        right: 100,
                        left: 100
                    }, RadarChart.SegmentLevels = 6, RadarChart.SegmentFactor = 1, RadarChart.Radians = 2 * Math.PI, 
                    RadarChart.Scale = 1, RadarChart.NodeFillOpacity = 1, RadarChart.AreaFillOpacity = .6, 
                    RadarChart.DimmedAreaFillOpacity = .4, RadarChart.AxesLabelsFontFamily = "sans-serif", 
                    RadarChart.AxesLabelsfontSize = "11px", RadarChart.AxesLabelsMaxWidth = 200, RadarChart;
                }();
                samples.RadarChart = RadarChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, HistogramChartWarning = function() {
                    function HistogramChartWarning(message) {
                        this.message = message;
                    }
                    return Object.defineProperty(HistogramChartWarning.prototype, "code", {
                        get: function() {
                            return "BulletChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), HistogramChartWarning.prototype.getMessages = function(resourceProvider) {
                        return {
                            message: this.message,
                            title: resourceProvider.get(""),
                            detail: resourceProvider.get("")
                        };
                    }, HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big", 
                    HistogramChartWarning;
                }();
                samples.HistogramChartWarning = HistogramChartWarning;
                var Histogram = function() {
                    function Histogram(histogramConstructorOptions) {
                        this.ColumnPadding = 1, this.MinColumnHeight = 1, this.MinOpacity = .3, this.MaxOpacity = 1, 
                        this.TooltipDisplayName = "Range", this.SeparatorNumbers = ", ", this.LegendSize = 50, 
                        this.YLegendSize = 50, this.XLegendSize = 50, this.AxisSize = 30, this.DataLabelMargin = 0, 
                        this.widthOfColumn = 0, this.yTitleMargin = 0, this.outerPadding = 5, this.ExcludeBrackets = {
                            left: "(",
                            right: ")"
                        }, this.IncludeBrackets = {
                            left: "[",
                            right: "]"
                        }, this.margin = {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }, this.durationAnimations = 200, this.oldInnerPaddingRatio = visuals.CartesianChart.InnerPaddingRatio, 
                        this.oldMinOrdinalRectThickness = visuals.CartesianChart.MinOrdinalRectThickness, 
                        this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: PixelConverter.toString(9)
                        }, histogramConstructorOptions && (histogramConstructorOptions.svg && (this.svg = histogramConstructorOptions.svg), 
                        histogramConstructorOptions.animator && (this.animator = histogramConstructorOptions.animator), 
                        this.margin = histogramConstructorOptions.margin || this.margin);
                    }
                    return Object.defineProperty(Histogram.prototype, "columnsSelection", {
                        get: function() {
                            return this.main.select(Histogram.Columns.selector).selectAll(Histogram.Column.selector);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Histogram.prototype.init = function(visualsOptions) {
                        this.hostService = visualsOptions.host, this.svg ? this.root = this.svg : this.root = d3.select(visualsOptions.element.get(0)).append("svg");
                        var style = visualsOptions.style;
                        this.colors = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                        this.root.classed(Histogram.ClassName, !0), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(Histogram.Axes["class"], !0), 
                        this.axisX = this.axes.append("g").classed(Histogram.Axis["class"], !0), this.axisY = this.axes.append("g").classed(Histogram.Axis["class"], !0), 
                        this.legend = this.main.append("g").classed(Histogram.Legends["class"], !0), this.columns = this.main.append("g").classed(Histogram.Columns["class"], !0), 
                        this.labels = this.main.append("g").classed(Histogram.Labels["class"], !0), this.selectionManager = new SelectionManager({
                            hostServices: visualsOptions.host
                        });
                    }, Histogram.prototype.converter = function(dataView) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0)) return null;
                        var settings, histogramLayout, values, data, xScale, yScale, valueFormatter, xLabelFormatter, yLabelFormatter, numericalValues = [], frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0;
                        if (dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && (frequencies = dataView.categorical.values[0].values), 
                        dataView.categorical.categories[0].identity && dataView.categorical.categories[0].identity.length > 0 && (identities = dataView.categorical.categories[0].identity), 
                        settings = this.parseSettings(dataView), !settings) return null;
                        values = Histogram.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities), 
                        values.forEach(function(value) {
                            numericalValues.push(value.value), sumFrequency += value.frequency;
                        }), histogramLayout = d3.layout.histogram(), settings.bins && settings.bins > Histogram.MinNumberOfBins && (histogramLayout = histogramLayout.bins(settings.bins)), 
                        data = histogramLayout.frequency(settings.frequency)(numericalValues), data.forEach(function(bin, index) {
                            var filteredValues, frequency;
                            filteredValues = values.filter(function(value) {
                                return Histogram.isValueContainedInRange(value, bin, index);
                            }), frequency = filteredValues.reduce(function(previousValue, currentValue) {
                                return previousValue + currentValue.frequency;
                            }, 0), bin.y = settings.frequency ? frequency : frequency / sumFrequency, shiftByValues += bin.length;
                        });
                        var yAxisSettings = settings.yAxisSettings, maxYvalue = null !== yAxisSettings.end && yAxisSettings.end > yAxisSettings.start ? yAxisSettings.end : d3.max(data, function(item) {
                            return item.y;
                        }), minYValue = yAxisSettings.start < maxYvalue ? yAxisSettings.start : 0;
                        return settings.yAxisSettings.end = maxYvalue, settings.yAxisSettings.start = minYValue, 
                        settings.maxX = d3.max(data, function(item) {
                            return d3.max(item);
                        }), xScale = d3.scale.linear().domain([ d3.min(data, function(item) {
                            return d3.min(item);
                        }), d3.max(data, function(item) {
                            return d3.max(item);
                        }) ]).range([ 0, this.viewport.width - this.YLegendSize - this.AxisSize ]), yScale = d3.scale.linear().domain([ minYValue, maxYvalue ]).range([ this.viewport.height - this.LegendSize, this.outerPadding ]), 
                        valueFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties.general.formatString),
                            value: values[0].value,
                            value2: values[values.length - 1].value,
                            precision: settings.precision
                        }), xLabelFormatter = ValueFormatter.create({
                            value: 0 === settings.xAxisSettings.displayUnits ? values[values.length - 1].value : settings.xAxisSettings.displayUnits,
                            precision: settings.xAxisSettings.precision
                        }), yLabelFormatter = ValueFormatter.create({
                            value: settings.yAxisSettings.displayUnits,
                            precision: settings.yAxisSettings.precision
                        }), {
                            xScale: xScale,
                            yScale: yScale,
                            settings: settings,
                            data: this.getData(values, numericalValues, data, settings, yLabelFormatter, xLabelFormatter),
                            formatter: valueFormatter,
                            xLabelFormatter: xLabelFormatter,
                            yLabelFormatter: yLabelFormatter
                        };
                    }, Histogram.getValuesByFrequencies = function(sourceValues, frequencies, identities) {
                        var values = [];
                        return sourceValues.forEach(function(item, index) {
                            var frequency = 1, value = Number(item);
                            value = isNaN(value) ? 0 : value, frequencies && frequencies[index] && !isNaN(frequencies[index]) && frequencies[index] > 1 && (frequency = frequencies[index]), 
                            values.push({
                                value: value,
                                frequency: frequency,
                                selectionId: visuals.SelectionId.createWithId(identities[index])
                            });
                        }), values;
                    }, Histogram.prototype.getData = function(values, numericalValues, data, settings, yValueFormatter, xValueFormatter) {
                        var _this = this, minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues), fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize);
                        return data.map(function(bin, index) {
                            return bin.range = Histogram.getRange(minValue, maxValue, bin.dx, index), bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, 0 === index, yValueFormatter, xValueFormatter), 
                            bin.selectionIds = Histogram.getSelectionIds(values, bin, index), bin.labelFontSize = fontSizeInPx, 
                            bin;
                        });
                    }, Histogram.getRange = function(minValue, maxValue, step, index) {
                        var leftBorder = minValue + index * step, rightBorder = leftBorder + step;
                        return [ leftBorder, rightBorder ];
                    }, Histogram.prototype.getTooltipData = function(value, range, settings, includeLeftBorder, yValueFormatter, xValueFormatter) {
                        return [ {
                            displayName: Histogram.getLegendText(settings),
                            value: yValueFormatter.format(value)
                        }, {
                            displayName: this.TooltipDisplayName,
                            value: this.rangeToString(range, includeLeftBorder, xValueFormatter)
                        } ];
                    }, Histogram.getSelectionIds = function(values, bin, index) {
                        var selectionIds = [];
                        return values.forEach(function(value) {
                            Histogram.isValueContainedInRange(value, bin, index) && selectionIds.push(value.selectionId);
                        }), selectionIds;
                    }, Histogram.isValueContainedInRange = function(value, bin, index) {
                        return (0 === index && value.value >= bin.x || value.value > bin.x) && value.value <= bin.x + bin.dx;
                    }, Histogram.prototype.parseSettings = function(dataView) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var objects, colorHelper, histogramSettings = {};
                        colorHelper = new visuals.ColorHelper(this.colors, Histogram.Properties.dataPoint.fill, Histogram.DefaultHistogramSettings.fillColor), 
                        histogramSettings.displayName = dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName, 
                        objects = Histogram.getObjectsFromDataView(dataView);
                        var xAxisSettings = {
                            axisColor: Histogram.getXAxisColor(objects).solid.color,
                            title: Histogram.getXTitle(objects),
                            precision: Histogram.getXPrecision(objects),
                            style: Histogram.getXStyle(objects),
                            displayUnits: Histogram.getXDisplayUnit(objects),
                            show: Histogram.getXAxisShow(objects)
                        }, yAxisSettings = {
                            axisColor: Histogram.getYAxisColor(objects).solid.color,
                            title: Histogram.getYTitle(objects),
                            precision: Histogram.getYPrecision(objects),
                            style: Histogram.getYStyle(objects),
                            displayUnits: Histogram.getYDisplayUnit(objects),
                            show: Histogram.getYAxisShow(objects),
                            start: Histogram.getYStart(objects),
                            end: Histogram.getYEnd(objects),
                            position: Histogram.getYPosition(objects)
                        }, labelSettings = {
                            show: Histogram.getLabelShow(objects),
                            color: Histogram.getLabelColor(objects).solid.color,
                            displayUnits: Histogram.getLabelDisplayUnits(objects),
                            precision: Histogram.getLabelPrecision(objects),
                            fontSize: Histogram.getLabelFontSize(objects)
                        };
                        return histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, ""), 
                        histogramSettings.bins = Histogram.getBins(objects), histogramSettings.frequency = Histogram.getFrequency(objects), 
                        histogramSettings.precision = Histogram.getPrecision(objects), histogramSettings.displayName = Histogram.getLegend(histogramSettings.displayName, xAxisSettings.style, xAxisSettings.displayUnits), 
                        histogramSettings.xAxisSettings = xAxisSettings, histogramSettings.yAxisSettings = yAxisSettings, 
                        histogramSettings.labelSettings = labelSettings, histogramSettings;
                    }, Histogram.getLegend = function(title, style, displayUnit) {
                        var retValue, formatter = ValueFormatter.create({
                            value: displayUnit
                        });
                        switch (style) {
                          case visuals.axisStyle.showTitleOnly:
                            retValue = title;
                            break;

                          case visuals.axisStyle.showUnitOnly:
                            retValue = 0 === displayUnit || 1 === displayUnit ? title : formatter.displayUnit.title;
                            break;

                          case visuals.axisStyle.showBoth:
                            retValue = 0 === displayUnit || 1 === displayUnit ? title : title + " (" + formatter.displayUnit.title + ")";
                        }
                        return retValue;
                    }, Histogram.getLabelFontSize = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.fontSize, Histogram.DefaultHistogramSettings.labelSettings.fontSize);
                    }, Histogram.getLabelShow = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.show, Histogram.DefaultHistogramSettings.labelSettings.show);
                    }, Histogram.getLabelColor = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.color, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.labelSettings.color
                            }
                        });
                    }, Histogram.getLabelDisplayUnits = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.displayUnits, Histogram.DefaultHistogramSettings.labelSettings.displayUnits);
                    }, Histogram.getLabelPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.precision, Histogram.DefaultHistogramSettings.labelSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.getXStyle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.style, Histogram.DefaultHistogramSettings.xAxisSettings.style);
                    }, Histogram.getXDisplayUnit = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.displayUnits, Histogram.DefaultHistogramSettings.xAxisSettings.displayUnits);
                    }, Histogram.getXPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.precision, Histogram.DefaultHistogramSettings.xAxisSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.getXAxisShow = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.show, Histogram.DefaultHistogramSettings.xAxisSettings.show);
                    }, Histogram.getXAxisColor = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.axisColor, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.xAxisSettings.axisColor
                            }
                        });
                    }, Histogram.getXTitle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.title, Histogram.DefaultHistogramSettings.xAxisSettings.title);
                    }, Histogram.getYStyle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.style, Histogram.DefaultHistogramSettings.yAxisSettings.style);
                    }, Histogram.getYPosition = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.position, Histogram.DefaultHistogramSettings.yAxisSettings.position);
                    }, Histogram.getYAxisShow = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.show, Histogram.DefaultHistogramSettings.yAxisSettings.show);
                    }, Histogram.getYAxisColor = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.axisColor, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.yAxisSettings.axisColor
                            }
                        });
                    }, Histogram.getYStart = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.start, Histogram.DefaultHistogramSettings.yAxisSettings.start);
                    }, Histogram.getYEnd = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.end, Histogram.DefaultHistogramSettings.yAxisSettings.end);
                    }, Histogram.getYDisplayUnit = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.displayUnits, Histogram.DefaultHistogramSettings.yAxisSettings.displayUnits);
                    }, Histogram.getYPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.precision, Histogram.DefaultHistogramSettings.yAxisSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.getYTitle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.title, Histogram.DefaultHistogramSettings.yAxisSettings.title);
                    }, Histogram.getBins = function(objects) {
                        var binsNumber = Number(powerbi.DataViewObjects.getValue(objects, Histogram.Properties.general.bins, Histogram.DefaultHistogramSettings.bins));
                        return !binsNumber || isNaN(binsNumber) || binsNumber <= Histogram.MinNumberOfBins ? Histogram.DefaultHistogramSettings.bins : binsNumber > Histogram.MaxNumberOfBins ? Histogram.MaxNumberOfBins : binsNumber;
                    }, Histogram.getFrequency = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.general.frequency, Histogram.DefaultHistogramSettings.frequency);
                    }, Histogram.getPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.precision, Histogram.DefaultHistogramSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.prototype.validateData = function(data) {
                        return data && data.data.some(function(x) {
                            return x.range.some(function(x) {
                                return isNaN(x) || x === 1 / 0 || x === -(1 / 0);
                            });
                        }) ? (this.hostService.setWarnings([ new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues) ]), 
                        !1) : !0;
                    }, Histogram.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0]) {
                            visuals.CartesianChart.InnerPaddingRatio = 1;
                            var dataView = visualUpdateOptions.dataViews[0];
                            if (this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                            this.setSize(visualUpdateOptions.viewport), this.histogramDataView = this.converter(dataView), 
                            this.validateData(this.histogramDataView) || (this.histogramDataView.data = []), 
                            this.histogramDataView) {
                                this.YLegendSize = this.histogramDataView.settings.yAxisSettings.title ? 50 : 25, 
                                this.XLegendSize = this.histogramDataView.settings.xAxisSettings.title ? 50 : 25, 
                                this.fixXTicSize(), this.xAxisProperties = this.calculateXAxes(dataView.categorical.categories[0].source, this.textProperties, !1);
                                var ySource = dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values ? dataView.categorical.values[0].source : dataView.categorical.categories[0].source;
                                this.yAxisProperties = this.calculateYAxes(ySource, this.textProperties, !1), this.render(), 
                                visuals.CartesianChart.InnerPaddingRatio = this.oldInnerPaddingRatio, visuals.CartesianChart.MinOrdinalRectThickness = this.oldMinOrdinalRectThickness;
                            }
                        }
                    }, Histogram.prototype.fixXTicSize = function() {
                        if (this.histogramDataView && this.histogramDataView.settings) {
                            var ticLabel = this.histogramDataView.xLabelFormatter.format(this.histogramDataView.settings.maxX), textProperties = {
                                text: ticLabel,
                                fontFamily: this.textProperties.fontFamily,
                                fontSize: this.textProperties.fontSize
                            }, widthOfLabel = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                            visuals.CartesianChart.MinOrdinalRectThickness = widthOfLabel + 3;
                        }
                    }, Histogram.prototype.setSize = function(viewport) {
                        var height, width;
                        height = viewport.height - this.margin.top - this.margin.bottom, width = viewport.width - this.margin.left - this.margin.right, 
                        this.viewport = {
                            height: height,
                            width: width
                        }, this.updateElements(viewport.height, viewport.width);
                    }, Histogram.prototype.updateElements = function(height, width) {
                        this.root.attr({
                            height: height,
                            width: width
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.legend.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.XLegendSize));
                    }, Histogram.prototype.shouldShowYOnRight = function() {
                        return this.histogramDataView.settings.yAxisSettings.position === visuals.yAxisPosition.right;
                    }, Histogram.prototype.columsAndAxesTransform = function(labelWidth) {
                        var constMargin = 20, shiftToRight = this.shouldShowYOnRight() ? 10 : this.histogramDataView.settings.yAxisSettings.title ? this.margin.left + labelWidth + constMargin : this.margin.left + labelWidth;
                        this.DataLabelMargin = shiftToRight, this.columns.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0)), 
                        this.axes.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0)), this.axisY.attr("transform", visuals.SVGUtil.translate(this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - this.YLegendSize + .01 : 0, 0)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.XLegendSize));
                    }, Histogram.prototype.render = function() {
                        if (this.histogramDataView && this.histogramDataView.settings) {
                            this.renderAxes();
                            var columnsSelection = this.renderColumns();
                            this.adjustTransformToAxisLabels(), this.renderLegend(), this.histogramDataView.settings.labelSettings.show ? this.renderLabels() : this.main.selectAll(".labels").selectAll("*").remove(), 
                            this.bindSelectionHandler(columnsSelection);
                        }
                    }, Histogram.prototype.adjustTransformToAxisLabels = function() {
                        var maxWidthOfLabael = 0;
                        this.main.selectAll("g.axis").filter(function(d, index) {
                            return 1 === index;
                        }).selectAll("g.tick text").each(function(d, i) {
                            var p = powerbi.TextMeasurementService.getSvgMeasurementProperties(this), textProperties = {
                                text: p.text,
                                fontFamily: p.fontFamily,
                                fontSize: p.fontSize
                            }, widthOfLabel = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                            widthOfLabel > maxWidthOfLabael && (maxWidthOfLabael = widthOfLabel);
                        });
                        var constMargin = 70;
                        this.yTitleMargin = this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - constMargin + this.YLegendSize + maxWidthOfLabael : 0, 
                        this.columsAndAxesTransform(maxWidthOfLabael);
                    }, Histogram.prototype.renderColumns = function() {
                        var widthOfColumn, updateColumnsSelection, _this = this, data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length;
                        return widthOfColumn = countOfValues && (this.viewport.width - this.AxisSize - this.YLegendSize) / countOfValues - this.ColumnPadding, 
                        0 > widthOfColumn && (widthOfColumn = 0), this.widthOfColumn = widthOfColumn, updateColumnsSelection = this.columnsSelection.data(data), 
                        updateColumnsSelection.enter().append("svg:rect"), updateColumnsSelection.attr("x", this.ColumnPadding / 2).attr("width", widthOfColumn).attr("height", function(item) {
                            return _this.getColumnHeight(item, yScale);
                        }).style("fill", this.histogramDataView.settings.fillColor).attr("class", Histogram.Column["class"]).attr("transform", function(item, index) {
                            return visuals.SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5);
                        }), countOfValues && updateColumnsSelection.classed(Histogram.Column["class"]), 
                        updateColumnsSelection.exit().remove(), Histogram.renderTooltip(updateColumnsSelection), 
                        updateColumnsSelection;
                    }, Histogram.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, Histogram.prototype.getColumnHeight = function(column, y) {
                        var height = this.viewport.height - this.XLegendSize - y(column.y);
                        return height > 0 ? height : this.MinColumnHeight;
                    }, Histogram.prototype.renderAxes = function() {
                        var xAxis, yAxis, _this = this;
                        xAxis = this.xAxisProperties.axis.tickFormat(function(item) {
                            return _this.histogramDataView.xLabelFormatter.format(item);
                        }).orient("bottom"), yAxis = this.yAxisProperties.axis.orient(this.histogramDataView.settings.yAxisSettings.position.toLowerCase()).tickFormat(function(item) {
                            return _this.histogramDataView.yLabelFormatter.format(item);
                        });
                        var xShow = this.histogramDataView.settings.xAxisSettings.show, yShow = this.histogramDataView.settings.yAxisSettings.show;
                        xShow ? this.axisX.transition().duration(1).call(xAxis) : this.axisX.selectAll("*").remove(), 
                        yShow ? this.axisY.call(yAxis) : this.axisY.selectAll("*").remove(), this.main.selectAll("g.axis").filter(function(d, index) {
                            return 0 === index;
                        }).selectAll("g.tick text").style({
                            fill: this.histogramDataView.settings.xAxisSettings.axisColor
                        }), this.main.selectAll("g.axis").filter(function(d, index) {
                            return 1 === index;
                        }).selectAll("g.tick text").style({
                            fill: this.histogramDataView.settings.yAxisSettings.axisColor
                        });
                    }, Histogram.prototype.getLabaelLayout = function() {
                        var _this = this, labelSettings = this.histogramDataView.settings.labelSettings, fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), dataLabelFormatter = ValueFormatter.create({
                            value: labelSettings.displayUnits,
                            precision: labelSettings.precision
                        });
                        return {
                            labelText: function(b) {
                                return dataLabelFormatter.format(b.y).toString();
                            },
                            labelLayout: {
                                x: function(b) {
                                    return _this.DataLabelMargin + _this.histogramDataView.xScale(b.x) + _this.widthOfColumn / 2;
                                },
                                y: function(b) {
                                    return _this.histogramDataView.yScale(b.y) - 5;
                                }
                            },
                            filter: function(b) {
                                return null != b;
                            },
                            style: {
                                fill: labelSettings.color,
                                "font-size": fontSizeInPx
                            }
                        };
                    }, Histogram.prototype.renderLabels = function() {
                        var layout = this.getLabaelLayout(), dataPointsArray = this.histogramDataView.data;
                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray, this.main, layout, this.viewport);
                    }, Histogram.rangesToArray = function(data) {
                        return data.reduce(function(previousValue, currentValue, index) {
                            var range;
                            return range = 0 === index ? currentValue.range : currentValue.range.slice(1), previousValue.concat(range);
                        }, []);
                    }, Histogram.prototype.rangeToString = function(range, includeLeftBorder, valueFormatter) {
                        var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
                        return leftBracket = includeLeftBorder ? this.IncludeBrackets.left : this.ExcludeBrackets.left, 
                        "" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;
                    }, Histogram.prototype.renderLegend = function() {
                        var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);
                        legendElements = this.main.select(Histogram.Legends.selector).selectAll(Histogram.Legend.selector), 
                        legendSelection = legendElements.data(datalegends), legendSelection.enter().append("svg:text"), 
                        legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                            return item.dx;
                        }).attr("dy", function(item) {
                            return item.dy;
                        }).attr("transform", function(item) {
                            return item.transform;
                        }).attr("class", Histogram.Legend["class"]).text(function(item) {
                            return item.text;
                        }).classed(Histogram.Legend["class"], !0), legendSelection.exit().remove(), this.legend.select("text").style({
                            display: this.histogramDataView.settings.xAxisSettings.title === !0 ? "block" : "none"
                        }), this.legend.selectAll("text").filter(function(d, index) {
                            return 1 === index;
                        }).style({
                            display: this.histogramDataView.settings.yAxisSettings.title === !0 ? "block" : "none"
                        });
                    }, Histogram.prototype.getDataLegends = function(settings) {
                        var bottomLegendText = Histogram.getLegendText(settings);
                        return bottomLegendText = Histogram.getLegend(bottomLegendText, settings.yAxisSettings.style, settings.yAxisSettings.displayUnits), 
                        [ {
                            transform: visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
                            text: settings.displayName,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(this.shouldShowYOnRight() ? this.yTitleMargin : 0, this.viewport.height / 2, 0, 0, 270),
                            text: bottomLegendText,
                            dx: "3em"
                        } ];
                    }, Histogram.getLegendText = function(settings) {
                        return settings.frequency ? Histogram.FrequencyText : Histogram.DensityText;
                    }, Histogram.prototype.bindSelectionHandler = function(columnsSelection) {
                        var _this = this;
                        this.setSelection(columnsSelection), columnsSelection.on("click", function(data) {
                            _this.selectionManager.clear(), data.selectionIds.forEach(function(selectionId) {
                                _this.selectionManager.select(selectionId, !0).then(function(selectionIds) {
                                    selectionIds.length > 0 ? _this.setSelection(columnsSelection, data) : _this.setSelection(columnsSelection);
                                });
                            }), d3.event.stopPropagation();
                        }), this.root.on("click", function() {
                            _this.selectionManager.clear(), _this.setSelection(columnsSelection);
                        });
                    }, Histogram.prototype.setSelection = function(columnsSelection, data) {
                        columnsSelection.transition().duration(this.durationAnimations).style("fill-opacity", this.MaxOpacity), 
                        data && columnsSelection.filter(function(columnSelection) {
                            return columnSelection !== data;
                        }).transition().duration(this.durationAnimations).style("fill-opacity", this.MinOpacity);
                    }, Histogram.prototype.enumerateObjectInstances = function(options) {
                        var settings, instances = [];
                        if (!this.histogramDataView || !this.histogramDataView.settings) return instances;
                        switch (settings = this.histogramDataView.settings, options.objectName) {
                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    bins: settings.bins,
                                    frequency: settings.frequency
                                }
                            };
                            instances.push(general);
                            break;

                          case "dataPoint":
                            var dataPoint = {
                                objectName: "dataPoint",
                                displayName: "dataPoint",
                                selector: null,
                                properties: {
                                    fill: settings.fillColor
                                }
                            };
                            instances.push(dataPoint);
                            break;

                          case "labels":
                            var labelsSettings = settings.labelSettings, labels = {
                                objectName: "labels",
                                displayName: "labels",
                                selector: null,
                                properties: {
                                    show: labelsSettings.show,
                                    color: labelsSettings.color,
                                    displayUnits: labelsSettings.displayUnits,
                                    precision: labelsSettings.precision,
                                    fontSize: labelsSettings.fontSize
                                }
                            };
                            instances.push(labels);
                            break;

                          case "xAxis":
                            var xAxisSettings = settings.xAxisSettings, xAxis = {
                                objectName: "xAxis",
                                displayName: "X-Axis",
                                selector: null,
                                properties: {
                                    show: xAxisSettings.show,
                                    title: xAxisSettings.title,
                                    style: xAxisSettings.style,
                                    axisColor: xAxisSettings.axisColor,
                                    displayUnits: xAxisSettings.displayUnits,
                                    precision: xAxisSettings.precision
                                }
                            };
                            instances.push(xAxis);
                            break;

                          case "yAxis":
                            var yAxisSettings = settings.yAxisSettings, yAxis = {
                                objectName: "yAxis",
                                displayName: "Y-Axis",
                                selector: null,
                                properties: {
                                    show: yAxisSettings.show,
                                    position: yAxisSettings.position,
                                    start: yAxisSettings.start,
                                    end: yAxisSettings.end,
                                    title: yAxisSettings.title,
                                    style: yAxisSettings.style,
                                    axisColor: yAxisSettings.axisColor,
                                    displayUnits: yAxisSettings.displayUnits,
                                    precision: yAxisSettings.precision
                                }
                            };
                            instances.push(yAxis);
                        }
                        return instances;
                    }, Histogram.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, Histogram.prototype.destroy = function() {
                        this.root = null;
                    }, Histogram.prototype.calculateXAxes = function(source, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forcedXDomain: Histogram.rangesToArray(this.histogramDataView.data),
                            forceMerge: !0,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: visuals.axisScale.linear,
                            valueAxisScaleType: null,
                            trimOrdinalDataOnOverflow: !1
                        }, width = this.viewport.width, axes = this.calculateXAxesProperties(visualOptions, source);
                        return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, Histogram.prototype.calculateXAxesProperties = function(options, metaDataColumn) {
                        var xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewport.width - this.YLegendSize - this.AxisSize,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: visuals.valueFormatter.getFormatString(metaDataColumn, Histogram.Properties.general.formatString),
                            outerPadding: 0,
                            isScalar: !1,
                            isVertical: !1,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: options.categoryAxisScaleType
                        });
                        return xAxisProperties.axisLabel = this.histogramDataView.settings.displayName, 
                        xAxisProperties;
                    }, Histogram.prototype.calculateYAxes = function(source, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forceMerge: !0,
                            showCategoryAxisLabel: !0,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: visuals.axisScale.linear,
                            valueAxisScaleType: null,
                            trimOrdinalDataOnOverflow: !1
                        }, yAxisSettings = this.histogramDataView.settings.yAxisSettings;
                        visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ yAxisSettings.start, yAxisSettings.end ], visualOptions.forcedYDomain);
                        var axes = this.calculateYAxesProperties(visualOptions, source);
                        return axes;
                    }, Histogram.prototype.calculateYAxesProperties = function(options, metaDataColumn) {
                        var yAxisSettings = this.histogramDataView.settings.yAxisSettings, yAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewport.height - this.XLegendSize + 5,
                            dataDomain: visuals.AxisHelper.combineDomain(options.forcedYDomain, [ yAxisSettings.start, yAxisSettings.end ]),
                            metaDataColumn: metaDataColumn,
                            formatString: visuals.valueFormatter.getFormatString(metaDataColumn, Histogram.Properties.general.formatString),
                            outerPadding: this.outerPadding,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: options.categoryAxisScaleType
                        });
                        return yAxisProperties;
                    }, Histogram.ClassName = "histogram", Histogram.FrequencyText = "Frequency", Histogram.DensityText = "Density", 
                    Histogram.Properties = {
                        general: {
                            bins: {
                                objectName: "general",
                                propertyName: "bins"
                            },
                            frequency: {
                                objectName: "general",
                                propertyName: "frequency"
                            },
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            displayUnits: {
                                objectName: "labels",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "labels",
                                propertyName: "precision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        },
                        xAxis: {
                            show: {
                                objectName: "xAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "xAxis",
                                propertyName: "axisColor"
                            },
                            title: {
                                objectName: "xAxis",
                                propertyName: "title"
                            },
                            displayUnits: {
                                objectName: "xAxis",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "xAxis",
                                propertyName: "precision"
                            },
                            style: {
                                objectName: "xAxis",
                                propertyName: "style"
                            }
                        },
                        yAxis: {
                            show: {
                                objectName: "yAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "yAxis",
                                propertyName: "axisColor"
                            },
                            title: {
                                objectName: "yAxis",
                                propertyName: "title"
                            },
                            displayUnits: {
                                objectName: "yAxis",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "yAxis",
                                propertyName: "precision"
                            },
                            style: {
                                objectName: "yAxis",
                                propertyName: "style"
                            },
                            start: {
                                objectName: "yAxis",
                                propertyName: "start"
                            },
                            end: {
                                objectName: "yAxis",
                                propertyName: "end"
                            },
                            position: {
                                objectName: "yAxis",
                                propertyName: "position"
                            }
                        }
                    }, Histogram.DefaultHistogramSettings = {
                        frequency: !0,
                        displayName: "Histogram",
                        bins: null,
                        fillColor: "#5f9ea0",
                        precision: 2,
                        xAxisSettings: {
                            show: !0,
                            axisColor: "#5f9ea0",
                            title: !0,
                            displayUnits: 0,
                            precision: 2,
                            style: visuals.axisStyle.showTitleOnly
                        },
                        yAxisSettings: {
                            show: !0,
                            axisColor: "#5f9ea0",
                            title: !0,
                            displayUnits: 0,
                            precision: 2,
                            style: visuals.axisStyle.showTitleOnly,
                            start: 0,
                            position: visuals.yAxisPosition.left
                        },
                        labelSettings: {
                            show: !1,
                            color: "#5f9ea0",
                            displayUnits: 0,
                            precision: 2,
                            fontSize: 9
                        }
                    }, Histogram.Axes = createClassAndSelector("axes"), Histogram.Axis = createClassAndSelector("axis"), 
                    Histogram.Labels = createClassAndSelector("labels"), Histogram.Columns = createClassAndSelector("columns"), 
                    Histogram.Column = createClassAndSelector("column"), Histogram.Legends = createClassAndSelector("legends"), 
                    Histogram.Legend = createClassAndSelector("legend"), Histogram.capabilities = {
                        dataRoles: [ {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        }, {
                            name: "Frequency",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Frequency"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Values: {
                                    min: 1,
                                    max: 1
                                },
                                Frequency: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    bind: {
                                        to: "Values"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": "Frequency"
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: "Values",
                                    direction: 1
                                } ]
                            }
                        },
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    bins: {
                                        displayName: "Bins",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    frequency: {
                                        displayName: "Frequency",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            xAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axis: {
                                        displayName: "Axis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    style: {
                                        displayName: "Style",
                                        type: {
                                            enumeration: visuals.axisStyle.type
                                        }
                                    }
                                }
                            },
                            yAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axis: {
                                        displayName: "yAxis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    style: {
                                        displayName: "Style",
                                        type: {
                                            enumeration: visuals.axisStyle.type
                                        }
                                    },
                                    start: {
                                        displayName: "Start",
                                        type: {
                                            numeric: !0
                                        },
                                        placeHolderText: "Start",
                                        suppressFormatPainterCopy: !0
                                    },
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        },
                                        placeHolderText: "End",
                                        suppressFormatPainterCopy: !0
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: visuals.yAxisPosition.type
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, Histogram.MinNumberOfBins = 0, Histogram.MaxNumberOfBins = 100, Histogram.MinPrecision = 0, 
                    Histogram.MaxPrecision = 17, Histogram;
                }();
                samples.Histogram = Histogram;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration, CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, AxisScale = powerbi.visuals.axisScale, PixelConverter = jsCommon.PixelConverter, MaxXAxisHeight = 40, LabelMargin = 15, DefaultRadius = 5, DefaultStrokeWidth = 1, DefaultDataPointColor = "#00B8AA", MinPrecision = 0, MaxPrecision = 17;
                samples.DotPlotProperties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        labelDisplayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        labelColor: {
                            objectName: "labels",
                            propertyName: "color"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    categories: {
                        show: {
                            objectName: "categories",
                            propertyName: "show"
                        },
                        fontColor: {
                            objectName: "categories",
                            propertyName: "fontColor"
                        },
                        fontSize: {
                            objectName: "categories",
                            propertyName: "fontSize"
                        }
                    },
                    categoryAxis: {
                        show: {
                            objectName: "categoryAxis",
                            propertyName: "show"
                        },
                        showAxisTitle: {
                            objectName: "categoryAxis",
                            propertyName: "showAxisTitle"
                        },
                        labelColor: {
                            objectName: "categoryAxis",
                            propertyName: "labelColor"
                        }
                    }
                };
                var DotPlot = function() {
                    function DotPlot(options) {
                        this.DefaultMargin = {
                            top: 10,
                            bottom: 10,
                            right: 20,
                            left: 20
                        }, this.durationAnimations = 200, this.scaleType = AxisScale.linear, this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(9)
                        }, this.dotPlotSelectors = {
                            svgPlotSelector: CreateClassAndSelector("dotplot"),
                            plotSelector: CreateClassAndSelector("dotplotSelector"),
                            plotGroupSelector: CreateClassAndSelector("dotplotGroup"),
                            axisSelector: CreateClassAndSelector("axisGraphicsContext"),
                            xAxisSelector: CreateClassAndSelector("x axis"),
                            circleSeletor: CreateClassAndSelector("circleSelector")
                        }, this.DefaultDotPlotSettings = {
                            labelSettings: {
                                show: !0,
                                precision: 2,
                                fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                                displayUnits: 0,
                                labelColor: visuals.dataLabelUtils.defaultLabelColor
                            },
                            categorySettings: {
                                show: !0,
                                fontColor: visuals.LegendData.DefaultLegendLabelFillColor
                            },
                            defaultDataPointColor: DefaultDataPointColor,
                            categoryAxisSettings: {
                                show: !0,
                                showAxisTitle: !0,
                                labelColor: {
                                    solid: {
                                        color: visuals.dataLabelUtils.defaultLabelColor
                                    }
                                }
                            }
                        }, options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                        this.radius = options.radius || DefaultRadius, this.strokeWidth = options.strokeWidth || DefaultStrokeWidth);
                    }
                    return DotPlot.getTooltipData = function(value) {
                        return [ {
                            displayName: "Value",
                            value: value.toString()
                        } ];
                    }, DotPlot.converter = function(dataView, objects, scale, defaultMargin, defaultSetting, colors, viewport, radius) {
                        var settings, values = dataView.categorical.values, dataPointsGroup = [], displayName = dataView.categorical.categories[0].source.displayName, defaultColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), categories = dataView.categorical.categories[0].values.map(function(x, i) {
                            return {
                                value: x,
                                selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i])
                            };
                        });
                        settings = {
                            categorySettings: this.getCategorySettings(objects, defaultSetting),
                            defaultDataPointColor: defaultColor,
                            labelSettings: this.parseSettings(objects, defaultSetting),
                            categoryAxisSettings: this.parseCategoryAxisSettings(objects, defaultSetting)
                        };
                        for (var categoryColumn = dataView.categorical.categories[0], diameter = 2 * radius + 1, dotsTotalHeight = viewport.height - radius - MaxXAxisHeight, maxDots = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1, fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize), yScale = d3.scale.linear().domain([ 0, maxDots ]).range([ dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom ]), _i = 0, values_1 = values; _i < values_1.length; _i++) for (var value = values_1[_i], min = _.min(value.values), max = _.max(value.values), color = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), length_1 = value && value.values ? value.values.length : 0, minDots = min / (max / maxDots), dotsScale = d3.scale.log().domain([ 0 > min ? 1 : min, max ]).range([ 0 >= minDots ? 1 : minDots, maxDots ]).clamp(!0), k = 0; length_1 > k; k++) {
                            for (var y = dotsScale(value.values[k]), dataPoints = [], level = 0; y > level; level++) dataPoints.push({
                                x: scale(categories[k].value) + scale.rangeBand() / 2,
                                y: yScale(level),
                                tooltipInfo: DotPlot.getTooltipData(value.values[k].toFixed(settings.labelSettings.precision))
                            });
                            var categorySelectionId = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId(), tooltipInfo = DotPlot.getTooltipData(value.values[k].toFixed(settings.labelSettings.precision));
                            dataPointsGroup.push({
                                selected: !1,
                                value: value.values[k],
                                label: value.values[k],
                                color: color,
                                identity: categorySelectionId,
                                tooltipInfo: tooltipInfo,
                                dataPoints: dataPoints,
                                labelFontSize: fontSizeInPx
                            });
                        }
                        return {
                            dataPoints: dataPointsGroup,
                            values: dataView.categorical.categories[0].values,
                            displayName: displayName,
                            categories: categories,
                            settings: settings
                        };
                    }, DotPlot.prototype.init = function(options) {
                        var element = options.element;
                        this.behavior = new DotplotBehavior(), this.interactivityService = visuals.createInteractivityService(options.host), 
                        this.radius = DefaultRadius, this.strokeWidth = DefaultStrokeWidth, this.colors = options.style.colorPalette.dataColors, 
                        this.svg = d3.select(element.get(0)).append("svg").classed(this.dotPlotSelectors.svgPlotSelector["class"], !0).style("position", "absolute"), 
                        this.clearCatcher = visuals.appendClearCatcher(this.svg);
                        var axisGraphicsContext = this.svg.append("g").classed(this.dotPlotSelectors.axisSelector["class"], !0);
                        this.dotPlot = this.svg.append("g").classed(this.dotPlotSelectors.plotSelector["class"], !0), 
                        this.xAxis = axisGraphicsContext.append("g").classed(this.dotPlotSelectors.xAxisSelector["class"], !0);
                    }, DotPlot.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);
                            var dataView = this.dataView = options.dataViews[0], viewport = options.viewport;
                            if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1 || !dataView.categorical || !dataView.categorical.categories || !dataView.categorical.categories[0]) return void this.clearData();
                            var viewportIn = {
                                height: viewport.height - this.DefaultMargin.top,
                                width: viewport.width - this.DefaultMargin.left
                            };
                            this.viewportIn = viewportIn, this.svg.style({
                                height: PixelConverter.toString(viewport.height),
                                width: PixelConverter.toString(viewport.width)
                            });
                            var objects = DotPlot.getObjectsFromDataView(dataView), categoryAxisSettings = DotPlot.parseCategoryAxisSettings(objects, this.DefaultDotPlotSettings), xAxisProperties = this.calculateAxes(viewportIn, categoryAxisSettings, this.textProperties, objects, !1), data = DotPlot.converter(dataView, objects, xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);
                            this.dotPlotDataView = data;
                            var dataPoints = data.dataPoints;
                            this.interactivityService && this.interactivityService.applySelectionStateToData(dataPoints), 
                            this.renderAxis(viewportIn.height - MaxXAxisHeight, viewportIn, xAxisProperties, categoryAxisSettings, data, this.durationAnimations), 
                            this.drawDotPlot(dataPoints, data.settings);
                            var dataLabelsSettings = data.settings.labelSettings;
                            if (dataLabelsSettings.show) {
                                var layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn), labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);
                                labels && labels.attr("transform", function(d) {
                                    return visuals.SVGUtil.translate(5 + d.size.width / 2, 5 + d.size.height / 2);
                                });
                            } else visuals.dataLabelUtils.cleanDataLabels(this.svg);
                        }
                    }, DotPlot.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "dataPoint":
                            this.enumerateDataPoints(enumeration, this.dataView);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration, this.dataView);
                            break;

                          case "categories":
                            this.enumerateCategories(enumeration, this.dataView);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxisValues(enumeration, this.dataView);
                        }
                        return enumeration.complete();
                    }, DotPlot.prototype.enumerateCategoryAxisValues = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "categoryAxis",
                            displayName: "Category Axis",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.show, this.DefaultDotPlotSettings.categoryAxisSettings.show),
                                showAxisTitle: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.showAxisTitle, this.DefaultDotPlotSettings.categoryAxisSettings.showAxisTitle),
                                labelColor: objects && objects.categoryAxis && objects.categoryAxis.labelColor ? objects.categoryAxis.labelColor : this.DefaultDotPlotSettings.categoryAxisSettings.labelColor
                            }
                        });
                    }, DotPlot.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, DotPlot.parseSettings = function(objects, defaultDotPlotSettings) {
                        var precision = this.getPrecision(objects, defaultDotPlotSettings);
                        return {
                            show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),
                            precision: precision,
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),
                            displayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor)
                        };
                    }, DotPlot.parseCategoryAxisSettings = function(objects, defaultDotPlotSettings) {
                        return {
                            show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.show, defaultDotPlotSettings.categoryAxisSettings.show),
                            showAxisTitle: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.showAxisTitle, defaultDotPlotSettings.categoryAxisSettings.showAxisTitle),
                            labelColor: objects && objects.categoryAxis && objects.categoryAxis.labelColor ? objects.categoryAxis.labelColor : defaultDotPlotSettings.categoryAxisSettings.labelColor
                        };
                    }, DotPlot.getCategorySettings = function(objects, defaultDotPlotSettings) {
                        return {
                            show: powerbi.DataViewObject.getValue(objects, samples.DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)
                        };
                    }, DotPlot.getPrecision = function(objects, defaultDotPlotSettings) {
                        var precision = powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);
                        return MinPrecision >= precision ? MinPrecision : precision >= MaxPrecision ? MaxPrecision : precision;
                    }, DotPlot.prototype.drawDotPlot = function(data, setting) {
                        var selection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data), hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                        selection.enter().append("g").attr({
                            stroke: "black",
                            "stroke-width": this.strokeWidth
                        }).style("fill-opacity", function(item) {
                            return visuals.ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, !1);
                        }).classed(this.dotPlotSelectors.plotGroupSelector["class"], !0);
                        var circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function(d) {
                            return d.dataPoints;
                        });
                        circleSelection.enter().append("circle").classed(this.dotPlotSelectors.circleSeletor["class"], !0), 
                        circleSelection.attr({
                            cx: function(point) {
                                return point.x;
                            },
                            cy: function(point) {
                                return point.y;
                            },
                            r: this.radius,
                            fill: setting.defaultDataPointColor
                        }), this.renderTooltip(selection), circleSelection.exit().remove(), selection.exit().remove();
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(data);
                            var behaviorOptions = {
                                columns: selection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            interactivityService.bind(data, this.behavior, behaviorOptions);
                        }
                    }, DotPlot.prototype.getEnhanchedDotplotLayout = function(labelSettings, viewport) {
                        var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize), formatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, samples.DotPlotProperties.general.formatString),
                            precision: labelSettings.precision,
                            value: labelSettings.displayUnits
                        });
                        return {
                            labelText: function(d) {
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: formatter.format(d.label),
                                    fontSize: labelSettings.fontSize,
                                    maxWidth: viewport.width
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return d.dataPoints[d.dataPoints.length - 1].x - 5;
                                },
                                y: function(d) {
                                    return d.dataPoints[d.dataPoints.length - 1].y - LabelMargin - 5;
                                }
                            },
                            filter: function(d) {
                                return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1];
                            },
                            style: {
                                fill: labelSettings.labelColor,
                                "font-size": fontSizeInPx
                            }
                        };
                    }, DotPlot.prototype.enumerateDataLabels = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),
                                fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),
                                labelPrecision: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),
                                labelDisplayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),
                                color: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)
                            }
                        });
                    }, DotPlot.prototype.enumerateDataPoints = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0, dataPointColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: "Data Points",
                            selector: null,
                            properties: {
                                fill: {
                                    solid: {
                                        color: dataPointColor
                                    }
                                }
                            }
                        });
                    }, DotPlot.prototype.enumerateCategories = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0, categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);
                        enumeration.pushInstance({
                            objectName: "categories",
                            displayName: "Categories",
                            selector: null,
                            properties: {
                                show: categoriesSettings.show,
                                fontSize: categoriesSettings.fontSize,
                                fontColor: categoriesSettings.fontColor
                            }
                        });
                    }, DotPlot.prototype.clearData = function() {
                        this.dotPlot.selectAll("*").remove(), this.xAxis.selectAll("*").remove(), visuals.dataLabelUtils.cleanDataLabels(this.svg);
                    }, DotPlot.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, DotPlot.prototype.calculateAxes = function(viewportIn, categoryAxisSettings, textProperties, objects, scrollbarVisible) {
                        var category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0 ? this.dataView.categorical.categories[0] : {
                            source: void 0,
                            values: [ visuals.valueFormatter.format(null) ],
                            identity: void 0
                        }, visualOptions = {
                            viewport: viewportIn,
                            margin: this.DefaultMargin,
                            forcedXDomain: this.dataView.categorical.categories[0].values,
                            forceMerge: !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: this.scaleType,
                            valueAxisScaleType: null,
                            valueAxisDisplayUnits: 0,
                            categoryAxisDisplayUnits: 0,
                            trimOrdinalDataOnOverflow: !1
                        }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, categoryAxisSettings, visualOptions, category.source, objects);
                        return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.DefaultMargin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, DotPlot.prototype.calculateAxesProperties = function(viewportIn, categoryAxisSettings, options, metaDataColumn, objects) {
                        var xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: viewportIn.width,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: visuals.valueFormatter.getFormatString(metaDataColumn, samples.DotPlotProperties.general.formatString),
                            outerPadding: 0,
                            isScalar: !1,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return categoryAxisSettings.show ? index : "";
                            },
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        });
                        return categoryAxisSettings.show && (xAxisProperties.axisLabel = visuals.AxisHelper.createAxisLabel(objects, "", "")), 
                        xAxisProperties;
                    }, DotPlot.prototype.renderAxis = function(height, viewportIn, xAxisProperties, categoryAxisSettings, data, duration) {
                        this.xAxis.attr({
                            transform: visuals.SVGUtil.translate(0, height)
                        });
                        var xAxis = xAxisProperties.axis;
                        xAxis.orient("bottom"), this.xAxis.transition().duration(duration).call(xAxis).call(DotPlot.setAxisLabelColor, categoryAxisSettings.labelColor);
                        var xAxisTicks = this.xAxis.selectAll(".tick text");
                        xAxisTicks.data(xAxisProperties.values), xAxisTicks.call(visuals.AxisHelper.LabelLayoutStrategy.clip, xAxisProperties.xLabelMaxWidth, powerbi.TextMeasurementService.svgEllipsis), 
                        xAxisTicks.append("title").text(function(d) {
                            return d;
                        }), this.xAxis.selectAll("line").style("opacity", data.settings.categoryAxisSettings.show ? 1 : 0), 
                        this.xAxis.selectAll(".xAxisLabel").remove(), data.settings.categoryAxisSettings.showAxisTitle && this.xAxis.append("text").text(this.dataView.categorical.categories[0].source.displayName).style("text-anchor", "middle").attr("class", "xAxisLabel").style("fill", categoryAxisSettings.labelColor.solid.color).attr("transform", "translate(" + viewportIn.width / 2 + ",40)");
                    }, DotPlot.setAxisLabelColor = function(g, fill) {
                        g.selectAll("g.tick text").style("fill", fill && fill.solid ? fill.solid.color : null);
                    }, DotPlot.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        description: "Title options",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Label color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                description: "Display data label options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showSeries: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display units",
                                        description: "Select the units (millions, billions, etc.)",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal places",
                                        description: "Select the number of decimal places to display",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    showAll: {
                                        displayName: "Customize series",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, DotPlot;
                }();
                samples.DotPlot = DotPlot;
                var DotplotBehavior = function() {
                    function DotplotBehavior() {}
                    return DotplotBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.columns.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, DotplotBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.columns.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, DotplotBehavior;
                }();
                samples.DotplotBehavior = DotplotBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter;
                !function(LinkColorType) {
                    LinkColorType[LinkColorType.ByWeight = "By Weight"] = "ByWeight", LinkColorType[LinkColorType.ByLinkType = "By Link Type"] = "ByLinkType", 
                    LinkColorType[LinkColorType.Interactive = "Interactive"] = "Interactive";
                }(samples.LinkColorType || (samples.LinkColorType = {}));
                var LinkColorType = samples.LinkColorType, ForceGraphSettings = function() {
                    function ForceGraphSettings() {
                        this.labels = {
                            show: !0,
                            color: visuals.dataLabelUtils.defaultLabelColor,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt
                        }, this.links = {
                            showArrow: !1,
                            showLabel: !1,
                            colorLink: LinkColorType.Interactive,
                            thickenLink: !0,
                            displayUnits: 0,
                            decimalPlaces: null
                        }, this.nodes = {
                            displayImage: !1,
                            defaultImage: "Home",
                            imageUrl: "",
                            imageExt: ".png",
                            nameMaxLength: 10,
                            highlightReachableLinks: !1
                        }, this.size = {
                            charge: -15
                        };
                    }
                    return Object.defineProperty(ForceGraphSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ForceGraphSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, ForceGraphSettings.getProperties = function(capabilities) {
                        var properties = {};
                        for (var objectKey in capabilities.objects) {
                            properties[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, ForceGraphSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, ForceGraphSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return powerbi.DataViewObjects.getFillColor;

                          default:
                            return powerbi.DataViewObjects.getValue;
                        }
                    }, ForceGraphSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        var enumeration = new visuals.ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration.complete();
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration.complete();
                    }, ForceGraphSettings;
                }();
                samples.ForceGraphSettings = ForceGraphSettings;
                var ForceGraphColumns = function() {
                    function ForceGraphColumns() {
                        this.Source = null, this.Target = null, this.Weight = null, this.LinkType = null, 
                        this.SourceType = null, this.TargetType = null;
                    }
                    return ForceGraphColumns.getMetadataColumns = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new ForceGraphColumns(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, ForceGraphColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getMetadataColumns(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, ForceGraphColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getMetadataColumns(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, ForceGraphColumns.Roles = Object.freeze(_.mapValues(new ForceGraphColumns(), function(x, i) {
                        return i;
                    })), ForceGraphColumns;
                }();
                samples.ForceGraphColumns = ForceGraphColumns;
                var ForceGraph = function() {
                    function ForceGraph() {
                        this.uniqieId = "_" + ForceGraph.Count++ + "_";
                    }
                    return Object.defineProperty(ForceGraph, "Href", {
                        get: function() {
                            return window.location.href.replace(window.location.hash, "");
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "margin", {
                        get: function() {
                            return this.marginValue || {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                        },
                        set: function(value) {
                            this.marginValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            this.viewportValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ForceGraph.substractMargin = function(viewport, margin) {
                        return {
                            width: Math.max(viewport.width - (margin.left + margin.right), 0),
                            height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                        };
                    }, ForceGraph.prototype.scale1to10 = function(d) {
                        var scale = d3.scale.linear().domain([ this.data.minFiles, this.data.maxFiles ]).rangeRound([ 1, 10 ]).clamp(!0);
                        return scale(d);
                    }, ForceGraph.prototype.getLinkColor = function(d) {
                        switch (this.settings.links.colorLink) {
                          case LinkColorType.ByWeight:
                            return this.colors.getColorByIndex(this.scale1to10(d.weight)).value;

                          case LinkColorType.ByLinkType:
                            return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : ForceGraph.DefaultValues.defaultLinkColor;
                        }
                        return ForceGraph.DefaultValues.defaultLinkColor;
                    }, ForceGraph.prototype.enumerateObjectInstances = function(options) {
                        return ForceGraphSettings.enumerateObjectInstances(this.settings, options, ForceGraph.capabilities);
                    }, ForceGraph.converter = function(dataView, colors) {
                        var categorical = dataView.categorical, settings = ForceGraph.parseSettings(dataView), nodes = {}, minFiles = Number.MAX_VALUE, maxFiles = 0, linkedByName = {}, links = [], linkDataPoints = {}, linkTypeCount = 0, tooltipInfo = [], metadata = ForceGraphColumns.getMetadataColumns(dataView);
                        if (!metadata || !metadata.Source || !metadata.Target) return null;
                        var tableRows = ForceGraphColumns.getTableRows(dataView), formatStringProp = ForceGraphSettings.getProperties(ForceGraph.capabilities).general.formatString, categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp), categoryTargetFormatString = visuals.valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp), weightFormatter = metadata.Weight && visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(metadata.Weight, formatStringProp, !0),
                            precision: settings.links.decimalPlaces,
                            value: settings.links.displayUnits || _.max(tableRows, function(x) {
                                return x.Weight;
                            }).Weight
                        });
                        return tableRows.forEach(function(x) {
                            linkedByName[x.Source + "," + x.Target] = 1;
                            var source = nodes[x.Source] || (nodes[x.Source] = {
                                name: x.Source,
                                image: x.SourceType || "",
                                adj: {}
                            }), target = nodes[x.Target] || (nodes[x.Target] = {
                                name: x.Target,
                                image: x.TargetType || "",
                                adj: {}
                            });
                            source.adj[target.name] = 1, target.adj[source.name] = 1, tooltipInfo = [ {
                                displayName: dataView.metadata.columns[0].displayName,
                                value: visuals.valueFormatter.format(source.name, categorySourceFormatString)
                            }, {
                                displayName: dataView.metadata.columns[1].displayName,
                                value: visuals.valueFormatter.format(target.name, categoryTargetFormatString)
                            } ], metadata.Weight && tooltipInfo.push({
                                displayName: dataView.metadata.columns[2].displayName,
                                value: x.Weight
                            });
                            var link = {
                                source: source,
                                target: target,
                                weight: Math.max(x.Weight, 0),
                                formattedWeight: x.Weight && weightFormatter.format(x.Weight),
                                type: x.LinkType || "",
                                tooltipInfo: tooltipInfo
                            };
                            metadata.LinkType && (linkDataPoints[x.LinkType] || (linkDataPoints[x.LinkType] = {
                                label: x.LinkType,
                                color: colors.getColorByIndex(linkTypeCount++).value
                            })), link.weight < minFiles && (minFiles = link.weight), link.weight > maxFiles && (maxFiles = link.weight), 
                            links.push(link);
                        }), {
                            nodes: nodes,
                            links: links,
                            minFiles: minFiles,
                            maxFiles: maxFiles,
                            linkedByName: linkedByName,
                            linkTypes: linkDataPoints,
                            settings: settings
                        };
                    }, ForceGraph.parseSettings = function(dataView) {
                        var settings = ForceGraphSettings.parse(dataView, ForceGraph.capabilities);
                        return settings.size.charge = Math.min(Math.max(settings.size.charge, -100), -.1), 
                        settings.links.decimalPlaces = settings.links.decimalPlaces && Math.min(Math.max(settings.links.decimalPlaces, 0), 5), 
                        settings;
                    }, ForceGraph.prototype.init = function(options) {
                        var _this = this;
                        this.root = d3.select(options.element.get(0)), this.forceLayout = d3.layout.force(), 
                        this.forceLayout.drag().on("dragstart", function(d) {
                            d.isDrag = !0, _this.fadeNode(d);
                        }).on("dragend", function(d) {
                            d.isDrag = !1, _this.fadeNode(d);
                        }).on("drag", function(d) {
                            return _this.fadeNode(d);
                        }), this.colors = options.style.colorPalette.dataColors;
                    }, ForceGraph.prototype.update = function(options) {
                        var _this = this;
                        if (options.dataViews && !(options.dataViews.length < 1) && (this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors), 
                        this.data)) {
                            this.viewport = options.viewport;
                            var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
                            this.root.selectAll("svg").remove();
                            var svg = this.root.append("svg").attr("width", this.viewport.width).attr("height", this.viewport.height).classed(ForceGraph.VisualClassName, !0);
                            if (this.forceLayout.gravity(100 * k).links(this.data.links).size([ this.viewport.width, this.viewport.height ]).linkDistance(100).charge(this.settings.size.charge / k).on("tick", this.tick()), 
                            this.updateNodes(), this.forceLayout.start(), this.paths = svg.selectAll(".link").data(this.forceLayout.links()).enter().append("path").attr("class", "link").attr("id", function(d, i) {
                                return "linkid_" + _this.uniqieId + i;
                            }).attr("stroke-width", function(d) {
                                return _this.settings.links.thickenLink ? _this.scale1to10(d.weight) : ForceGraph.DefaultValues.defaultLinkThickness;
                            }).style("stroke", function(d) {
                                return _this.getLinkColor(d);
                            }).style("fill", function(d) {
                                return _this.settings.links.showArrow ? _this.getLinkColor(d) : void 0;
                            }).on("mouseover", this.fadePath(.3, ForceGraph.DefaultValues.defaultLinkHighlightColor)).on("mouseout", this.fadePath(1, ForceGraph.DefaultValues.defaultLinkColor)), 
                            visuals.TooltipManager.addTooltip(this.paths, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            }), this.settings.links.showLabel) {
                                var linklabelholderUpdate = svg.selectAll(".linklabelholder").data(this.forceLayout.links());
                                linklabelholderUpdate.enter().append("g").attr("class", "linklabelholder").append("text").attr("class", "linklabel").attr("y", "-12").attr("text-anchor", "middle").style("fill", "#000").append("textPath").attr("xlink:href", function(d, i) {
                                    return ForceGraph.Href + "#linkid_" + _this.uniqieId + i;
                                }).attr("startOffset", "25%").text(function(d) {
                                    return _this.settings.links.colorLink === LinkColorType.ByLinkType ? d.type : d.formattedWeight;
                                }), linklabelholderUpdate.exit().remove();
                            }
                            this.nodes = svg.selectAll(".node").data(this.forceLayout.nodes()).enter().append("g").attr("class", "node").call(this.forceLayout.drag).on("mouseover", function(d) {
                                d.isOver = !0, _this.fadeNode(d);
                            }).on("mouseout", function(d) {
                                d.isOver = !1, _this.fadeNode(d);
                            }).on("mousedown", function() {
                                return d3.event.stopPropagation();
                            }).attr("drag-resize-disabled", !0), this.settings.nodes.displayImage ? this.nodes.append("image").attr("xlink:href", function(d) {
                                return d.image && "" !== d.image ? _this.settings.nodes.imageUrl + d.image + _this.settings.nodes.imageExt : _this.settings.nodes.defaultImage && "" !== _this.settings.nodes.defaultImage ? _this.settings.nodes.imageUrl + _this.settings.nodes.defaultImage + _this.settings.nodes.imageExt : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=";
                            }).attr("x", "-12px").attr("y", "-12px").attr("width", "24px").attr("height", "24px") : this.nodes.append("circle").attr("r", function(d) {
                                return d.weight < 5 ? 5 : d.weight;
                            }), this.settings.labels.show && this.nodes.append("text").attr({
                                x: 12,
                                dy: ".35em"
                            }).style({
                                fill: this.settings.labels.color,
                                "font-size": PixelConverter.fromPoint(this.settings.labels.fontSize)
                            }).text(function(d) {
                                return d.name ? d.name.length > _this.settings.nodes.nameMaxLength ? d.name.substr(0, _this.settings.nodes.nameMaxLength) : d.name : "";
                            });
                        }
                    }, ForceGraph.prototype.updateNodes = function() {
                        var oldNodes = this.forceLayout.nodes();
                        this.forceLayout.nodes(d3.values(this.data.nodes)), this.forceLayout.nodes().forEach(function(node, i) {
                            oldNodes[i] && (node.x = oldNodes[i].x, node.y = oldNodes[i].y, node.px = oldNodes[i].px, 
                            node.py = oldNodes[i].py, node.weight = oldNodes[i].weight);
                        });
                    }, ForceGraph.prototype.tick = function() {
                        var _this = this, viewport = this.viewportIn, maxWidth = 20 * viewport.width, maxHeight = 20 * viewport.height, limitX = function(x) {
                            return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x));
                        }, limitY = function(y) {
                            return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y));
                        }, getPath = this.settings.links.showArrow ? function(d) {
                            d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
                            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
                        } : function(d) {
                            d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        };
                        return function() {
                            _this.paths.each(function() {
                                this.parentNode.insertBefore(this, this);
                            }), _this.paths.attr("d", getPath), _this.nodes.attr("transform", function(d) {
                                return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")";
                            });
                        };
                    }, ForceGraph.prototype.fadePath = function(opacity, highlight) {
                        var _this = this;
                        if (this.settings.links.colorLink === LinkColorType.Interactive) return function(d) {
                            _this.paths.style("stroke-opacity", function(o) {
                                return o.source === d.source && o.target === d.target ? 1 : opacity;
                            }), _this.paths.style("stroke", function(o) {
                                return o.source === d.source && o.target === d.target ? highlight : ForceGraph.DefaultValues.defaultLinkColor;
                            });
                        };
                    }, ForceGraph.prototype.isReachable = function(a, b) {
                        if (a.name === b.name) return !0;
                        if (this.data.linkedByName[a.name + "," + b.name]) return !0;
                        var visited = {};
                        for (var name in this.data.nodes) visited[name] = !1;
                        visited[a.name] = !0;
                        var stack = [];
                        for (stack.push(a.name); stack.length > 0; ) {
                            var cur = stack.pop(), node = this.data.nodes[cur];
                            for (var nb in node.adj) {
                                if (nb === b.name) return !0;
                                visited[nb] || (visited[nb] = !0, stack.push(nb));
                            }
                        }
                        return !1;
                    }, ForceGraph.prototype.fadeNode = function(node) {
                        var _this = this;
                        if (this.settings.links.colorLink === LinkColorType.Interactive) {
                            var isConnected = function(a, b) {
                                return _this.data.linkedByName[a.name + "," + b.name] || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name;
                            }, isHighlight = node.isOver || node.isDrag, opacity = isHighlight ? .3 : 1, highlight = isHighlight ? ForceGraph.DefaultValues.defaultLinkHighlightColor : ForceGraph.DefaultValues.defaultLinkColor, that = this;
                            this.nodes.style("stroke-opacity", function(o) {
                                var thisOpacity = (that.settings.nodes.highlightReachableLinks ? that.isReachable(node, o) : isConnected(node, o)) ? 1 : opacity;
                                return this.setAttribute("fill-opacity", thisOpacity), thisOpacity;
                            }), this.paths.style("stroke-opacity", function(o) {
                                return (_this.settings.nodes.highlightReachableLinks ? _this.isReachable(node, o.source) : o.source === node || o.target === node) ? 1 : opacity;
                            }), this.paths.style("stroke", function(o) {
                                return (_this.settings.nodes.highlightReachableLinks ? _this.isReachable(node, o.source) : o.source === node || o.target === node) ? highlight : ForceGraph.DefaultValues.defaultLinkColor;
                            });
                        }
                    }, ForceGraph.prototype.destroy = function() {
                        this.root = null;
                    }, ForceGraph.VisualClassName = "forceGraph", ForceGraph.Count = 0, ForceGraph.DefaultValues = {
                        defaultLinkColor: "#bbb",
                        defaultLinkHighlightColor: "#f00",
                        defaultLinkThickness: "1.5px"
                    }, ForceGraph.capabilities = {
                        dataRoles: [ {
                            name: ForceGraphColumns.Roles.Source,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Source"
                        }, {
                            name: ForceGraphColumns.Roles.Target,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Target"
                        }, {
                            name: ForceGraphColumns.Roles.Weight,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Weight"
                        }, {
                            name: ForceGraphColumns.Roles.LinkType,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Link Type",
                            description: "Links can be colored by link types"
                        }, {
                            name: ForceGraphColumns.Roles.SourceType,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Source Type",
                            description: "Source type represents the image name for source entities"
                        }, {
                            name: ForceGraphColumns.Roles.TargetType,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Target Type",
                            description: "Target type represents the image name for target entities"
                        } ],
                        objects: {
                            general: {
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            links: {
                                displayName: "Links",
                                properties: {
                                    showArrow: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Arrow"
                                    },
                                    showLabel: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Label",
                                        description: "Displays weight on links"
                                    },
                                    colorLink: {
                                        type: {
                                            enumeration: ForceGraphSettings.createEnumTypeFromEnum(LinkColorType)
                                        },
                                        displayName: "Color"
                                    },
                                    thickenLink: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Thickness",
                                        description: "Thickenss of links represents weight"
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    decimalPlaces: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            nodes: {
                                displayName: "Nodes",
                                properties: {
                                    displayImage: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Image",
                                        description: "Images are loaded from image url + source or target type + image extension"
                                    },
                                    defaultImage: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Default image"
                                    },
                                    imageUrl: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Image url"
                                    },
                                    imageExt: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Image extension"
                                    },
                                    nameMaxLength: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Max name length",
                                        description: "Max length of the name of entities displayed"
                                    },
                                    highlightReachableLinks: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Highlight all reachable links",
                                        description: "In interactive mode, whether a node's all reachable links will be highlighted"
                                    }
                                }
                            },
                            size: {
                                displayName: "Size",
                                properties: {
                                    charge: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Charge",
                                        description: "The larger the negative charge the more apart the entities, must be negative but greater than -100"
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Source: {
                                    max: 1
                                },
                                Target: {
                                    max: 1
                                },
                                Weight: {
                                    max: 1
                                },
                                LinkType: {
                                    max: 1
                                },
                                SourceType: {
                                    max: 1
                                },
                                TargetType: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Source"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Target"
                                        }
                                    }, {
                                        bind: {
                                            to: "Weight"
                                        }
                                    }, {
                                        bind: {
                                            to: "LinkType"
                                        }
                                    }, {
                                        bind: {
                                            to: "SourceType"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetType"
                                        }
                                    } ]
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        suppressDefaultTitle: !0
                    }, ForceGraph;
                }();
                samples.ForceGraph = ForceGraph;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function createEnumTypeFromEnum(type) {
                    var even = !1;
                    return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                        return !!(i % 2) === even && type[key] === key && !void (even === !even) || !!(i % 2) !== even;
                    }).map(function(x) {
                        return {
                            value: x,
                            displayName: x
                        };
                    }));
                }
                var SelectionManager = visuals.utility.SelectionManager, PixelConverter = jsCommon.PixelConverter, PercentFormat = "0.00 %;-0.00 %;0.00 %", MillisecondsInADay = 864e5, MillisecondsInWeek = 6048e5, MillisecondsInAMonth = 2629746e3, MillisecondsInAYear = 31556952e3, ChartLineHeight = 40, PaddingTasks = 5;
                !function(GanttDateType) {
                    GanttDateType[GanttDateType.Day = "Day"] = "Day", GanttDateType[GanttDateType.Week = "Week"] = "Week", 
                    GanttDateType[GanttDateType.Month = "Month"] = "Month", GanttDateType[GanttDateType.Year = "Year"] = "Year";
                }(samples.GanttDateType || (samples.GanttDateType = {}));
                var Selectors, GanttDateType = samples.GanttDateType;
                !function(Selectors) {
                    var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                    Selectors.ClassName = CreateClassAndSelector("gantt"), Selectors.Chart = CreateClassAndSelector("chart"), 
                    Selectors.ChartLine = CreateClassAndSelector("chart-line"), Selectors.Body = CreateClassAndSelector("gantt-body"), 
                    Selectors.AxisGroup = CreateClassAndSelector("axis"), Selectors.Domain = CreateClassAndSelector("domain"), 
                    Selectors.AxisTick = CreateClassAndSelector("tick"), Selectors.Tasks = CreateClassAndSelector("tasks"), 
                    Selectors.TaskGroup = CreateClassAndSelector("task-group"), Selectors.SingleTask = CreateClassAndSelector("task"), 
                    Selectors.TaskRect = CreateClassAndSelector("task-rect"), Selectors.TaskProgress = CreateClassAndSelector("task-progress"), 
                    Selectors.TaskResource = CreateClassAndSelector("task-resource"), Selectors.SingleMilestone = CreateClassAndSelector("milestone"), 
                    Selectors.TaskLabels = CreateClassAndSelector("task-labels"), Selectors.TaskLines = CreateClassAndSelector("task-lines"), 
                    Selectors.SingleTaskLine = CreateClassAndSelector("task-line"), Selectors.Label = CreateClassAndSelector("label"), 
                    Selectors.LegendItems = CreateClassAndSelector("legendItem"), Selectors.LegendTitle = CreateClassAndSelector("legendTitle");
                }(Selectors || (Selectors = {}));
                var Gantt = function() {
                    function Gantt() {
                        this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(9)
                        }, this.margin = Gantt.DefaultMargin;
                    }
                    return Gantt.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, Object.defineProperty(Gantt, "DefaultMargin", {
                        get: function() {
                            return {
                                top: 50,
                                right: 40,
                                bottom: 40,
                                left: 10
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Gantt.prototype.init = function(options) {
                        this.viewport = _.clone(options.viewport), this.style = options.style, this.body = d3.select(options.element.get(0)), 
                        this.hostServices = options.host, this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                        this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                        this.createViewport(options.element), this.updateChartSize(), this.behavior = new GanttChartBehavior(), 
                        this.colors = options.style.colorPalette.dataColors;
                    }, Gantt.prototype.createViewport = function(element) {
                        this.ganttDiv = this.body.append("div").classed(Selectors.Body["class"], !0), this.ganttSvg = this.ganttDiv.append("svg").classed(Selectors.ClassName["class"], !0), 
                        this.clearCatcher = visuals.appendClearCatcher(this.ganttSvg), this.axisGroup = this.ganttSvg.append("g").classed(Selectors.AxisGroup["class"], !0), 
                        this.lineGroup = this.ganttSvg.append("g").classed(Selectors.TaskLines["class"], !0), 
                        this.chartGroup = this.ganttSvg.append("g").classed(Selectors.Chart["class"], !0), 
                        this.taskGroup = this.chartGroup.append("g").classed(Selectors.Tasks["class"], !0), 
                        this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top);
                    }, Gantt.prototype.clearViewport = function() {
                        this.body.selectAll(Selectors.LegendItems.selector).remove(), this.body.selectAll(Selectors.LegendTitle.selector).remove(), 
                        this.axisGroup.selectAll(Selectors.AxisTick.selector).remove(), this.axisGroup.selectAll(Selectors.Domain.selector).remove(), 
                        this.lineGroup.selectAll("*").remove(), this.chartGroup.selectAll(Selectors.ChartLine.selector).remove(), 
                        this.chartGroup.selectAll(Selectors.TaskGroup.selector).remove(), this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();
                    }, Gantt.prototype.updateChartSize = function() {
                        this.ganttDiv.style({
                            height: PixelConverter.toString(this.viewport.height),
                            width: PixelConverter.toString(this.viewport.width)
                        });
                    }, Gantt.getTaskProperty = function(columnSource, child, propertyName) {
                        if (!(child && columnSource && columnSource.length > 0 && columnSource[0].roles)) return null;
                        var index = columnSource.indexOf(columnSource.filter(function(x) {
                            return x.roles[propertyName];
                        })[0]);
                        return -1 !== index ? child[index] : null;
                    }, Gantt.hasRole = function(column, name) {
                        var roles = column.roles;
                        return roles && roles[name];
                    }, Gantt.getTooltipInfo = function(task, formatters, timeInterval) {
                        void 0 === timeInterval && (timeInterval = "Days");
                        var tooltipDataArray = [];
                        return task.taskType && tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[0].name,
                            value: task.taskType
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[1].name,
                            value: task.name
                        }), isNaN(task.start.getDate()) || tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[2].name,
                            value: formatters.startDateFormatter.format(task.start.toLocaleDateString())
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[3].name,
                            value: formatters.durationFormatter.format(task.duration) + " " + timeInterval
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[4].name,
                            value: formatters.completionFormatter.format(task.completion)
                        }), task.resource && tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[5].name,
                            value: task.resource
                        }), tooltipDataArray;
                    }, Gantt.isChartHasTask = function(dataView) {
                        if (dataView.table && dataView.table.columns) for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            if (Gantt.hasRole(column, "Task")) return !0;
                        }
                        return !1;
                    }, Gantt.getFormatters = function(dataView) {
                        if (!dataView || !dataView.metadata || !dataView.metadata.columns) return null;
                        for (var dateFormat = "d", numberFormat = "#", _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                            var dvColumn = _a[_i];
                            if (dataView.categorical.categories) for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {
                                var dvCategory = _c[_b];
                                Gantt.hasRole(dvCategory.source, "StartDate") && (dateFormat = dvColumn.format);
                            }
                        }
                        return {
                            startDateFormatter: visuals.valueFormatter.create({
                                format: dateFormat
                            }),
                            durationFormatter: visuals.valueFormatter.create({
                                format: numberFormat
                            }),
                            completionFormatter: visuals.valueFormatter.create({
                                format: PercentFormat,
                                value: 1,
                                allowFormatBeautification: !0
                            })
                        };
                    }, Gantt.createTasks = function(dataView, formatters, colors) {
                        var columnSource = dataView.table.columns, data = dataView.table.rows, categories = dataView.categorical.categories[0], colorHelper = new visuals.ColorHelper(colors, void 0);
                        return data.map(function(child, index) {
                            var dateString = Gantt.getTaskProperty(columnSource, child, "StartDate");
                            dateString = Gantt.isValidDate(dateString) ? dateString : new Date(Date.now());
                            var duration = Gantt.getTaskProperty(columnSource, child, "Duration"), completionValue = Gantt.getTaskProperty(columnSource, child, "Completion"), completion = Gantt.convertToDecimal(completionValue);
                            completion = 1 >= completion ? completion : 1;
                            var taskType = Gantt.getTaskProperty(columnSource, child, "Legend"), tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType), task = {
                                id: index,
                                name: Gantt.getTaskProperty(columnSource, child, "Task"),
                                start: dateString ? dateString : new Date(Date.now()),
                                duration: duration > 0 ? duration : 1,
                                end: null,
                                completion: completion > 0 ? completion : 0,
                                resource: Gantt.getTaskProperty(columnSource, child, "Resource"),
                                taskType: taskType,
                                color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,
                                tooltipInfo: null,
                                description: "",
                                identity: visuals.SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),
                                selected: !1
                            };
                            return task.end = d3.time.day.offset(task.start, task.duration), task.tooltipInfo = Gantt.getTooltipInfo(task, formatters), 
                            task;
                        });
                    }, Gantt.createSeries = function(objects, tasks, dataView, colors) {
                        var colorHelper = new visuals.ColorHelper(colors, void 0), taskGroup = _.groupBy(tasks, function(t) {
                            return t.taskType;
                        }), taskTypes = Gantt.getAllTasksTypes(dataView), series = _.map(taskTypes.types, function(type) {
                            return {
                                tasks: taskGroup[type],
                                fill: colorHelper.getColorForMeasure(objects, type),
                                name: type,
                                identity: visuals.SelectionId.createWithMeasure(type),
                                selected: !1
                            };
                        });
                        return series;
                    }, Gantt.converter = function(dataView, colors) {
                        if (!dataView || !dataView.categorical || !Gantt.isChartHasTask(dataView) || 0 === dataView.table.rows.length) return null;
                        var settings = Gantt.parseSettings(dataView, colors), taskTypes = Gantt.getAllTasksTypes(dataView), legendData = {
                            fontSize: settings.legend.fontSize,
                            dataPoints: [],
                            title: taskTypes.typeName
                        }, colorHelper = new visuals.ColorHelper(colors, void 0);
                        legendData.dataPoints = _.map(taskTypes.types, function(type) {
                            return {
                                label: type,
                                color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),
                                icon: visuals.LegendIcon.Circle,
                                selected: !1,
                                identity: visuals.SelectionId.createWithMeasure(type)
                            };
                        });
                        var formatters = this.getFormatters(dataView), tasks = Gantt.createTasks(dataView, formatters, colors), series = Gantt.createSeries(dataView.metadata.objects, tasks, dataView, colors), viewModel = {
                            dataView: dataView,
                            settings: settings,
                            tasks: tasks,
                            series: series,
                            legendData: legendData,
                            taskTypes: taskTypes
                        };
                        return viewModel;
                    }, Gantt.parseSettings = function(dataView, colors) {
                        var result = _.cloneDeep(Gantt.DefaultSettings);
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return result;
                        var objects = dataView.metadata.objects;
                        return result.general.groupTasks = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.general.groupTasks, Gantt.DefaultSettings.general.groupTasks), 
                        result.taskLabels.show = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.taskLabels.show, Gantt.DefaultSettings.taskLabels.show), 
                        result.taskLabels.fill = powerbi.DataViewObjects.getFillColor(objects, Gantt.Properties.taskLabels.fill, Gantt.DefaultSettings.taskLabels.fill), 
                        result.taskLabels.fontSize = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.taskLabels.fontSize, Gantt.DefaultSettings.taskLabels.fontSize), 
                        result.taskLabels.width = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.taskLabels.width, result.taskLabels.show ? Gantt.DefaultSettings.taskLabels.width : 0), 
                        result.taskCompletion.show = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.taskCompletion.show, Gantt.DefaultSettings.taskCompletion.show), 
                        delete result.taskCompletion.show, result.taskCompletion.fill = powerbi.DataViewObjects.getFillColor(objects, Gantt.Properties.taskCompletion.fill, Gantt.DefaultSettings.taskCompletion.fill), 
                        result.taskResource.show = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.taskResource.show, Gantt.DefaultSettings.taskResource.show), 
                        result.taskResource.fontSize = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.taskResource.fontSize, Gantt.DefaultSettings.taskResource.fontSize), 
                        result.taskResource.fill = powerbi.DataViewObjects.getFillColor(objects, Gantt.Properties.taskResource.fill, Gantt.DefaultSettings.taskResource.fill), 
                        result.dateType.type = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.dateType.type, Gantt.DefaultSettings.dateType.type), 
                        result.legend.show = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.legend.show, Gantt.DefaultSettings.legend.show), 
                        result.legend.fontSize = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.legend.fontSize, Gantt.DefaultSettings.legend.fontSize), 
                        result.legend.labelColor = powerbi.DataViewObjects.getFillColor(objects, Gantt.Properties.legend.labelColor, Gantt.DefaultSettings.legend.labelColor), 
                        result.legend.position = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.legend.position, Gantt.DefaultSettings.legend.position), 
                        result.legend.showTitle = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.legend.showTitle, Gantt.DefaultSettings.legend.showTitle), 
                        result.legend.titleText = powerbi.DataViewObjects.getValue(objects, Gantt.Properties.legend.titleText, Gantt.DefaultSettings.legend.titleText), 
                        result;
                    }, Gantt.isValidDate = function(date) {
                        return "[object Date]" !== Object.prototype.toString.call(date) ? !1 : !isNaN(date.getTime());
                    }, Gantt.convertToDecimal = function(number) {
                        return number >= 0 && 1 >= number ? number : number / 100;
                    }, Gantt.getAllTasksTypes = function(dataView) {
                        var taskTypes, types = [], groupName = "", data = dataView.table.rows, index = _.findIndex(dataView.table.columns, function(col) {
                            return col.roles.hasOwnProperty("Legend");
                        });
                        return -1 !== index && (groupName = dataView.table.columns[index].displayName, types = _.unique(data, function(d) {
                            return d[index];
                        }).map(function(d) {
                            return d[index];
                        })), taskTypes = {
                            typeName: groupName,
                            types: types
                        };
                    }, Gantt.prototype.renderLegend = function() {
                        if (this.viewModel.legendData) {
                            visuals.LegendData.update(this.viewModel.legendData, powerbi.DataViewObjects.getObject(this.viewModel.dataView.metadata.objects, "legend", {}));
                            var position = this.viewModel.settings.legend.show ? visuals.LegendPosition[this.viewModel.settings.legend.position] : visuals.LegendPosition.None;
                            switch (this.legend.changeOrientation(position), this.legend.drawLegend(this.viewModel.legendData, _.clone(this.viewport)), 
                            visuals.Legend.positionChartArea(this.ganttDiv, this.legend), this.legend.getOrientation()) {
                              case visuals.LegendPosition.Left:
                              case visuals.LegendPosition.LeftCenter:
                              case visuals.LegendPosition.Right:
                              case visuals.LegendPosition.RightCenter:
                                this.viewport.width -= this.legend.getMargins().width;
                                break;

                              case visuals.LegendPosition.Top:
                              case visuals.LegendPosition.TopCenter:
                              case visuals.LegendPosition.Bottom:
                              case visuals.LegendPosition.BottomCenter:
                                this.viewport.height -= this.legend.getMargins().height;
                            }
                        }
                    }, Gantt.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            if (this.viewModel = Gantt.converter(options.dataViews[0], this.colors), !this.viewModel) return void this.clearViewport();
                            this.viewport = _.clone(options.viewport), this.margin = Gantt.DefaultMargin, this.renderLegend(), 
                            this.updateChartSize();
                            var tasks = this.viewModel.tasks;
                            if (this.interactivityService && (this.interactivityService.applySelectionStateToData(tasks), 
                            this.interactivityService.applySelectionStateToData(this.viewModel.series)), tasks.length > 0) {
                                var tasksSortedByStartDate = _.sortBy(tasks, function(t) {
                                    return t.start;
                                }), tasksSortedByEndDate = _.sortBy(tasks, function(t) {
                                    return t.end;
                                }), dateTypeMilliseconds = this.getDateType(), startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds), groupedTasks = this.groupTasks(tasks);
                                ticks = 0 === ticks || 1 === ticks ? 2 : ticks;
                                var axisLength = 50 * ticks;
                                this.ganttSvg.attr({
                                    height: PixelConverter.toString(groupedTasks.length * ChartLineHeight + this.margin.top),
                                    width: PixelConverter.toString(this.margin.left + this.viewModel.settings.taskLabels.width + axisLength + Gantt.DefaultValues.ResourceWidth)
                                });
                                var viewportIn = {
                                    height: this.viewport.height,
                                    width: axisLength
                                }, xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, !1);
                                if (this.timeScale = xAxisProperties.scale, this.renderAxis(xAxisProperties, 200), 
                                this.renderTasks(groupedTasks), this.createMilestoneLine(groupedTasks), this.updateTaskLabels(groupedTasks, this.viewModel.settings.taskLabels.width), 
                                this.updateElementsPositions(this.viewport, this.margin), this.interactivityService) {
                                    var behaviorOptions = {
                                        clearCatcher: this.clearCatcher,
                                        taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),
                                        legendSelection: this.body.selectAll(Selectors.LegendItems.selector),
                                        interactivityService: this.interactivityService
                                    };
                                    this.interactivityService.bind(tasks, this.behavior, behaviorOptions);
                                }
                            }
                        }
                    }, Gantt.prototype.getDateType = function() {
                        var milliSeconds = MillisecondsInWeek;
                        switch (this.viewModel.settings.dateType.type) {
                          case "Day":
                            milliSeconds = MillisecondsInADay;
                            break;

                          case "Week":
                            milliSeconds = MillisecondsInWeek;
                            break;

                          case "Month":
                            milliSeconds = MillisecondsInAMonth;
                            break;

                          case "Year":
                            milliSeconds = MillisecondsInAYear;
                        }
                        return milliSeconds;
                    }, Gantt.prototype.calculateAxes = function(viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {
                        var dataTypeDatetime = powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Date), category = {
                            displayName: "StartDate",
                            queryName: "StartDate",
                            type: dataTypeDatetime,
                            index: 0
                        }, visualOptions = {
                            viewport: viewportIn,
                            margin: this.margin,
                            forcedXDomain: [ startDate, endDate ],
                            forceMerge: !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: powerbi.visuals.axisScale.linear,
                            valueAxisScaleType: null,
                            valueAxisDisplayUnits: 0,
                            categoryAxisDisplayUnits: 0,
                            trimOrdinalDataOnOverflow: !1,
                            forcedTickCount: ticksCount
                        }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);
                        return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, Gantt.prototype.calculateAxesProperties = function(viewportIn, options, axisLength, metaDataColumn) {
                        var _this = this, xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: viewportIn.width,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: Gantt.DefaultValues.DateFormatStrings[this.viewModel.settings.dateType.type],
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return visuals.valueFormatter.format(new Date(index), Gantt.DefaultValues.DateFormatStrings[_this.viewModel.settings.dateType.type]);
                            },
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        });
                        return xAxisProperties.axisLabel = metaDataColumn.displayName, xAxisProperties;
                    }, Gantt.prototype.groupTasks = function(tasks) {
                        if (this.viewModel.settings.general.groupTasks) {
                            var groupedTasks = _.groupBy(tasks, function(x) {
                                return x.name;
                            }), result = _.map(groupedTasks, function(x, i) {
                                return {
                                    name: i,
                                    tasks: groupedTasks[i]
                                };
                            });
                            return result.forEach(function(x, i) {
                                x.tasks.forEach(function(t) {
                                    return t.id = i;
                                }), x.id = i;
                            }), result;
                        }
                        return tasks.map(function(x) {
                            return {
                                name: x.name,
                                id: x.id,
                                tasks: [ x ]
                            };
                        });
                    }, Gantt.prototype.renderAxis = function(xAxisProperties, duration) {
                        var xAxis = xAxisProperties.axis;
                        xAxis.orient("bottom"), this.axisGroup.transition().duration(duration).call(xAxis);
                    }, Gantt.prototype.updateTaskLabels = function(tasks, width) {
                        var axisLabel, _this = this, taskLineCoordinateX = 15, taskLabelsShow = this.viewModel ? this.viewModel.settings.taskLabels.show : !0, taskLabelsColor = this.viewModel ? this.viewModel.settings.taskLabels.fill : Gantt.DefaultSettings.taskLabels.fill, taskLabelsFontSize = this.viewModel ? this.viewModel.settings.taskLabels.fontSize : Gantt.DefaultSettings.taskLabels.fontSize;
                        taskLabelsShow ? (axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks), 
                        axisLabel.enter().append("text").classed(Selectors.Label["class"], !0), axisLabel.attr({
                            x: taskLineCoordinateX,
                            y: function(task, i) {
                                return _this.getTaskLabelCoordinateY(task.id);
                            },
                            fill: taskLabelsColor,
                            "stroke-width": 1
                        }).style("font-size", PixelConverter.fromPoint(taskLabelsFontSize)).text(function(task) {
                            return task.name;
                        }), axisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width - 20, powerbi.TextMeasurementService.svgEllipsis), 
                        axisLabel.append("title").text(function(task) {
                            return task.name;
                        }), axisLabel.exit().remove()) : this.lineGroup.selectAll(Selectors.Label.selector).remove();
                    }, Gantt.prototype.renderTasks = function(groupedTasks) {
                        var _this = this, taskGroupSelection = this.taskGroup.selectAll(Selectors.TaskGroup.selector).data(groupedTasks), taskProgressColor = this.viewModel ? this.viewModel.settings.taskCompletion.fill : Gantt.DefaultSettings.taskCompletion.fill, taskResourceShow = this.viewModel ? this.viewModel.settings.taskResource.show : !0, padding = 4, taskResourceColor = this.viewModel ? this.viewModel.settings.taskResource.fill : Gantt.DefaultSettings.taskResource.fill, taskResourceFontSize = this.viewModel ? this.viewModel.settings.taskResource.fontSize : Gantt.DefaultSettings.taskResource.fontSize;
                        taskGroupSelection.enter().append("g").classed(Selectors.TaskGroup["class"], !0);
                        var taskSelection = taskGroupSelection.selectAll(Selectors.SingleTask.selector).data(function(d) {
                            return d.tasks;
                        });
                        taskSelection.enter().append("g").classed(Selectors.SingleTask["class"], !0);
                        var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function(d) {
                            return [ d ];
                        });
                        taskRect.enter().append("rect").classed(Selectors.TaskRect["class"], !0), taskRect.classed(Selectors.TaskRect["class"], !0).attr({
                            x: function(task) {
                                return _this.timeScale(task.start);
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id);
                            },
                            width: function(task) {
                                return _this.taskDurationToWidth(task);
                            },
                            height: function() {
                                return _this.getBarHeight();
                            }
                        }).style("fill", function(task) {
                            return task.color;
                        }), taskRect.exit().remove();
                        var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function(d) {
                            return [ d ];
                        });
                        if (taskProgress.enter().append("rect").classed(Selectors.TaskProgress["class"], !0), 
                        taskProgress.attr({
                            x: function(task) {
                                return _this.timeScale(task.start);
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2;
                            },
                            width: function(task) {
                                return _this.setTaskProgress(task);
                            },
                            height: Gantt.DefaultValues.ProgressBarHeight
                        }).style("fill", taskProgressColor), taskProgress.exit().remove(), taskResourceShow) {
                            var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function(d) {
                                return [ d ];
                            });
                            taskResource.enter().append("text").classed(Selectors.TaskResource["class"], !0), 
                            taskResource.attr({
                                x: function(task) {
                                    return _this.timeScale(task.end) + padding;
                                },
                                y: function(task) {
                                    return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 + padding;
                                }
                            }).text(function(task) {
                                return task.resource;
                            }).style({
                                fill: taskResourceColor,
                                "font-size": PixelConverter.fromPoint(taskResourceFontSize)
                            }).call(visuals.AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, powerbi.TextMeasurementService.svgEllipsis), 
                            taskResource.exit().remove();
                        } else taskSelection.selectAll(Selectors.TaskResource.selector).remove();
                        visuals.TooltipManager.addTooltip(taskSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), taskSelection.exit().remove(), taskGroupSelection.exit().remove();
                    }, Gantt.prototype.onClearSelection = function() {
                        this.selectionManager.clear();
                    }, Gantt.prototype.getTaskLabelCoordinateY = function(taskIndex) {
                        var fontSize = +this.viewModel.settings.taskLabels.fontSize;
                        return ChartLineHeight * taskIndex + (this.getBarHeight() + 5 - (40 - fontSize) / 4);
                    }, Gantt.prototype.setTaskProgress = function(task) {
                        var fraction = task.completion / 1, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;
                        return progress;
                    }, Gantt.prototype.getBarYCoordinate = function(lineNumber) {
                        return ChartLineHeight * lineNumber + PaddingTasks;
                    }, Gantt.prototype.getBarHeight = function() {
                        return ChartLineHeight / 1.5;
                    }, Gantt.prototype.taskDurationToWidth = function(task) {
                        return this.timeScale(task.end) - this.timeScale(task.start);
                    }, Gantt.prototype.getTooltipForMilstoneLine = function(timestamp, milestoneTitle) {
                        var stringDate = new Date(timestamp).toDateString(), tooltip = [ {
                            displayName: milestoneTitle,
                            value: stringDate
                        } ];
                        return tooltip;
                    }, Gantt.prototype.createMilestoneLine = function(tasks, milestoneTitle, timestamp) {
                        void 0 === milestoneTitle && (milestoneTitle = "Today"), void 0 === timestamp && (timestamp = Date.now());
                        var line = [ {
                            x1: this.timeScale(timestamp),
                            y1: 0,
                            x2: this.timeScale(timestamp),
                            y2: this.getMilestoneLineLength(tasks.length),
                            tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)
                        } ], chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);
                        chartLineSelection.enter().append("line").classed(Selectors.ChartLine["class"], !0), 
                        chartLineSelection.attr({
                            x1: function(line) {
                                return line.x1;
                            },
                            y1: function(line) {
                                return line.y1;
                            },
                            x2: function(line) {
                                return line.x2;
                            },
                            y2: function(line) {
                                return line.y2;
                            },
                            tooltipInfo: function(line) {
                                return line.tooltipInfo;
                            }
                        }), visuals.TooltipManager.addTooltip(chartLineSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), chartLineSelection.exit().remove();
                    }, Gantt.prototype.updateElementsPositions = function(viewport, margin) {
                        this.axisGroup.attr("transform", visuals.SVGUtil.translate(this.viewModel.settings.taskLabels.width + margin.left, 15)), 
                        this.chartGroup.attr("transform", visuals.SVGUtil.translate(this.viewModel.settings.taskLabels.width + margin.left, margin.top)), 
                        this.lineGroup.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                    }, Gantt.prototype.getMilestoneLineLength = function(numOfTasks) {
                        return numOfTasks * ChartLineHeight;
                    }, Gantt.prototype.enumerateGeneral = function(settings) {
                        return [];
                    }, Gantt.prototype.enumerateLegend = function(settings) {
                        return [ {
                            displayName: Gantt.Properties.legend.show.objectName,
                            selector: null,
                            properties: settings.legend,
                            objectName: Gantt.Properties.legend.show.objectName
                        } ];
                    }, Gantt.prototype.enumerateDataPoints = function(settings) {
                        return this.viewModel.series.map(function(item) {
                            return {
                                objectName: "dataPoint",
                                displayName: item.name,
                                selector: visuals.ColorHelper.normalizeSelector(item.identity.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: item.fill
                                        }
                                    }
                                }
                            };
                        });
                    }, Gantt.prototype.enumerateTaskCompletion = function(settings) {
                        return [ {
                            selector: null,
                            properties: settings.taskCompletion,
                            objectName: Gantt.Properties.taskCompletion.show.objectName
                        } ];
                    }, Gantt.prototype.enumerateTaskLabels = function(settings) {
                        return [ {
                            selector: null,
                            properties: settings.taskLabels,
                            objectName: Gantt.Properties.taskLabels.show.objectName
                        } ];
                    }, Gantt.prototype.enumerateTaskResources = function(settings) {
                        return [ {
                            selector: null,
                            properties: settings.taskResource,
                            objectName: Gantt.Properties.taskResource.show.objectName
                        } ];
                    }, Gantt.prototype.enumerateDateType = function(settings) {
                        return [ {
                            selector: null,
                            properties: settings.dateType,
                            objectName: Gantt.Properties.dateType.type.objectName
                        } ];
                    }, Gantt.prototype.enumerateObjectInstances = function(options) {
                        var settings = this.viewModel && this.viewModel.settings || Gantt.DefaultSettings, enumeration = new visuals.ObjectEnumerationBuilder(), push = function(instances) {
                            return instances.forEach(function(x) {
                                return enumeration.pushInstance(x);
                            });
                        };
                        switch (options.objectName) {
                          case "general":
                            push(this.enumerateGeneral(settings));
                            break;

                          case "legend":
                            push(this.enumerateLegend(settings));
                            break;

                          case "dataPoint":
                            push(this.enumerateDataPoints(settings));
                            break;

                          case "taskLabels":
                            push(this.enumerateTaskLabels(settings));
                            break;

                          case "taskCompletion":
                            push(this.enumerateTaskCompletion(settings));
                            break;

                          case "taskResource":
                            push(this.enumerateTaskResources(settings));
                            break;

                          case "dateType":
                            push(this.enumerateDateType(settings));
                        }
                        return enumeration.complete();
                    }, Gantt.DefaultSettings = {
                        general: {
                            groupTasks: !1
                        },
                        legend: {
                            show: !0,
                            position: visuals.legendPosition.right,
                            showTitle: !0,
                            titleText: "",
                            labelColor: "#000000",
                            fontSize: 8
                        },
                        taskLabels: {
                            show: !0,
                            fill: "#000000",
                            fontSize: 9,
                            width: 110
                        },
                        taskCompletion: {
                            show: !0,
                            fill: "#000000"
                        },
                        taskResource: {
                            show: !0,
                            fill: "#000000",
                            fontSize: 9
                        },
                        dateType: {
                            type: GanttDateType.Week
                        }
                    }, Gantt.DefaultValues = {
                        AxisTickSize: 6,
                        MaxTaskOpacity: 1,
                        MinTaskOpacity: .4,
                        ProgressBarHeight: 4,
                        ResourceWidth: 100,
                        TaskColor: "#00B099",
                        TaskLineWidth: 15,
                        DefaultDateType: GanttDateType.Week,
                        DateFormatStrings: {
                            Day: "MMM dd",
                            Week: "MMM dd",
                            Month: "MMM yyyy",
                            Year: "yyyy"
                        }
                    }, Gantt.capabilities = {
                        dataRoles: [ {
                            name: "Legend",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "Task",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Task"
                        }, {
                            name: "StartDate",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Start Date"
                        }, {
                            name: "Duration",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Duration",
                            requiredTypes: [ {
                                numeric: !0
                            }, {
                                integer: !0
                            } ]
                        }, {
                            name: "Completion",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "% Completion",
                            requiredTypes: [ {
                                numeric: !0
                            }, {
                                integer: !0
                            } ]
                        }, {
                            name: "Resource",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Resource"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 1,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 0
                                },
                                Duration: {
                                    min: 0,
                                    max: 0
                                },
                                Completion: {
                                    min: 0,
                                    max: 0
                                },
                                Resource: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 1,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 1
                                },
                                Duration: {
                                    min: 0,
                                    max: 0
                                },
                                Completion: {
                                    min: 0,
                                    max: 0
                                },
                                Resource: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 0,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 1
                                },
                                Duration: {
                                    min: 0,
                                    max: 1
                                },
                                Completion: {
                                    min: 0,
                                    max: 1
                                },
                                Resource: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            table: {
                                rows: {
                                    select: [ {
                                        "for": {
                                            "in": "Legend"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Task"
                                        }
                                    }, {
                                        "for": {
                                            "in": "StartDate"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Duration"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Completion"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Resource"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    groupTasks: {
                                        displayName: "Group Tasks",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                description: "Display legend options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            taskLabels: {
                                displayName: "Category Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Font Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            taskCompletion: {
                                displayName: "Task Completion",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Completion Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            taskResource: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Font Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dateType: {
                                displayName: "Gantt Date Type",
                                properties: {
                                    type: {
                                        displayName: "Type",
                                        type: {
                                            enumeration: createEnumTypeFromEnum(GanttDateType)
                                        }
                                    }
                                }
                            }
                        },
                        sorting: {
                            "default": {}
                        }
                    }, Gantt.Properties = Gantt.getProperties(Gantt.capabilities), Gantt;
                }();
                samples.Gantt = Gantt;
                var GanttChartBehavior = function() {
                    function GanttChartBehavior() {}
                    return GanttChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var clearCatcher = options.clearCatcher;
                        options.taskSelection.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, GanttChartBehavior.prototype.renderSelection = function(hasSelection) {
                        this.options.taskSelection.style("opacity", function(d) {
                            return hasSelection && !d.selected ? Gantt.DefaultValues.MinTaskOpacity : Gantt.DefaultValues.MaxTaskOpacity;
                        });
                    }, GanttChartBehavior;
                }();
                samples.GanttChartBehavior = GanttChartBehavior;
                var GanttChartWarning = function() {
                    function GanttChartWarning() {}
                    return Object.defineProperty(GanttChartWarning.prototype, "code", {
                        get: function() {
                            return "GanttChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), GanttChartWarning.prototype.getMessages = function(resourceProvider) {
                        var visualMessage, message = "This visual requires task value", titleKey = "", detailKey = "";
                        return visualMessage = {
                            message: message,
                            title: resourceProvider.get(titleKey),
                            detail: resourceProvider.get(detailKey)
                        };
                    }, GanttChartWarning;
                }();
                samples.GanttChartWarning = GanttChartWarning;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, SelectionManager = visuals.utility.SelectionManager, px = jsCommon.PixelConverter.toString, pt = jsCommon.PixelConverter.fromPoint, fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;
                samples.Months = powerbi.createEnumType([ {
                    value: 1,
                    displayName: "January"
                }, {
                    value: 2,
                    displayName: "February"
                }, {
                    value: 3,
                    displayName: "March"
                }, {
                    value: 4,
                    displayName: "April"
                }, {
                    value: 5,
                    displayName: "May"
                }, {
                    value: 6,
                    displayName: "June"
                }, {
                    value: 7,
                    displayName: "July"
                }, {
                    value: 8,
                    displayName: "August"
                }, {
                    value: 9,
                    displayName: "September"
                }, {
                    value: 10,
                    displayName: "October"
                }, {
                    value: 11,
                    displayName: "November"
                }, {
                    value: 12,
                    displayName: "December"
                } ]), samples.WeekDays = powerbi.createEnumType([ {
                    value: 0,
                    displayName: "Sunday"
                }, {
                    value: 1,
                    displayName: "Monday"
                }, {
                    value: 2,
                    displayName: "Tuesday"
                }, {
                    value: 3,
                    displayName: "Wednesday"
                }, {
                    value: 4,
                    displayName: "Thursday"
                }, {
                    value: 5,
                    displayName: "Friday"
                }, {
                    value: 6,
                    displayName: "Saturday"
                } ]), function(GranularityType) {
                    GranularityType[GranularityType.year = 0] = "year", GranularityType[GranularityType.quarter = 1] = "quarter", 
                    GranularityType[GranularityType.month = 2] = "month", GranularityType[GranularityType.week = 3] = "week", 
                    GranularityType[GranularityType.day = 4] = "day";
                }(samples.GranularityType || (samples.GranularityType = {}));
                var GranularityType = samples.GranularityType, SelectedCellColorProp = {
                    objectName: "cells",
                    propertyName: "fillSelected"
                }, UnselectedCellColorProp = {
                    objectName: "cells",
                    propertyName: "fillUnselected"
                }, TimeRangeColorProp = {
                    objectName: "rangeHeader",
                    propertyName: "fontColor"
                }, TimeRangeSizeProp = {
                    objectName: "rangeHeader",
                    propertyName: "textSize"
                }, TimeRangeShowProp = {
                    objectName: "rangeHeader",
                    propertyName: "show"
                }, LabelsColorProp = {
                    objectName: "labels",
                    propertyName: "fontColor"
                }, LabelsSizeProp = {
                    objectName: "labels",
                    propertyName: "textSize"
                }, LabelsShowProp = {
                    objectName: "labels",
                    propertyName: "show"
                }, CalendarMonthProp = {
                    objectName: "calendar",
                    propertyName: "month"
                }, CalendarDayProp = {
                    objectName: "calendar",
                    propertyName: "day"
                }, WeekDayProp = {
                    objectName: "weekDay",
                    propertyName: "day"
                }, GranularityNames = [ {
                    granularityType: GranularityType.year,
                    name: "year"
                }, {
                    granularityType: GranularityType.quarter,
                    name: "quarter"
                }, {
                    granularityType: GranularityType.month,
                    name: "month"
                }, {
                    granularityType: GranularityType.week,
                    name: "week"
                }, {
                    granularityType: GranularityType.day,
                    name: "day"
                } ], TimelineGranularity = function() {
                    function TimelineGranularity() {
                        this.datePeriods = [];
                    }
                    return TimelineGranularity.prototype.shortMonthName = function(date) {
                        return date.toString().split(" ")[1];
                    }, TimelineGranularity.prototype.resetDatePeriods = function() {
                        this.datePeriods = [];
                    }, TimelineGranularity.prototype.getDatePeriods = function() {
                        return this.datePeriods;
                    }, TimelineGranularity.prototype.getExtendedLabel = function() {
                        return this.extendedLabel;
                    }, TimelineGranularity.prototype.setExtendedLabel = function(extendedLabel) {
                        this.extendedLabel = extendedLabel;
                    }, TimelineGranularity.prototype.createLabels = function(granularity) {
                        var lastDatePeriod, labels = [];
                        return _.map(this.datePeriods, function(x) {
                            !_.isEmpty(labels) && granularity.sameLabel(x, lastDatePeriod) || (lastDatePeriod = x, 
                            labels.push(granularity.generateLabel(x)));
                        }), labels;
                    }, TimelineGranularity.prototype.addDate = function(date, identifierArray) {
                        var datePeriods = this.getDatePeriods(), lastDatePeriod = datePeriods[datePeriods.length - 1];
                        0 !== datePeriods.length && _.isEqual(lastDatePeriod.identifierArray, identifierArray) ? lastDatePeriod.endDate = date : (datePeriods.length > 0 && (lastDatePeriod.endDate = date), 
                        datePeriods.push({
                            identifierArray: identifierArray,
                            startDate: date,
                            endDate: date,
                            week: this.determineWeek(date),
                            year: this.determineYear(date),
                            fraction: 1,
                            index: datePeriods.length
                        }));
                    }, TimelineGranularity.prototype.setNewEndDate = function(date) {
                        _.last(this.datePeriods).endDate = date;
                    }, TimelineGranularity.prototype.splitPeriod = function(index, newFraction, newDate) {
                        var oldDatePeriod = this.datePeriods[index];
                        oldDatePeriod.fraction -= newFraction;
                        var newDateObject = {
                            identifierArray: oldDatePeriod.identifierArray,
                            startDate: newDate,
                            endDate: oldDatePeriod.endDate,
                            week: this.determineWeek(newDate),
                            year: this.determineYear(newDate),
                            fraction: newFraction,
                            index: oldDatePeriod.index + oldDatePeriod.fraction
                        };
                        oldDatePeriod.endDate = newDate, this.datePeriods.splice(index + 1, 0, newDateObject);
                    }, TimelineGranularity.prototype.previousMonth = function(month) {
                        return month > 0 ? month - 1 : 11;
                    }, TimelineGranularity.prototype.nextMonth = function(month) {
                        return 11 > month ? month + 1 : 0;
                    }, TimelineGranularity.prototype.countWeeks = function(startDate, endDate) {
                        var totalDays;
                        if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate()) totalDays = endDate.getDate() - startDate.getDate(); else {
                            totalDays = endDate.getDate() - 1;
                            for (var lastMonth = this.nextMonth(startDate.getMonth()), month = endDate.getMonth(); month !== lastMonth; ) totalDays += new Date(endDate.getFullYear(), month, 0).getDate(), 
                            month = this.previousMonth(month);
                            totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();
                        }
                        return 1 + Math.floor(totalDays / 7);
                    }, TimelineGranularity.prototype.determineWeek = function(date) {
                        var year = date.getFullYear();
                        this.inPreviousYear(date) && year--;
                        var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year), weeks = this.countWeeks(dateOfFirstWeek, date);
                        return [ weeks, year ];
                    }, TimelineGranularity.prototype.inPreviousYear = function(date) {
                        var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());
                        return dateOfFirstWeek > date;
                    }, TimelineGranularity.prototype.determineYear = function(date) {
                        var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());
                        return date.getFullYear() - (date >= firstDay ? 0 : 1);
                    }, TimelineGranularity;
                }();
                samples.TimelineGranularity = TimelineGranularity;
                var DayGranularity = function(_super) {
                    function DayGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(DayGranularity, _super), DayGranularity.prototype.getType = function() {
                        return GranularityType.day;
                    }, DayGranularity.prototype.splitDate = function(date) {
                        return [ this.shortMonthName(date), date.getDate(), date.getFullYear() ];
                    }, DayGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();
                    }, DayGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: this.shortMonthName(datePeriod.startDate) + " " + datePeriod.startDate.getDate() + " - " + datePeriod.year,
                            text: datePeriod.startDate.getDate().toString(),
                            id: datePeriod.index
                        };
                    }, DayGranularity;
                }(TimelineGranularity);
                samples.DayGranularity = DayGranularity;
                var MonthGranularity = function(_super) {
                    function MonthGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(MonthGranularity, _super), MonthGranularity.prototype.getType = function() {
                        return GranularityType.month;
                    }, MonthGranularity.prototype.splitDate = function(date) {
                        return [ this.shortMonthName(date), date.getFullYear() ];
                    }, MonthGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);
                    }, MonthGranularity.prototype.generateLabel = function(datePeriod) {
                        var shortMonthName = this.shortMonthName(datePeriod.startDate);
                        return {
                            title: shortMonthName,
                            text: shortMonthName,
                            id: datePeriod.index
                        };
                    }, MonthGranularity;
                }(TimelineGranularity);
                samples.MonthGranularity = MonthGranularity;
                var WeekGranularity = function(_super) {
                    function WeekGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(WeekGranularity, _super), WeekGranularity.prototype.getType = function() {
                        return GranularityType.week;
                    }, WeekGranularity.prototype.splitDate = function(date) {
                        return this.determineWeek(date);
                    }, WeekGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);
                    }, WeekGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: "Week " + datePeriod.week[0] + " - " + datePeriod.week[1],
                            text: "W" + datePeriod.week[0],
                            id: datePeriod.index
                        };
                    }, WeekGranularity;
                }(TimelineGranularity);
                samples.WeekGranularity = WeekGranularity;
                var QuarterGranularity = function(_super) {
                    function QuarterGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(QuarterGranularity, _super), QuarterGranularity.prototype.quarterText = function(date) {
                        for (var quarter = 3, year = date.getFullYear(); date < Timeline.calendar.getQuarterStartDate(year, quarter); ) quarter > 0 ? quarter-- : (quarter = 3, 
                        year--);
                        return quarter++, "Q" + quarter;
                    }, QuarterGranularity.prototype.getType = function() {
                        return GranularityType.quarter;
                    }, QuarterGranularity.prototype.splitDate = function(date) {
                        return [ this.quarterText(date), date.getFullYear() ];
                    }, QuarterGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate) && firstDatePeriod.year === secondDatePeriod.year;
                    }, QuarterGranularity.prototype.generateLabel = function(datePeriod) {
                        var quarter = this.quarterText(datePeriod.startDate);
                        return {
                            title: quarter + " " + datePeriod.year,
                            text: quarter,
                            id: datePeriod.index
                        };
                    }, QuarterGranularity;
                }(TimelineGranularity);
                samples.QuarterGranularity = QuarterGranularity;
                var YearGranularity = function(_super) {
                    function YearGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(YearGranularity, _super), YearGranularity.prototype.getType = function() {
                        return GranularityType.year;
                    }, YearGranularity.prototype.splitDate = function(date) {
                        return [ date.getFullYear() ];
                    }, YearGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return firstDatePeriod.year === secondDatePeriod.year;
                    }, YearGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: "Year " + datePeriod.year,
                            text: datePeriod.year.toString(),
                            id: datePeriod.index
                        };
                    }, YearGranularity;
                }(TimelineGranularity);
                samples.YearGranularity = YearGranularity;
                var TimelineGranularityData = function() {
                    function TimelineGranularityData(startDate, endDate) {
                        this.granularities = [], this.setDatesRange(startDate, endDate);
                        var lastDate = this.dates[this.dates.length - 1];
                        this.endingDate = TimelineGranularityData.nextDay(lastDate);
                    }
                    return TimelineGranularityData.previousDay = function(date) {
                        var prevDay = new Date(date.getTime());
                        return prevDay.setDate(prevDay.getDate() - 1), prevDay;
                    }, TimelineGranularityData.nextDay = function(date) {
                        var nextDay = new Date(date.getTime());
                        return nextDay.setDate(nextDay.getDate() + 1), nextDay;
                    }, TimelineGranularityData.prototype.setDatesRange = function(startDate, endDate) {
                        this.dates = [];
                        for (var date = startDate; endDate >= date; ) this.dates.push(date), date = TimelineGranularityData.nextDay(date);
                    }, TimelineGranularityData.prototype.addGranularity = function(granularity) {
                        granularity.resetDatePeriods();
                        for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {
                            var date = _a[_i], identifierArray = granularity.splitDate(date);
                            granularity.addDate(date, identifierArray);
                        }
                        granularity.setNewEndDate(this.endingDate), this.granularities.push(granularity);
                    }, TimelineGranularityData.prototype.getGranularity = function(index) {
                        return this.granularities[index];
                    }, TimelineGranularityData.prototype.createGranularities = function() {
                        this.granularities = [], this.addGranularity(new YearGranularity()), this.addGranularity(new QuarterGranularity()), 
                        this.addGranularity(new MonthGranularity()), this.addGranularity(new WeekGranularity()), 
                        this.addGranularity(new DayGranularity());
                    }, TimelineGranularityData.prototype.createLabels = function() {
                        var _this = this;
                        this.granularities.forEach(function(x) {
                            x.setExtendedLabel({
                                dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],
                                weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],
                                monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],
                                quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],
                                yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : []
                            });
                        });
                    }, TimelineGranularityData;
                }();
                samples.TimelineGranularityData = TimelineGranularityData;
                var Utils = function() {
                    function Utils() {}
                    return Utils.getStartSelectionDate = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
                    }, Utils.getEndSelectionDate = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
                    }, Utils.getEndSelectionPeriod = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
                    }, Utils.getCellColor = function(d, timelineData, cellFormat) {
                        var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
                        return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;
                    }, Utils.getGranularityType = function(granularityName) {
                        var index = _.findIndex(GranularityNames, function(x) {
                            return x.name === granularityName;
                        });
                        return GranularityNames[index].granularityType;
                    }, Utils.getGranularityName = function(granularity) {
                        var index = _.findIndex(GranularityNames, function(x) {
                            return x.granularityType === granularity;
                        });
                        return GranularityNames[index].name;
                    }, Utils.separateSelection = function(timelineData, startDate, endDate) {
                        var datePeriods = timelineData.currentGranularity.getDatePeriods(), startDateIndex = _.findIndex(datePeriods, function(x) {
                            return startDate < x.endDate;
                        }), endDateIndex = _.findIndex(datePeriods, function(x) {
                            return endDate <= x.endDate;
                        });
                        timelineData.selectionStartIndex = startDateIndex, timelineData.selectionEndIndex = endDateIndex;
                        var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, !0), endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, !1);
                        if (endRatio > 0 && timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate), 
                        startRatio > 0) {
                            var startFration = datePeriods[startDateIndex].fraction - startRatio;
                            timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate), 
                            timelineData.selectionStartIndex++, timelineData.selectionEndIndex++;
                        }
                    }, Utils.getDateRatio = function(datePeriod, date, fromStart) {
                        var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime(), periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
                        return 0 === periodDifference ? 0 : dateDifference / periodDifference;
                    }, Utils.timeRangeText = function(timelineData) {
                        var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData)), endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
                        return startSelectionDateArray.join(" ") + " - " + endSelectionDateArray.join(" ");
                    }, Utils.dateRangeText = function(datePeriod) {
                        return datePeriod.startDate.toDateString() + " - " + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();
                    }, Utils.unseparateSelection = function(datePeriods) {
                        var separationIndex = _.findIndex(datePeriods, function(x) {
                            return x.fraction < 1;
                        });
                        return separationIndex >= 0 ? (datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate, 
                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction, 
                        datePeriods.splice(separationIndex + 1, 1), !0) : !1;
                    }, Utils;
                }();
                samples.Utils = Utils;
                var Calendar = function() {
                    function Calendar(calendarFormat) {
                        var _this = this;
                        this.firstDayOfWeek = calendarFormat.weekDayProperty, this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1, 
                        this.firstDayOfYear = calendarFormat.firstDayProperty, this.dateOfFirstWeek = {}, 
                        this.quarterFirstMonths = [ 0, 3, 6, 9 ].map(function(x) {
                            return x + _this.firstMonthOfYear;
                        });
                    }
                    return Calendar.prototype.getFirstDayOfWeek = function() {
                        return this.firstDayOfWeek;
                    }, Calendar.prototype.getFirstMonthOfYear = function() {
                        return this.firstMonthOfYear;
                    }, Calendar.prototype.getFirstDayOfYear = function() {
                        return this.firstDayOfYear;
                    }, Calendar.prototype.getQuarterStartDate = function(year, quarterIndex) {
                        return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);
                    }, Calendar.prototype.isChanged = function(calendarFormat) {
                        return this.firstMonthOfYear !== calendarFormat.firstMonthProperty - 1 || this.firstDayOfYear !== calendarFormat.firstDayProperty || this.firstDayOfWeek !== calendarFormat.weekDayProperty;
                    }, Calendar.prototype.calculateDateOfFirstWeek = function(year) {
                        for (var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear); date.getDay() !== this.firstDayOfWeek; ) date = TimelineGranularityData.nextDay(date);
                        return date;
                    }, Calendar.prototype.getDateOfFirstWeek = function(year) {
                        return this.dateOfFirstWeek[year] || (this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year)), 
                        this.dateOfFirstWeek[year];
                    }, Calendar;
                }();
                samples.Calendar = Calendar;
                var Timeline = function() {
                    function Timeline() {
                        var _this = this;
                        this.requiresNoUpdate = !1, this.datasetsChangedState = !1, this.selector = [ "Y", "Q", "M", "W", "D" ], 
                        this.timelineMargins = {
                            LeftMargin: 15,
                            RightMargin: 15,
                            TopMargin: 15,
                            BottomMargin: 10,
                            CellWidth: 40,
                            CellHeight: 25,
                            StartXpoint: 10,
                            StartYpoint: 20,
                            ElementWidth: 30,
                            MinCellWidth: 30,
                            MaxCellHeight: 60,
                            PeriodSlicerRectWidth: 15,
                            PeriodSlicerRectHeight: 23
                        }, this.defaultTimelineProperties = {
                            DefaultLabelsShow: !0,
                            TimelineDefaultTextSize: 9,
                            TimelineDefaultCellColor: "#ADD8E6",
                            TimelineDefaultCellColorOut: "#FFFFFF",
                            TimelineDefaultTimeRangeShow: !0,
                            DefaultTimeRangeColor: "#777777",
                            DefaultLabelColor: "#777777",
                            DefaultGranularity: GranularityType.month,
                            DefaultFirstMonth: 1,
                            DefaultFirstDay: 1,
                            DefaultFirstWeekDay: 0
                        }, this.timelineSelectors = {
                            TimelineVisual: createClassAndSelector("Timeline"),
                            SelectionRangeContainer: createClassAndSelector("selectionRangeContainer"),
                            textLabel: createClassAndSelector("label"),
                            LowerTextCell: createClassAndSelector("lowerTextCell"),
                            UpperTextCell: createClassAndSelector("upperTextCell"),
                            UpperTextArea: createClassAndSelector("upperTextArea"),
                            LowerTextArea: createClassAndSelector("lowerTextArea"),
                            RangeTextArea: createClassAndSelector("rangeTextArea"),
                            CellsArea: createClassAndSelector("cellsArea"),
                            CursorsArea: createClassAndSelector("cursorsArea"),
                            MainArea: createClassAndSelector("mainArea"),
                            SelectionCursor: createClassAndSelector("selectionCursor"),
                            Cell: createClassAndSelector("cell"),
                            CellRect: createClassAndSelector("cellRect"),
                            VertLine: createClassAndSelector("timelineVertLine"),
                            TimelineSlicer: createClassAndSelector("timelineSlicer"),
                            PeriodSlicerGranularities: createClassAndSelector("periodSlicerGranularities"),
                            PeriodSlicerSelection: createClassAndSelector("periodSlicerSelection"),
                            PeriodSlicerSelectionRect: createClassAndSelector("periodSlicerSelectionRect"),
                            PeriodSlicerRect: createClassAndSelector("periodSlicerRect")
                        }, this.drag = d3.behavior.drag().origin(function(d) {
                            return d.x = d.selectionIndex * _this.timelineProperties.cellWidth, d;
                        }).on("dragstart", function() {
                            _this.dragstarted();
                        }).on("drag", function(d) {
                            _this.dragged(d);
                        }).on("dragend", function() {
                            _this.dragended();
                        });
                    }
                    return Timeline.prototype.changeGranularity = function(granularity, startDate, endDate) {
                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()) && Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()), 
                        this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity), 
                        Utils.separateSelection(this.timelineData, startDate, endDate);
                    }, Timeline.prototype.init = function(options) {
                        this.hostServices = options.host, this.initialized = !1;
                        var element = options.element;
                        this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.timelineProperties = {
                            element: element,
                            textYPosition: 50,
                            cellsYPosition: 3 * this.timelineMargins.TopMargin + 65,
                            topMargin: this.timelineMargins.TopMargin,
                            bottomMargin: this.timelineMargins.BottomMargin,
                            leftMargin: this.timelineMargins.LeftMargin,
                            startXpoint: this.timelineMargins.StartXpoint,
                            startYpoint: this.timelineMargins.StartYpoint,
                            cellWidth: this.timelineMargins.CellWidth,
                            cellHeight: this.timelineMargins.CellHeight,
                            elementWidth: this.timelineMargins.ElementWidth,
                            rightMargin: this.timelineMargins.RightMargin
                        }, this.body = d3.select(element.get(0)), this.timelineDiv = this.body.append("div"), 
                        this.svg = this.timelineDiv.append("svg").attr("width", px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual["class"], !0), 
                        this.addWrappElements();
                    }, Timeline.prototype.addWrappElements = function() {
                        this.clearCatcher = visuals.appendClearCatcher(this.svg), this.clearCatcher.data([ this ]).on("click", function(timeline) {
                            return timeline.clear();
                        }).on("touchstart", function(timeline) {
                            return timeline.clear();
                        }), this.rangeText = this.svg.append("g").classed(this.timelineSelectors.RangeTextArea["class"], !0).append("text"), 
                        this.mainGroupElement = this.svg.append("g").classed(this.timelineSelectors.MainArea["class"], !0), 
                        this.yearLabelsElement = this.mainGroupElement.append("g"), this.quarterLabelsElement = this.mainGroupElement.append("g"), 
                        this.monthLabelsElement = this.mainGroupElement.append("g"), this.weekLabelsElement = this.mainGroupElement.append("g"), 
                        this.dayLabelsElement = this.mainGroupElement.append("g"), this.cellsElement = this.mainGroupElement.append("g").classed(this.timelineSelectors.CellsArea["class"], !0), 
                        this.cursorGroupElement = this.svg.append("g").classed(this.timelineSelectors.CursorsArea["class"], !0);
                    }, Timeline.prototype.clear = function() {
                        this.initialized && (this.selectionManager.clear(), this.timelineData && (this.timelineData.selectionStartIndex = 0, 
                        this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1, 
                        _.any(this.timelineData.timelineDatapoints, function(x) {
                            return x.index % 1 !== 0;
                        }) ? this.selectPeriod(this.timelineData.currentGranularity.getType()) : (Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth), 
                        this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat)), 
                        this.setSelection(this.timelineData)));
                    }, Timeline.prototype.drawGranular = function(timelineProperties) {
                        var _this = this, dragPeriodRectState = !1, startXpoint = timelineProperties.startXpoint, startYpoint = timelineProperties.startYpoint, elementWidth = timelineProperties.elementWidth;
                        this.selectorContainer = this.svg.append("g").classed(this.timelineSelectors.TimelineSlicer["class"], !0), 
                        this.selectorContainer.on("mouseleave", function(d) {
                            return dragPeriodRectState = !1;
                        });
                        var fillRect = this.selectorContainer.append("rect"), selectorPeriods = this.selector;
                        fillRect.attr({
                            height: px(1),
                            x: px(startXpoint),
                            y: px(startYpoint + 2),
                            width: px((selectorPeriods.length - 1) * elementWidth)
                        });
                        var fillVertLine = this.selectorContainer.selectAll("vertLines").data(selectorPeriods).enter().append("rect");
                        fillVertLine.classed(this.timelineSelectors.VertLine["class"], !0).attr({
                            x: function(d, index) {
                                return px(startXpoint + index * elementWidth);
                            },
                            y: px(startYpoint),
                            width: px(2),
                            height: px(3)
                        }).style({
                            cursor: "pointer"
                        });
                        var textLabels, text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector).data(selectorPeriods).enter().append("text").classed(this.timelineSelectors.PeriodSlicerGranularities["class"], !0);
                        textLabels = text.text(function(d) {
                            return d;
                        }).attr({
                            x: function(d, index) {
                                return px(startXpoint - 3 + index * elementWidth);
                            },
                            y: px(startYpoint - 3)
                        }), this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelectors.PeriodSlicerSelection["class"], !0), 
                        this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity)).attr({
                            x: px(startXpoint + 2 * elementWidth),
                            y: px(startYpoint + 17)
                        });
                        var selRects = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector).data(selectorPeriods).enter().append("rect").classed(this.timelineSelectors.PeriodSlicerSelectionRect["class"], !0), clickHandler = function(d, index) {
                            _this.selectPeriod(index), dragPeriodRectState = !0;
                        };
                        selRects.attr({
                            x: function(d, index) {
                                return px(startXpoint - elementWidth / 2 + index * elementWidth);
                            },
                            y: px(3),
                            width: px(elementWidth),
                            height: px(23)
                        }).style({
                            cursor: "pointer"
                        }).on("mousedown", clickHandler).on("touchstart", clickHandler).on("mouseup", function() {
                            return dragPeriodRectState = !1;
                        }).on("touchend", function() {
                            return dragPeriodRectState = !1;
                        }).on("mouseover", function(d, index) {
                            dragPeriodRectState && _this.selectPeriod(index);
                        });
                        var dragPeriodRect = d3.behavior.drag().on("dragstart", function(e, b) {
                            dragPeriodRectState = !0;
                        }).on("dragend", function(e, b) {
                            dragPeriodRectState = !1;
                        });
                        this.periodSlicerRect = this.selectorContainer.append("rect").classed(this.timelineSelectors.PeriodSlicerRect["class"], !0).attr({
                            x: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),
                            y: px(startYpoint - 16),
                            rx: px(4),
                            width: px(15),
                            height: px(23)
                        }).on("mouseup", function(d) {
                            return dragPeriodRectState = !1;
                        }), this.periodSlicerRect.call(dragPeriodRect);
                    }, Timeline.prototype.redrawPeriod = function(granularity) {
                        var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;
                        this.periodSlicerRect.transition().attr("x", px(dx - 7)), this.selectedText.text(Utils.getGranularityName(granularity));
                        var startDate = Utils.getStartSelectionDate(this.timelineData), endDate = Utils.getEndSelectionDate(this.timelineData);
                        this.changeGranularity(granularity, startDate, endDate);
                    }, Timeline.setMeasures = function(labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {
                        timelineProperties.cellsYPosition = timelineProperties.textYPosition;
                        var labelSize = fromPointToPixel(labelFormat.sizeProperty);
                        labelFormat.showProperty && (timelineProperties.cellsYPosition += 1.5 * labelSize * (granularityType + 1));
                        var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin), maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount, height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20)), width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);
                        timelineProperties.cellHeight = height, timelineProperties.cellWidth = width;
                    }, Timeline.prototype.visualChangeOnly = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata && this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {
                            var newObjects_1 = options.dataViews[0].metadata.objects, oldObjects_1 = this.options.dataViews[0].metadata.objects, properties = [ "rangeHeader", "cells", "labels" ], metadataChanged = !properties.every(function(x) {
                                return _.isEqual(newObjects_1 ? newObjects_1[x] : void 0, oldObjects_1 ? oldObjects_1[x] : void 0);
                            });
                            return options.suppressAnimations || metadataChanged;
                        }
                        return !1;
                    }, Timeline.prototype.datasetsChanged = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].categorical && options.dataViews[0].categorical.categories && options.dataViews[0].categorical.categories[0] && options.dataViews[0].categorical.categories[0].source && this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].categorical && this.options.dataViews[0].categorical.categories && this.options.dataViews[0].categorical.categories[0] && this.options.dataViews[0].categorical.categories[0].source) {
                            var newObjects = options.dataViews[0].categorical.categories[0].source.displayName, oldObjects = this.options.dataViews[0].categorical.categories[0].source.displayName;
                            if (!_.isEqual(newObjects, oldObjects)) return !0;
                        }
                        return !1;
                    }, Timeline.prototype.unavailableType = function(dataViewCategorical) {
                        return !(dataViewCategorical.categories && 1 === dataViewCategorical.categories.length && dataViewCategorical.categories[0].values && 0 !== dataViewCategorical.categories[0].values.length && dataViewCategorical.categories[0].source && dataViewCategorical.categories[0].source.type);
                    }, Timeline.prototype.unavailableChildIdentityField = function(dataViewTree) {
                        return !dataViewTree.root || !dataViewTree.root.childIdentityFields || 0 === dataViewTree.root.childIdentityFields.length;
                    }, Timeline.prototype.createTimelineOptions = function(dataView) {
                        if (this.dataView = dataView, !dataView.categorical || !dataView.metadata || this.unavailableType(dataView.categorical) || !dataView.tree || this.unavailableChildIdentityField(dataView.tree)) return !1;
                        var columnExp = dataView.tree.root.childIdentityFields[0];
                        return this.valueType = columnExp ? columnExp.ref : null, dataView.categorical.categories[0].source.type.dateTime || dataView.categorical.categories[0].source.type.numeric && ("Year" === this.valueType || "Date" === this.valueType) ? (this.values = this.prepareValues(this.dataView.categorical.categories[0].values), 
                        !0) : !1;
                    }, Timeline.prototype.prepareValues = function(values) {
                        values = values.filter(Boolean);
                        for (var i in values) {
                            var item = values[i];
                            if ("String" == typeof item && "Invalid Date" !== String(new Date(item))) return values[i] = new Date(item);
                        }
                        return values;
                    }, Timeline.prototype.createTimelineData = function() {
                        var startDate, endDate;
                        if ("Year" === this.valueType) {
                            var years = this.values;
                            startDate = new Date(_.min(years), 0), endDate = new Date(_.max(years), 11);
                        } else {
                            var dates = this.values;
                            startDate = _.min(dates), endDate = _.max(dates);
                        }
                        if (this.initialized || this.drawGranular(this.timelineProperties), this.initialized) {
                            var actualEndDate = TimelineGranularityData.nextDay(endDate), daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods(), prevStartDate = daysPeriods[0].startDate, prevEndDate = daysPeriods[daysPeriods.length - 1].endDate, changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();
                            this.newGranularity = this.timelineData.currentGranularity.getType(), changedSelection ? (this.changeGranularity(this.newGranularity, startDate, actualEndDate), 
                            this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties)) : (prevEndDate > actualEndDate && (endDate = daysPeriods[daysPeriods.length - 1].startDate), 
                            startDate > prevStartDate && (startDate = prevStartDate), this.initialized = !1);
                        }
                        this.initialized || (this.timelineGranularityData = new TimelineGranularityData(startDate, endDate), 
                        this.timelineData = {
                            elementsCount: 0,
                            timelineDatapoints: [],
                            cursorDataPoints: new Array()
                        });
                    }, Timeline.prototype.update = function(options) {
                        var visualChange = this.visualChangeOnly(options);
                        if (this.datasetsChangedState = this.datasetsChanged(options), this.requiresNoUpdate = this.requiresNoUpdate && !this.datasetsChangedState && !visualChange, 
                        this.requiresNoUpdate) return void (this.requiresNoUpdate = !1);
                        if (this.options = options, options.dataViews && options.dataViews[0]) {
                            var validOptions = this.createTimelineOptions(options.dataViews[0]);
                            if (!validOptions) return void this.clearData();
                            this.newGranularity = this.defaultTimelineProperties.DefaultGranularity, visualChange || this.createTimelineData(), 
                            this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins), 
                            this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options), 
                            this.initialized = !0;
                        }
                    }, Timeline.prototype.selectPeriod = function(periodNameIndex) {
                        this.redrawPeriod(periodNameIndex), this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins), 
                        this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);
                    }, Timeline.isDataNotMatch = function(dataView) {
                        return dataView.categorical.categories.length <= 0 || void 0 === dataView.categorical.categories[0] || void 0 === dataView.categorical.categories[0].identityFields || dataView.categorical.categories[0].identityFields.length <= 0;
                    }, Timeline.converter = function(timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {
                        var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
                        if (initialized || (timelineData.cursorDataPoints.push({
                            x: 0,
                            selectionIndex: 0,
                            cursorIndex: 0
                        }), timelineData.cursorDataPoints.push({
                            x: 0,
                            selectionIndex: 0,
                            cursorIndex: 1
                        })), initialized && !Timeline.calendar.isChanged(timelineFormat.calendarFormat) || (Timeline.calendar = new Calendar(timelineFormat.calendarFormat), 
                        timelineGranularityData.createGranularities(), timelineGranularityData.createLabels(), 
                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType), 
                        timelineData.selectionStartIndex = 0, timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1), 
                        timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName, 
                        timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0], 
                        dataView.categorical.categories[0].source.type.numeric && (timelineData.columnIdentity.ref = "Date"), 
                        !this.isDataNotMatch(dataView)) {
                            var timelineElements = timelineData.currentGranularity.getDatePeriods();
                            timelineData.elementsCount = timelineElements.length, timelineData.timelineDatapoints = [];
                            for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {
                                var currentTimePeriod = timelineElements_1[_i], datapoint = {
                                    index: currentTimePeriod.index,
                                    datePeriod: currentTimePeriod
                                };
                                timelineData.timelineDatapoints.push(datapoint);
                            }
                            var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function(x) {
                                return x.index % 1 === 0;
                            }).length;
                            return Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins), 
                            Timeline.updateCursors(timelineData, timelineProperties.cellWidth), timelineFormat;
                        }
                    }, Timeline.prototype.render = function(timelineData, timelineFormat, timelineProperties, options) {
                        var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function(x) {
                            return x.index % 1 === 0;
                        }).length;
                        this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount, 
                        this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), this.timelineDiv.attr({
                            height: px(options.viewport.height),
                            width: px(options.viewport.width),
                            "drag-resize-disabled": !0
                        }).style({
                            "overflow-x": "auto",
                            "overflow-y": "auto"
                        }), this.svg.attr({
                            height: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),
                            width: px(Math.max(0, this.svgWidth))
                        });
                        var fixedTranslateString = visuals.SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin), translateString = visuals.SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);
                        this.mainGroupElement.attr("transform", translateString), this.selectorContainer.attr("transform", fixedTranslateString), 
                        this.cursorGroupElement.attr("transform", translateString);
                        var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel(), granularityType = this.timelineData.currentGranularity.getType(), yPos = 0, yDiff = 1.5;
                        this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, 0 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, 1 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, 2 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, 3 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, 4 === granularityType), 
                        this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations), 
                        this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
                    }, Timeline.prototype.renderLabels = function(labels, labelsElement, index, isLast) {
                        var _this = this, labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);
                        if (!this.timelineFormat.labelFormat.showProperty) return void labelTextSelection.remove();
                        var labelsGroupSelection = labelTextSelection.data(labels);
                        labelsGroupSelection.enter().append("text").classed(this.timelineSelectors.textLabel["class"], !0), 
                        labelsGroupSelection.text(function(x, id) {
                            if (!isLast && 0 === id && labels.length > 1) {
                                var fontSize = pt(_this.timelineFormat.labelFormat.sizeProperty), textProperties = {
                                    text: labels[0].text,
                                    fontFamily: "arial",
                                    fontSize: fontSize
                                }, halfFirstTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
                                textProperties = {
                                    text: labels[1].text,
                                    fontFamily: "arial",
                                    fontSize: fontSize
                                };
                                var halfSecondTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2, diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);
                                if (halfFirstTextWidth + halfSecondTextWidth > diff) return "";
                            }
                            var labelFormattedTextOptions = {
                                label: x.text,
                                maxWidth: _this.timelineProperties.cellWidth * (isLast ? .9 : 3),
                                fontSize: _this.timelineFormat.labelFormat.sizeProperty
                            };
                            return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                        }).style("font-size", pt(this.timelineFormat.labelFormat.sizeProperty)).attr({
                            x: function(x) {
                                return (x.id + .5) * _this.timelineProperties.cellWidth;
                            },
                            y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),
                            fill: this.timelineFormat.labelFormat.colorProperty
                        }).append("title").text(function(x) {
                            return x.title;
                        }), labelsGroupSelection.exit().remove();
                    }, Timeline.prototype.clearData = function() {
                        this.initialized = !1, this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove(), 
                        this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove(), 
                        this.rangeText.text(""), this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove(), 
                        this.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove(), this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector);
                    }, Timeline.updateCursors = function(timelineData, cellWidth) {
                        var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;
                        timelineData.cursorDataPoints[0].selectionIndex = startDate.index;
                        var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
                        timelineData.cursorDataPoints[1].selectionIndex = endDate.index + endDate.fraction;
                    }, Timeline.fillTimelineFormat = function(objects, timelineProperties) {
                        var timelineFormat = {
                            rangeTextFormat: {
                                showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),
                                colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
                                sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)
                            },
                            cellFormat: {
                                colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),
                                colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)
                            },
                            labelFormat: {
                                showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
                                colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
                                sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)
                            },
                            calendarFormat: {
                                firstMonthProperty: powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1),
                                firstDayProperty: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),
                                weekDayProperty: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))
                            }
                        };
                        return timelineFormat;
                    }, Timeline.prototype.fillCells = function(cellFormat) {
                        var _this = this, dataPoints = this.timelineData.timelineDatapoints, cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);
                        cellSelection.attr("fill", function(d) {
                            return Utils.getCellColor(d, _this.timelineData, cellFormat);
                        });
                    }, Timeline.prototype.renderCells = function(timelineData, timelineFormat, timelineProperties, suppressAnimations) {
                        var _this = this, allDataPoints = timelineData.timelineDatapoints, totalX = 0, cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);
                        cellsSelection.enter().append("rect").classed(this.timelineSelectors.CellRect["class"], !0), 
                        cellsSelection.attr({
                            height: px(timelineProperties.cellHeight),
                            width: function(d) {
                                return px(d.datePeriod.fraction * timelineProperties.cellWidth);
                            },
                            x: function(d) {
                                var value = totalX;
                                return totalX += d.datePeriod.fraction * timelineProperties.cellWidth, px(value);
                            },
                            y: px(timelineProperties.cellsYPosition),
                            id: function(d) {
                                return d.index;
                            }
                        });
                        var clickHandler = function(d, index) {
                            d3.event.preventDefault();
                            var cursorDataPoints = _this.timelineData.cursorDataPoints, keyEvent = d3.event;
                            keyEvent.altKey || keyEvent.shiftKey ? _this.timelineData.selectionEndIndex < index ? (cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction, 
                            timelineData.selectionEndIndex = index) : (cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                            timelineData.selectionStartIndex = index) : (timelineData.selectionStartIndex = index, 
                            timelineData.selectionEndIndex = index, cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                            cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction), 
                            _this.fillCells(timelineFormat.cellFormat), _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition), 
                            _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), _this.setSelection(timelineData);
                        };
                        cellsSelection.on("click", clickHandler).on("touchstart", clickHandler), this.fillCells(timelineFormat.cellFormat), 
                        cellsSelection.exit().remove();
                    }, Timeline.prototype.dragstarted = function() {
                        this.timelineData.dragging = !0;
                    }, Timeline.prototype.dragged = function(currentCursor) {
                        if (this.timelineData.dragging === !0) {
                            var xScale = 1, container = d3.select(this.timelineSelectors.TimelineVisual.selector);
                            if (container) {
                                var transform = container.style("transform");
                                if (void 0 !== transform && "none" !== transform) {
                                    var str = transform.split("(")[1];
                                    xScale = Number(str.split(", ")[0]);
                                }
                            }
                            var cursorOverElement = this.findCursorOverElement(d3.event.x);
                            if (!cursorOverElement) return;
                            var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;
                            0 === currentCursor.cursorIndex && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex && (this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex, 
                            this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index), 
                            1 === currentCursor.cursorIndex && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex && (this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex, 
                            this.timelineData.cursorDataPoints[1].selectionIndex = currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction), 
                            this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                            this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
                        }
                    }, Timeline.prototype.findCursorOverElement = function(x) {
                        var timelineDatapoints = this.timelineData.timelineDatapoints || [], length = timelineDatapoints.length, cellWidth = this.timelineProperties.cellWidth;
                        if (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) return {
                            index: 0,
                            datapoint: timelineDatapoints[0]
                        };
                        if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) return {
                            index: length - 1,
                            datapoint: timelineDatapoints[length - 1]
                        };
                        for (var i = 1; length > i; i++) {
                            var left = timelineDatapoints[i].index * cellWidth, right = timelineDatapoints[i + 1].index * cellWidth;
                            if (x >= left && right >= x) return {
                                index: i,
                                datapoint: timelineDatapoints[i]
                            };
                        }
                        return null;
                    }, Timeline.prototype.dragended = function() {
                        this.setSelection(this.timelineData);
                    }, Timeline.prototype.renderCursors = function(timelineData, timelineFormat, cellHeight, cellsYPosition) {
                        var _this = this, cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);
                        return cursorSelection.enter().append("path").classed(this.timelineSelectors.SelectionCursor["class"], !0), 
                        cursorSelection.attr("transform", function(d) {
                            return visuals.SVGUtil.translate(d.selectionIndex * _this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition);
                        }).attr({
                            d: d3.svg.arc().innerRadius(0).outerRadius(cellHeight / 2).startAngle(function(d) {
                                return d.cursorIndex * Math.PI + Math.PI;
                            }).endAngle(function(d) {
                                return d.cursorIndex * Math.PI + 2 * Math.PI;
                            })
                        }).call(this.drag), cursorSelection.exit().remove(), cursorSelection;
                    }, Timeline.prototype.renderTimeRangeText = function(timelineData, timeRangeFormat) {
                        var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth, maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;
                        if (timeRangeFormat.showProperty && maxWidth > 0) {
                            var timeRangeText = Utils.timeRangeText(timelineData), labelFormattedTextOptions = {
                                label: timeRangeText,
                                maxWidth: maxWidth,
                                fontSize: timeRangeFormat.sizeProperty
                            }, actualText = visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                            this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer["class"], !0), 
                            this.rangeText.attr({
                                x: GranularityNames.length * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),
                                y: 40,
                                fill: timeRangeFormat.colorProperty
                            }).style({
                                "font-size": pt(timeRangeFormat.sizeProperty)
                            }).text(actualText).append("title").text(timeRangeText);
                        } else this.rangeText.text("");
                    }, Timeline.prototype.setSelection = function(timelineData) {
                        this.requiresNoUpdate = !0;
                        var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData)), upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1)), filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper), filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr), objects = {
                            merge: [ {
                                objectName: "general",
                                selector: void 0,
                                properties: {
                                    filter: filter
                                }
                            } ]
                        };
                        this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                            data: []
                        });
                    }, Timeline.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "rangeHeader":
                            this.enumerateRangeHeader(enumeration, this.dataView);
                            break;

                          case "cells":
                            this.enumerateCells(enumeration, this.dataView);
                            break;

                          case "labels":
                            this.enumerateLabels(enumeration, this.dataView);
                            break;

                          case "calendar":
                            this.enumerateCalendar(enumeration, this.dataView);
                            break;

                          case "weekDay":
                            this.enumerateWeekDay(enumeration, this.dataView);
                        }
                        return enumeration.complete();
                    }, Timeline.prototype.enumerateRangeHeader = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "rangeHeader",
                            displayName: "Selection Color",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),
                                fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
                                textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                            }
                        });
                    }, Timeline.prototype.enumerateCells = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "cells",
                            selector: null,
                            properties: {
                                fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),
                                fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)
                            }
                        });
                    }, Timeline.prototype.enumerateLabels = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "labels",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
                                fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
                                textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                            }
                        });
                    }, Timeline.prototype.enumerateCalendar = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "calendar",
                            selector: null,
                            properties: {
                                month: Math.max(1, Math.min(12, powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1))),
                                day: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, 1)))
                            }
                        });
                    }, Timeline.prototype.enumerateWeekDay = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "weekDay",
                            selector: null,
                            properties: {
                                day: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, 0)))
                            }
                        });
                    }, Timeline.capabilities = {
                        dataRoles: [ {
                            name: "Time",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Time"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Time: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Time"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Time"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    selected: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    filter: {
                                        type: {
                                            filter: {}
                                        },
                                        rule: {
                                            output: {
                                                property: "selected",
                                                selector: [ "Time" ]
                                            }
                                        }
                                    }
                                }
                            },
                            calendar: {
                                displayName: "Fiscal Year Start",
                                properties: {
                                    month: {
                                        displayName: "Month",
                                        type: {
                                            enumeration: samples.Months
                                        }
                                    },
                                    day: {
                                        displayName: "Day",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            weekDay: {
                                displayName: "First Day of Week",
                                properties: {
                                    day: {
                                        displayName: "Day",
                                        type: {
                                            enumeration: samples.WeekDays
                                        }
                                    }
                                }
                            },
                            rangeHeader: {
                                displayName: "Range Header",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            cells: {
                                displayName: "Cells",
                                properties: {
                                    fillSelected: {
                                        displayName: "Selected cell color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillUnselected: {
                                        displayName: "Unselected cell color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, Timeline;
                }();
                samples.Timeline = Timeline;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ValueFormatter = powerbi.visuals.valueFormatter, PixelConverter = jsCommon.PixelConverter, StreamGraphAxisGraphicsContextClassName = "axisGraphicsContext", DataPointsContainer = "dataPointsContainer", StreamGraphXAxisClassName = "x axis", StreamGraphYAxisClassName = "y axis", StreamGraphDefaultColor = "#777", StreamGraphDefaultFontSizeInPoints = 8, DefaultDataLabelsOffset = 4, DefaultLabelTickWidth = 10, DefaultLegendLabelFillColor = "#666666", StreamGraphDefaultFontFamily = "wf_segoe-ui_normal", StreamGraphDefaultFontWeight = "normal", XAxisOnSize = 20, XAxisOffSize = 10, XAxisLabelSize = 20, YAxisOnSize = 45, YAxisOffSize = 10, YAxisLabelSize = 20, StreamGraphDefaultSettings = {
                    legendSettings: {
                        show: !0,
                        showTitle: !0,
                        labelColor: DefaultLegendLabelFillColor,
                        titleText: "",
                        fontSize: StreamGraphDefaultFontSizeInPoints
                    },
                    categoryAxisSettings: {
                        show: !0,
                        labelColor: StreamGraphDefaultColor,
                        showAxisTitle: !1
                    },
                    valueAxisSettings: {
                        show: !0,
                        labelColor: StreamGraphDefaultColor,
                        showAxisTitle: !1
                    },
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings()
                }, StreamGraphWebBehavior = function() {
                    function StreamGraphWebBehavior() {}
                    return StreamGraphWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.selection = options.selection, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.selection.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, StreamGraphWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.selection.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, StreamGraphWebBehavior;
                }(), StreamGraph = function() {
                    function StreamGraph() {
                        this.margin = {
                            left: YAxisOnSize,
                            right: 15,
                            bottom: XAxisOnSize,
                            top: 10
                        };
                    }
                    return StreamGraph.prototype.converter = function(dataView, colors, interactivityService) {
                        if (!(dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.categories && colors)) return null;
                        for (var valueFormatter, categoryFormatter, catDv = dataView.categorical, categories = catDv.categories, values = catDv.values, series = [], legendData = {
                            dataPoints: [],
                            title: values.source ? values.source.displayName : "",
                            fontSize: StreamGraphDefaultFontSizeInPoints
                        }, value = 0, category = categories && categories.length > 0 ? categories[0] : null, formatString = StreamGraph.Properties.general.formatString, hasHighlights = !!(values.length > 0 && values[0].highlights), streamGraphSettings = this.parseSettings(dataView), fontSizeInPx = PixelConverter.fromPoint(streamGraphSettings.dataLabelsSettings.fontSize), i = 0; i < values.length; i++) {
                            var label = values[i].source.groupName, identity = values[i].identity ? visuals.SelectionId.createWithId(values[i].identity) : visuals.SelectionId.createWithMeasure(values[i].source.queryName);
                            label ? legendData.dataPoints.push({
                                label: label,
                                color: colors.getColorByIndex(i).value,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: identity
                            }) : label = values[i].source.displayName;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatString, {
                                categories: null,
                                values: values
                            }, null, null, null, null, i);
                            series[i] = {
                                dataPoints: [],
                                tooltipInfo: tooltipInfo,
                                highlight: hasHighlights,
                                identity: identity,
                                selected: !1
                            };
                            var dataPointsValues = values[i].values;
                            if (0 !== dataPointsValues.length) for (var k = 0; k < dataPointsValues.length; k++) {
                                var y = hasHighlights ? values[i].highlights[k] : dataPointsValues[k];
                                y > value && (value = y), series[i].dataPoints.push({
                                    x: k,
                                    y: isNaN(y) ? 0 : y,
                                    text: label,
                                    labelFontSize: fontSizeInPx
                                });
                            }
                        }
                        interactivityService && interactivityService.applySelectionStateToData(series), 
                        valueFormatter = ValueFormatter.create({
                            format: "g",
                            value: value
                        }), categoryFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(category.source, StreamGraph.Properties.general.formatString),
                            value: category.values
                        });
                        for (var categoriesText = [], getTextPropertiesFunction = this.getTextPropertiesFunction, index = 0; index < category.values.length; index++) {
                            var formattedValue = void 0;
                            if (null != category.values[index]) {
                                formattedValue = categoryFormatter.format(category.values[index]);
                                var textLength = powerbi.TextMeasurementService.measureSvgTextWidth(getTextPropertiesFunction(formattedValue));
                                textLength > StreamGraph.MaxNumberOfAxisXValues && (StreamGraph.MaxNumberOfAxisXValues = textLength);
                            }
                            categoriesText.push(formattedValue);
                        }
                        return {
                            series: series,
                            legendData: legendData,
                            valueFormatter: valueFormatter,
                            categoryFormatter: categoryFormatter,
                            streamGraphSettings: streamGraphSettings,
                            categoriesText: categoriesText
                        };
                    }, StreamGraph.prototype.parseSettings = function(dataView) {
                        if (!dataView || !dataView.metadata) return StreamGraphDefaultSettings;
                        var objects = dataView.metadata.objects, streamGraphSettings = _.cloneDeep(StreamGraphDefaultSettings), categoryAxisSettings = streamGraphSettings.categoryAxisSettings;
                        categoryAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show), 
                        categoryAxisSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.labelColor, categoryAxisSettings.labelColor), 
                        categoryAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);
                        var valueAxisSettings = streamGraphSettings.valueAxisSettings;
                        valueAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show), 
                        valueAxisSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.labelColor, valueAxisSettings.labelColor), 
                        valueAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);
                        var dataLabelsSettings = streamGraphSettings.dataLabelsSettings;
                        dataLabelsSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.labels.show, dataLabelsSettings.show), 
                        dataLabelsSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.labels.color, dataLabelsSettings.labelColor), 
                        dataLabelsSettings.fontSize = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.labels.fontSize, dataLabelsSettings.fontSize);
                        var legendSettings = streamGraphSettings.legendSettings, valuesSource = dataView.categorical.values.source, titleTextDefault = valuesSource && _.isEmpty(legendSettings.titleText) ? valuesSource.displayName : legendSettings.titleText;
                        return legendSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.legend.show, legendSettings.show), 
                        legendSettings.showTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.legend.showTitle, legendSettings.showTitle), 
                        legendSettings.titleText = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.legend.titleText, titleTextDefault), 
                        legendSettings.labelColor = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.legend.labelColor, legendSettings.labelColor), 
                        legendSettings.fontSize = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.legend.fontSize, legendSettings.fontSize), 
                        _.isEmpty(legendSettings.titleText) && (legendSettings.titleText = titleTextDefault), 
                        streamGraphSettings;
                    }, StreamGraph.prototype.init = function(options) {
                        var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(StreamGraph.VisualClassName, !0).style("position", "absolute");
                        this.clearCatcher = visuals.appendClearCatcher(svg), this.axisGraphicsContext = svg.append("g").classed(StreamGraphAxisGraphicsContextClassName, !0), 
                        this.xAxis = this.axisGraphicsContext.append("g").classed(StreamGraphXAxisClassName, !0), 
                        this.yAxis = this.axisGraphicsContext.append("g").classed(StreamGraphYAxisClassName, !0), 
                        this.dataPointsContainer = svg.append("g").classed(DataPointsContainer, !0), this.viewport = options.viewport, 
                        this.colors = options.style.colorPalette.dataColors, this.behavior = new StreamGraphWebBehavior();
                        var interactivity = options.interactivity;
                        this.interactivityService = visuals.createInteractivityService(options.host), this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, StreamGraph.prototype.update = function(options) {
                        if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) return void this.clearData();
                        this.viewport = {
                            width: Math.max(0, options.viewport.width),
                            height: Math.max(0, options.viewport.height)
                        };
                        var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors, this.interactivityService);
                        if (!data || !data.series || !data.series.length) return void this.clearData();
                        this.renderLegend(data), this.renderXAxisLabels(), this.renderYAxisLabels(), this.svg.attr({
                            width: this.viewport.width + "px",
                            height: this.viewport.height + "px"
                        });
                        var selection = this.renderChart(data.series, duration);
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            var behaviorOptions = {
                                selection: selection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: interactivityService
                            };
                            interactivityService.bind(data.series, this.behavior, behaviorOptions);
                        }
                    }, StreamGraph.prototype.getStreamGraphLabelLayout = function(xScale, yScale) {
                        var dataLabelsSettings = this.data.streamGraphSettings.dataLabelsSettings, fontSize = PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                        return {
                            labelText: function(d) {
                                return d.text;
                            },
                            labelLayout: {
                                x: function(d) {
                                    return xScale(d.x);
                                },
                                y: function(d) {
                                    return yScale(d.y0);
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.text;
                            },
                            style: {
                                fill: dataLabelsSettings.labelColor,
                                "font-size": fontSize
                            }
                        };
                    }, StreamGraph.prototype.renderChart = function(series, duration) {
                        var _this = this, stack = d3.layout.stack().values(function(d) {
                            return d.dataPoints;
                        }), width = this.viewport.width, height = this.viewport.height;
                        this.getWiggle(this.dataView) && stack.offset("wiggle");
                        var layers = stack(series), margin = this.margin, xScale = d3.scale.linear().domain([ 0, series[0].dataPoints.length - 1 ]).range([ margin.left, width - margin.right ]), yMax = d3.max(layers, function(layer) {
                            return d3.max(layer.dataPoints, function(d) {
                                return d.y0 + d.y;
                            });
                        }), yMin = d3.min(layers, function(layer) {
                            return d3.min(layer.dataPoints, function(d) {
                                return d.y0 + d.y;
                            });
                        }), yScale = d3.scale.linear().domain([ Math.min(yMin, 0), yMax ]).range([ height - margin.bottom, margin.top ]).nice(), area = d3.svg.area().interpolate("monotone").x(function(d) {
                            return xScale(d.x);
                        }).y0(function(d) {
                            return yScale(d.y0);
                        }).y1(function(d) {
                            return yScale(d.y0 + d.y);
                        }).defined(function(d) {
                            return !isNaN(d.y0) && !isNaN(d.y);
                        }), selection = this.dataPointsContainer.selectAll(StreamGraph.Layer.selector).data(layers);
                        if (selection.enter().append("path").classed(StreamGraph.Layer["class"], !0), selection.style("fill", function(d, i) {
                            return _this.colors.getColorByIndex(i).value;
                        }).style("fill-opacity", visuals.ColumnUtil.DefaultOpacity).transition().duration(duration).attr("d", function(d) {
                            return area(d.dataPoints);
                        }), selection.selectAll("path").append("g").classed(DataPointsContainer, !0), selection.exit().remove(), 
                        this.data.streamGraphSettings.dataLabelsSettings.show) {
                            var labelsXScale = d3.scale.linear().domain([ 0, series[0].dataPoints.length - 1 ]).range([ 0, width - margin.left - margin.right ]), layout = this.getStreamGraphLabelLayout(labelsXScale, yScale), dataPointsArray_1 = [];
                            series.forEach(function(seriesItem) {
                                var filteredDataPoints;
                                filteredDataPoints = seriesItem.dataPoints.filter(function(dataPoint) {
                                    return dataPoint && null !== dataPoint.y && void 0 !== dataPoint.y;
                                }), filteredDataPoints.length > 0 && (dataPointsArray_1 = dataPointsArray_1.concat(filteredDataPoints));
                            });
                            var viewport = {
                                height: height - margin.top - margin.bottom,
                                width: width - margin.right - margin.left
                            }, labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray_1, this.svg, layout, viewport);
                            if (labels) {
                                var offset_1 = DefaultDataLabelsOffset + margin.left;
                                labels.attr("transform", function(d) {
                                    return visuals.SVGUtil.translate(offset_1 + d.size.width / 2, d.size.height / 2);
                                });
                            }
                        } else visuals.dataLabelUtils.cleanDataLabels(this.svg);
                        return this.drawAxis(this.data, xScale, yScale), selection;
                    }, StreamGraph.prototype.drawAxis = function(data, xScale, yScale) {
                        for (var margin = this.margin, shiftY = this.viewport.height - margin.bottom, shiftX = this.viewport.width - margin.left - margin.right, categoriesText = this.data.categoriesText, xAxis = d3.svg.axis(), maxNumberOfAxisXValues = StreamGraph.MaxNumberOfAxisXValues, getTextPropertiesFunction = this.getTextPropertiesFunction, index = 0; index < categoriesText.length; index++) if (null != categoriesText[index]) {
                            var str = categoriesText[index].toString(), textLength = powerbi.TextMeasurementService.measureSvgTextWidth(getTextPropertiesFunction(str));
                            textLength > maxNumberOfAxisXValues && (maxNumberOfAxisXValues = textLength);
                        }
                        xAxis.scale(xScale).orient("bottom").ticks(categoriesText.length).tickFormat(function(index) {
                            var item = categoriesText[index];
                            return data.categoryFormatter && (item = data.categoryFormatter.format(item)), null === index || void 0 === index || 0 !== index && index !== categoriesText.length - 1 || (item = powerbi.TextMeasurementService.getTailoredTextOrDefault(getTextPropertiesFunction(item), 2 * (index ? margin.right : margin.left))), 
                            item;
                        });
                        var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(function(item) {
                            var tempItem = item;
                            return data.valueFormatter && (tempItem = data.valueFormatter.format(tempItem)), 
                            tempItem = powerbi.TextMeasurementService.getTailoredTextOrDefault(getTextPropertiesFunction(tempItem.toString()), YAxisOnSize - DefaultLabelTickWidth);
                        });
                        this.setMaxTicks(xAxis, shiftX, Math.max(2, Math.round(shiftX / maxNumberOfAxisXValues))), 
                        this.setMaxTicks(yAxis, shiftY);
                        var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                        if (valueAxisSettings.show) {
                            var axisColor = valueAxisSettings.labelColor;
                            this.yAxis.attr("transform", visuals.SVGUtil.translate(margin.left, 0)).call(yAxis), 
                            this.yAxis.selectAll("text").style("fill", axisColor);
                        } else this.yAxis.selectAll("*").remove();
                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                        if (categoryAxisSettings.show) {
                            var axisColor = categoryAxisSettings.labelColor;
                            this.xAxis.attr("transform", visuals.SVGUtil.translate(0, shiftY)).call(xAxis), 
                            this.xAxis.selectAll("text").style("fill", axisColor);
                        } else this.xAxis.selectAll("*").remove();
                    }, StreamGraph.prototype.renderYAxisLabels = function() {
                        this.axisGraphicsContext.selectAll(StreamGraph.YAxisLabel.selector).remove();
                        var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                        if (this.margin.left = valueAxisSettings.show ? YAxisOnSize : YAxisOffSize, valueAxisSettings.showAxisTitle) {
                            this.margin.left += YAxisLabelSize;
                            var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings, isXAxisOn = categoryAxisSettings.show === !0, isXTitleOn = categoryAxisSettings.showAxisTitle === !0, marginTop_1 = this.margin.top, height_1 = this.viewport.height - marginTop_1 - (isXAxisOn ? XAxisOnSize : XAxisOffSize) - (isXTitleOn ? XAxisLabelSize : 0), values = this.dataView.categorical.values, yAxisText = values.source ? values.source.displayName : this.getYAxisTitleFromValues(values), textSettings = this.getTextPropertiesFunction(yAxisText);
                            yAxisText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textSettings, height_1);
                            var yAxisClass_1 = StreamGraph.YAxisLabel["class"], yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").style("font-family", textSettings.fontFamily).style("font-size", textSettings.fontSize).style("font-style", textSettings.fontStyle).style("font-weight", textSettings.fontWeight).text(yAxisText).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": yAxisClass_1,
                                        transform: "rotate(-90)",
                                        fill: valueAxisSettings.labelColor,
                                        x: -(marginTop_1 + height_1 / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height_1, powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }, StreamGraph.prototype.getYAxisTitleFromValues = function(values) {
                        for (var valuesMetadataArray = [], i = 0; i < values.length; i++) values[i] && values[i].source && values[i].source.displayName && valuesMetadataArray.push({
                            displayName: values[i].source.displayName
                        });
                        var valuesNames = valuesMetadataArray.map(function(v) {
                            return v ? v.displayName : "";
                        }).filter(function(value, index, self) {
                            return "" !== value && self.indexOf(value) === index;
                        });
                        return visuals.valueFormatter.formatListAnd(valuesNames);
                    }, StreamGraph.prototype.renderXAxisLabels = function() {
                        this.axisGraphicsContext.selectAll(StreamGraph.XAxisLabel.selector).remove();
                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                        if (this.margin.bottom = categoryAxisSettings.show ? XAxisOnSize : XAxisOffSize, 
                        categoryAxisSettings.showAxisTitle && this.dataView.categorical.categories[0].source) {
                            this.margin.bottom += XAxisLabelSize;
                            var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings, isYAxisOn = valueAxisSettings.show === !0, isYTitleOn = valueAxisSettings.showAxisTitle === !0, leftMargin_1 = (isYAxisOn ? YAxisOnSize : YAxisOffSize) + (isYTitleOn ? YAxisLabelSize : 0), width_1 = this.viewport.width - this.margin.right - leftMargin_1, height_2 = this.viewport.height, xAxisText = this.dataView.categorical.categories[0].source.displayName, textSettings = this.getTextPropertiesFunction(xAxisText);
                            xAxisText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textSettings, width_1);
                            var xAxisClass_1 = StreamGraph.XAxisLabel["class"], xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").style("font-family", textSettings.fontFamily).style("font-size", textSettings.fontSize).style("font-weight", textSettings.fontWeight).text(xAxisText).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": xAxisClass_1,
                                        transform: visuals.SVGUtil.translate(leftMargin_1 + width_1 / 2, height_2),
                                        fill: categoryAxisSettings.labelColor,
                                        dy: "-0.5em"
                                    });
                                });
                            });
                            xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width_1, powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }, StreamGraph.prototype.renderLegend = function(streamGraphData) {
                        var legendSettings = streamGraphData.streamGraphSettings.legendSettings, legendData = streamGraphData.legendData;
                        if (this.dataView && this.dataView.metadata) {
                            var legendObjectProperties = powerbi.DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {});
                            legendObjectProperties.titleText = legendSettings.titleText, visuals.LegendData.update(legendData, legendObjectProperties);
                            var position = legendObjectProperties[visuals.legendProps.position];
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]), this.legend.drawLegend(legendData, _.clone(this.viewport)), 
                            visuals.Legend.positionChartArea(this.svg, this.legend), this.updateViewPort();
                        }
                    }, StreamGraph.prototype.updateViewPort = function() {
                        var legendMargins = this.legend.getMargins(), legendPosition = this.legend.getOrientation();
                        switch (legendPosition) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height = Math.max(0, this.viewport.height - legendMargins.height);
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width = Math.max(0, this.viewport.width - legendMargins.width);
                        }
                    }, StreamGraph.prototype.setMaxTicks = function(axis, maxSize, maxValue) {
                        var maxTicks = void 0 === maxValue ? this.getTicksByAxis(axis).length : Math.min(maxValue, this.getTicksByAxis(axis).length);
                        axis.scale().domain.toString() === d3.scale.linear().domain.toString() ? axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks)) : axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
                    }, StreamGraph.prototype.getFittedTickLength = function(axis, maxSize, maxTicks) {
                        for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([ maxTicks ]).length > maxTicks); maxTicks--, 
                        ticks = this.getTicksByAxis(axis)) axis.ticks(maxTicks);
                        return maxTicks;
                    }, StreamGraph.prototype.getFittedTickValues = function(axis, maxSize, maxTicks) {
                        for (var maxWidthOf2Ticks, ticks = this.getTicksByAxis(axis), tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks), currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, 
                        indexes = []) {
                            switch (currentMaxTicks) {
                              case 0:
                                return [];

                              case 1:
                                indexes = [ 0 ];
                                break;

                              case 2:
                                indexes = [ 0, ticks.length - 1 ];
                                break;

                              default:
                                for (var takeEvery = ticks.length / (currentMaxTicks - 1), i = 0; currentMaxTicks - 1 > i; i++) indexes.push(Math.round(takeEvery * i));
                                indexes.push(ticks.length - 1);
                            }
                            var ticksIndexes = indexes.map(function(x) {
                                return [ ticks[x], x ];
                            });
                            if (maxWidthOf2Ticks = maxSize / ticks.length * 2, ticksIndexes.reduce(function(a, b) {
                                return tickPairsWidths.push([ measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks ]), 
                                b;
                            }), !tickPairsWidths.some(function(x) {
                                return x[0] > x[1];
                            })) return ticksIndexes.map(function(x) {
                                return x[0];
                            });
                        }
                        return [];
                    }, StreamGraph.prototype.measureTicks = function(ticks, measureTickFunction) {
                        return ticks.map(function(x) {
                            return measureTickFunction(x);
                        }).reduce(function(a, b) {
                            return a + b;
                        });
                    }, StreamGraph.prototype.getTicksByAxis = function(axis) {
                        var scale = axis.scale(), result = null === axis.tickValues() ? scale.ticks ? scale.ticks.apply(scale, axis.ticks()) : scale.domain() : axis.tickValues();
                        return void 0 === result.length ? [ result ] : result;
                    }, StreamGraph.prototype.getMeasureTickFunction = function(axis, ticks) {
                        var measureFunction = "top" === axis.orient() || "bottom" === axis.orient() ? powerbi.TextMeasurementService.measureSvgTextWidth : powerbi.TextMeasurementService.measureSvgTextHeight, getTextPropertiesFunction = this.getTextPropertiesFunction, cache = {};
                        return function(x) {
                            return cache[x] ? cache[x] : cache[x] = measureFunction(getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
                        };
                    }, StreamGraph.prototype.getTextPropertiesFunction = function(text) {
                        var fontFamily = StreamGraphDefaultFontFamily, fontSize = PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;
                        return {
                            text: text,
                            fontFamily: fontFamily,
                            fontSize: fontSize,
                            fontWeight: fontWeight
                        };
                    }, StreamGraph.prototype.getWiggle = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var general = powerbi.DataViewObjects.getObject(objects, "general", void 0);
                                if (general) return general.wiggle;
                            }
                        }
                        return !0;
                    }, StreamGraph.prototype.enumerateValueAxisValues = function(enumeration) {
                        var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "valueAxis",
                            displayName: "Y-Axis",
                            properties: {
                                show: valueAxisSettings.show,
                                showAxisTitle: valueAxisSettings.showAxisTitle,
                                labelColor: valueAxisSettings.labelColor
                            }
                        });
                    }, StreamGraph.prototype.enumerateCategoryAxisValues = function(enumeration) {
                        var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "categoryAxis",
                            displayName: "X-Axis",
                            properties: {
                                show: categoryAxisSettings.show,
                                showAxisTitle: categoryAxisSettings.showAxisTitle,
                                labelColor: categoryAxisSettings.labelColor
                            }
                        });
                    }, StreamGraph.prototype.enumerateLegend = function(enumeration) {
                        var legendSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings : StreamGraphDefaultSettings.legendSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "legend",
                            displayName: "Legend",
                            properties: {
                                show: legendSettings.show,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: legendSettings.showTitle,
                                titleText: legendSettings.titleText,
                                labelColor: legendSettings.labelColor,
                                fontSize: legendSettings.fontSize
                            }
                        });
                    }, StreamGraph.prototype.clearData = function() {
                        this.svg.selectAll(StreamGraph.Layer.selector).remove(), this.legend.drawLegend({
                            dataPoints: []
                        }, this.viewport), this.yAxis.selectAll("*").remove(), this.axisGraphicsContext.selectAll(StreamGraph.YAxisLabel.selector).remove(), 
                        this.xAxis.selectAll("*").remove(), this.axisGraphicsContext.selectAll(StreamGraph.XAxisLabel.selector).remove(), 
                        this.svg.select(".labels").remove();
                    }, StreamGraph.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, StreamGraph.prototype.enumerateObjectInstances = function(options) {
                        var dataLabelsSettings, enumeration = new visuals.ObjectEnumerationBuilder(), dataView = this.dataView;
                        switch (this.data && (dataLabelsSettings = this.data.streamGraphSettings.dataLabelsSettings ? this.data.streamGraphSettings.dataLabelsSettings : StreamGraphDefaultSettings.dataLabelsSettings), 
                        options.objectName) {
                          case "legend":
                            dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.source && this.enumerateLegend(enumeration);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxisValues(enumeration);
                            break;

                          case "valueAxis":
                            this.enumerateValueAxisValues(enumeration);
                            break;

                          case "labels":
                            var labelSettingOptions = {
                                enumeration: enumeration,
                                dataLabelsSettings: dataLabelsSettings,
                                show: !0,
                                fontSize: !0
                            };
                            visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                            break;

                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "General",
                                selector: null,
                                properties: {
                                    wiggle: this.getWiggle(dataView)
                                }
                            };
                            enumeration.pushInstance(general);
                        }
                        return enumeration.complete();
                    }, StreamGraph.VisualClassName = "streamGraph", StreamGraph.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            },
                            showTitle: {
                                objectName: "legend",
                                propertyName: "showTitle"
                            },
                            titleText: {
                                objectName: "legend",
                                propertyName: "titleText"
                            },
                            labelColor: {
                                objectName: "legend",
                                propertyName: "labelColor"
                            },
                            fontSize: {
                                objectName: "legend",
                                propertyName: "fontSize"
                            }
                        },
                        categoryAxis: {
                            show: {
                                objectName: "categoryAxis",
                                propertyName: "show"
                            },
                            labelColor: {
                                objectName: "categoryAxis",
                                propertyName: "labelColor"
                            },
                            showAxisTitle: {
                                objectName: "categoryAxis",
                                propertyName: "showAxisTitle"
                            }
                        },
                        valueAxis: {
                            show: {
                                objectName: "valueAxis",
                                propertyName: "show"
                            },
                            labelColor: {
                                objectName: "valueAxis",
                                propertyName: "labelColor"
                            },
                            showAxisTitle: {
                                objectName: "valueAxis",
                                propertyName: "showAxisTitle"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        }
                    }, StreamGraph.Layer = {
                        "class": "layer",
                        selector: ".layer"
                    }, StreamGraph.XAxisLabel = {
                        "class": "xAxisLabel",
                        selector: ".xAxisLabel"
                    }, StreamGraph.YAxisLabel = {
                        "class": "yAxisLabel",
                        selector: ".yAxisLabel"
                    }, StreamGraph.MaxNumberOfAxisXValues = 5, StreamGraph.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Series"
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    min: 1,
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        bottom: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            bottom: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    wiggle: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Wiggle"
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, StreamGraph;
                }();
                samples.StreamGraph = StreamGraph;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function createEnumTypeFromEnum(type) {
                    var even = !1;
                    return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                        return !!(i % 2) === even && type[key] === key && !void (even === !even) || !!(i % 2) !== even;
                    }).map(function(x) {
                        return {
                            value: x,
                            displayName: x
                        };
                    }));
                }
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, TextMeasurementService = powerbi.TextMeasurementService;
                samples.createEnumTypeFromEnum = createEnumTypeFromEnum, function(PulseChartXAxisDateFormat) {
                    PulseChartXAxisDateFormat[PulseChartXAxisDateFormat.DateOnly = "Date only"] = "DateOnly", 
                    PulseChartXAxisDateFormat[PulseChartXAxisDateFormat.TimeOnly = "Time only"] = "TimeOnly";
                }(samples.PulseChartXAxisDateFormat || (samples.PulseChartXAxisDateFormat = {}));
                var PulseChartXAxisDateFormat = samples.PulseChartXAxisDateFormat;
                !function(XAxisPosition) {
                    XAxisPosition[XAxisPosition.Center = "Center"] = "Center", XAxisPosition[XAxisPosition.Bottom = "Bottom"] = "Bottom";
                }(samples.XAxisPosition || (samples.XAxisPosition = {}));
                var XAxisPosition = samples.XAxisPosition;
                !function(RunnerCounterPosition) {
                    RunnerCounterPosition[RunnerCounterPosition.TopLeft = "Top Left"] = "TopLeft", RunnerCounterPosition[RunnerCounterPosition.TopRight = "Top Right"] = "TopRight";
                }(samples.RunnerCounterPosition || (samples.RunnerCounterPosition = {}));
                var RunnerCounterPosition = samples.RunnerCounterPosition, PulseChart = function() {
                    function PulseChart(options) {
                        options && options.svg && (this.svg = options.svg), this.margin = PulseChart.DefaultMargin;
                    }
                    return PulseChart.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, PulseChart.GetPopupValueTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.GetPopupTitleTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontWeight: "bold",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.GetPopupDescriptionTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.GetRunnerCounterTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.ConvertTextPropertiesToStyle = function(textProperties) {
                        return {
                            "font-family": textProperties.fontFamily,
                            "font-weight": textProperties.fontWeight,
                            "font-size": textProperties.fontSize
                        };
                    }, PulseChart.GetDateTimeFormatString = function(dateFormatType, dateFormat) {
                        switch (dateFormatType) {
                          case PulseChartXAxisDateFormat.DateOnly:
                            return dateFormat;

                          case PulseChartXAxisDateFormat.TimeOnly:
                            return "H:mm";

                          default:
                            return "";
                        }
                    }, PulseChart.GetFullWidthOfDateFormat = function(dateFormat, textProperties) {
                        return textProperties.text = visuals.valueFormatter.create({
                            format: dateFormat
                        }).format(new Date(2e3, 10, 20, 20, 20, 20)), TextMeasurementService.measureSvgTextWidth(textProperties);
                    }, PulseChart.AddOnTouchClick = function(selection, callback) {
                        var preventDefaultCallback = function(data, index) {
                            d3.event.preventDefault(), callback(data, index);
                        };
                        return selection.on("click", preventDefaultCallback).on("touchstart", preventDefaultCallback);
                    }, PulseChart.getCategoricalColumnOfRole = function(dataView, roleName) {
                        var filterFunc = function(cols) {
                            return cols.filter(function(x) {
                                return x.source && x.source.roles && x.source.roles[roleName];
                            })[0];
                        };
                        return filterFunc(dataView.categorical.categories) || filterFunc(dataView.categorical.values);
                    }, PulseChart.converter = function(dataView, colors, interactivityService) {
                        if (!(dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && dataView.categorical.categories)) return null;
                        var columns = _.mapValues(PulseChart.RoleNames, function(x, i) {
                            return PulseChart.getCategoricalColumnOfRole(dataView, i);
                        }), timeStampColumn = columns.Timestamp;
                        if (!timeStampColumn) return null;
                        var isScalar = !(timeStampColumn.source && timeStampColumn.source.type && timeStampColumn.source.type.dateTime), settings = PulseChart.parseSettings(dataView, colors, columns), categoryValues = timeStampColumn.values;
                        if (!categoryValues || _.isEmpty(dataView.categorical.values) || !columns.Value || _.isEmpty(columns.Value.values)) return null;
                        var minValuesValue = Math.min.apply(null, columns.Value.values), maxValuesValue = Math.max.apply(null, columns.Value.values), minCategoryValue = Math.min.apply(null, categoryValues), maxCategoryValue = Math.max.apply(null, categoryValues);
                        settings.xAxis.dateFormat = 864e5 > maxCategoryValue - minCategoryValue && new Date(maxCategoryValue).getDate() === new Date(minCategoryValue).getDate() ? PulseChartXAxisDateFormat.TimeOnly : PulseChartXAxisDateFormat.DateOnly, 
                        settings.xAxis.formatterOptions = {
                            value: isScalar ? minCategoryValue : new Date(minCategoryValue),
                            value2: isScalar ? maxCategoryValue : new Date(maxCategoryValue)
                        }, settings.yAxis.formatterOptions = {
                            value: minValuesValue,
                            value2: maxValuesValue,
                            format: ValueFormatter.getFormatString(columns.Value.source, PulseChart.DefaultSettings.formatStringProperty)
                        }, isScalar ? settings.xAxis.formatterOptions.format = ValueFormatter.getFormatString(timeStampColumn.source, PulseChart.DefaultSettings.formatStringProperty) : settings.xAxis.formatterOptions.format = PulseChart.GetDateTimeFormatString(settings.xAxis.dateFormat, timeStampColumn.source.format);
                        var widthOfXAxisLabel = 70, widthOfTooltipValueLabel = isScalar ? 60 : PulseChart.GetFullWidthOfDateFormat(timeStampColumn.source.format, PulseChart.GetPopupValueTextProperties()) + 5, heightOfTooltipDescriptionTextLine = TextMeasurementService.measureSvgTextHeight(PulseChart.GetPopupDescriptionTextProperties("lj", settings.popup.fontSize)), runnerCounterFormatString = columns.RunnerCounter && visuals.valueFormatter.getFormatString(columns.RunnerCounter.source, settings.formatStringProperty);
                        settings.popup.width = Math.max(widthOfTooltipValueLabel + 20, settings.popup.width);
                        var minSize = PulseChart.DefaultSettings.dots.minSize, maxSize = PulseChart.DefaultSettings.dots.maxSize;
                        settings.dots && (minSize = settings.dots.minSize, maxSize = settings.dots.maxSize);
                        for (var eventSizeScale = PulseChart.createScale(!0, columns.EventSize ? [ d3.min(columns.EventSize.values), d3.max(columns.EventSize.values) ] : [ 0, 0 ], minSize, maxSize), xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata), hasDynamicSeries = (visuals.ColumnUtil.applyUserMinMax(isScalar, dataView.categorical, xAxisCardProperties), 
                        !(!timeStampColumn.values || !timeStampColumn.source)), dataPointLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings(), gapWidths = PulseChart.getGapWidths(categoryValues), maxGapWidth = Math.max.apply(null, gapWidths), firstValueMeasureIndex = 0, firstGroupIndex = 0, secondGroupIndex = 1, grouped = dataView.categorical.values && dataView.categorical.values.grouped(), y_group0Values = grouped[firstGroupIndex] && grouped[firstGroupIndex].values[firstValueMeasureIndex] && grouped[firstGroupIndex].values[firstValueMeasureIndex].values, y_group1Values = grouped[secondGroupIndex] && grouped[secondGroupIndex].values[firstValueMeasureIndex] && grouped[secondGroupIndex].values[firstValueMeasureIndex].values, series = [], dataPoints = [], categoryIndex = 0, seriesCategoryIndex = 0, len = timeStampColumn.values.length; len > categoryIndex; categoryIndex++, 
                        seriesCategoryIndex++) {
                            var categoryValue = categoryValues[categoryIndex], value = visuals.AxisHelper.normalizeNonFiniteNumber(timeStampColumn.values[categoryIndex]), runnerCounterValue = columns.RunnerCounter && columns.RunnerCounter.values && columns.RunnerCounter.values[categoryIndex], identity = visuals.SelectionIdBuilder.builder().withCategory(timeStampColumn, categoryIndex).createSelectionId(), minGapWidth = Math.max((maxCategoryValue - minCategoryValue) / PulseChart.MaxGapCount, PulseChart.MinGapWidth[settings.xAxis.dateFormat]), gapWidth = gapWidths[categoryIndex], isGap = settings.gaps.show && gapWidth > 0 && gapWidth > minGapWidth + (100 - settings.gaps.visibleGapsPercentage) * (maxGapWidth - minGapWidth) / 100;
                            if (isGap && dataPoints.length > 0 && (series.push({
                                displayName: grouped[firstGroupIndex].name,
                                key: identity.getKey(),
                                lineIndex: series.length,
                                color: settings.series.fill,
                                xCol: timeStampColumn.source,
                                yCol: timeStampColumn.source,
                                data: dataPoints,
                                identity: identity,
                                selected: !1,
                                labelSettings: dataPointLabelSettings,
                                width: settings.series.width,
                                widthOfGap: gapWidth
                            }), seriesCategoryIndex = 0, dataPoints = []), !isScalar || null !== categoryValue && null !== value) {
                                var popupInfo = (dataView.categorical, null), eventSize = columns.EventSize && columns.EventSize.values && columns.EventSize.values[categoryIndex] || 0;
                                if (columns.EventTitle && columns.EventTitle.values && columns.EventTitle.values[categoryIndex] || columns.EventDescription && columns.EventDescription.values && columns.EventDescription.values[categoryIndex]) {
                                    var formattedValue = categoryValue;
                                    !isScalar && categoryValue && (formattedValue = visuals.valueFormatter.create({
                                        format: timeStampColumn.source.format
                                    }).format(categoryValue)), popupInfo = {
                                        value: formattedValue,
                                        title: columns.EventTitle && columns.EventTitle.values && columns.EventTitle.values[categoryIndex],
                                        description: columns.EventDescription && columns.EventDescription.values && columns.EventDescription.values[categoryIndex]
                                    };
                                }
                                var dataPoint = {
                                    categoryValue: categoryValue,
                                    value: value,
                                    categoryIndex: categoryIndex,
                                    seriesIndex: series.length,
                                    tooltipInfo: null,
                                    popupInfo: popupInfo,
                                    selected: !1,
                                    identity: identity,
                                    key: JSON.stringify({
                                        ser: identity.getKey(),
                                        catIdx: categoryIndex
                                    }),
                                    labelFill: dataPointLabelSettings.labelColor,
                                    labelSettings: dataPointLabelSettings,
                                    x: categoryValue,
                                    y: y_group0Values && y_group0Values[categoryIndex] || y_group1Values && y_group1Values[categoryIndex] || 0,
                                    pointColor: settings.series.fill,
                                    groupIndex: PulseChart.getGroupIndex(categoryIndex, grouped),
                                    eventSize: columns.EventSize ? eventSizeScale(eventSize) : 0,
                                    runnerCounterValue: runnerCounterValue,
                                    runnerCounterFormatString: runnerCounterFormatString
                                };
                                dataPoints.push(dataPoint);
                            }
                        }
                        interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                        dataPoints.length > 0 && series.push({
                            displayName: grouped[firstGroupIndex].name,
                            key: identity.getKey(),
                            lineIndex: series.length,
                            color: settings.series.fill,
                            xCol: timeStampColumn.source,
                            yCol: timeStampColumn.source,
                            data: dataPoints,
                            identity: identity,
                            selected: !1,
                            labelSettings: dataPointLabelSettings,
                            width: settings.series.width,
                            widthOfGap: 0
                        }), xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                        var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata), values = dataView.categorical.categories, valuesMetadataArray = [];
                        if (values) for (var i = 0; i < values.length; i++) values[i] && values[i].source && values[i].source.displayName && valuesMetadataArray.push({
                            displayName: values[i].source.displayName
                        });
                        var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, timeStampColumn.source, valuesMetadataArray);
                        return interactivityService && interactivityService.applySelectionStateToData(series), 
                        {
                            columns: columns,
                            series: series,
                            isScalar: isScalar,
                            dataLabelsSettings: dataPointLabelSettings,
                            axesLabels: {
                                x: axesLabels.xAxisLabel,
                                y: axesLabels.yAxisLabel
                            },
                            hasDynamicSeries: hasDynamicSeries,
                            categoryMetadata: timeStampColumn.source,
                            categories: categoryValues,
                            settings: settings,
                            grouped: grouped,
                            hasHighlights: !!columns.Value.highlights,
                            widthOfXAxisLabel: widthOfXAxisLabel,
                            widthOfTooltipValueLabel: widthOfTooltipValueLabel,
                            heightOfTooltipDescriptionTextLine: heightOfTooltipDescriptionTextLine,
                            runnerCounterHeight: TextMeasurementService.measureSvgTextHeight(PulseChart.GetRunnerCounterTextProperties("lj", settings.runnerCounter.fontSize))
                        };
                    }, PulseChart.createAxisY = function(commonYScale, height, formatterOptions, show) {
                        void 0 === show && (show = !0);
                        var formatter = visuals.valueFormatter.create(formatterOptions), ticks = Math.max(2, Math.round(height / 40)), yAxis = d3.svg.axis().scale(commonYScale).ticks(ticks).outerTickSize(0).tickFormat(formatter.format);
                        return yAxis;
                    }, PulseChart.createAxisX = function(isScalar, series, originalScale, formatterOptions, dateFormat, position, widthOfXAxisLabel) {
                        for (var scales = PulseChart.getXAxisScales(series, isScalar, originalScale), xAxisProperties = new Array(scales.length), i = 0, rotate = !1; i < xAxisProperties.length; i++) {
                            var values = PulseChart.getXAxisValuesToDisplay(scales[i], rotate, isScalar, dateFormat, widthOfXAxisLabel);
                            if (!rotate && position === XAxisPosition.Bottom && values.length < PulseChart.MinimumTicksToRotate) {
                                var rotatedValues = PulseChart.getXAxisValuesToDisplay(scales[i], !0, isScalar, dateFormat, widthOfXAxisLabel);
                                if (rotatedValues.length > values.length) {
                                    rotate = !0, i = -1;
                                    continue;
                                }
                            }
                            xAxisProperties[i] = {
                                values: values,
                                scale: scales[i],
                                rotate: rotate
                            };
                        }
                        return formatterOptions.tickCount = xAxisProperties.length && 5 * xAxisProperties.map(function(x) {
                            return x.values.length;
                        }).reduce(function(a, b) {
                            return a + b;
                        }), formatterOptions.value = originalScale.domain()[0], formatterOptions.value2 = originalScale.domain()[1], 
                        xAxisProperties.forEach(function(properties) {
                            var values = properties.values.filter(function(value) {
                                return null !== value;
                            }), formatter = visuals.valueFormatter.create(formatterOptions);
                            properties.axis = d3.svg.axis().scale(properties.scale).tickValues(values).tickFormat(formatter.format).outerTickSize(0);
                        }), xAxisProperties;
                    }, PulseChart.getXAxisScales = function(series, isScalar, originalScale) {
                        return series.map(function(seriesElement) {
                            var dataPoints = seriesElement.data, minValue = dataPoints[0].categoryValue, maxValue = dataPoints[dataPoints.length - 1].categoryValue, minX = originalScale(dataPoints[0].categoryValue), maxX = originalScale(dataPoints[dataPoints.length - 1].categoryValue);
                            return PulseChart.createScale(isScalar, [ minValue, maxValue ], minX, maxX);
                        });
                    }, PulseChart.getXAxisValuesToDisplay = function(scale, rotate, isScalar, dateFormat, widthOfXAxisLabel) {
                        var genScale = scale, tickWidth = rotate ? PulseChart.XAxisTickHeight * (rotate ? Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 0) : widthOfXAxisLabel, tickSpace = PulseChart.XAxisTickSpace;
                        if (scale.range()[1] < tickWidth) return [];
                        var minValue = scale.invert(scale.range()[0] + tickWidth / 2), maxValue = scale.invert(scale.range()[1] - tickWidth / 2), width = scale.range()[1] - scale.range()[0], maxTicks = Math.floor((width + tickSpace) / (tickWidth + tickSpace));
                        rotate && (maxTicks = Math.min(PulseChart.MinimumTicksToRotate, maxTicks));
                        var values = [];
                        if (values = isScalar ? d3.range(minValue, maxValue, (maxValue - minValue) / (100 * maxTicks)) : (dateFormat === PulseChartXAxisDateFormat.TimeOnly ? d3.time.minute : d3.time.day).range(minValue, maxValue), 
                        (!values.length || _.last(values) < maxValue) && values.push(maxValue), !maxTicks) return [];
                        maxTicks = Math.min(values.length, maxTicks);
                        var valuesIndexses = d3.scale.ordinal().domain(d3.range(maxTicks)).rangePoints([ 0, values.length - 1 ]).range();
                        values = valuesIndexses.map(function(x) {
                            return values[Math.round(x)];
                        });
                        for (var i = 1; i < values.length; i++) {
                            var prevXValue = genScale(values[i - 1]), curXValue = genScale(values[i]);
                            tickWidth + tickSpace / 3 > curXValue - prevXValue && values.splice(i--, 1);
                        }
                        return values;
                    }, PulseChart.getGroupIndex = function(index, grouped) {
                        for (var i = 0; i < grouped.length; i++) if (grouped[i].values && grouped[i].values[0] && void 0 !== grouped[i].values[0].values[index] && null !== grouped[i].values[0].values[index]) return i;
                        return 0;
                    }, PulseChart.getGapWidths = function(values) {
                        for (var result = [], i = 0, prevVal = 0, length = values.length; length > i; i++) prevVal && values[i] ? result.push(values[i] - prevVal) : result.push(0), 
                        prevVal = values[i];
                        return result;
                    }, PulseChart.createScale = function(isScalar, domain, minX, maxX) {
                        var scale;
                        return scale = isScalar ? d3.scale.linear() : d3.time.scale(), scale.domain(domain).range([ minX, maxX ]);
                    }, Object.defineProperty(PulseChart.prototype, "runnerCounterPlaybackButtonsHeight", {
                        get: function() {
                            return Math.max(PulseChart.PlaybackButtonsHeight, this.data && this.data.runnerCounterHeight / 2 + 17);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "popupHeight", {
                        get: function() {
                            return this.data && this.data.settings && this.data.settings.popup && this.data.settings.popup.show && this.data.settings.popup.height || 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseChart.prototype.init = function(options) {
                        powerbi.formattingService.initialize(), this.host = options.host, this.selectionManager = new SelectionManager({
                            hostServices: this.host
                        });
                        var svg = this.svg = d3.select(options.element.get(0)).append("svg").classed("pulseChart", !0);
                        this.gaps = svg.append("g").classed(PulseChart.Gaps["class"], !0), this.yAxis = svg.append("g").attr("class", "y axis"), 
                        this.chart = svg.append("g").attr("class", PulseChart.Chart["class"]), this.dots = svg.append("g").attr("class", "dots"), 
                        this.animationDot = this.dots.append("circle").classed(PulseChart.AnimationDot["class"], !0).attr("display", "none"), 
                        this.animationHandler = new PulseAnimator(this, svg);
                        var style = options.style;
                        this.colors = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette();
                    }, PulseChart.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0]) {
                            this.viewport = $.extend({}, options.viewport);
                            var dataView = options.dataViews[0];
                            if (this.updateData(PulseChart.converter(dataView, this.colors)), !this.validateData(this.data)) return void this.clearAll(!0);
                            var width = this.getChartWidth();
                            if (this.calculateXAxisProperties(width), this.data.xScale.ticks(void 0).length < 2) return void this.clearAll(!0);
                            var height = this.getChartHeight(this.data.settings.xAxis.show && this.data.series.some(function(series) {
                                return series.xAxisProperties.rotate;
                            }));
                            this.calculateYAxisProperties(height), this.size = {
                                width: width,
                                height: height
                            }, this.updateElements(), this.render(!0);
                        }
                    }, PulseChart.prototype.updateData = function(data) {
                        if (!this.data) return void (this.data = data);
                        var oldDataObj = this.getDataArrayToCompare(this.data), newDataObj = this.getDataArrayToCompare(data);
                        _.isEqual(oldDataObj, newDataObj) || this.clearAll(!1), this.data = data;
                    }, PulseChart.prototype.getDataArrayToCompare = function(data) {
                        if (!data || !data.series) return null;
                        var dataPoints = _.flatten(data.series.map(function(x) {
                            return x.data;
                        }));
                        return _.flatten(dataPoints.map(function(x) {
                            return x && _.flatten([ [ x.categoryValue, x.eventSize, x.groupIndex, x.runnerCounterValue, x.y, x.seriesIndex ], x.popupInfo && [ x.popupInfo.description, x.popupInfo.title, x.popupInfo.value ] ]);
                        }));
                    }, PulseChart.prototype.validateData = function(data) {
                        return data ? !data.categories.some(function(x) {
                            return !(x instanceof Date || $.isNumeric(x));
                        }) : !1;
                    }, PulseChart.prototype.getChartWidth = function() {
                        var marginRight = this.margin.right;
                        this.data.settings.yAxis && this.data.settings.yAxis.show && (marginRight += PulseChart.MaxWidthOfYAxis);
                        var width = this.viewport.width - this.margin.left - marginRight;
                        return Math.max(width, PulseChart.DefaultViewport.width);
                    }, PulseChart.prototype.getChartHeight = function(xAxisRotated) {
                        var marginBottom = 10 + (xAxisRotated ? this.data.widthOfXAxisLabel * Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 3);
                        !this.data.settings.popup.alwaysOnTop && this.popupHeight && (marginBottom = Math.max(this.margin.bottom + this.popupHeight, marginBottom));
                        var height = this.viewport.height - this.margin.top - this.runnerCounterPlaybackButtonsHeight - marginBottom - this.popupHeight;
                        return Math.max(height, PulseChart.DefaultViewport.height);
                    }, PulseChart.prototype.updateElements = function() {
                        var chartMarginTop = this.margin.top + this.runnerCounterPlaybackButtonsHeight + this.popupHeight;
                        this.svg.attr(this.viewport), this.svg.style("display", void 0), this.gaps.attr("transform", visuals.SVGUtil.translate(this.margin.left, chartMarginTop + this.size.height / 2)), 
                        this.chart.attr("transform", visuals.SVGUtil.translate(this.margin.left, chartMarginTop)), 
                        this.yAxis.attr("transform", visuals.SVGUtil.translate(this.size.width + this.margin.left, chartMarginTop)), 
                        this.dots.attr("transform", visuals.SVGUtil.translate(this.margin.left, chartMarginTop));
                    }, PulseChart.prototype.calculateXAxisProperties = function(width) {
                        this.data.xScale = PulseChart.createScale(this.data.isScalar, [ this.data.categories[0], this.data.categories[this.data.categories.length - 1] ], 0, width);
                        var xAxisProperties = PulseChart.createAxisX(this.data.isScalar, this.data.series, this.data.xScale, $.extend({}, this.data.settings.xAxis.formatterOptions), this.data.settings.xAxis.dateFormat, this.data.settings.xAxis.position, this.data.widthOfXAxisLabel);
                        this.data.series.forEach(function(series, index) {
                            series.xAxisProperties = xAxisProperties[index];
                        });
                    }, PulseChart.prototype.calculateYAxisProperties = function(height) {
                        this.data.yScales = this.getYAxisScales(height);
                        var domain = [];
                        this.data.yScales.forEach(function(scale) {
                            return domain = domain.concat(scale.domain());
                        }), this.data.commonYScale = PulseChart.createScale(!0, [ d3.max(domain), d3.min(domain) ], 0, height), 
                        this.data.yAxis = PulseChart.createAxisY(this.data.commonYScale, height, this.data.settings.yAxis.formatterOptions);
                    }, PulseChart.prototype.getYAxisScales = function(height) {
                        var data = this.data, stepOfHeight = height / data.grouped.length;
                        return data.grouped.map(function(group, index) {
                            var values = group.values[0].values.map(function(x) {
                                return x || 0;
                            }), minValue = Number.MAX_VALUE, maxValue = -Number.MAX_VALUE;
                            if (values.forEach(function(value) {
                                minValue > value && (minValue = value), value > maxValue && (maxValue = value);
                            }), maxValue === minValue) {
                                var offset = 0 === maxValue ? 1 : Math.abs(maxValue / 2);
                                maxValue += offset, minValue -= offset;
                            }
                            return PulseChart.createScale(!0, [ maxValue, minValue ], stepOfHeight * index, stepOfHeight * (index + 1));
                        });
                    }, Object.defineProperty(PulseChart.prototype, "autoplayPauseDuration", {
                        get: function() {
                            return 1e3 * (this.data && this.data.settings && this.data.settings.playback ? this.data.settings.playback.autoplayPauseDuration : PulseChart.DefaultSettings.playback.autoplayPauseDuration);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "isAutoPlay", {
                        get: function() {
                            return this.data && this.data.settings && this.data.settings.playback && this.data.settings.playback.autoplay;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseChart.prototype.render = function(suppressAnimations) {
                        var result, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), data = this.data;
                        this.lastSelectedPoint = null;
                        var xScale = data.xScale, yScales = data.yScales;
                        return this.lineX = d3.svg.line().x(function(d) {
                            return xScale(d.categoryValue);
                        }).y(function(d) {
                            return yScales[d.groupIndex](d.y);
                        }), this.data && this.data.settings && this.data.settings.playback && this.data.settings.playback.color && this.animationHandler.setControlsColor(this.data.settings.playback.color), 
                        this.animationHandler.render(), this.animationHandler.setRunnerCounterValue(), this.renderAxes(data, duration), 
                        this.renderGaps(data, duration), result;
                    }, PulseChart.prototype.renderAxes = function(data, duration) {
                        this.renderXAxis(data, duration), this.renderYAxis(data, duration);
                    }, PulseChart.prototype.renderXAxis = function(data, duration) {
                        var axisNodeSelection, axisNodeUpdateSelection, axisBoxUpdateSelection, color = PulseChart.DefaultSettings.xAxis.color, fontColor = PulseChart.DefaultSettings.xAxis.fontColor;
                        this.data && this.data.settings && this.data.settings.xAxis && (color = this.data.settings.xAxis.color, 
                        fontColor = this.data.settings.xAxis.fontColor), axisNodeSelection = this.rootSelection.selectAll(PulseChart.XAxisNode.selector), 
                        axisNodeUpdateSelection = axisNodeSelection.data(data.series), axisNodeUpdateSelection.enter().insert("g", "g." + PulseChart.LineContainer["class"]).classed(PulseChart.XAxisNode["class"], !0), 
                        axisNodeUpdateSelection.call(function(selection) {
                            selection.forEach(function(selectionElement, index) {
                                d3.select(selectionElement[0]).call(data.series[index].xAxisProperties.axis.orient("bottom"));
                            });
                        }), axisNodeUpdateSelection.exit().remove(), axisBoxUpdateSelection = axisNodeUpdateSelection.selectAll(".tick").selectAll(".axisBox").data([ [] ]), 
                        axisBoxUpdateSelection.enter().insert("rect", "text").classed("axisBox", !0), axisBoxUpdateSelection.style("display", this.data.settings.xAxis.position === XAxisPosition.Center ? "inherit" : "none").style("fill", this.data.settings.xAxis.backgroundColor);
                        var tickRectY = this.data.settings.xAxis.position === XAxisPosition.Center ? -11 : 0;
                        axisBoxUpdateSelection.attr({
                            x: -(this.data.widthOfXAxisLabel / 2),
                            y: tickRectY + "px",
                            width: this.data.widthOfXAxisLabel,
                            height: PulseChart.XAxisTickHeight + "px"
                        }), axisBoxUpdateSelection.exit().remove(), axisNodeUpdateSelection.style("stroke", this.data.settings.xAxis.position === XAxisPosition.Center ? color : "none").style("display", this.data.settings.xAxis.show ? "inherit" : "none"), 
                        axisNodeUpdateSelection.call(function(selection) {
                            var rotate = selection.datum().xAxisProperties.rotate, rotateCoeff = rotate ? Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 0, dy = tickRectY + 3;
                            selection.selectAll("text").attr("transform", function() {
                                return "translate(0, " + (dy + 9 + $(this).width() / 2 * rotateCoeff) + ") rotate(" + (rotate ? PulseChart.AxisTickRotateAngle : 0) + ")";
                            }).style("fill", fontColor).style("stroke", "none").attr("dy", -9);
                        }), axisNodeUpdateSelection.selectAll(".domain").style("stroke", color), axisNodeUpdateSelection.selectAll(".domain").forEach(function(element) {
                            $(element).insertBefore($(element).parent().children().first());
                        });
                        var xAxisTop = this.size.height;
                        switch (this.data.settings.xAxis.position) {
                          case XAxisPosition.Center:
                            xAxisTop /= 2;
                            break;

                          case XAxisPosition.Bottom:                        }
                        axisNodeUpdateSelection.attr("transform", visuals.SVGUtil.translate(0, xAxisTop));
                    }, PulseChart.prototype.renderYAxis = function(data, duration) {
                        var yAxis = data.yAxis, isShow = !1, color = PulseChart.DefaultSettings.yAxis.color, fontColor = PulseChart.DefaultSettings.yAxis.fontColor;
                        yAxis.orient("right"), this.data && this.data.settings && this.data.settings.yAxis && this.data.settings.yAxis.show && (isShow = !0), 
                        this.data && this.data.settings && this.data.settings.yAxis && this.data.settings.yAxis && (color = this.data.settings.yAxis.color, 
                        fontColor = this.data.settings.yAxis.fontColor), this.yAxis.call(yAxis).attr("display", isShow ? "inline" : "none"), 
                        this.yAxis.selectAll(".domain, path, line").style("stroke", color), this.yAxis.selectAll("text").style("fill", fontColor), 
                        this.yAxis.selectAll("g.tick line").attr("x1", -this.size.width);
                    }, PulseChart.prototype.renderChart = function() {
                        var data = this.data, series = this.data.series, selection = this.rootSelection = this.chart.selectAll(PulseChart.LineNode.selector).data(series), lineNode = selection.enter().append("g").classed(PulseChart.LineNode["class"], !0);
                        lineNode.append("g").classed(PulseChart.LineContainer["class"], !0), lineNode.append("g").classed(PulseChart.TooltipContainer["class"], !0), 
                        lineNode.append("g").classed(PulseChart.DotsContainer["class"], !0), this.animationHandler.isAnimated ? this.showAnimationDot() : this.hideAnimationDot(), 
                        this.drawTooltips(data, this.selectionManager.getSelectionIds()), this.drawDots(data), 
                        this.drawLines(data), selection.exit().remove();
                    }, PulseChart.prototype.drawLinesStatic = function(limit, isAnimated) {
                        var _this = this, node = PulseChart.Line, nodeParent = PulseChart.LineContainer, rootSelection = this.rootSelection, selection = rootSelection.filter(function(d, index) {
                            return !isAnimated || limit > index;
                        }).select(nodeParent.selector).selectAll(node.selector).data(function(d) {
                            return [ d ];
                        });
                        selection.enter().append("path").classed(node["class"], !0), selection.style({
                            fill: "none",
                            stroke: function(d) {
                                return d.color;
                            },
                            "stroke-width": function(d) {
                                return d.width + "px";
                            }
                        }), selection.attr("d", function(d) {
                            return _this.lineX(d.data);
                        }), selection.exit().remove();
                    }, PulseChart.prototype.drawLinesStaticBeforeAnimation = function(limit) {
                        var _this = this, node = PulseChart.Line, nodeParent = PulseChart.LineContainer, rootSelection = this.rootSelection;
                        this.animationSelection = rootSelection.filter(function(d, index) {
                            return index === limit;
                        }).select(nodeParent.selector).selectAll(node.selector).data(function(d) {
                            return [ d ];
                        }), this.animationSelection.enter().append("path").classed(node["class"], !0), this.animationSelection.style({
                            fill: "none",
                            stroke: function(d) {
                                return d.color;
                            },
                            "stroke-width": function(d) {
                                return d.width + "px";
                            }
                        }), this.animationSelection.attr("d", function(d) {
                            var flooredStart = _this.animationHandler.flooredPosition.index;
                            if (0 === flooredStart) return _this.moveAnimationDot(d.data[0]), _this.lineX([]);
                            var dataReduced = d.data.slice(0, flooredStart + 1);
                            return _this.moveAnimationDot(dataReduced[dataReduced.length - 1]), _this.lineX(dataReduced);
                        }), this.animationSelection.exit().remove();
                    }, PulseChart.prototype.moveAnimationDot = function(d) {
                        var xScale = this.data.xScale, yScales = this.data.yScales;
                        this.animationDot.attr("cx", xScale(d.x)).attr("cy", yScales[d.groupIndex](d.y));
                    }, PulseChart.prototype.playAnimation = function(delay) {
                        var _this = this;
                        void 0 === delay && (delay = 0);
                        var flooredStart = this.animationHandler.flooredPosition.index;
                        this.showAnimationDot(), this.animationSelection.transition().delay(delay).duration(this.animationDuration).ease("linear").attrTween("d", function(d, index) {
                            return _this.getInterpolation(d.data, flooredStart);
                        }).each("end", function(series) {
                            return _this.handleSelection(_this.animationHandler.flooredPosition);
                        });
                    }, PulseChart.prototype.pauseAnimation = function() {
                        this.animationSelection && (this.hideAnimationDot(), this.animationSelection.selectAll("path").transition(), 
                        this.animationSelection.transition().duration(0).delay(0));
                    }, PulseChart.prototype.stopAnimation = function() {
                        this.pauseAnimation(), d3.timer.flush();
                    }, PulseChart.prototype.findNextPoint = function(position) {
                        for (var i = position.series; i < this.data.series.length; i++) for (var series = this.data.series[i], j = i === position.series ? Math.floor(position.index + 1) : 0; j < series.data.length; j++) if (series.data[j] && series.data[j].popupInfo) return {
                            series: i,
                            index: j
                        };
                        return null;
                    }, PulseChart.prototype.findPrevPoint = function(position) {
                        for (var i = position.series; i >= 0; i--) for (var series = this.data.series[i], j = i === position.series ? Math.ceil(position.index - 1) : series.data.length; j >= 0; j--) if (series.data[j] && series.data[j].popupInfo) return {
                            series: i,
                            index: j
                        };
                        return null;
                    }, PulseChart.prototype.isAnimationSeriesAndIndexLast = function(position) {
                        return this.isAnimationSeriesLast(position) && this.isAnimationIndexLast(position);
                    }, PulseChart.prototype.isAnimationSeriesLast = function(position) {
                        return position.series >= this.data.series.length - 1;
                    }, PulseChart.prototype.isAnimationIndexLast = function(position) {
                        var series = this.data.series[position.series];
                        return position.index >= series.data.length - 1;
                    }, PulseChart.prototype.drawLines = function(data) {
                        var positionSeries = this.animationHandler.position.series, isAnimated = this.animationHandler.isAnimated;
                        this.drawLinesStatic(positionSeries, isAnimated), isAnimated && this.drawLinesStaticBeforeAnimation(positionSeries);
                    }, PulseChart.prototype.showAnimationDot = function() {
                        if (this.animationHandler.isPlaying) {
                            var size = PulseChart.DefaultSettings.dots.size;
                            this.data && this.data.settings && this.data.settings.dots && this.data.settings.dots.size && (size = this.data.settings.dots.size), 
                            this.animationDot.attr("display", "inline").attr("fill", this.data.settings.dots.color).style("opacity", this.dotOpacity).attr("r", size);
                        }
                    }, PulseChart.prototype.hideAnimationDot = function() {
                        this.animationDot.attr("display", "none");
                    }, PulseChart.prototype.getInterpolation = function(data, start) {
                        var _this = this;
                        if (this.data) {
                            var xScale = this.data.xScale, yScales = this.data.yScales, stop = start + 1;
                            this.showAnimationDot();
                            var lineFunction = d3.svg.line().x(function(d) {
                                return d.x;
                            }).y(function(d) {
                                return d.y;
                            }).interpolate("linear"), interpolatedLine = data.slice(0, start + 1).map(function(d) {
                                return {
                                    x: xScale(d.x),
                                    y: yScales[d.groupIndex](d.y)
                                };
                            }), x0 = xScale(data[start].x), x1 = xScale(data[stop].x), y0 = yScales[data[start].groupIndex](data[start].y), y1 = yScales[data[stop].groupIndex](data[stop].y), interpolateIndex = d3.scale.linear().domain([ 0, 1 ]).range([ start, stop ]), interpolateX = d3.scale.linear().domain([ 0, 1 ]).range([ x0, x1 ]), interpolateY = d3.scale.linear().domain([ 0, 1 ]).range([ y0, y1 ]);
                            return this.animationHandler.setRunnerCounterValue(start), function(t) {
                                if (!_this.animationHandler.isPlaying) return lineFunction(interpolatedLine);
                                var x = interpolateX(t), y = interpolateY(t);
                                return _this.animationDot.attr("cx", x).attr("cy", y), interpolatedLine.push({
                                    x: x,
                                    y: y
                                }), _this.animationHandler.position.index = interpolateIndex(t), lineFunction(interpolatedLine);
                            };
                        }
                    }, PulseChart.prototype.clearSelection = function() {
                        this.data && this.data.hasHighlights || !this.selectionManager.hasSelection() ? this.selectionManager.selectedIds = [] : this.selectionManager.clear(), 
                        this.chart.selectAll(PulseChart.Tooltip.selector).remove();
                    }, PulseChart.prototype.handleSelection = function(position) {
                        var _this = this;
                        if (this.data) {
                            var animationPlayingIndex = this.animationHandler.animationPlayingIndex, dataPoint = this.data.series[position.series].data[position.index], isLastDataPoint = this.animationHandler.isPlaying && this.isAnimationSeriesAndIndexLast(position);
                            if ((!dataPoint || !dataPoint.popupInfo) && this.animationHandler.isPlaying) return void (isLastDataPoint ? setTimeout(function() {
                                return _this.animationHandler.toEnd();
                            }, 0) : this.animationHandler.play(0, !0));
                            isLastDataPoint ? setTimeout(function() {
                                return _this.animationHandler.toEnd();
                            }, 0) : this.animationHandler.pause(), this.selectionManager.select(dataPoint.identity).then(function(selectionIds) {
                                _this.setSelection(selectionIds), clearTimeout(_this.handleSelectionTimeout), _this.handleSelectionTimeout = setTimeout(function() {
                                    _this.animationHandler.animationPlayingIndex === animationPlayingIndex && ((isLastDataPoint || _this.animationHandler.isPaused) && _this.clearSelection(), 
                                    !isLastDataPoint && _this.animationHandler.isPaused && _this.animationHandler.play());
                                }, _this.pauseDuration);
                            });
                        }
                    }, Object.defineProperty(PulseChart.prototype, "animationDuration", {
                        get: function() {
                            return 1e3 / (this.data && this.data.settings && this.data.settings.playback ? this.data.settings.playback.playSpeed : PulseChart.DefaultSettings.playback.playSpeed);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "pauseDuration", {
                        get: function() {
                            return 1e3 * (this.data && this.data.settings && this.data.settings.playback ? this.data.settings.playback.pauseDuration : PulseChart.DefaultSettings.playback.pauseDuration);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "dotOpacity", {
                        get: function() {
                            return 1 - (this.data && this.data.settings && this.data.settings.dots ? this.data.settings.dots.transparency : PulseChart.DefaultSettings.dots.transparency) / 100;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseChart.prototype.drawDots = function(data) {
                        var _this = this;
                        if (data && data.xScale) {
                            var xScale = data.xScale, yScales = data.yScales, node = PulseChart.Dot, nodeParent = PulseChart.DotsContainer, rootSelection = this.rootSelection, dotColor = this.data.settings.dots.color, dotSize = this.data.settings.dots.size, isAnimated = this.animationHandler.isAnimated, position = this.animationHandler.position, selection = rootSelection.filter(function(d, index) {
                                return !isAnimated || index <= position.series;
                            }).select(nodeParent.selector).selectAll(node.selector).data(function(d, seriesIndex) {
                                return _.filter(d.data, function(value, valueIndex) {
                                    return isAnimated && seriesIndex === position.series && valueIndex > position.index ? !1 : !!value.popupInfo;
                                });
                            });
                            selection.enter().append("circle").classed(node["class"], !0), selection.attr("cx", function(d) {
                                return xScale(d.categoryValue);
                            }).attr("cy", function(d) {
                                return yScales[d.groupIndex](d.y);
                            }).attr("r", function(d) {
                                return d.eventSize || dotSize;
                            }).style("fill", dotColor).style("opacity", this.dotOpacity).style("cursor", "pointer").call(PulseChart.AddOnTouchClick, function(d) {
                                d3.event.stopPropagation(), _this.selectionManager.select(d.identity, d3.event.ctrlKey).then(function(selectionIds) {
                                    return _this.setSelection(selectionIds);
                                });
                            }), selection.exit().remove();
                        }
                    }, PulseChart.prototype.renderGaps = function(data, duration) {
                        var gaps, gapsSelection, gapsEnterSelection, gapNodeSelection, series = data.series, isScalar = data.isScalar, xScale = data.xScale;
                        gaps = [ {
                            left: -4.5,
                            top: -5,
                            height: 10,
                            width: 3
                        }, {
                            left: 1.5,
                            top: -5,
                            height: 10,
                            width: 3
                        } ], gapsSelection = this.gaps.selectAll(PulseChart.Gap.selector).data(series.slice(0, series.length - 1)), 
                        gapsEnterSelection = gapsSelection.enter().append("g"), gapsSelection.attr("transform", function(seriesElement, index) {
                            var x, middleOfGap = seriesElement.widthOfGap / 2, categoryValue = seriesElement.data[seriesElement.data.length - 1].categoryValue;
                            return x = xScale(isScalar ? middleOfGap + categoryValue : new Date(middleOfGap + categoryValue.getTime())), 
                            visuals.SVGUtil.translate(x, 0);
                        }), gapNodeSelection = gapsSelection.selectAll(PulseChart.GapNode.selector).data(gaps), 
                        gapNodeSelection.enter().append("rect").attr({
                            x: function(gap) {
                                return gap.left;
                            },
                            y: function(gap) {
                                return gap.top;
                            },
                            height: function(gap) {
                                return gap.height;
                            },
                            width: function(gap) {
                                return gap.width;
                            }
                        }).classed(PulseChart.GapNode["class"], !0), gapsEnterSelection.classed(PulseChart.Gap["class"], !0), 
                        gapsSelection.exit().remove(), gapNodeSelection.exit().remove();
                    }, PulseChart.prototype.setSelection = function(selectionIds) {
                        this.data && (this.drawDots(this.data), this.drawTooltips(this.data, selectionIds));
                    }, PulseChart.prototype.isPopupShow = function(d, selectionIds) {
                        return this.popupHeight && d.popupInfo && selectionIds ? SelectionManager.containsSelection(selectionIds, d.identity) : !1;
                    }, PulseChart.prototype.drawTooltips = function(data, selectionIds) {
                        var _this = this, xScale = data.xScale, yScales = data.yScales, node = PulseChart.Tooltip, nodeParent = PulseChart.TooltipContainer, rootSelection = this.rootSelection, line = d3.svg.line().x(function(d) {
                            return d.x;
                        }).y(function(d) {
                            return d.y;
                        }), marginTop = PulseChart.DefaultTooltipSettings.marginTop, width = this.data.settings.popup.width, height = this.data.settings.popup.height, topShift = 20, tooltipShiftY = function(y, groupIndex) {
                            return _this.isHigherMiddle(y, groupIndex) ? -1 * marginTop + topShift : _this.size.height + marginTop;
                        }, tooltipRoot = rootSelection.select(nodeParent.selector).selectAll(node.selector).data(function(d) {
                            return _.filter(d.data, function(value) {
                                return _this.isPopupShow(value, selectionIds);
                            });
                        });
                        tooltipRoot.enter().append("g").classed(node["class"], !0), tooltipRoot.attr("transform", function(d) {
                            var x = xScale(d.x) - width / 2, y = tooltipShiftY(d.y, d.groupIndex);
                            return d.popupInfo.offsetX = Math.min(_this.viewport.width - _this.margin.right - width, Math.max(-_this.margin.left, x)) - x, 
                            visuals.SVGUtil.translate(x + d.popupInfo.offsetX, y);
                        });
                        var tooltipRect = tooltipRoot.selectAll(PulseChart.TooltipRect.selector).data(function(d) {
                            return [ d ];
                        });
                        tooltipRect.enter().append("path").classed(PulseChart.TooltipRect["class"], !0), 
                        tooltipRect.attr("display", function(d) {
                            return d.popupInfo ? "inherit" : "none";
                        }).style("fill", this.data.settings.popup.color).attr("d", function(d) {
                            var path = [ {
                                x: -2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            }, {
                                x: -2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : height
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : height
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            } ];
                            return line(path);
                        });
                        var tooltipTriangle = tooltipRoot.selectAll(PulseChart.TooltipTriangle.selector).data(function(d) {
                            return [ d ];
                        });
                        tooltipTriangle.enter().append("path").classed(PulseChart.TooltipTriangle["class"], !0), 
                        tooltipTriangle.style("fill", this.data.settings.popup.color).attr("d", function(d) {
                            var path = [ {
                                x: width / 2 - 5 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            }, {
                                x: width / 2 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop - 5) : -5
                            }, {
                                x: width / 2 + 5 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            } ];
                            return line(path);
                        }).style("stroke-width", "1px");
                        var tooltipLine = tooltipRoot.selectAll(PulseChart.TooltipLine.selector).data(function(d) {
                            return [ d ];
                        });
                        tooltipLine.enter().append("path").classed(PulseChart.TooltipLine["class"], !0), 
                        tooltipLine.style("fill", this.data.settings.popup.color).style("stroke", this.data.settings.popup.color).style("stroke-width", "1px").attr("d", function(d) {
                            var path = [ {
                                x: width / 2 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? yScales[d.groupIndex](d.y) + tooltipShiftY(d.y, d.groupIndex) - d.eventSize : yScales[d.groupIndex](d.y) - tooltipShiftY(d.y, d.groupIndex) + d.eventSize
                            }, {
                                x: width / 2 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            } ];
                            return line(path);
                        });
                        var isShowTime = this.data.settings.popup.showTime, isShowTitle = this.data.settings.popup.showTitle, timeRect = tooltipRoot.selectAll(PulseChart.TooltipTimeRect.selector).data(function(d) {
                            return [ d ];
                        }), timeDisplayStyle = {
                            display: isShowTime ? void 0 : "none"
                        };
                        timeRect.enter().append("path").classed(PulseChart.TooltipTimeRect["class"], !0), 
                        timeRect.style("fill", this.data.settings.popup.timeFill).style(timeDisplayStyle).attr("d", function(d) {
                            var path = [ {
                                x: width - _this.data.widthOfTooltipValueLabel - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : 0
                            }, {
                                x: width - _this.data.widthOfTooltipValueLabel - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight) : PulseChart.DefaultTooltipSettings.timeHeight
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight) : PulseChart.DefaultTooltipSettings.timeHeight
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : 0
                            } ];
                            return line(path);
                        });
                        var time = tooltipRoot.selectAll(PulseChart.TooltipTime.selector).data(function(d) {
                            return [ d ];
                        });
                        time.enter().append("text").classed(PulseChart.TooltipTime["class"], !0), time.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupValueTextProperties())).style(timeDisplayStyle).style("fill", this.data.settings.popup.timeColor).attr("x", function(d) {
                            return width - _this.data.widthOfTooltipValueLabel;
                        }).attr("y", function(d) {
                            return _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight + 3) : PulseChart.DefaultTooltipSettings.timeHeight - 3;
                        }).text(function(d) {
                            return d.popupInfo.value;
                        });
                        var titleDisplayStyle = {
                            display: isShowTitle ? void 0 : "none"
                        }, title = tooltipRoot.selectAll(PulseChart.TooltipTitle.selector).data(function(d) {
                            return [ d ];
                        });
                        title.enter().append("text").classed(PulseChart.TooltipTitle["class"], !0), title.style(titleDisplayStyle).style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupTitleTextProperties())).style("fill", this.data.settings.popup.fontColor).attr("x", function(d) {
                            return PulseChart.PopupTextPadding;
                        }).attr("y", function(d) {
                            return (_this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - 12) : 12) + PulseChart.PopupTextPadding;
                        }).text(function(d) {
                            if (!d.popupInfo) return "";
                            var maxWidth = width - 2 * PulseChart.PopupTextPadding - (isShowTime ? _this.data.widthOfTooltipValueLabel - PulseChart.PopupTextPadding : 0) - 10;
                            return TextMeasurementService.getTailoredTextOrDefault(PulseChart.GetPopupTitleTextProperties(d.popupInfo.title), maxWidth);
                        });
                        var getDescriptionDimenstions = function(d) {
                            var shiftY = PulseChart.PopupTextPadding + _this.data.settings.popup.fontSize, descriptionYOffset = shiftY + PulseChart.DefaultTooltipSettings.timeHeight;
                            return d.popupInfo && (shiftY = isShowTitle && d.popupInfo.title || isShowTime && d.popupInfo.value ? descriptionYOffset : shiftY), 
                            {
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - shiftY) : shiftY,
                                x: PulseChart.PopupTextPadding,
                                width: width - 2 * PulseChart.PopupTextPadding,
                                height: height - shiftY
                            };
                        }, description = tooltipRoot.selectAll(PulseChart.TooltipDescription.selector).data(function(d) {
                            return [ d ];
                        });
                        description.enter().append("text").classed(PulseChart.TooltipDescription["class"], !0), 
                        description.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupDescriptionTextProperties(null, this.data.settings.popup.fontSize))).style("fill", this.data.settings.popup.fontColor).text(function(d) {
                            return d.popupInfo && d.popupInfo.description;
                        }).attr("y", function(d) {
                            var descriptionDimenstions = getDescriptionDimenstions(d), el = d3.select(this)[0][0];
                            return TextMeasurementService.wordBreak(el, descriptionDimenstions.width, descriptionDimenstions.height), 
                            0;
                        }).attr("transform", function(d) {
                            var descriptionDimenstions = getDescriptionDimenstions(d);
                            return visuals.SVGUtil.translate(0, descriptionDimenstions.y);
                        }), description.selectAll("tspan").attr("x", PulseChart.PopupTextPadding), tooltipRoot.exit().remove();
                    }, PulseChart.prototype.isHigherMiddle = function(value, groupIndex) {
                        if (this.data.settings.popup.alwaysOnTop) return !0;
                        if (this.data.yScales.length > 1) return 0 === groupIndex;
                        var domain = this.data.commonYScale.domain(), minValue = d3.min(domain), middleValue = Math.abs((d3.max(domain) - minValue) / 2);
                        return middleValue = 0 === middleValue ? middleValue : minValue + middleValue, value >= middleValue;
                    }, PulseChart.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, PulseChart.parseSettings = function(dataView, colors, columns) {
                        var settings = {}, objects = PulseChart.getObjectsFromDataView(dataView);
                        return settings.xAxis = this.getAxisXSettings(objects, colors), settings.yAxis = this.getAxisYSettings(objects, colors), 
                        settings.popup = this.getPopupSettings(objects, colors), settings.dots = this.getDotsSettings(objects, colors), 
                        settings.series = this.getSeriesSettings(objects, colors), settings.gaps = this.getGapsSettings(objects), 
                        settings.playback = this.getPlaybackSettings(objects, colors), settings.runnerCounter = this.getRunnerCounterSettings(objects, colors, columns), 
                        settings;
                    }, PulseChart.getPopupSettings = function(objects, colors) {
                        var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.show, PulseChart.DefaultSettings.popup.show), alwaysOnTop = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.alwaysOnTop, PulseChart.DefaultSettings.popup.alwaysOnTop), width = Math.max(PulseChart.PopupMinWidth, Math.min(PulseChart.PopupMaxWidth, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.width, PulseChart.DefaultSettings.popup.width))), height = Math.max(PulseChart.PopupMinHeight, Math.min(PulseChart.PopupMaxHeight, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.height, PulseChart.DefaultSettings.popup.height))), colorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.color, PulseChart.DefaultSettings.popup.color), color = colorHelper.getColorForMeasure(objects, ""), fontSize = parseInt(powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.fontSize, PulseChart.DefaultSettings.popup.fontSize), 10), fontColorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.fontColor, PulseChart.DefaultSettings.popup.fontColor), fontColor = fontColorHelper.getColorForMeasure(objects, ""), showTime = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.showTime, PulseChart.DefaultSettings.popup.showTime), showTitle = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.showTitle, PulseChart.DefaultSettings.popup.showTitle), timeColorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.timeColor, PulseChart.DefaultSettings.popup.timeColor), timeColor = timeColorHelper.getColorForMeasure(objects, ""), timeFillHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.timeFill, PulseChart.DefaultSettings.popup.timeFill), timeFill = timeFillHelper.getColorForMeasure(objects, "");
                        return {
                            show: show,
                            alwaysOnTop: alwaysOnTop,
                            width: width,
                            height: height,
                            color: color,
                            fontSize: fontSize,
                            fontColor: fontColor,
                            showTime: showTime,
                            showTitle: showTitle,
                            timeColor: timeColor,
                            timeFill: timeFill
                        };
                    }, PulseChart.getDotsSettings = function(objects, colors) {
                        var properties = PulseChart.Properties.dots, defaultSettings = PulseChart.DefaultSettings.dots, colorHelper = new visuals.ColorHelper(colors, properties.color, defaultSettings.color), color = colorHelper.getColorForMeasure(objects, ""), minSize = Math.max(0, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.minSize, defaultSettings.minSize))), maxSize = Math.max(minSize, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.maxSize, defaultSettings.maxSize))), size = Math.max(minSize, Math.min(maxSize, powerbi.DataViewObjects.getValue(objects, properties.size, defaultSettings.size))), transparency = Math.max(0, Math.min(100, powerbi.DataViewObjects.getValue(objects, properties.transparency, defaultSettings.transparency)));
                        return {
                            color: color,
                            size: size,
                            minSize: minSize,
                            maxSize: maxSize,
                            transparency: transparency
                        };
                    }, PulseChart.getSeriesSettings = function(objects, colors) {
                        var width = Math.max(1, Math.min(100, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.series.width, PulseChart.DefaultSettings.series.width))), colorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.series.fill, PulseChart.DefaultSettings.series.fill), fill = colorHelper.getColorForMeasure(objects, "");
                        return {
                            width: width,
                            fill: fill
                        };
                    }, PulseChart.getGapsSettings = function(objects) {
                        var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.gaps.show, PulseChart.DefaultSettings.gaps.show), visibleGapsPercentage = Math.max(1, Math.min(100, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.gaps.transparency, PulseChart.DefaultSettings.gaps.visibleGapsPercentage)));
                        return {
                            show: show,
                            visibleGapsPercentage: visibleGapsPercentage
                        };
                    }, PulseChart.getAxisXSettings = function(objects, colors) {
                        var properties = PulseChart.Properties.xAxis, defaultSettings = PulseChart.DefaultSettings.xAxis, color = new visuals.ColorHelper(colors, properties.color, defaultSettings.color).getColorForMeasure(objects, ""), fontColor = new visuals.ColorHelper(colors, properties.fontColor, defaultSettings.fontColor).getColorForMeasure(objects, ""), show = powerbi.DataViewObjects.getValue(objects, properties.show, defaultSettings.show), position = powerbi.DataViewObjects.getValue(objects, properties.position, defaultSettings.position), backgroundColor = new visuals.ColorHelper(colors, properties.backgroundColor, defaultSettings.backgroundColor).getColorForMeasure(objects, "");
                        return {
                            show: show,
                            position: position,
                            color: color,
                            fontColor: fontColor,
                            backgroundColor: backgroundColor
                        };
                    }, PulseChart.getAxisYSettings = function(objects, colors) {
                        var properties = PulseChart.Properties.yAxis, defaultSettings = PulseChart.DefaultSettings.yAxis, colorHelper = new visuals.ColorHelper(colors, properties.color, defaultSettings.color), color = colorHelper.getColorForMeasure(objects, ""), fontColorHelper = new visuals.ColorHelper(colors, properties.fontColor, defaultSettings.fontColor), fontColor = fontColorHelper.getColorForMeasure(objects, ""), show = powerbi.DataViewObjects.getValue(objects, properties.show, defaultSettings.show);
                        return {
                            color: color,
                            fontColor: fontColor,
                            show: show
                        };
                    }, PulseChart.getPlaybackSettings = function(objects, colors) {
                        var playbackSettings = {}, properties = PulseChart.Properties.playback, defaultSettings = PulseChart.DefaultSettings.playback;
                        playbackSettings.autoplay = powerbi.DataViewObjects.getValue(objects, properties.autoplay, defaultSettings.autoplay), 
                        playbackSettings.playSpeed = Math.max(1, Math.min(99999, powerbi.DataViewObjects.getValue(objects, properties.playSpeed, defaultSettings.playSpeed))), 
                        playbackSettings.pauseDuration = Math.max(0, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.pauseDuration, defaultSettings.pauseDuration))), 
                        playbackSettings.autoplayPauseDuration = Math.max(1, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.autoplayPauseDuration, defaultSettings.autoplayPauseDuration)));
                        var colorHelper = new visuals.ColorHelper(colors, properties.color, defaultSettings.color);
                        playbackSettings.color = colorHelper.getColorForMeasure(objects, "");
                        var position = powerbi.DataViewObjects.getValue(objects, properties.position, "");
                        if (position.length > 3) try {
                            playbackSettings.position = JSON.parse(position);
                        } catch (ex) {}
                        return playbackSettings.position = playbackSettings.position || defaultSettings.position, 
                        playbackSettings;
                    }, PulseChart.getRunnerCounterSettings = function(objects, colors, columns) {
                        var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.show, PulseChart.DefaultSettings.runnerCounter.show), label = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.label, columns.RunnerCounter && columns.RunnerCounter.source && columns.RunnerCounter.source.displayName || PulseChart.DefaultSettings.runnerCounter.label), position = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.position, PulseChart.DefaultSettings.runnerCounter.position), fontSize = parseInt(powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.fontSize, PulseChart.DefaultSettings.runnerCounter.fontSize), 10), fontColor = new visuals.ColorHelper(colors, PulseChart.Properties.runnerCounter.fontColor, PulseChart.DefaultSettings.runnerCounter.fontColor).getColorForMeasure(objects, "");
                        return {
                            show: show,
                            label: label,
                            position: position,
                            fontSize: fontSize,
                            fontColor: fontColor
                        };
                    }, PulseChart.prototype.clearAll = function(hide) {
                        this.gaps.selectAll(PulseChart.Gap.selector).remove(), this.animationHandler && (this.animationHandler.reset(), 
                        this.animationHandler.clear()), hide && this.svg.style("display", "none"), this.clearChart();
                    }, PulseChart.prototype.clearChart = function() {
                        this.clearSelection(), this.hideAnimationDot(), this.chart.selectAll(PulseChart.Line.selector).remove(), 
                        this.chart.selectAll(PulseChart.Dot.selector).remove();
                    }, PulseChart.prototype.clearRedundant = function(position) {
                        var _this = this;
                        if (this.data) {
                            var popups = this.chart.selectAll(PulseChart.Tooltip.selector).filter(function(data) {
                                return data.seriesIndex < position.series || data.seriesIndex === position.series && _this.data.series[data.seriesIndex].data[position.index].value >= data.value;
                            }), selectedPopupsIds = popups.data().map(function(data) {
                                return data.identity;
                            });
                            if (this.clearSelection(), selectedPopupsIds.length) {
                                var popupsSelecting = selectedPopupsIds.map(function(id) {
                                    return _this.selectionManager.select(id, !0);
                                });
                                $.when.apply(null, popupsSelecting).then(function(selectionIds) {
                                    return _this.setSelection(selectionIds);
                                });
                            }
                            this.chart.selectAll(PulseChart.Line.selector).remove(), this.chart.selectAll(PulseChart.Dot.selector).remove();
                        }
                    }, PulseChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "general":
                            this.readGeneralInstance(enumeration);
                            break;

                          case "popup":
                            this.readPopupInstance(enumeration);
                            break;

                          case "dots":
                            this.readDotsInstance(enumeration);
                            break;

                          case "xAxis":
                            this.xAxisInstance(enumeration);
                            break;

                          case "yAxis":
                            this.yAxisInstance(enumeration);
                            break;

                          case "series":
                            this.readSeriesInstance(enumeration);
                            break;

                          case "gaps":
                            this.readGapsInstance(enumeration);
                            break;

                          case "playback":
                            this.readPlaybackInstance(enumeration);
                            break;

                          case "runnerCounter":
                            this.readRunnerCounterInstance(enumeration);
                        }
                        return enumeration.complete();
                    }, PulseChart.prototype.getSettings = function(name) {
                        return this.data && this.data.settings && this.data.settings[name] ? this.data.settings[name] : PulseChart.DefaultSettings[name];
                    }, PulseChart.prototype.readGeneralInstance = function(enumeration) {
                        var instance = {
                            objectName: "general",
                            displayName: "general",
                            selector: null,
                            properties: {}
                        };
                        enumeration.pushInstance(instance);
                    }, PulseChart.prototype.readPopupInstance = function(enumeration) {
                        var settings = this.getSettings("popup"), popup = {
                            objectName: "popup",
                            displayName: "popup",
                            selector: null,
                            properties: {
                                show: settings.show,
                                alwaysOnTop: settings.alwaysOnTop,
                                width: settings.width,
                                height: settings.height,
                                color: settings.color,
                                fontColor: settings.fontColor,
                                fontSize: settings.fontSize,
                                showTime: settings.showTime,
                                showTitle: settings.showTitle,
                                timeColor: settings.timeColor,
                                timeFill: settings.timeFill
                            }
                        };
                        enumeration.pushInstance(popup);
                    }, PulseChart.prototype.readDotsInstance = function(enumeration) {
                        var settings = this.getSettings("dots"), instance = {
                            objectName: "dots",
                            displayName: "Dots",
                            selector: null,
                            properties: {
                                color: settings.color,
                                size: settings.size,
                                minSize: settings.minSize,
                                maxSize: settings.maxSize,
                                transparency: settings.transparency
                            }
                        };
                        enumeration.pushInstance(instance);
                    }, PulseChart.prototype.xAxisInstance = function(enumeration) {
                        var settings = this.getSettings("xAxis");
                        enumeration.pushInstance({
                            objectName: "xAxis",
                            displayName: "xAxis",
                            selector: null,
                            properties: {
                                show: settings.show,
                                position: settings.position,
                                color: settings.color,
                                fontColor: settings.fontColor,
                                backgroundColor: settings.backgroundColor
                            }
                        });
                    }, PulseChart.prototype.yAxisInstance = function(enumeration) {
                        var settings = this.getSettings("yAxis");
                        enumeration.pushInstance({
                            objectName: "yAxis",
                            displayName: "yAxis",
                            selector: null,
                            properties: {
                                color: settings.color,
                                fontColor: settings.fontColor,
                                show: settings.show
                            }
                        });
                    }, PulseChart.prototype.readSeriesInstance = function(enumeration) {
                        var settings = this.getSettings("series"), series = {
                            objectName: "series",
                            displayName: "series",
                            selector: null,
                            properties: {
                                fill: settings.fill,
                                width: settings.width
                            }
                        };
                        enumeration.pushInstance(series);
                    }, PulseChart.prototype.readGapsInstance = function(enumeration) {
                        var settings = this.getSettings("gaps"), gaps = {
                            objectName: "gaps",
                            selector: null,
                            properties: {
                                show: settings.show,
                                transparency: settings.visibleGapsPercentage
                            }
                        };
                        enumeration.pushInstance(gaps);
                    }, PulseChart.prototype.readPlaybackInstance = function(enumeration) {
                        var settings = this.getSettings("playback");
                        enumeration.pushInstance({
                            objectName: "playback",
                            displayName: "playback",
                            selector: null,
                            properties: {
                                autoplay: settings.autoplay,
                                playSpeed: settings.playSpeed,
                                pauseDuration: settings.pauseDuration,
                                autoplayPauseDuration: settings.autoplayPauseDuration,
                                color: settings.color
                            }
                        });
                    }, PulseChart.prototype.readRunnerCounterInstance = function(enumeration) {
                        var runnerCounterSettings = this.getSettings("runnerCounter"), instance = {
                            objectName: "runnerCounter",
                            selector: null,
                            properties: {}
                        };
                        this.data && this.data.columns && this.data.columns.RunnerCounter && (instance.properties = {
                            show: runnerCounterSettings.show,
                            label: runnerCounterSettings.label,
                            position: runnerCounterSettings.position,
                            fontSize: runnerCounterSettings.fontSize,
                            fontColor: runnerCounterSettings.fontColor
                        }), enumeration.pushInstance(instance);
                    }, PulseChart.prototype.destroy = function() {
                        this.data = null, this.clearAll(!0);
                    }, PulseChart.RoleDisplayNames = {
                        Timestamp: "Timestamp",
                        Category: "Category",
                        Value: "Value",
                        EventTitle: "Event Title",
                        EventDescription: "Event Description",
                        EventSize: "Event Size",
                        RunnerCounter: "Runner Counter"
                    }, PulseChart.RoleNames = _.mapValues(PulseChart.RoleDisplayNames, function(x, i) {
                        return i;
                    }), PulseChart.capabilities = {
                        dataRoles: [ {
                            displayName: PulseChart.RoleDisplayNames.Timestamp,
                            name: PulseChart.RoleNames.Timestamp,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: PulseChart.RoleDisplayNames.Value,
                            name: PulseChart.RoleNames.Value,
                            kind: powerbi.VisualDataRoleKind.Measure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.EventTitle,
                            name: PulseChart.RoleNames.EventTitle,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.EventDescription,
                            name: PulseChart.RoleNames.EventDescription,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.EventSize,
                            name: PulseChart.RoleNames.EventSize,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.RunnerCounter,
                            name: PulseChart.RoleNames.RunnerCounter,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Timestamp: {
                                    max: 1
                                },
                                Value: {
                                    max: 1
                                },
                                Category: {
                                    max: 1
                                },
                                EventTitle: {
                                    max: 1
                                },
                                EventDescription: {
                                    max: 1
                                },
                                EventSize: {
                                    max: 1
                                },
                                RunnerCounter: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": PulseChart.RoleNames.Timestamp
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 1e4
                                        }
                                    }
                                },
                                values: {
                                    group: {
                                        by: PulseChart.RoleNames.Category,
                                        select: [ {
                                            bind: {
                                                to: PulseChart.RoleNames.Value
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.EventTitle
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.EventDescription
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.EventSize
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.RunnerCounter
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            series: {
                                displayName: "Series",
                                description: "Series",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            gaps: {
                                displayName: "Gaps",
                                description: "Gaps",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    transparency: {
                                        displayName: "Visible gaps",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    fill: {
                                        displayName: "Background color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            popup: {
                                displayName: "Popup",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    alwaysOnTop: {
                                        displayName: "Always on top",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    height: {
                                        displayName: "Height",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Text color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showTime: {
                                        displayName: "Show time",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Show title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    timeColor: {
                                        displayName: "Time color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    timeFill: {
                                        displayName: "Time fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            dots: {
                                displayName: "Dots",
                                properties: {
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    minSize: {
                                        displayName: "Min Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxSize: {
                                        displayName: "Max Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    size: {
                                        displayName: "Default Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    transparency: {
                                        displayName: "Transparency",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            xAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: createEnumTypeFromEnum(XAxisPosition)
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    color: {
                                        displayName: "Axis Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    backgroundColor: {
                                        displayName: "Background Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            yAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    color: {
                                        displayName: "Axis Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            playback: {
                                displayName: "Playback",
                                properties: {
                                    autoplay: {
                                        displayName: "Autoplay",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    playSpeed: {
                                        displayName: "Speed (dots/sec)",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    pauseDuration: {
                                        displayName: "Pause Duration",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    autoplayPauseDuration: {
                                        displayName: "Start Delay",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Buttons Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            runnerCounter: {
                                displayName: "Runner Counter",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    label: {
                                        displayName: "Label",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: createEnumTypeFromEnum(RunnerCounterPosition)
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: PulseChart.RoleNames.Timestamp,
                                    direction: 1
                                } ]
                            }
                        },
                        supportsHighlight: !0
                    }, PulseChart.Properties = PulseChart.getProperties(PulseChart.capabilities), PulseChart.DefaultMargin = {
                        top: 20,
                        bottom: 20,
                        right: 25,
                        left: 25
                    }, PulseChart.DefaultViewport = {
                        width: 50,
                        height: 50
                    }, PulseChart.PlaybackButtonsHeight = 26, PulseChart.PopupMinHeight = 20, PulseChart.PopupMinWidth = 20, 
                    PulseChart.PopupMaxHeight = 200, PulseChart.PopupMaxWidth = 2e3, PulseChart.MaxWidthOfYAxis = 50, 
                    PulseChart.PopupTextPadding = 3, PulseChart.XAxisTickSpace = 15, PulseChart.XAxisTickHeight = 16, 
                    PulseChart.MinimumTicksToRotate = 3, PulseChart.AxisTickRotateAngle = -35, PulseChart.DefaultSettings = {
                        precision: 0,
                        popup: {
                            show: !0,
                            alwaysOnTop: !1,
                            width: 100,
                            height: 80,
                            color: "#808181",
                            fontSize: 10,
                            fontColor: "white",
                            showTime: !0,
                            showTitle: !0,
                            timeColor: "white",
                            timeFill: "#010101"
                        },
                        dots: {
                            color: "#808181",
                            size: 5,
                            minSize: 5,
                            maxSize: 20,
                            transparency: 25
                        },
                        gaps: {
                            show: !1,
                            visibleGapsPercentage: 1
                        },
                        series: {
                            fill: "#3779B7",
                            width: 2
                        },
                        xAxis: {
                            color: "#777777",
                            fontColor: "#777777",
                            position: XAxisPosition.Center,
                            show: !0,
                            dateFormat: PulseChartXAxisDateFormat.TimeOnly,
                            backgroundColor: "#E1F2F7"
                        },
                        yAxis: {
                            color: "#777777",
                            fontColor: "#777777",
                            show: !0
                        },
                        playback: {
                            autoplay: !1,
                            playSpeed: 5,
                            pauseDuration: 10,
                            autoplayPauseDuration: 0,
                            color: "#777",
                            position: null
                        },
                        runnerCounter: {
                            show: !0,
                            label: "",
                            position: RunnerCounterPosition.TopRight,
                            fontSize: 13,
                            fontColor: "#777777"
                        },
                        formatStringProperty: PulseChart.Properties.general.formatString
                    }, PulseChart.DefaultTooltipSettings = {
                        dataPointColor: "#808181",
                        marginTop: 20,
                        timeHeight: 15
                    }, PulseChart.MaxGapCount = 100, PulseChart.MinGapWidth = _.object([ [ PulseChartXAxisDateFormat.DateOnly, 144e4 ], [ PulseChartXAxisDateFormat.TimeOnly, 6e4 ] ], void 0), 
                    PulseChart.Chart = createClassAndSelector("chart"), PulseChart.Line = createClassAndSelector("line"), 
                    PulseChart.LineContainer = createClassAndSelector("lineContainer"), PulseChart.LineNode = createClassAndSelector("lineNode"), 
                    PulseChart.XAxisNode = createClassAndSelector("xAxisNode"), PulseChart.Dot = createClassAndSelector("dot"), 
                    PulseChart.DotsContainer = createClassAndSelector("dotsContainer"), PulseChart.Tooltip = createClassAndSelector("Tooltip"), 
                    PulseChart.TooltipRect = createClassAndSelector("tooltipRect"), PulseChart.TooltipTriangle = createClassAndSelector("tooltipTriangle"), 
                    PulseChart.Gaps = createClassAndSelector("gaps"), PulseChart.Gap = createClassAndSelector("gap"), 
                    PulseChart.GapNode = createClassAndSelector("gapNode"), PulseChart.TooltipLine = createClassAndSelector("tooltipLine"), 
                    PulseChart.TooltipTime = createClassAndSelector("tooltipTime"), PulseChart.TooltipTimeRect = createClassAndSelector("tooltipTimeRect"), 
                    PulseChart.TooltipTitle = createClassAndSelector("tooltipTitle"), PulseChart.TooltipDescription = createClassAndSelector("tooltipDescription"), 
                    PulseChart.TooltipContainer = createClassAndSelector("tooltipContainer"), PulseChart.AnimationDot = createClassAndSelector("animationDot"), 
                    PulseChart;
                }();
                samples.PulseChart = PulseChart;
                var PulseAnimatorStates;
                !function(PulseAnimatorStates) {
                    PulseAnimatorStates[PulseAnimatorStates.Ready = 0] = "Ready", PulseAnimatorStates[PulseAnimatorStates.Play = 1] = "Play", 
                    PulseAnimatorStates[PulseAnimatorStates.Paused = 2] = "Paused", PulseAnimatorStates[PulseAnimatorStates.Stopped = 3] = "Stopped";
                }(PulseAnimatorStates || (PulseAnimatorStates = {}));
                var PulseAnimator = function() {
                    function PulseAnimator(chart, svg) {
                        var _this = this;
                        this.animationPlayingIndex = 0, this.runnerCounterTopLeftPosition = 180, this.isAutoPlayed = !1, 
                        this.isPositionWasSaved = !1, this.chart = chart, this.svg = svg, this.setDefaultValues();
                        var container = this.container = this.svg.append("g");
                        this.animationPlay = container.append("g").classed(PulseAnimator.AnimationPlay["class"], !0), 
                        this.animationPlay.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationPlay.call(PulseChart.AddOnTouchClick, function() {
                            return _this.play();
                        }), this.animationPlay.append("path").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3 17v-10l9 5.146-9 4.854z"), 
                        this.animationPause = container.append("g").classed(PulseAnimator.AnimationPause["class"], !0), 
                        this.animationPause.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationPause.call(PulseChart.AddOnTouchClick, function() {
                            return _this.stop();
                        }), this.animationPause.append("path").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-1 17h-3v-10h3v10zm5-10h-3v10h3v-10z"), 
                        this.animationReset = container.append("g").classed(PulseAnimator.AnimationReset["class"], !0), 
                        this.animationReset.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationReset.call(PulseChart.AddOnTouchClick, function() {
                            return _this.reset();
                        }), this.animationReset.append("path").attr("d", "M22 12c0 5.514-4.486 10-10 10s-10-4.486-10-10 4.486-10 10-10 10 4.486 10 10zm-22 0c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12zm13 0l5-4v8l-5-4zm-5 0l5-4v8l-5-4zm-2 4h2v-8h-2v8z"), 
                        this.animationPrev = container.append("g").classed(PulseAnimator.AnimationPrev["class"], !0), 
                        this.animationPrev.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationPrev.call(PulseChart.AddOnTouchClick, function() {
                            return _this.prev();
                        }), this.animationPrev.append("path").attr("d", "M9.5 12l7.5-4.5v9l-7.5-4.5zm-4.5 0l6.5 4v-1.634l-3.943-2.366 3.943-2.366v-1.634l-6.5 4zm17 0c0 5.514-4.486 10-10 10s-10-4.486-10-10 4.486-10 10-10 10 4.486 10 10zm-22 0c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12z"), 
                        this.animationNext = container.append("g").classed(PulseAnimator.AnimationNext["class"], !0), 
                        this.animationNext.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationNext.call(PulseChart.AddOnTouchClick, function() {
                            return _this.next();
                        }), this.animationNext.append("path").attr("d", "M7 16.5v-9l7.5 4.5-7.5 4.5zm5.5-8.5v1.634l3.943 2.366-3.943 2.366v1.634l6.5-4-6.5-4zm-.5-6c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12z").attr("rotate", 180), 
                        this.animationToEnd = container.append("g").classed(PulseAnimator.AnimationToEnd["class"], !0), 
                        this.animationToEnd.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationToEnd.call(PulseChart.AddOnTouchClick, function() {
                            return _this.toEnd();
                        }), this.animationToEnd.append("path").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-6 16v-8l5 4-5 4zm5 0v-8l5 4-5 4zm7-8h-2v8h2v-8z"), 
                        this.runnerCounter = container.append("g").classed(PulseAnimator.RunnerCounter["class"], !0), 
                        this.runnerCounterText = this.runnerCounter.append("text"), this.setControlsColor(PulseAnimator.DefaultControlsColor);
                    }
                    return Object.defineProperty(PulseAnimator, "AnimationMinPosition", {
                        get: function() {
                            return {
                                series: 0,
                                index: 0
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "runnerCounterPosition", {
                        get: function() {
                            return this.chart.data.settings.runnerCounter.position;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "maxTextWidthOfRunnerCounterValue", {
                        get: function() {
                            var top = this.runnerCounterPosition === RunnerCounterPosition.TopLeft || this.runnerCounterPosition === RunnerCounterPosition.TopRight;
                            return this.chart.viewport.width - (top ? this.runnerCounterTopLeftPosition : 0);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isAnimated", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Paused || this.animatorState === PulseAnimatorStates.Play || this.animatorState === PulseAnimatorStates.Stopped;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isPlaying", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Play;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isPaused", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Paused;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isStopped", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Stopped;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseAnimator.prototype.setDefaultValues = function() {
                        this.position = PulseAnimator.AnimationMinPosition, this.animatorState = PulseAnimatorStates.Ready, 
                        this.runnerCounterValue = null;
                    }, PulseAnimator.prototype.render = function() {
                        this.renderControls(), this.disableControls(), this.chart.isAutoPlay || (this.isAutoPlayed = !0, 
                        this.savedPosition && (this.savedPosition = null)), this.chart.isAutoPlay && this.isAutoPlayed && this.animatorState === PulseAnimatorStates.Play && !this.isPositionWasSaved && !_.isEqual(this.autoPlayPosition, this.savedPosition) && (this.chart.stopAnimation(), 
                        this.isAutoPlayed = !1, this.isPositionWasSaved = !0, this.animatorState = PulseAnimatorStates.Ready), 
                        this.animatorState === PulseAnimatorStates.Play ? this.play() : this.chart.isAutoPlay && !this.isAutoPlayed && this.animatorState === PulseAnimatorStates.Ready ? (this.autoPlayPosition = this.savedPosition, 
                        this.isAutoPlayed = !0, this.savedPosition && this.savedPosition.series < this.chart.data.series.length && this.savedPosition.index < this.chart.data.series[this.savedPosition.series].data.length && (this.position = this.savedPosition), 
                        this.play(this.chart.autoplayPauseDuration)) : this.chart.renderChart();
                    }, PulseAnimator.prototype.setControlsColor = function(color) {
                        this.color = color;
                    }, PulseAnimator.prototype.renderControls = function() {
                        this.show(), this.animationPlay.attr("transform", visuals.SVGUtil.translate(0, 0)).attr("fill", this.color), 
                        this.animationPause.attr("transform", visuals.SVGUtil.translate(30, 0)).attr("fill", this.color), 
                        this.animationReset.attr("transform", visuals.SVGUtil.translate(60, 0)).attr("fill", this.color), 
                        this.animationPrev.attr("transform", visuals.SVGUtil.translate(90, 0)).attr("fill", this.color), 
                        this.animationNext.attr("transform", visuals.SVGUtil.translate(120, 0)).attr("fill", this.color), 
                        this.animationToEnd.attr("transform", visuals.SVGUtil.translate(150, 0)).attr("fill", this.color), 
                        this.runnerCounter.attr("fill", this.color).attr("transform", visuals.SVGUtil.translate(this.runnerCounterPosition === RunnerCounterPosition.TopLeft ? this.runnerCounterTopLeftPosition : this.chart.viewport.width - 2, this.chart.data.runnerCounterHeight / 2 + 7)), 
                        this.runnerCounterText.style("text-anchor", this.runnerCounterPosition === RunnerCounterPosition.TopLeft ? "start" : "end"), 
                        this.chart.data && this.chart.data.settings && (this.runnerCounterText.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetRunnerCounterTextProperties(null, this.chart.data.settings.runnerCounter.fontSize))), 
                        this.runnerCounterText.style("fill", this.chart.data.settings.runnerCounter.fontColor)), 
                        this.drawCounterValue();
                    }, PulseAnimator.setControlVisiblity = function(element, isVisible, isDisabled) {
                        void 0 === isDisabled && (isDisabled = !1), element.style("opacity", isVisible ? PulseAnimator.DefaultOpacity : PulseAnimator.DimmedOpacity), 
                        isVisible ? element.attr("display", "inline") : isDisabled && element.attr("display", "none");
                    }, PulseAnimator.prototype.disableControls = function() {
                        var showRunner = this.chart.data && this.chart.data.settings && this.chart.data.settings.runnerCounter.show;
                        switch (PulseAnimator.setControlVisiblity(this.animationReset, !0), PulseAnimator.setControlVisiblity(this.animationToEnd, !0), 
                        this.animatorState) {
                          case PulseAnimatorStates.Play:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !1), PulseAnimator.setControlVisiblity(this.animationPrev, !0), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !0), PulseAnimator.setControlVisiblity(this.animationPause, !0), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, !0);
                            break;

                          case PulseAnimatorStates.Paused:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPause, !0), 
                            PulseAnimator.setControlVisiblity(this.animationPrev, !0), PulseAnimator.setControlVisiblity(this.animationNext, !0), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, !0);
                            break;

                          case PulseAnimatorStates.Stopped:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPrev, !0), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !0), PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, !0), 
                            PulseAnimator.setControlVisiblity(this.animationPause, !1);
                            break;

                          case PulseAnimatorStates.Ready:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPrev, !1), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !1), PulseAnimator.setControlVisiblity(this.animationPause, !1), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, !1, !0);
                            break;

                          default:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPrev, !1), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !1), PulseAnimator.setControlVisiblity(this.animationPause, !1), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, !1, !0);
                        }
                    }, PulseAnimator.prototype.show = function() {
                        this.container.style("display", "inline");
                    }, PulseAnimator.prototype.setRunnerCounterValue = function(index) {
                        var dataPoint = this.chart.data && this.chart.data.series && this.chart.data.series[this.position.series] && this.chart.data.series[this.position.series].data && this.chart.data.series[this.position.series].data[$.isNumeric(index) ? index : this.flooredPosition.index], runnerCounterValue = dataPoint && null != dataPoint.runnerCounterValue ? dataPoint.runnerCounterValue : "";
                        if (dataPoint && dataPoint.runnerCounterFormatString) {
                            var runnerCounterformatter = visuals.valueFormatter.create({
                                format: dataPoint.runnerCounterFormatString
                            });
                            runnerCounterValue = runnerCounterformatter.format(runnerCounterValue);
                        }
                        this.runnerCounterValue = this.chart.data.settings.runnerCounter.label + " " + runnerCounterValue, 
                        this.drawCounterValue();
                    }, PulseAnimator.prototype.drawCounterValue = function() {
                        var progressText = "" + this.runnerCounterValue;
                        this.runnerCounterText.text(progressText), TextMeasurementService.svgEllipsis(this.runnerCounterText.node(), this.maxTextWidthOfRunnerCounterValue);
                    }, PulseAnimator.prototype.play = function(delay, renderDuringPlaying) {
                        if (void 0 === delay && (delay = 0), void 0 === renderDuringPlaying && (renderDuringPlaying = !1), 
                        this.animatorState !== PulseAnimatorStates.Play || renderDuringPlaying) {
                            if (this.animatorState === PulseAnimatorStates.Ready && (this.animationPlayingIndex++, 
                            this.chart.clearChart()), this.chart.isAnimationIndexLast(this.position)) return void this.playNext();
                            this.animatorState === PulseAnimatorStates.Paused && this.chart.clearSelection(), 
                            this.animatorState = PulseAnimatorStates.Play, this.chart.renderChart(), this.chart.playAnimation(delay), 
                            this.disableControls();
                        }
                    }, PulseAnimator.prototype.playNext = function() {
                        this.pause(), this.chart.isAnimationSeriesLast(this.position) ? (this.setDefaultValues(), 
                        this.chart.clearSelection()) : (this.position = {
                            series: this.position.series + 1,
                            index: PulseAnimator.AnimationMinPosition.index
                        }, this.play());
                    }, PulseAnimator.prototype.pause = function() {
                        this.animatorState === PulseAnimatorStates.Play && (this.animatorState = PulseAnimatorStates.Paused, 
                        this.chart.pauseAnimation()), this.disableControls();
                    }, PulseAnimator.prototype.reset = function() {
                        this.clearTimeouts(), this.chart.stopAnimation(), this.chart.clearSelection(), this.chart.clearChart(), 
                        this.setDefaultValues(), this.animatorState = PulseAnimatorStates.Stopped, this.disableControls(), 
                        this.savedPosition = null;
                    }, PulseAnimator.prototype.next = function() {
                        if (this.isAnimated) {
                            this.stop();
                            var newPosition = this.chart.findNextPoint(this.position);
                            newPosition ? (this.position = newPosition, this.chart.renderChart()) : this.toEnd();
                        }
                    }, PulseAnimator.prototype.prev = function() {
                        if (this.isAnimated) {
                            this.stop();
                            var newPosition = this.chart.findPrevPoint(this.position);
                            newPosition ? (this.chart.clearRedundant(newPosition), this.position = newPosition, 
                            this.chart.renderChart()) : this.reset();
                        }
                    }, PulseAnimator.prototype.toEnd = function() {
                        this.savedPosition = null, this.chart.stopAnimation(), this.chart.clearSelection(), 
                        this.chart.clearChart(), this.setDefaultValues(), this.disableControls(), this.chart.renderChart();
                    }, PulseAnimator.prototype.stop = function() {
                        this.isAnimated && (this.drawCounterValue(), this.savedPosition = this.position, 
                        this.chart.stopAnimation(), this.animatorState = PulseAnimatorStates.Stopped, this.disableControls());
                    }, Object.defineProperty(PulseAnimator.prototype, "position", {
                        get: function() {
                            return this.positionValue;
                        },
                        set: function(position) {
                            this.positionValue = position;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "flooredPosition", {
                        get: function() {
                            return this.position && {
                                series: this.position.series,
                                index: Math.floor(this.position.index)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "savedPosition", {
                        get: function() {
                            return this.chart.data && this.chart.data.settings && this.chart.data.settings.playback && this.chart.data.settings.playback.position;
                        },
                        set: function(position) {
                            this.chart.isAutoPlay || (position = null), this.chart.data && this.chart.data.settings && this.chart.data.settings.playback && (this.isPositionWasSaved = !0, 
                            this.chart.data && this.chart.data.settings && this.chart.data.settings.playback && (this.chart.data.settings.playback.position = position), 
                            this.chart.host.persistProperties({
                                merge: [ {
                                    objectName: "playback",
                                    selector: null,
                                    properties: {
                                        position: position && JSON.stringify(position) || ""
                                    }
                                } ]
                            }));
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseAnimator.prototype.clear = function() {
                        this.isAnimated && this.chart.stopAnimation(), this.setDefaultValues(), this.container.style("display", "none");
                    }, PulseAnimator.prototype.clearTimeouts = function() {
                        clearTimeout(this.chart.handleSelectionTimeout);
                    }, PulseAnimator.AnimationPlay = createClassAndSelector("animationPlay"), PulseAnimator.AnimationPause = createClassAndSelector("animationPause"), 
                    PulseAnimator.AnimationReset = createClassAndSelector("animationReset"), PulseAnimator.AnimationToEnd = createClassAndSelector("animationToEnd"), 
                    PulseAnimator.AnimationPrev = createClassAndSelector("animationPrev"), PulseAnimator.AnimationNext = createClassAndSelector("animationNext"), 
                    PulseAnimator.RunnerCounter = createClassAndSelector("runnerCounter"), PulseAnimator.DimmedOpacity = .25, 
                    PulseAnimator.DefaultOpacity = 1, PulseAnimator.DefaultControlsColor = "#777", PulseAnimator;
                }();
                samples.PulseAnimator = PulseAnimator;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, LineDotChart = function() {
                    function LineDotChart() {
                        this.margin = {
                            top: 10,
                            right: 30,
                            bottom: 10,
                            left: 10
                        }, this.LegendSize = 50, this.AxisSize = 30;
                    }
                    return LineDotChart.prototype.init = function(options) {
                        var _this = this;
                        this.hostServices = options.host, this.selectionManager = new SelectionManager({
                            hostServices: this.hostServices
                        }), this.root = d3.select(options.element.get(0)).append("svg").classed(LineDotChart.Identity["class"], !0), 
                        this.root.on("click", function(d) {
                            _this.clearSelection();
                        }), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(LineDotChart.Axes["class"], !0), 
                        this.axisX = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), this.axisY = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), 
                        this.axisY2 = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), this.legends = this.main.append("g").classed(LineDotChart.Legends["class"], !0), 
                        this.line = this.main.append("g").classed(LineDotChart.Values["class"], !0), this.colors = options.style && options.style.colorPalette ? options.style.colorPalette.dataColors : new visuals.DataColorPalette();
                    }, LineDotChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var viewport = options.viewport, model = this.model = this.converter(options.dataViews[0], viewport);
                            this.clearSelection(), this.resize(viewport), this.draw(model);
                        }
                    }, LineDotChart.prototype.destroy = function() {
                        this.root = null;
                    }, LineDotChart.prototype.setIsStopped = function(isstopped) {
                        var objects = {
                            merge: [ {
                                objectName: "misc",
                                selector: void 0,
                                properties: {
                                    isstopped: isstopped
                                }
                            } ]
                        };
                        this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                            data: []
                        });
                    }, LineDotChart.prototype.enumerateObjectInstances = function(options) {
                        var instances = [];
                        if (!this.model || !this.model.settings) return instances;
                        var settings = this.model.settings;
                        switch (options.objectName) {
                          case "lineoptions":
                            var lineoptions = {
                                objectName: "lineoptions",
                                displayName: "lineoptions",
                                selector: null,
                                properties: {
                                    fill: settings.lineFill,
                                    lineThickness: settings.lineThickness
                                }
                            };
                            instances.push(lineoptions);
                            break;

                          case "dotoptions":
                            var dotoptions = {
                                objectName: "dotoptions",
                                displayName: "dotoptions",
                                selector: null,
                                properties: {
                                    color: settings.dotFill,
                                    dotSizeMin: settings.dotSizeMin,
                                    dotSizeMax: settings.dotSizeMax
                                }
                            };
                            instances.push(dotoptions);
                            break;

                          case "counteroptions":
                            var counteroptions = {
                                objectName: "counteroptions",
                                displayName: "counteroptions",
                                selector: null,
                                properties: {
                                    counterTitle: settings.counterTitle
                                }
                            };
                            instances.push(counteroptions);
                            break;

                          case "misc":
                            var misc = {
                                objectName: "misc",
                                displayName: "misc",
                                selector: null,
                                properties: {
                                    isanimated: settings.isanimated,
                                    isstopped: settings.isstopped,
                                    duration: settings.duration
                                }
                            };
                            instances.push(misc);
                        }
                        return instances;
                    }, LineDotChart.prototype.selectDot = function(dotelement, selector) {
                        var dot = d3.select(dotelement);
                        dot.classed("point_selected") ? this.clearSelection() : (selector && this.selectionManager.select(selector), 
                        this.root.classed("filtered", !0), this.line.selectAll("circle.point").classed("point_selected", !1), 
                        d3.select(dotelement).classed("point_selected", !0)), d3.event.stopPropagation();
                    }, LineDotChart.prototype.clearSelection = function() {
                        this.root.classed("filtered", !1), this.root.selectAll("circle.point").classed("point_selected", !1), 
                        this.selectionManager.clear();
                    }, LineDotChart.prototype.converter = function(dataView, viewport) {
                        if (!(dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0 && dataView.categorical && dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && dataView.categorical.values[0].values.length > 0)) return null;
                        var metadataColumn, extent, min, max, values = [], that = this, categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, !0);
                        this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                        var formatter, isScalar = !0, settings = this.parseSettings(dataView), effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize), effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize), format = "";
                        values = dataView.categorical.categories[0].values, metadataColumn = dataView.categorical.categories[0].source, 
                        extent = d3.extent(values), this.isDateTime ? (min = extent[0].getTime(), max = extent[1].getTime(), 
                        min = new Date(min), max = new Date(max + .05 * (max - min)), format = "MMM dd yyyy", 
                        formatter = visuals.valueFormatter.create({
                            format: format
                        })) : (min = extent[0], max = extent[1], max += .05 * (max - min), formatter = visuals.valueFormatter.create({
                            value: 0
                        }));
                        var xAxis = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveWidth,
                            dataDomain: [ min, max ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !0,
                            isScalar: isScalar,
                            isVertical: !1,
                            forcedTickCount: void 0,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: function(index, type) {
                                return that.isDateTime ? formatter.format(new Date(index)) : index;
                            }
                        });
                        xAxis.formatter = formatter, metadataColumn = dataView.categorical.values[0].source, 
                        values = dataView.categorical.values[0].values, extent = d3.extent(values), min = extent[0], 
                        max = extent[1];
                        for (var selector, result = [], value_sum = 0, value = 0, time = 0, i = 0; i < dataView.categorical.categories[0].values.length; i++) value = dataView.categorical.values[0].values[i], 
                        time = dataView.categorical.categories[0].values[i], value_sum += value, selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]), 
                        result.push({
                            dot: (value - min) / (max - min),
                            value: value,
                            sum: value_sum,
                            time: time,
                            selector: selector
                        });
                        value_sum += .1 * (value_sum - min);
                        var yAxis = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveHeight,
                            dataDomain: [ min, value_sum ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !1,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0
                        }), yAxis2 = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveHeight,
                            dataDomain: [ min, value_sum ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !1,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0
                        });
                        return yAxis2.axis.orient("right"), {
                            points: result,
                            settings: settings,
                            xAxis: xAxis,
                            yAxis: yAxis,
                            yAxis2: yAxis2,
                            legends: this.generateAxisLabels(viewport, settings)
                        };
                    }, LineDotChart.prototype.parseSettings = function(dataView) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var objects = dataView.metadata.objects, lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill), dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill), xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle, yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;
                        dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.categories[0].source.displayName && dataView.categorical.values[0] && dataView.categorical.values[0].source && dataView.categorical.values[0].source.displayName && (xAxisTitle = dataView.categorical.categories[0].source.displayName, 
                        yAxisTitle = dataView.categorical.values[0].source.displayName);
                        var lineThickness = LineDotChart.DefaultSettings.lineThickness, dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin, dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax, counterTitle = LineDotChart.DefaultSettings.counterTitle, isanimated = LineDotChart.DefaultSettings.isanimated, isstopped = LineDotChart.DefaultSettings.isstopped, duration = LineDotChart.DefaultSettings.duration;
                        return objects && (lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness), 
                        dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin), 
                        dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax), 
                        counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle), 
                        isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated), 
                        isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped), 
                        duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration)), 
                        {
                            xAxisTitle: xAxisTitle,
                            yAxisTitle: yAxisTitle,
                            lineFill: lineFillColorHelper.getColorForMeasure(objects, ""),
                            lineThickness: lineThickness,
                            dotFill: dotFillColorHelper.getColorForMeasure(objects, ""),
                            dotSizeMin: dotSizeMin,
                            dotSizeMax: dotSizeMax,
                            counterTitle: counterTitle,
                            isstopped: isstopped,
                            isanimated: isanimated,
                            duration: duration
                        };
                    }, LineDotChart.prototype.generateAxisLabels = function(viewport, settings) {
                        return [ {
                            transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, viewport.height - this.margin.top - this.margin.bottom),
                            text: settings.xAxisTitle,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),
                            text: settings.yAxisTitle,
                            dx: "3em"
                        } ];
                    }, LineDotChart.prototype.resize = function(viewport) {
                        this.root.attr({
                            height: Math.max(0, viewport.height),
                            width: Math.max(0, viewport.width)
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.legends.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.line.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                        this.axes.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize)), 
                        this.axisY2.attr("transform", visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));
                    }, LineDotChart.prototype.draw = function(model) {
                        var _this = this, that = this;
                        if (this.line.selectAll("*").remove(), this.legends.selectAll("*").remove(), this.axisX.selectAll("*").remove(), 
                        this.axisY.selectAll("*").remove(), this.axisY2.selectAll("*").remove(), model && (this.renderLegends(model), 
                        model && model.points && model.points.length)) {
                            if (this.axisX.call(model.xAxis.axis), this.axisY.call(model.yAxis.axis), this.axisY2.call(model.yAxis2.axis), 
                            model.settings.isanimated) {
                                var playBtn = this.line.append("g").classed("lineDotChart__playBtn", !0).attr("transform", "translate(40, 20)");
                                if (playBtn.append("circle").attr("r", 17), model.settings.isstopped) return playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform", "translate(-4,-8)"), 
                                void playBtn.on("click.lineDotChart__playBt", function() {
                                    that.setIsStopped(!1);
                                });
                                playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform-origin", "center").attr("transform", "translate(6, 8) rotate(180)"), 
                                playBtn.append("rect").attr("width", "2").attr("height", "12").attr("transform", "translate(-7,-6)"), 
                                playBtn.on("click.lineDotChart__playBt", function() {
                                    that.setIsStopped(!0);
                                });
                            }
                            var clip = this.line.append("clipPath").attr("id", "lineClip").append("rect").attr("x", 0).attr("y", 0).attr("width", 1).attr("height", 1e4), line = d3.svg.line().x(function(d) {
                                return model.xAxis.scale(d.time);
                            }).y(function(d) {
                                return model.yAxis.scale(d.sum);
                            }), lineSelection = this.line.selectAll("path.plot").data([ model.points ]);
                            lineSelection.enter().append("path"), lineSelection.classed("plot", !0).attr("stroke", function(d, i) {
                                return model.settings.lineFill;
                            }).attr("stroke-width", model.settings.lineThickness).attr("d", line);
                            var totalLength = lineSelection.node().getTotalLength(), line_left = lineSelection.node().getPointAtLength(0).x, line_right = lineSelection.node().getPointAtLength(totalLength).x;
                            lineSelection.attr("clip-path", "url(" + location.href + "#lineClip)"), model.settings.isanimated ? clip.attr("x", line_left).interrupt().transition().ease("linear").duration(1e3 * model.settings.duration).attr("width", line_right - line_left) : clip.interrupt().attr("x", line_left).attr("width", line_right - line_left), 
                            lineSelection.exit().remove();
                            var point_time = 300, counter_time = 0, lineTipSelection = this.line.selectAll("circle.point").data(model.points), that = this;
                            lineTipSelection.enter().append("circle").attr("fill", model.settings.dotFill).attr("opacity", .77).attr("r", function(d) {
                                return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin);
                            }).classed("point", !0).on("mouseover.point", this.showDataPoint).on("mouseout.point", this.hideDataPoint).on("click.point", function(d) {
                                that.selectDot(this, d.selector);
                            }), model.settings.isanimated ? lineTipSelection.interrupt().attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(0.005)";
                            }).transition().duration(point_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration);
                            }).ease("linear").attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(3.4)";
                            }).transition().duration(point_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration) + point_time;
                            }).ease("elastic").attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                            }) : lineTipSelection.interrupt().attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                            }), lineTipSelection.exit().remove();
                            for (var i = 0; i < lineTipSelection[0].length; i++) this.addTooltip(model, lineTipSelection[0][i]);
                            var lineTextSelection = this.line.selectAll("text").data(model.points);
                            lineTextSelection.enter().append("text").classed("text", !0).text(function(d, i) {
                                return model.settings.counterTitle + " " + (i + 1);
                            }).attr("x", line_right - 260).attr("y", 30), model.settings.isanimated ? lineTextSelection.attr("opacity", 0).interrupt().transition().duration(counter_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration);
                            }).attr("transform", "translate(0 0)").attr("opacity", 1).transition().duration(counter_time).delay(function(d, i) {
                                return model.points[i + 1] ? _this.pointDelay(model.points, i + 1, model.settings.duration) : Number.POSITIVE_INFINITY;
                            }).attr("opacity", 0) : lineTextSelection.interrupt().attr("transform", "translate(0 0)").attr("opacity", function(d, i) {
                                return Number(i === model.points.length - 1);
                            }), lineTextSelection.exit().remove();
                        }
                    }, LineDotChart.prototype.pointDelay = function(points, num, animation_duration) {
                        if (!points.length || !points[num] || 0 === num) return 0;
                        if (this.isDateTime) var time = points[num].time, min = points[0].time.getTime(), max = points[points.length - 1].time.getTime(), val = time.getTime(); else var time = points[num].time, min = points[0].time, max = points[points.length - 1].time, val = time;
                        return 1e3 * animation_duration * (val - min) / (max - min);
                    }, LineDotChart.prototype.showDataPoint = function(data, index) {
                        d3.select(this).classed("show", !0);
                    }, LineDotChart.prototype.hideDataPoint = function(data, index) {
                        d3.select(this).classed("show", !1);
                    }, LineDotChart.prototype.addTooltip = function(model, element) {
                        var selection = d3.select(element), data = selection.datum();
                        visuals.TooltipManager.addTooltip(selection, function(event) {
                            return [ {
                                displayName: model.settings.xAxisTitle,
                                value: model.xAxis.formatter.format(data.time)
                            }, {
                                displayName: model.settings.yAxisTitle,
                                value: data.value.toString()
                            } ];
                        });
                    }, LineDotChart.prototype.renderLegends = function(model) {
                        var legendSelection = this.legends.selectAll(LineDotChart.Legend.selector).data(model.legends);
                        legendSelection.enter().append("svg:text"), legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                            return item.dx;
                        }).attr("dy", function(item) {
                            return item.dy;
                        }).attr("transform", function(item) {
                            return item.transform;
                        }).text(function(item) {
                            return item.text;
                        }).classed(LineDotChart.Legend["class"], !0), legendSelection.exit().remove();
                    }, LineDotChart.DefaultSettings = {
                        lineFill: "rgb(102, 212, 204)",
                        lineThickness: 3,
                        dotFill: "#005c55",
                        dotSizeMin: 4,
                        dotSizeMax: 38,
                        counterTitle: "Total features",
                        xAxisTitle: "",
                        yAxisTitle: "",
                        duration: 20,
                        isanimated: !0,
                        isstopped: !0
                    }, LineDotChart.capabilities = {
                        dataRoles: [ {
                            name: "Date",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Date"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Date: {
                                    min: 0,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                },
                                Labels: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Date"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": "Values"
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            lineoptions: {
                                displayName: "Line",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    lineThickness: {
                                        displayName: "Thickness",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            dotoptions: {
                                displayName: "Dot",
                                properties: {
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    dotSizeMin: {
                                        displayName: "Min size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    dotSizeMax: {
                                        displayName: "Min size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            counteroptions: {
                                displayName: "Counter",
                                properties: {
                                    counterTitle: {
                                        displayName: "Title",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            misc: {
                                displayName: "Animation",
                                properties: {
                                    isanimated: {
                                        displayName: "Animated",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isstopped: {
                                        displayName: "Stop on load",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    duration: {
                                        displayName: "Time",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, LineDotChart.Identity = {
                        "class": "lineDotChart",
                        selector: ".lineDotChart"
                    }, LineDotChart.Axes = {
                        "class": "axes",
                        selector: ".axes"
                    }, LineDotChart.Axis = {
                        "class": "axis",
                        selector: ".axis"
                    }, LineDotChart.Legends = {
                        "class": "legends",
                        selector: ".legends"
                    }, LineDotChart.Legend = {
                        "class": "legend",
                        selector: ".legend"
                    }, LineDotChart.Values = {
                        "class": "line",
                        selector: ".line"
                    }, LineDotChart.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        lineoptions: {
                            fill: {
                                objectName: "lineoptions",
                                propertyName: "fill"
                            },
                            lineThickness: {
                                objectName: "lineoptions",
                                propertyName: "lineThickness"
                            }
                        },
                        dotoptions: {
                            color: {
                                objectName: "dotoptions",
                                propertyName: "color"
                            },
                            dotSizeMin: {
                                objectName: "dotoptions",
                                propertyName: "dotSizeMin"
                            },
                            dotSizeMax: {
                                objectName: "dotoptions",
                                propertyName: "dotSizeMax"
                            }
                        },
                        counteroptions: {
                            counterTitle: {
                                objectName: "counteroptions",
                                propertyName: "counterTitle"
                            }
                        },
                        misc: {
                            isanimated: {
                                objectName: "misc",
                                propertyName: "isanimated"
                            },
                            isstopped: {
                                objectName: "misc",
                                propertyName: "isstopped"
                            },
                            duration: {
                                objectName: "misc",
                                propertyName: "duration"
                            }
                        }
                    }, LineDotChart;
                }();
                samples.LineDotChart = LineDotChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager;
                samples.sunburstRoleNames = {
                    nodes: "Nodes",
                    values: "Values"
                };
                var Sunburst = function() {
                    function Sunburst() {
                        this.total = 0;
                    }
                    return Sunburst.prototype.init = function(options) {
                        var _this = this;
                        this.arc = d3.svg.arc().startAngle(function(d) {
                            return d.x;
                        }).endAngle(function(d) {
                            return d.x + d.dx;
                        }).innerRadius(function(d) {
                            return Math.sqrt(d.y);
                        }).outerRadius(function(d) {
                            return Math.sqrt(d.y + d.dy);
                        }), this.colors = options.style.colorPalette.dataColors, this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.svg = d3.select(options.element.get(0)).append("svg"), this.svg.classed("mainDrawArea", !0), 
                        this.g = this.svg.append("g"), this.g.classed("container", !0), this.svg.append("text").classed("sunBurstPercentageFixed", !0), 
                        this.svg.on("mousedown", function(d) {
                            _this.svg.selectAll("path").style("opacity", 1), _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0), 
                            _this.selectionManager.clear();
                        });
                    }, Sunburst.setAllUnhide = function(selection) {
                        selection.attr("setUnHide", "true");
                    }, Sunburst.prototype.update = function(options) {
                        if (options.dataViews.length > 0) {
                            var data = this.converter(options.dataViews[0], this.colors);
                            this.viewport = options.viewport, this.updateInternal(data);
                        }
                    }, Sunburst.prototype.updateInternal = function(dataRootNode) {
                        var _this = this;
                        this.svg.attr({
                            height: this.viewport.height,
                            width: this.viewport.width
                        }), this.g.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                        var radius = Math.min(this.viewport.width, this.viewport.height) / 2, partition = d3.layout.partition().size([ 2 * Math.PI, radius * radius ]).value(function(d) {
                            return d.value;
                        }), path = this.g.datum(dataRootNode).selectAll("path").data(partition.nodes);
                        path.enter().append("path"), path.attr("display", function(d) {
                            return d.depth ? null : "none";
                        }).attr("d", this.arc).style("stroke", "#fff").style("fill", function(d) {
                            return d.color;
                        }).style("fill-rule", "evenodd").on("mousedown", function(d) {
                            d.selector && _this.selectionManager.select(d.selector), d3.selectAll("path").call(Sunburst.setAllUnhide).attr("setUnHide", null), 
                            _this.highlightPath(d, _this, !0);
                            var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed"), percentage = 0 === _this.total ? 0 : (100 * d.total / _this.total).toPrecision(3);
                            percentageFixedText.text(d ? percentage + "%" : ""), percentageFixedText.style("fill", d.color), 
                            _this.onResize(), event.stopPropagation();
                        }), this.renderTooltip(path), path.exit().remove(), this.onResize();
                    }, Sunburst.getTreePath = function(node) {
                        for (var path = [], current = node; current.parent; ) path.unshift(current), current = current.parent;
                        return path;
                    }, Sunburst.prototype.onResize = function() {
                        var width = this.viewport.width, height = this.viewport.height, percentageFixedText = this.svg.select(".sunBurstPercentageFixed"), textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
                        percentageFixedText.style("opacity", 1), percentageFixedText.attr("y", height / 2 + 4), 
                        percentageFixedText.attr("x", width / 2 - textWidth / 2);
                    }, Sunburst.prototype.highlightPath = function(d, sunBurst, setUnhide) {
                        var parentsArray = d ? Sunburst.getTreePath(d) : [];
                        sunBurst.svg.selectAll("path").each(function() {
                            "true" !== d3.select(this).attr("setUnHide") && d3.select(this).style("opacity", Sunburst.minOpacity);
                        }), sunBurst.svg.selectAll("path").filter(function(node) {
                            return parentsArray.indexOf(node) >= 0;
                        }).each(function() {
                            d3.select(this).style("opacity", 1), setUnhide === !0 && d3.select(this).attr("setUnHide", "true");
                        });
                    }, Sunburst.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, Sunburst.getTooltipData = function(displayName, value) {
                        return [ {
                            displayName: displayName,
                            value: 0 > value ? "" : value.toString()
                        } ];
                    }, Sunburst.prototype.covertTreeNodeToSunBurstNode = function(originParentNode, sunburstParentNode, colors, pathIdentity, color) {
                        var selector;
                        originParentNode.identity && (pathIdentity = pathIdentity.concat([ originParentNode.identity ]), 
                        selector = {
                            data: pathIdentity
                        });
                        var selectionId = 0 === pathIdentity.length ? null : new visuals.SelectionId(selector, !1), valueToSet = originParentNode.values ? originParentNode.values[0].value : 0, newSunNode = {
                            name: originParentNode.name,
                            value: Math.max(valueToSet, 0),
                            selector: selectionId,
                            total: valueToSet
                        };
                        if (originParentNode.value && (newSunNode.color = color ? color : colors.getColor(originParentNode.value).value), 
                        this.total += newSunNode.value, originParentNode.children && originParentNode.children.length > 0) {
                            newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1), newSunNode.children = [];
                            for (var i = 0; i < originParentNode.children.length; i++) {
                                var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
                                newSunNode.children.push(newChild), newSunNode.total += newChild.total;
                            }
                        } else newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
                        return sunburstParentNode && (newSunNode.parent = sunburstParentNode), newSunNode;
                    }, Sunburst.prototype.converter = function(dataView, colors) {
                        var colorScale = colors.getNewColorScale();
                        this.total = 0;
                        var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], void 0);
                        return root;
                    }, Sunburst.minOpacity = .2, Sunburst.roleNames = {
                        nodes: "Nodes",
                        values: "Values"
                    }, Sunburst.capabilities = {
                        dataRoles: [ {
                            name: Sunburst.roleNames.nodes,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Groups"
                        }, {
                            name: Sunburst.roleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Groups: {
                                    min: 0
                                },
                                Values: {
                                    max: 1
                                }
                            } ],
                            matrix: {
                                rows: {
                                    "for": {
                                        "in": Sunburst.roleNames.nodes
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": Sunburst.roleNames.values
                                    }
                                }
                            }
                        } ]
                    }, Sunburst;
                }();
                samples.Sunburst = Sunburst;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var plugins;
            !function(plugins) {
                plugins.sunburstCustom = {
                    name: "sunburstCustom",
                    watermarkKey: "defaultWatermark",
                    capabilities: visuals.samples.Sunburst.capabilities,
                    create: function() {
                        return new visuals.samples.Sunburst();
                    }
                }, plugins.asterPlot = {
                    name: "asterPlot",
                    capabilities: visuals.samples.AsterPlot.capabilities,
                    create: function() {
                        return new visuals.samples.AsterPlot();
                    }
                }, plugins.tornadoChart = {
                    name: "tornadoChart",
                    capabilities: visuals.samples.TornadoChart.capabilities,
                    create: function() {
                        return new visuals.samples.TornadoChart();
                    }
                }, plugins.sankeyDiagram = {
                    name: "sankeyDiagram",
                    capabilities: visuals.samples.SankeyDiagram.capabilities,
                    create: function() {
                        return new visuals.samples.SankeyDiagram();
                    }
                }, plugins.mekkoChart = {
                    name: "mekkoChart",
                    watermarkKey: "mekko",
                    capabilities: visuals.samples.MekkoChart.capabilities,
                    create: function() {
                        return new visuals.samples.MekkoChart({
                            chartType: 0
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    }
                }, plugins.bulletChart = {
                    name: "bulletChart",
                    capabilities: visuals.samples.BulletChart.capabilities,
                    create: function() {
                        return new visuals.samples.BulletChart();
                    }
                }, plugins.wordCloud = {
                    name: "wordCloud",
                    capabilities: visuals.samples.WordCloud.capabilities,
                    create: function() {
                        return new visuals.samples.WordCloud();
                    }
                }, plugins.chicletSlicer = {
                    name: "chicletSlicer",
                    capabilities: visuals.samples.ChicletSlicer.capabilities,
                    create: function() {
                        return new visuals.samples.ChicletSlicer();
                    }
                }, plugins.chordChart = {
                    name: "chordChart",
                    capabilities: visuals.samples.ChordChart.capabilities,
                    create: function() {
                        return new visuals.samples.ChordChart();
                    }
                }, plugins.enhancedScatterChart = {
                    name: "enhancedScatterChart",
                    capabilities: visuals.samples.EnhancedScatterChart.capabilities,
                    create: function() {
                        return new visuals.samples.EnhancedScatterChart();
                    }
                }, plugins.radarChart = {
                    name: "radarChart",
                    capabilities: visuals.samples.RadarChart.capabilities,
                    create: function() {
                        return new visuals.samples.RadarChart();
                    }
                }, plugins.dotPlot = {
                    name: "dotPlot",
                    capabilities: visuals.samples.DotPlot.capabilities,
                    create: function() {
                        return new visuals.samples.DotPlot();
                    }
                }, plugins.histogram = {
                    name: "histogram",
                    capabilities: visuals.samples.Histogram.capabilities,
                    create: function() {
                        return new visuals.samples.Histogram();
                    }
                }, plugins.timeline = {
                    name: "timeline",
                    capabilities: visuals.samples.Timeline.capabilities,
                    create: function() {
                        return new visuals.samples.Timeline();
                    }
                }, plugins.forceGraph = {
                    name: "forceGraph",
                    capabilities: visuals.samples.ForceGraph.capabilities,
                    create: function() {
                        return new visuals.samples.ForceGraph();
                    }
                }, plugins.gantt = {
                    name: "gantt",
                    capabilities: visuals.samples.Gantt.capabilities,
                    create: function() {
                        return new visuals.samples.Gantt();
                    }
                }, plugins.streamGraph = {
                    name: "streamGraph",
                    capabilities: visuals.samples.StreamGraph.capabilities,
                    create: function() {
                        return new visuals.samples.StreamGraph();
                    }
                }, plugins.pulseChart = {
                    name: "pulseChart",
                    capabilities: visuals.samples.PulseChart.capabilities,
                    create: function() {
                        return new visuals.samples.PulseChart();
                    }
                }, plugins.lineDotChart = {
                    name: "lineDotChart",
                    capabilities: visuals.samples.LineDotChart.capabilities,
                    create: function() {
                        return new visuals.samples.LineDotChart();
                    }
                };
            }(plugins = visuals.plugins || (visuals.plugins = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
} ]);