function loadGlobeMapLibs() {}

var __extends = this && this.__extends || function(d, b) {
    function __() {
        this.constructor = d;
    }
    for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
}, powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, ValueFormatter = powerbi.visuals.valueFormatter, AsterPlotVisualClassName = "asterPlot", AsterPlotLegendObjectName = "legend", AsterDefaultOuterLineThickness = 1, AsterDefaultLabelFill = {
                solid: {
                    color: "#333"
                }
            }, AsterDefaultLegendFontSize = 8, AsterRadiusRatio = .9, AsterConflictRatio = .9, MaxPrecision = 17, AsterPlotWebBehavior = function() {
                function AsterPlotWebBehavior() {}
                return AsterPlotWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.selection = options.selection, this.highlightedSelection = options.highlightedSelection, 
                    this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                    this.selection.on("click", function(d, i) {
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    }), this.highlightedSelection && this.highlightedSelection.on("click", function(d, i) {
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    }), this.clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, AsterPlotWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var hasHighlights = this.interactivityService.hasSelection();
                    this.selection.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, !d.data.highlight && hasSelection, !d.data.selected && hasHighlights);
                    });
                }, AsterPlotWebBehavior;
            }(), AsterPlotWarning = function() {
                function AsterPlotWarning(message) {
                    this.message = message;
                }
                return Object.defineProperty(AsterPlotWarning.prototype, "code", {
                    get: function() {
                        return "AsterPlotWarning";
                    },
                    enumerable: !0,
                    configurable: !0
                }), AsterPlotWarning.prototype.getMessages = function(resourceProvider) {
                    return {
                        message: this.message,
                        title: resourceProvider.get(""),
                        detail: resourceProvider.get("")
                    };
                }, AsterPlotWarning;
            }();
            samples.AsterPlotWarning = AsterPlotWarning;
            var AsterPlot = function() {
                function AsterPlot() {
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 15,
                        left: 10
                    };
                }
                return AsterPlot.prototype.getDefaultAsterData = function() {
                    return {
                        dataPoints: [],
                        highlightedDataPoints: [],
                        legendData: {
                            dataPoints: [],
                            title: null,
                            fontSize: AsterDefaultLegendFontSize,
                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor
                        },
                        legendSettings: {
                            show: !1,
                            position: "Top",
                            showTitle: !0,
                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                            titleText: "",
                            fontSize: AsterDefaultLegendFontSize
                        },
                        valueFormatter: null,
                        labelSettings: {
                            show: !1,
                            displayUnits: 0,
                            precision: visuals.dataLabelUtils.defaultLabelPrecision,
                            labelColor: visuals.dataLabelUtils.defaultLabelColor,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt
                        },
                        showOuterLine: !1,
                        outerLineThickness: AsterDefaultOuterLineThickness
                    };
                }, AsterPlot.prototype.converter = function(dataView, colors) {
                    var asterDataResult = this.getDefaultAsterData();
                    if (!this.dataViewContainsCategory(dataView) || 1 !== dataView.categorical.categories.length) return asterDataResult;
                    var catDv = dataView.categorical, cat = catDv.categories[0], catSource = cat.source, catValues = cat.values, values = catDv.values, catObjects = cat.objects, colorHelper = new visuals.ColorHelper(colors, AsterPlot.Properties.dataPoint.fill), hasHighlights = this.hasHighlights = !!(values && values.length > 0 && values[0].highlights);
                    if (dataView.metadata || dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        asterDataResult.labelSettings = this.getLabelSettings(objects, asterDataResult.labelSettings), 
                        this.updateLegendSettings(objects, catSource, asterDataResult.legendSettings), asterDataResult.showOuterLine = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.show, asterDataResult.showOuterLine), 
                        asterDataResult.outerLineThickness = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.thickness, AsterDefaultOuterLineThickness);
                    }
                    var labelSettings = asterDataResult.labelSettings;
                    if (!catValues || catValues.length < 1 || !values || values.length < 1) return asterDataResult;
                    for (var formatStringProp = AsterPlot.Properties.general.formatString, maxValue = Math.max(d3.min(values[0].values)), minValue = Math.min(0, d3.min(values[0].values)), labelFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(values[0].source, formatStringProp),
                        precision: labelSettings.precision,
                        value: 0 === labelSettings.displayUnits && null != maxValue ? maxValue : labelSettings.displayUnits
                    }), categorySourceFormatString = visuals.valueFormatter.getFormatString(catSource, formatStringProp), fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), i = 0; i < catValues.length; i++) {
                        var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString), currentValue = values[0].values[i], tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0);
                        if (values.length > 1) {
                            var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].values[i], null, null, 1)[1];
                            toolTip && tooltipInfo.push(toolTip), currentValue += values[1].values[i];
                        }
                        var identity = cat.identity[i], color = colorHelper.getColorForMeasure(catObjects && catObjects[i], identity.key), selector = visuals.SelectionId.createWithId(identity), sliceWidth = Math.max(0, values.length > 1 ? values[1].values[i] : 1);
                        if (asterDataResult.dataPoints.push({
                            sliceHeight: values[0].values[i] - minValue,
                            sliceWidth: sliceWidth,
                            label: labelFormatter.format(currentValue),
                            color: color,
                            identity: selector,
                            selected: !1,
                            tooltipInfo: tooltipInfo,
                            labelFontSize: fontSizeInPx,
                            highlight: !1
                        }), asterDataResult.legendSettings.show && asterDataResult.legendData.dataPoints.push({
                            label: catValues[i],
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            selected: !1,
                            identity: selector
                        }), hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(selector), notNull = null != values[0].highlights[i];
                            if (currentValue = notNull ? values[0].highlights[i] : 0, tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0), 
                            values.length > 1) {
                                var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].highlights[i], null, null, 1)[1];
                                toolTip && tooltipInfo.push(toolTip), currentValue += null !== values[1].highlights[i] ? values[1].highlights[i] : 0;
                            }
                            asterDataResult.highlightedDataPoints.push({
                                sliceHeight: notNull ? values[0].highlights[i] - minValue : null,
                                sliceWidth: Math.max(0, values.length > 1 && null !== values[1].highlights[i] ? values[1].highlights[i] : sliceWidth),
                                label: labelFormatter.format(currentValue),
                                color: color,
                                identity: highlightIdentity,
                                selected: !1,
                                tooltipInfo: tooltipInfo,
                                labelFontSize: fontSizeInPx,
                                highlight: !0
                            });
                        }
                    }
                    return asterDataResult;
                }, AsterPlot.prototype.dataViewContainsCategory = function(dataView) {
                    return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.categories && dataView.categorical.categories[0];
                }, AsterPlot.prototype.getLabelSettings = function(objects, labelSettings) {
                    var asterPlotLabelsProperties = AsterPlot.Properties, precision = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelPrecision, labelSettings.precision);
                    labelSettings.precision = void 0 === precision ? precision : Math.min(precision, MaxPrecision), 
                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.show, labelSettings.show), 
                    labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.fontSize, labelSettings.fontSize), 
                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelDisplayUnits, labelSettings.displayUnits);
                    var colorHelper = new visuals.ColorHelper(this.colors, asterPlotLabelsProperties.labels.color, labelSettings.labelColor);
                    return labelSettings.labelColor = colorHelper.getColorForMeasure(objects, ""), labelSettings;
                }, AsterPlot.prototype.updateLegendSettings = function(objects, catSource, legendSettings) {
                    var legendProperties = AsterPlot.Properties.legend;
                    legendSettings.show = powerbi.DataViewObjects.getValue(objects, legendProperties.show, legendSettings.show), 
                    legendSettings.position = powerbi.DataViewObjects.getValue(objects, legendProperties.position, legendSettings.position), 
                    legendSettings.showTitle = powerbi.DataViewObjects.getValue(objects, legendProperties.showTitle, legendSettings.showTitle);
                    var titleText = powerbi.DataViewObjects.getValue(objects, legendProperties.titleText, "");
                    legendSettings.titleText = _.isEmpty(titleText) && catSource ? catSource.displayName : titleText, 
                    legendSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, legendProperties.labelColor, legendSettings.labelColor), 
                    legendSettings.fontSize = powerbi.DataViewObjects.getValue(objects, legendProperties.fontSize, legendSettings.fontSize);
                }, AsterPlot.prototype.init = function(options) {
                    this.hostService = options.host;
                    var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(AsterPlotVisualClassName, !0).style("position", "absolute");
                    this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = svg.append("g"), 
                    this.mainLabelsElement = svg.append("g"), this.behavior = new AsterPlotWebBehavior(), 
                    this.clearCatcher = visuals.appendClearCatcher(this.mainGroupElement);
                    var interactivity = options.interactivity;
                    this.interactivityService = visuals.createInteractivityService(this.hostService), 
                    this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                }, AsterPlot.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                        this.currentViewport = {
                            height: Math.max(0, options.viewport.height),
                            width: Math.max(0, options.viewport.width)
                        };
                        var dataView = this.dataView = options.dataViews[0], convertedData = this.data = this.converter(dataView, this.colors);
                        if (!convertedData || !convertedData.dataPoints || 0 === convertedData.dataPoints.length) return void this.clearData();
                        this.interactivityService && (this.interactivityService.applySelectionStateToData(convertedData.dataPoints), 
                        this.interactivityService.applySelectionStateToData(convertedData.highlightedDataPoints)), 
                        this.renderLegend(convertedData), this.updateViewPortAccordingToLegend(), this.svg.attr({
                            height: Math.max(0, this.currentViewport.height),
                            width: Math.max(0, this.currentViewport.width)
                        });
                        var margin = this.margin, transformX = (this.currentViewport.width - margin.left) / 2, transformY = (this.currentViewport.height - margin.top) / 2;
                        this.mainGroupElement.attr("transform", visuals.SVGUtil.translate(transformX, transformY)), 
                        this.mainLabelsElement.attr("transform", visuals.SVGUtil.translate(transformX, transformY)), 
                        this.clearCatcher.attr("transform", visuals.SVGUtil.translate(-transformX, -transformY)), 
                        this.mainGroupElement.selectAll(AsterPlot.AsterSlice.selector).remove(), this.mainGroupElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove(), 
                        visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0);
                        var dataPoints = convertedData.dataPoints;
                        if (dataPoints && 0 !== dataPoints.length) {
                            var highlightedSelection, selection = this.renderArcsAndLabels(dataPoints, duration, convertedData.labelSettings);
                            this.hasHighlights && (highlightedSelection = this.renderArcsAndLabels(convertedData.highlightedDataPoints, duration, convertedData.labelSettings, !0));
                            var interactivityService = this.interactivityService;
                            if (interactivityService) {
                                var behaviorOptions = {
                                    selection: selection,
                                    highlightedSelection: highlightedSelection,
                                    clearCatcher: this.clearCatcher,
                                    interactivityService: this.interactivityService
                                };
                                interactivityService.bind(convertedData.dataPoints.concat(convertedData.highlightedDataPoints), this.behavior, behaviorOptions);
                            }
                        }
                    }
                }, AsterPlot.prototype.renderArcsAndLabels = function(dataPoints, duration, labelSettings, isHighlight) {
                    void 0 === isHighlight && (isHighlight = !1);
                    var margin = this.margin, width = this.currentViewport.width - margin.left - margin.right, height = this.currentViewport.height - margin.top - margin.bottom, radius = Math.min(width, height) / 2, innerRadius = .3 * (labelSettings.show ? radius * AsterRadiusRatio : radius), maxScore = d3.max(dataPoints, function(d) {
                        return d.sliceHeight;
                    }), totalWeight = d3.sum(dataPoints, function(d) {
                        return d.sliceWidth;
                    }), hasSelection = this.interactivityService && this.interactivityService.hasSelection(), hasHighlights = this.hasHighlights, pie = d3.layout.pie().sort(null).value(function(d) {
                        return (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight;
                    }), arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(function(d) {
                        var height = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore, heightIsLabelsOn = innerRadius + (labelSettings.show ? height * AsterRadiusRatio : height);
                        return Math.max(heightIsLabelsOn, innerRadius);
                    }), arcDescriptorDataPoints = pie(dataPoints), classSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice, selection = this.mainGroupElement.selectAll(classSelector.selector).data(arcDescriptorDataPoints, function(d, idx) {
                        return d.data ? d.data.identity.getKey() : idx;
                    });
                    if (selection.enter().append("path").attr("stroke", "#333").classed(classSelector["class"], !0), 
                    selection.attr("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, hasHighlights);
                    }).transition().duration(duration).attrTween("d", function(data) {
                        if (!this.oldData) return this.oldData = data, function() {
                            return arc(data);
                        };
                        var interpolation = d3.interpolate(this.oldData, data);
                        return this.oldData = interpolation(0), function(x) {
                            return arc(interpolation(x));
                        };
                    }), selection.exit().remove(), visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    }), labelSettings.show && (!hasHighlights || hasHighlights && isHighlight)) {
                        var labelRadCalc_1 = function(d) {
                            var height = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;
                            return Math.max(height, innerRadius);
                        }, labelArc = d3.svg.arc().innerRadius(function(d) {
                            return labelRadCalc_1(d.data);
                        }).outerRadius(function(d) {
                            return labelRadCalc_1(d.data);
                        }), lineRadCalc_1 = function(d) {
                            var height = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;
                            return height = innerRadius + height * AsterRadiusRatio, Math.max(height, innerRadius);
                        }, outlineArc = d3.svg.arc().innerRadius(function(d) {
                            return lineRadCalc_1(d.data);
                        }).outerRadius(function(d) {
                            return lineRadCalc_1(d.data);
                        }), layout = this.getLabelLayout(labelSettings, labelArc, this.currentViewport);
                        this.drawLabels(arcDescriptorDataPoints, this.mainLabelsElement, layout, this.currentViewport, outlineArc, labelArc);
                    } else visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0);
                    return isHighlight || (this.drawCenterText(innerRadius), this.drawOuterLine(innerRadius, radius, arcDescriptorDataPoints)), 
                    selection;
                }, AsterPlot.prototype.getLabelLayout = function(labelSettings, arc, viewport) {
                    var midAngle = function(d) {
                        return d.startAngle + (d.endAngle - d.startAngle) / 2;
                    }, textProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                        text: ""
                    }, isLabelsHasConflict = function(d) {
                        var pos = arc.centroid(d);
                        textProperties.text = d.data.label;
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties), verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);
                        return d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels, 
                        d.isLabelHasConflict;
                    };
                    return {
                        labelText: function(d) {
                            textProperties.text = d.data.label;
                            var pos = arc.centroid(d), xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0], spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
                        },
                        labelLayout: {
                            x: function(d) {
                                var pos = arc.centroid(d);
                                textProperties.text = d.data.label;
                                var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];
                                return xPos;
                            },
                            y: function(d) {
                                var pos = arc.centroid(d), yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];
                                return yPos;
                            }
                        },
                        filter: function(d) {
                            return null != d && !_.isEmpty(d.data.label);
                        },
                        style: {
                            fill: labelSettings.labelColor,
                            "font-size": textProperties.fontSize,
                            "text-anchor": function(d) {
                                return midAngle(d) < Math.PI ? "start" : "end";
                            }
                        }
                    };
                }, AsterPlot.prototype.drawLabels = function(data, context, layout, viewport, outlineArc, labelArc) {
                    var _this = this, dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, !0);
                    if (0 === filteredData.length) return void visuals.dataLabelUtils.cleanDataLabels(context, !0);
                    context.select(AsterPlot.labelGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.labelGraphicsContextClass["class"], !0);
                    var labels = context.select(AsterPlot.labelGraphicsContextClass.selector).selectAll(".data-labels").data(filteredData, function(d) {
                        return d.data.identity.getKey();
                    });
                    if (labels.enter().append("text").classed("data-labels", !0), labels) {
                        labels.attr({
                            x: function(d) {
                                return d.labelX;
                            },
                            y: function(d) {
                                return d.labelY;
                            },
                            dy: ".35em"
                        }).text(function(d) {
                            return d.labeltext;
                        }).style(layout.style), labels.exit().remove(), context.select(AsterPlot.linesGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.linesGraphicsContextClass["class"], !0), 
                        filteredData = _.filter(filteredData, function(d) {
                            return null !== d.data.sliceHeight && 0 !== d.data.sliceHeight;
                        });
                        var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll("polyline").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }), labelLinePadding = 4, chartLinePadding = 1.02, midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        };
                        lines.enter().append("polyline").classed("line-label", !0), lines.attr("points", function(d) {
                            var textPoint = [ d.labelX, d.labelY ];
                            textPoint[0] = textPoint[0] + (midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding;
                            var chartPoint = outlineArc.centroid(d);
                            return chartPoint[0] *= chartLinePadding, chartPoint[1] *= chartLinePadding, [ chartPoint, textPoint ];
                        }).style({
                            opacity: .5,
                            "fill-opacity": 0,
                            stroke: function(d) {
                                return _this.data.labelSettings.labelColor;
                            }
                        }), lines.exit().remove();
                    }
                }, AsterPlot.prototype.renderLegend = function(asterPlotData) {
                    if (asterPlotData && asterPlotData.legendData) {
                        var legendData = asterPlotData.legendData, objects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : null, legendObjectProperties = powerbi.DataViewObjects.getObject(objects, AsterPlotLegendObjectName, {});
                        if (legendObjectProperties) {
                            var legendSettings = asterPlotData.legendSettings;
                            legendObjectProperties.titleText = legendSettings.titleText, visuals.LegendData.update(legendData, legendObjectProperties), 
                            this.legend.changeOrientation(visuals.LegendPosition[legendSettings.position]);
                        }
                        this.legend.drawLegend(legendData, _.clone(this.currentViewport)), visuals.Legend.positionChartArea(this.svg, this.legend);
                    }
                }, AsterPlot.prototype.updateViewPortAccordingToLegend = function() {
                    var legendSettings = this.data.legendSettings;
                    if (legendSettings && legendSettings.show) {
                        var legendMargins = this.legend.getMargins(), legendPosition = visuals.LegendPosition[legendSettings.position];
                        switch (legendPosition) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.currentViewport.height -= legendMargins.height;
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.currentViewport.width -= legendMargins.width;
                        }
                    }
                }, AsterPlot.prototype.drawOuterLine = function(innerRadius, radius, data) {
                    var mainGroup = this.mainGroupElement, outlineArc = d3.svg.arc().innerRadius(innerRadius).outerRadius(radius);
                    if (this.data.showOuterLine) {
                        var OuterThickness = this.data.outerLineThickness + "px", outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
                        outerLine.enter().append("path"), outerLine.attr("fill", "none").attr({
                            stroke: "#333",
                            "stroke-width": OuterThickness,
                            d: outlineArc
                        }).style("opacity", 1).classed(AsterPlot.OuterLine["class"], !0), outerLine.exit().remove();
                    } else mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();
                }, AsterPlot.prototype.getCenterText = function(dataView) {
                    if (dataView && dataView.metadata && dataView.metadata.columns && dataView.categorical && dataView.categorical.values) for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                        var column = _a[_i];
                        if (!column.isMeasure) return column.displayName;
                    }
                    return "";
                }, AsterPlot.prototype.drawCenterText = function(innerRadius) {
                    var text = this.getCenterText(this.dataView);
                    if (_.isEmpty(text)) return void this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
                    var centerTextProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontWeight: "bold",
                        fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),
                        text: text
                    };
                    this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty() && (this.centerText = this.mainGroupElement.append("text").classed(AsterPlot.CenterLabelClass["class"], !0)), 
                    this.centerText.style({
                        "line-height": 1,
                        "font-weight": centerTextProperties.fontWeight,
                        "font-size": centerTextProperties.fontSize,
                        fill: this.getLabelFill(this.dataView).solid.color
                    }).attr({
                        dy: "0.35em",
                        "text-anchor": "middle"
                    }).text(powerbi.TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
                }, AsterPlot.prototype.getLabelFill = function(dataView) {
                    return this.dataViewContainsObjects(dataView) ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterPlot.Properties.label.fill, AsterDefaultLabelFill) : AsterDefaultLabelFill;
                }, AsterPlot.prototype.dataViewContainsObjects = function(dataView) {
                    return dataView && dataView.metadata && dataView.metadata.objects;
                }, AsterPlot.prototype.enumerateLegend = function(instances) {
                    var legendSettings = this.data.legendSettings, instance = {
                        selector: null,
                        objectName: AsterPlotLegendObjectName,
                        displayName: "Legend",
                        properties: {
                            show: legendSettings.show,
                            position: legendSettings.position,
                            showTitle: legendSettings.showTitle,
                            titleText: legendSettings.titleText,
                            labelColor: legendSettings.labelColor,
                            fontSize: legendSettings.fontSize
                        }
                    };
                    instances.push(instance);
                }, AsterPlot.prototype.clearData = function() {
                    this.mainGroupElement.selectAll("path").remove(), visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0), 
                    this.legend.drawLegend({
                        dataPoints: []
                    }, this.currentViewport);
                }, AsterPlot.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, AsterPlot.prototype.enumerateLabels = function(instances) {
                    var labelSettings = this.data.labelSettings, labels = {
                        objectName: "labels",
                        displayName: "Labels",
                        selector: null,
                        properties: {
                            show: labelSettings.show,
                            fontSize: labelSettings.fontSize,
                            labelPrecision: labelSettings.precision,
                            labelDisplayUnits: labelSettings.displayUnits,
                            color: labelSettings.labelColor
                        }
                    };
                    instances.push(labels);
                }, AsterPlot.prototype.enumerateObjectInstances = function(options) {
                    var instances = [];
                    if (!this.dataViewContainsCategory(this.dataView)) return instances;
                    switch (options.objectName) {
                      case AsterPlotLegendObjectName:
                        this.data && this.enumerateLegend(instances);
                        break;

                      case "label":
                        var label = {
                            objectName: "label",
                            displayName: "Label",
                            selector: null,
                            properties: {
                                fill: this.getLabelFill(this.dataView)
                            }
                        };
                        instances.push(label);
                        break;

                      case "labels":
                        this.enumerateLabels(instances);
                        break;

                      case "outerLine":
                        var outerLine = {
                            objectName: "outerLine",
                            displayName: "Outer Line",
                            selector: null,
                            properties: {
                                show: this.data.showOuterLine,
                                thickness: this.data.outerLineThickness
                            }
                        };
                        instances.push(outerLine);
                    }
                    return instances;
                }, AsterPlot.capabilities = {
                    dataRoles: [ {
                        displayName: "Category",
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping
                    }, {
                        displayName: "Y Axis",
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Y: {
                                max: 2
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Y"
                                    }
                                } ]
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: "Legend",
                            description: "Display legend options",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: "Position",
                                    description: "Select the location for the legend",
                                    type: {
                                        enumeration: visuals.legendPosition.type
                                    }
                                },
                                showTitle: {
                                    displayName: "Title",
                                    description: "Display a title for legend symbols",
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: "Legend Name",
                                    description: "Title text",
                                    type: {
                                        text: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        label: {
                            displayName: "Center Label",
                            properties: {
                                fill: {
                                    displayName: "Fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: "Detail Labels",
                            properties: {
                                show: {
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: "Display Units",
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    }
                                },
                                labelPrecision: {
                                    displayName: "Decimal Places",
                                    placeHolderText: "Auto",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        outerLine: {
                            displayName: "Outer line",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                thickness: {
                                    displayName: "Thickness",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        }
                    },
                    supportsHighlight: !0
                }, AsterPlot.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    legend: {
                        show: {
                            objectName: AsterPlotLegendObjectName,
                            propertyName: "show"
                        },
                        position: {
                            objectName: AsterPlotLegendObjectName,
                            propertyName: "position"
                        },
                        showTitle: {
                            objectName: AsterPlotLegendObjectName,
                            propertyName: "showTitle"
                        },
                        titleText: {
                            objectName: AsterPlotLegendObjectName,
                            propertyName: "titleText"
                        },
                        labelColor: {
                            objectName: AsterPlotLegendObjectName,
                            propertyName: "labelColor"
                        },
                        fontSize: {
                            objectName: AsterPlotLegendObjectName,
                            propertyName: "fontSize"
                        }
                    },
                    label: {
                        fill: {
                            objectName: "label",
                            propertyName: "fill"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        color: {
                            objectName: "labels",
                            propertyName: "color"
                        },
                        labelDisplayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        }
                    },
                    outerLine: {
                        show: {
                            objectName: "outerLine",
                            propertyName: "show"
                        },
                        thickness: {
                            objectName: "outerLine",
                            propertyName: "thickness"
                        }
                    }
                }, AsterPlot.AsterSlice = createClassAndSelector("asterSlice"), AsterPlot.AsterHighlightedSlice = createClassAndSelector("asterHighlightedSlice"), 
                AsterPlot.OuterLine = createClassAndSelector("outerLine"), AsterPlot.labelGraphicsContextClass = createClassAndSelector("labels"), 
                AsterPlot.linesGraphicsContextClass = createClassAndSelector("lines"), AsterPlot.CenterLabelClass = createClassAndSelector("centerLabel"), 
                AsterPlot.CenterTextFontHeightCoefficient = .4, AsterPlot.CenterTextFontWidthCoefficient = 1.9, 
                AsterPlot;
            }();
            samples.AsterPlot = AsterPlot;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            function getTornadoChartWarning() {
                return new TornadoChartWarning();
            }
            var PixelConverter = jsCommon.PixelConverter, TornadoWebBehavior = function() {
                function TornadoWebBehavior() {}
                return TornadoWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                    this.columns.on("click", function(d, i) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }), this.clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, TornadoWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var hasHighlights = this.interactivityService.hasSelection();
                    this.columns.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                    });
                }, TornadoWebBehavior;
            }(), TornadoChartScrolling = function() {
                function TornadoChartScrolling(getRoot, getViewport, getMargin, isScrollable) {
                    this.scrollYBrush = d3.svg.brush(), this.getRoot = getRoot, this.getViewport = getViewport, 
                    this.isScrollable = isScrollable;
                }
                return Object.defineProperty(TornadoChartScrolling.prototype, "root", {
                    get: function() {
                        return this.getRoot();
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
                    get: function() {
                        return this.getViewport();
                    },
                    enumerable: !0,
                    configurable: !0
                }), TornadoChartScrolling.prototype.renderY = function(data, prefferedHeight, onScroll) {
                    var _this = this;
                    if (this.isYScrollBarVisible = prefferedHeight > this.viewport.height && this.viewport.height > 0 && this.viewport.width > 0, 
                    this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, "y brush"), 
                    this.updateScrollViewport(), !this.isYScrollBarVisible) return void onScroll.call(this, jQuery.extend(!0, {}, data), 0, 1);
                    var scrollSpaceLength = this.viewport.height, extentData = this.getExtentData(prefferedHeight, scrollSpaceLength), onRender = function(wheelDelta) {
                        void 0 === wheelDelta && (wheelDelta = 0);
                        var position = _this.scrollYBrush.extent();
                        if (0 !== wheelDelta) {
                            var halfScrollsize = (position[1] - position[0]) / 2;
                            if (position[0] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, position[1] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, 
                            position[0] < 0) {
                                var offset = 0 - position[0];
                                position[0] += offset, position[1] += offset;
                            }
                            if (position[1] > scrollSpaceLength) {
                                var offset = position[1] - scrollSpaceLength;
                                position[0] -= offset, position[1] -= offset;
                            }
                            _this.scrollYBrush.extent(position), _this.brushGraphicsContextY.select(".extent").attr("y", position[0]);
                        }
                        var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);
                        onScroll.call(_this, jQuery.extend(!0, {}, data), scrollPosition[0], scrollPosition[1]), 
                        _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], !0);
                    }, scrollYScale = d3.scale.ordinal().rangeBands([ 0, scrollSpaceLength ]);
                    this.scrollYBrush.y(scrollYScale).extent(extentData.value), this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender), 
                    onRender();
                }, TornadoChartScrolling.prototype.updateScrollViewport = function() {
                    this.scrollViewport = {
                        height: this.viewport.height,
                        width: this.viewport.width
                    }, this.isYScrollBarVisible && this.isScrollable && (this.scrollViewport.width -= TornadoChart.ScrollBarWidth);
                }, TornadoChartScrolling.prototype.createOrRemoveScrollbar = function(isVisible, brushGraphicsContext, brushClass) {
                    return isVisible && this.isScrollable ? brushGraphicsContext || this.root.append("g").classed(brushClass, !0) : brushGraphicsContext ? void brushGraphicsContext.remove() : void 0;
                }, TornadoChartScrolling.prototype.renderScrollbar = function(brush, brushGraphicsContext, brushX, onRender) {
                    var _this = this;
                    brush.on("brush", function() {
                        return window.requestAnimationFrame(function() {
                            return onRender(0);
                        });
                    }), this.root.on("wheel", function() {
                        if (_this.isYScrollBarVisible) {
                            var wheelEvent = d3.event;
                            onRender(wheelEvent.deltaY);
                        }
                    }), brushGraphicsContext.attr({
                        transform: visuals.SVGUtil.translate(brushX, 0),
                        "drag-resize-disabled": "true"
                    }), brushGraphicsContext.call(brush), brushGraphicsContext.selectAll(".resize").remove(), 
                    brushGraphicsContext.select(".background").remove(), brushGraphicsContext.selectAll(".extent").style({
                        "fill-opacity": .125,
                        cursor: "default"
                    });
                }, TornadoChartScrolling.prototype.setScrollBarSize = function(brushGraphicsContext, minExtent, isVertical) {
                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChart.ScrollBarWidth), 
                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
                }, TornadoChartScrolling.prototype.getExtentData = function(svgLength, scrollSpaceLength) {
                    var value = scrollSpaceLength * scrollSpaceLength / svgLength, scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value ? 1 : value / TornadoChartScrolling.ScrollBarMinLength;
                    value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
                    var toScrollPosition = function(extent, scrollSpaceLength) {
                        var scrollSize = extent[1] - extent[0], scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
                        scrollSize *= scaleMultipler;
                        var start = scrollPosition * (scrollSpaceLength - scrollSize), end = start + scrollSize;
                        return [ start / scrollSpaceLength, end / scrollSpaceLength ];
                    };
                    return {
                        value: [ 0, value ],
                        toScrollPosition: toScrollPosition
                    };
                }, TornadoChartScrolling.prototype.clearData = function() {
                    this.brushGraphicsContextY && this.brushGraphicsContextY.selectAll("*").remove();
                }, TornadoChartScrolling.ScrollBarMinLength = 15, TornadoChartScrolling;
            }(), TornadoChartWarning = function() {
                function TornadoChartWarning() {}
                return Object.defineProperty(TornadoChartWarning.prototype, "code", {
                    get: function() {
                        return "TornadoChartWarning";
                    },
                    enumerable: !0,
                    configurable: !0
                }), TornadoChartWarning.prototype.getMessages = function(resourceProvider) {
                    var visualMessage, message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "";
                    return visualMessage = {
                        message: message,
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                }, TornadoChartWarning;
            }();
            samples.TornadoChartWarning = TornadoChartWarning, samples.getTornadoChartWarning = getTornadoChartWarning;
            var TornadoChart = function() {
                function TornadoChart(tornadoChartConstructorOptions) {
                    this.DefaultTornadoChartSettings = {
                        labelOutsideFillColor: visuals.dataLabelUtils.defaultLabelColor,
                        labelSettings: {
                            show: !0,
                            precision: null,
                            fontSize: TornadoChart.DefaultFontSize,
                            displayUnits: 0,
                            labelColor: visuals.dataLabelUtils.defaultInsideLabelColor
                        },
                        showCategories: !0,
                        showLegend: !0,
                        legendFontSize: TornadoChart.DefaultLegendFontSize,
                        legendColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        categoriesFillColor: "#777"
                    }, this.DefaultFillColors = [ "purple", "teal" ], this.columnPadding = 5, this.leftLabelMargin = 4, 
                    this.InnerTextHeightDelta = 2, this.textOptions = {}, this.margin = {
                        top: 10,
                        right: 5,
                        bottom: 10,
                        left: 10
                    }, this.heightColumn = 0, this.widthLeftSection = 0, this.widthRightSection = 0, 
                    tornadoChartConstructorOptions && (this.svg = tornadoChartConstructorOptions.svg || this.svg, 
                    this.margin = tornadoChartConstructorOptions.margin || this.margin, this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding, 
                    this.animator = tornadoChartConstructorOptions.animator);
                }
                return TornadoChart.prototype.init = function(visualInitOptions) {
                    var fontSize, _this = this, style = visualInitOptions.style;
                    this.hostService = visualInitOptions.host;
                    var element = visualInitOptions.element;
                    this.colors = style.colorPalette.dataColors;
                    var interactivity = visualInitOptions.interactivity;
                    this.interactivityService = visuals.createInteractivityService(this.hostService);
                    var root;
                    this.svg ? this.root = root = this.svg : this.root = root = d3.select(element.get(0)).append("svg"), 
                    root.classed(TornadoChart.ClassName, !0).style("position", "absolute"), fontSize = root.style("font-size"), 
                    this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2), this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2)), 
                    this.textOptions.fontFamily = root.style("font-family"), this.scrolling = new TornadoChartScrolling(function() {
                        return root;
                    }, function() {
                        return _this.viewport;
                    }, function() {
                        return _this.margin;
                    }, !0);
                    var main = this.main = root.append("g");
                    this.clearCatcher = visuals.appendClearCatcher(main), this.columns = main.append("g").classed(TornadoChart.Columns["class"], !0), 
                    this.axes = main.append("g").classed(TornadoChart.Axes["class"], !0), this.labels = main.append("g").classed(TornadoChart.Labels["class"], !0), 
                    this.categories = main.append("g").classed(TornadoChart.Categories["class"], !0), 
                    this.behavior = new TornadoWebBehavior(), this.defaultTornadoChartDataView = {
                        categories: [],
                        series: [],
                        settings: null,
                        legend: null,
                        dataPoints: [],
                        highlightedDataPoints: []
                    }, this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                }, TornadoChart.prototype.update = function(visualUpdateOptions) {
                    visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0] && (this.viewport = {
                        height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),
                        width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)
                    }, this.animator ? this.durationAnimations = visuals.AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations) : this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250, 
                    this.tornadoChartDataView = this.converter(visualUpdateOptions.dataViews[0]), this.interactivityService && (this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.dataPoints), 
                    this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.highlightedDataPoints)), 
                    this.render());
                }, TornadoChart.prototype.updateElements = function() {
                    var elementsTranslate = visuals.SVGUtil.translate(this.widthLeftSection, 0);
                    this.root.attr({
                        height: this.viewport.height + this.margin.top + this.margin.bottom,
                        width: this.viewport.width + this.margin.left + this.margin.right
                    }), this.columns.attr("transform", elementsTranslate), this.labels.attr("transform", elementsTranslate), 
                    this.axes.attr("transform", elementsTranslate);
                }, TornadoChart.prototype.converter = function(dataView) {
                    if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.values && dataView.categorical.values[0])) return this.defaultTornadoChartDataView;
                    var categorical = dataView.categorical, categories = categorical.categories || [], values = categorical.values;
                    if (values.length > TornadoChart.MaxSeries) return this.hostService.setWarnings([ getTornadoChartWarning() ]), 
                    this.defaultTornadoChartDataView;
                    var category = categories[0], categoryValues = category.values, categoryValuesLength = categoryValues.length, objects = this.getObjectsFromDataView(dataView), formatStringProp = TornadoChart.Properties.general.formatString, valuesSourceFormatString = visuals.valueFormatter.getFormatString(values[0].source, formatStringProp), maxValue = d3.max(values[0].values), settings = this.parseSettings(objects, valuesSourceFormatString, maxValue);
                    this.hasDynamicSeries = !!values.source;
                    var hasHighlights = this.hasHighlights = !!(values.length > 0 && values[0].highlights);
                    this.labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight({
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize)
                    });
                    var series = [], dataPoints = [], highlightedDataPoints = [], categoriesLabels = [], groupedValues = [];
                    values.grouped && (groupedValues = values.grouped());
                    for (var maxCategoryLength = 0, showCategories = settings.showCategories, categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp), i = 0; categoryValuesLength > i; i++) {
                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString), textData = this.getTextData(formattedCategoryValue, !0);
                        categoriesLabels.push(textData), showCategories && textData.width > maxCategoryLength && (maxCategoryLength = textData.width);
                    }
                    var scrollBarWidth = categoryValuesLength * TornadoChart.CategoryMinHeight > this.viewport.height ? TornadoChart.ScrollBarWidth : 0;
                    this.widthLeftSection = maxCategoryLength + TornadoChart.LabelPadding;
                    var maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth;
                    this.updateElements();
                    var minValue = Math.min(d3.min(values[0].values), 0);
                    values.length === TornadoChart.MaxSeries && (minValue = d3.min([ minValue, d3.min(values[1].values) ]), 
                    maxValue = d3.max([ maxValue, d3.max(values[1].values) ]), maxColumnWidth /= TornadoChart.MaxSeries);
                    for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {
                        var parsedSeries = this.parseSeries(values, seriesIndex, this.hasDynamicSeries, groupedValues);
                        series.push(parsedSeries);
                        for (var currentSeries = values[seriesIndex], measureName = currentSeries.source.queryName, i = 0; categoryValuesLength > i; i++) {
                            var value = null == currentSeries.values[i] || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i], identity = visuals.SelectionIdBuilder.builder().withCategory(category, i).withSeries(values, currentSeries).withMeasure(measureName).createSelectionId(), formattedCategoryValue = categoriesLabels[i].text, tooltipInfo = void 0;
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);
                            var currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue, formatString = dataView.categorical.values[seriesIndex].source.format;
                            if (dataPoints.push({
                                value: value,
                                minValue: minValue,
                                maxValue: currentMaxValue,
                                formatString: formatString,
                                color: parsedSeries.fill,
                                selected: !1,
                                identity: identity,
                                tooltipData: tooltipInfo,
                                categoryIndex: i
                            }), hasHighlights) {
                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlight = currentSeries.highlights[i], highlightedValue = null != highlight ? highlight : 0;
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue), 
                                highlightedDataPoints.push({
                                    value: highlightedValue,
                                    minValue: minValue,
                                    maxValue: currentMaxValue,
                                    formatString: formatString,
                                    color: parsedSeries.fill,
                                    selected: !1,
                                    identity: highlightIdentity,
                                    tooltipData: tooltipInfo,
                                    categoryIndex: i,
                                    highlight: !0
                                });
                            }
                        }
                    }
                    return {
                        categories: categoriesLabels,
                        series: series,
                        settings: settings,
                        legend: this.getLegendData(series),
                        dataPoints: dataPoints,
                        highlightedDataPoints: highlightedDataPoints
                    };
                }, TornadoChart.prototype.parseSettings = function(objects, formatString, value) {
                    var precision = this.getPrecision(objects), displayUnits = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, this.DefaultTornadoChartSettings.labelSettings.displayUnits), labelSettings = this.DefaultTornadoChartSettings.labelSettings, labelValueFormatter = visuals.valueFormatter.create({
                        format: formatString,
                        precision: precision,
                        value: 0 === displayUnits && null != value ? value : displayUnits
                    });
                    return {
                        labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),
                        labelSettings: {
                            show: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
                            precision: precision,
                            fontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
                            displayUnits: displayUnits,
                            labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects)
                        },
                        showCategories: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),
                        showLegend: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),
                        legendFontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),
                        legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),
                        categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),
                        labelValueFormatter: labelValueFormatter
                    };
                }, TornadoChart.prototype.getColor = function(properties, defaultColor, objects) {
                    var colorHelper = new visuals.ColorHelper(this.colors, properties, defaultColor);
                    return colorHelper.getColorForMeasure(objects, "");
                }, TornadoChart.prototype.getPrecision = function(objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, this.DefaultTornadoChartSettings.labelSettings.precision);
                    return precision >= TornadoChart.MaxPrecision ? TornadoChart.MaxPrecision : precision;
                }, TornadoChart.prototype.getObjectsFromDataView = function(dataView) {
                    return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {}), 
                    dataView.metadata.objects) : (this.legendObjectProperties = {}, null);
                }, TornadoChart.prototype.parseSeries = function(dataViewValueColumns, index, isGrouped, grouped) {
                    var objects, categoryAxisObject, dataViewValueColumn = dataViewValueColumns[index], seriesGroup = isGrouped ? grouped[index] : grouped[0].values[index], source = dataViewValueColumn.source, selectionId = seriesGroup.identity ? visuals.SelectionId.createWithId(seriesGroup.identity) : visuals.SelectionIdBuilder.builder().withSeries(dataViewValueColumns, seriesGroup).withMeasure(source.queryName).createSelectionId(), displayName = source.groupName ? source.groupName : source.displayName;
                    isGrouped ? (categoryAxisObject = seriesGroup.objects ? seriesGroup.objects.categoryAxis : null, 
                    objects = seriesGroup.objects) : (objects = source.objects, categoryAxisObject = objects ? objects.categoryAxis : null);
                    var color = this.getColor(TornadoChart.Properties.dataPoint.fill, this.DefaultFillColors[index], objects), categoryAxisEnd = categoryAxisObject ? categoryAxisObject.end : null;
                    return {
                        fill: color,
                        name: displayName,
                        selectionId: selectionId,
                        categoryAxisEnd: categoryAxisEnd
                    };
                }, TornadoChart.prototype.getLegendData = function(series) {
                    var legendDataPoints = [];
                    return this.hasDynamicSeries && (legendDataPoints = series.map(function(series) {
                        return {
                            label: series.name,
                            color: series.fill,
                            icon: visuals.LegendIcon.Box,
                            selected: !1,
                            identity: series.selectionId
                        };
                    })), {
                        dataPoints: legendDataPoints
                    };
                }, TornadoChart.prototype.clearData = function() {
                    this.columns.selectAll("*").remove(), this.axes.selectAll("*").remove(), this.labels.selectAll("*").remove(), 
                    this.categories.selectAll("*").remove(), this.legend.drawLegend({
                        dataPoints: []
                    }, this.viewport), this.scrolling.clearData();
                }, TornadoChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, TornadoChart.prototype.render = function() {
                    var tornadoChartDataView = this.tornadoChartDataView;
                    return tornadoChartDataView && tornadoChartDataView.settings ? (this.renderLegend(), 
                    void this.scrolling.renderY(tornadoChartDataView, tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight, this.renderWithScrolling.bind(this))) : void this.clearData();
                }, TornadoChart.prototype.renderWithScrolling = function(tornadoChartDataView, scrollStart, scrollEnd) {
                    if (this.tornadoChartDataView && this.tornadoChartDataView.settings) {
                        var categoriesLength = tornadoChartDataView.categories.length, startIndex = scrollStart * categoriesLength, endIndex = scrollEnd * categoriesLength, startIndexRound = Math.floor(startIndex), endIndexRound = Math.floor(endIndex), maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
                        1 > scrollEnd - scrollStart && endIndexRound - startIndexRound > maxValues && (startIndex - startIndexRound > endIndex - endIndexRound ? startIndexRound++ : endIndex--), 
                        this.interactivityService && (this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints), 
                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints));
                        var scrollBarWidth = tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight > this.viewport.height ? TornadoChart.ScrollBarWidth : 0;
                        tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound), 
                        tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function(d) {
                            return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                        }), tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function(d) {
                            return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                        }), this.tornadoChartDataView = tornadoChartDataView, this.computeHeightColumn(), 
                        this.renderMiddleSection(scrollBarWidth), this.renderAxes(), this.renderCategories();
                    }
                }, TornadoChart.prototype.updateViewport = function() {
                    var legendPosition, legendMargins = this.legend.getMargins();
                    switch (legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]]) {
                      case visuals.LegendPosition.Top:
                      case visuals.LegendPosition.TopCenter:
                      case visuals.LegendPosition.Bottom:
                      case visuals.LegendPosition.BottomCenter:
                        this.viewport.height -= legendMargins.height;
                        break;

                      case visuals.LegendPosition.Left:
                      case visuals.LegendPosition.LeftCenter:
                      case visuals.LegendPosition.Right:
                      case visuals.LegendPosition.RightCenter:
                        this.viewport.width -= legendMargins.width;
                    }
                }, TornadoChart.prototype.computeHeightColumn = function() {
                    var length = this.tornadoChartDataView.categories.length;
                    this.heightColumn = (this.scrolling.scrollViewport.height - (length - 1) * this.columnPadding) / length;
                }, TornadoChart.prototype.renderMiddleSection = function(scrollBarWidth) {
                    var tornadoChartDataView = this.tornadoChartDataView;
                    this.calculateDataPoints(tornadoChartDataView.dataPoints, scrollBarWidth), this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints, scrollBarWidth);
                    var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);
                    this.renderColumns(dataPointsWithHighlights, 2 === tornadoChartDataView.series.length), 
                    this.renderLabels(this.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);
                }, TornadoChart.prototype.calculateDataPoints = function(dataPoints, scrollBarWidth) {
                    var maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth, categoriesLength = this.tornadoChartDataView.categories.length, settings = this.tornadoChartDataView.settings, hasHighlights = this.hasHighlights, heightColumn = Math.max(this.heightColumn, 0), py = heightColumn / 2, pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2, maxSeries = this.tornadoChartDataView.series.length === TornadoChart.MaxSeries;
                    maxSeries && (maxColumnWidth /= 2);
                    for (var i = 0; i < dataPoints.length; i++) {
                        var dataPoint = dataPoints[i], shiftToMiddle = categoriesLength > i && maxSeries, shiftToRight = i > categoriesLength - 1, widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, maxColumnWidth), dx = (maxColumnWidth - widthOfColumn) * Number(shiftToMiddle) + maxColumnWidth * Number(shiftToRight) - scrollBarWidth;
                        dx = Math.max(dx, 0);
                        var highlighted = hasHighlights && dataPoint.highlight, highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0, dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset, label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);
                        dataPoint.dx = dx, dataPoint.dy = dy, dataPoint.px = widthOfColumn / 2, dataPoint.py = highlighted ? pyHighlighted : py, 
                        dataPoint.angle = shiftToMiddle ? 180 : 0, dataPoint.width = widthOfColumn, dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn, 
                        dataPoint.label = label;
                    }
                }, TornadoChart.prototype.renderColumns = function(columnsData, selectSecondSeries) {
                    void 0 === selectSecondSeries && (selectSecondSeries = !1);
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), hasHighlights = this.hasHighlights, columnsSelection = this.columns.selectAll(TornadoChart.Column.selector).data(columnsData);
                    columnsSelection.enter().append("svg:rect").classed(TornadoChart.Column["class"], !0), 
                    columnsSelection.style("fill", function(p) {
                        return p.color;
                    }).style("fill-opacity", function(p) {
                        return visuals.ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, hasHighlights);
                    }).attr("transform", function(p) {
                        return visuals.SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle);
                    }).attr("height", function(p) {
                        return p.height;
                    }).attr("width", function(p) {
                        return p.width;
                    }), columnsSelection.exit().remove();
                    var interactivityService = this.interactivityService;
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(columnsData);
                        var behaviorOptions = {
                            columns: columnsSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService
                        };
                        interactivityService.bind(columnsData, this.behavior, behaviorOptions);
                    }
                    this.renderTooltip(columnsSelection);
                }, TornadoChart.prototype.renderTooltip = function(selection) {
                    visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipData;
                    });
                }, TornadoChart.prototype.getColumnWidth = function(value, minValue, maxValue, width) {
                    if (minValue === maxValue) return width;
                    var columnWidth = width * (value - minValue) / (maxValue - minValue);
                    return Math.max(0, Math.min(width, columnWidth));
                }, TornadoChart.prototype.getLabelData = function(value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {
                    var dx, tornadoChartSettings = settings ? settings : this.tornadoChartDataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor, maxOutsideLabelWidth = isColumnPositionLeft ? dxColumn - this.leftLabelMargin : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin), maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin), textProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize),
                        text: tornadoChartSettings.labelValueFormatter.format(value)
                    }, valueAfterValueFormatter = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth), textDataAfterValueFormatter = this.getTextData(valueAfterValueFormatter, !0, !1, fontSize);
                    return columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding ? dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2 : (dx = isColumnPositionLeft ? dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width : dxColumn + columnWidth + this.leftLabelMargin, 
                    color = tornadoChartSettings.labelOutsideFillColor), {
                        dx: dx,
                        source: value,
                        value: valueAfterValueFormatter,
                        color: color
                    };
                }, TornadoChart.prototype.renderAxes = function() {
                    var linesData, axesSelection, axesElements = this.main.select(TornadoChart.Axes.selector).selectAll(TornadoChart.Axis.selector);
                    return this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries ? void axesElements.remove() : (linesData = this.generateAxesData(), 
                    axesSelection = axesElements.data(linesData), axesSelection.enter().append("svg:line").classed(TornadoChart.Axis["class"], !0), 
                    axesSelection.transition().duration(this.durationAnimations).attr("x1", function(data) {
                        return data.x1;
                    }).attr("y1", function(data) {
                        return data.y1;
                    }).attr("x2", function(data) {
                        return data.x2;
                    }).attr("y2", function(data) {
                        return data.y2;
                    }), void axesSelection.exit().remove());
                }, TornadoChart.prototype.generateAxesData = function() {
                    var x, y1, y2;
                    return x = this.widthRightSection / 2, y1 = 0, y2 = this.scrolling.scrollViewport.height, 
                    [ {
                        x1: x,
                        y1: y1,
                        x2: x,
                        y2: y2
                    } ];
                }, TornadoChart.prototype.renderLabels = function(dataPoints, labelsSettings) {
                    var labelEnterSelection, _this = this, labelSelection = this.main.select(TornadoChart.Labels.selector).selectAll(TornadoChart.Label.selector).data(_.filter(dataPoints, function(p) {
                        return p.label.dx >= 0;
                    }));
                    if (!labelsSettings.show || this.labelHeight >= this.heightColumn) return void this.labels.selectAll("*").remove();
                    var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize), labelYOffset = this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta, categoriesLength = this.tornadoChartDataView.categories.length;
                    labelEnterSelection = labelSelection.enter().append("g"), labelEnterSelection.append("svg:title").classed(TornadoChart.LabelTitle["class"], !0), 
                    labelEnterSelection.append("svg:text").attr("dy", visuals.dataLabelUtils.DefaultDy).classed(TornadoChart.LabelText["class"], !0), 
                    labelSelection.attr("pointer-events", "none").classed(TornadoChart.Label["class"], !0), 
                    labelSelection.select(TornadoChart.LabelTitle.selector).text(function(p) {
                        return p.label.source;
                    }), labelSelection.attr("transform", function(p, index) {
                        var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);
                        return visuals.SVGUtil.translate(p.label.dx, dy + labelYOffset);
                    }), labelSelection.select(TornadoChart.LabelText.selector).attr("fill", function(p) {
                        return p.label.color;
                    }).attr("font-size", function(p) {
                        return fontSizeInPx;
                    }).text(function(p) {
                        return p.label.value;
                    }), labelSelection.exit().remove();
                }, TornadoChart.prototype.renderCategories = function() {
                    var categoriesEnterSelection, categoriesSelection, _this = this, settings = this.tornadoChartDataView.settings, color = settings.categoriesFillColor, categoryElements = this.main.select(TornadoChart.Categories.selector).selectAll(TornadoChart.Category.selector), self = this;
                    return settings.showCategories ? (categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories), 
                    categoriesEnterSelection = categoriesSelection.enter().append("g"), categoriesEnterSelection.append("svg:title").classed(TornadoChart.CategoryTitle["class"], !0), 
                    categoriesEnterSelection.append("svg:text").classed(TornadoChart.CategoryText["class"], !0), 
                    categoriesSelection.attr("transform", function(text, index) {
                        var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = _this.getTextData(text, !1, !0);
                        return shift = shift + textData.height / 2 - _this.InnerTextHeightDelta, visuals.SVGUtil.translate(0, shift);
                    }).classed(TornadoChart.Category["class"], !0), categoriesSelection.select(TornadoChart.CategoryTitle.selector).text(function(text) {
                        return text.text;
                    }), categoriesSelection.select(TornadoChart.CategoryText.selector).attr("fill", color).text(function(data) {
                        var textData = self.getTextData(data.text);
                        return powerbi.TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);
                    }), void categoriesSelection.exit().remove()) : void categoryElements.remove();
                }, TornadoChart.prototype.renderLegend = function() {
                    var legend = this.tornadoChartDataView.legend;
                    if (legend) {
                        var settings = this.tornadoChartDataView.settings, legendData = {
                            title: legend.title,
                            dataPoints: legend.dataPoints,
                            fontSize: settings.legendFontSize,
                            labelColor: settings.legendColor
                        };
                        if (this.legendObjectProperties) {
                            var position = void 0;
                            visuals.LegendData.update(legendData, this.legendObjectProperties), position = this.legendObjectProperties[visuals.legendProps.position], 
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                        var viewport = {
                            height: this.viewport.height + this.margin.top + this.margin.bottom,
                            width: this.viewport.width + this.margin.left + this.margin.right
                        };
                        this.legend.drawLegend(legendData, viewport), visuals.Legend.positionChartArea(this.root, this.legend), 
                        legendData.dataPoints.length > 0 && settings.showLegend && this.updateViewport();
                    }
                }, TornadoChart.prototype.getTextData = function(text, measureWidth, measureHeight, overrideFontSize) {
                    void 0 === measureWidth && (measureWidth = !1), void 0 === measureHeight && (measureHeight = !1);
                    var fontSize, textProperties, width = 0, height = 0;
                    return text = text || "", fontSize = overrideFontSize ? PixelConverter.fromPoint(overrideFontSize) : "" + this.textOptions.fontSize + this.textOptions.sizeUnit, 
                    textProperties = {
                        text: text,
                        fontFamily: this.textOptions.fontFamily,
                        fontSize: fontSize
                    }, measureWidth && (width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties)), 
                    measureHeight && (height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)), 
                    {
                        text: text,
                        width: width,
                        height: height,
                        textProperties: textProperties
                    };
                }, TornadoChart.prototype.enumerateObjectInstances = function(options) {
                    var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                    if (!this.tornadoChartDataView || !this.tornadoChartDataView.settings) return [];
                    switch (settings = this.tornadoChartDataView.settings, options.objectName) {
                      case "dataPoint":
                        this.enumerateDataPoint(enumeration);
                        break;

                      case "categoryAxis":
                        this.enumerateCategoryAxis(enumeration);
                        break;

                      case "labels":
                        var labelSettings = settings.labelSettings, labels = {
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: labelSettings.show,
                                fontSize: labelSettings.fontSize,
                                labelPrecision: labelSettings.precision,
                                labelDisplayUnits: labelSettings.displayUnits,
                                insideFill: labelSettings.labelColor,
                                outsideFill: settings.labelOutsideFillColor
                            }
                        };
                        enumeration.pushInstance(labels);
                        break;

                      case "legend":
                        if (!this.hasDynamicSeries) return;
                        var showTitle = !0, titleText = "", legend = void 0;
                        showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                        titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                        legend = {
                            objectName: "legend",
                            displayName: "Legend",
                            selector: null,
                            properties: {
                                show: settings.showLegend,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                fontSize: settings.legendFontSize,
                                labelColor: settings.legendColor
                            }
                        }, enumeration.pushInstance(legend);
                        break;

                      case "categories":
                        var categories = {
                            objectName: "categories",
                            displayName: "Categories",
                            selector: null,
                            properties: {
                                show: settings.showCategories,
                                fill: settings.categoriesFillColor
                            }
                        };
                        enumeration.pushInstance(categories);
                    }
                    return enumeration.complete();
                }, TornadoChart.prototype.enumerateDataPoint = function(enumeration) {
                    if (this.tornadoChartDataView && this.tornadoChartDataView.series) for (var series = this.tornadoChartDataView.series, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                        var currentSeries = series_1[_i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: currentSeries.name,
                            selector: visuals.ColorHelper.normalizeSelector(currentSeries.selectionId.getSelector(), !1),
                            properties: {
                                fill: {
                                    solid: {
                                        color: currentSeries.fill
                                    }
                                }
                            }
                        });
                    }
                }, TornadoChart.prototype.enumerateCategoryAxis = function(enumeration) {
                    if (this.tornadoChartDataView && this.tornadoChartDataView.series) for (var series = this.tornadoChartDataView.series, _i = 0, series_2 = series; _i < series_2.length; _i++) {
                        var currentSeries = series_2[_i];
                        enumeration.pushInstance({
                            objectName: "categoryAxis",
                            displayName: currentSeries.name,
                            selector: currentSeries.selectionId ? currentSeries.selectionId.getSelector() : null,
                            properties: {
                                end: currentSeries.categoryAxisEnd
                            }
                        });
                    }
                }, TornadoChart.prototype.destroy = function() {
                    this.root = null;
                }, TornadoChart.ClassName = "tornado-chart", TornadoChart.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        labelDisplayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        insideFill: {
                            objectName: "labels",
                            propertyName: "insideFill"
                        },
                        outsideFill: {
                            objectName: "labels",
                            propertyName: "outsideFill"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        },
                        labelColor: {
                            objectName: "legend",
                            propertyName: "labelColor"
                        },
                        fontSize: {
                            objectName: "legend",
                            propertyName: "fontSize"
                        }
                    },
                    categories: {
                        show: {
                            objectName: "categories",
                            propertyName: "show"
                        },
                        fill: {
                            objectName: "categories",
                            propertyName: "fill"
                        }
                    }
                }, TornadoChart.Columns = {
                    "class": "columns",
                    selector: ".columns"
                }, TornadoChart.Column = {
                    "class": "column",
                    selector: ".column"
                }, TornadoChart.Axes = {
                    "class": "axes",
                    selector: ".axes"
                }, TornadoChart.Axis = {
                    "class": "axis",
                    selector: ".axis"
                }, TornadoChart.Labels = {
                    "class": "labels",
                    selector: ".labels"
                }, TornadoChart.Label = {
                    "class": "label",
                    selector: ".label"
                }, TornadoChart.LabelTitle = {
                    "class": "label-title",
                    selector: ".label-title"
                }, TornadoChart.LabelText = {
                    "class": "label-text",
                    selector: ".label-text"
                }, TornadoChart.Categories = {
                    "class": "categories",
                    selector: ".categories"
                }, TornadoChart.Category = {
                    "class": "category",
                    selector: ".category"
                }, TornadoChart.CategoryTitle = {
                    "class": "category-title",
                    selector: ".category-title"
                }, TornadoChart.CategoryText = {
                    "class": "category-text",
                    selector: ".category-text"
                }, TornadoChart.MaxSeries = 2, TornadoChart.MaxPrecision = 17, TornadoChart.LabelPadding = 2.5, 
                TornadoChart.CategoryMinHeight = 25, TornadoChart.DefaultFontSize = 9, TornadoChart.DefaultLegendFontSize = 8, 
                TornadoChart.HighlightedShapeFactor = .5, TornadoChart.ScrollBarWidth = 10, TornadoChart.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                    }, {
                        name: "Values",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Values: {
                                min: 0,
                                max: 1
                            },
                            Series: {
                                min: 0,
                                max: 1
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Values: {
                                min: 2,
                                max: 2
                            },
                            Series: {
                                max: 0
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        "for": {
                                            "in": "Values"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: "Data Colors",
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: "X-Axis",
                            properties: {
                                end: {
                                    displayName: "End",
                                    type: {
                                        numeric: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                }
                            }
                        },
                        labels: {
                            displayName: "Data Labels",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                labelPrecision: {
                                    displayName: "Decimal Places",
                                    placeHolderText: "Auto",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: "Display Units",
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    }
                                },
                                insideFill: {
                                    displayName: "Inside fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                outsideFill: {
                                    displayName: "Outside fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: "Legend",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: "Position",
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                    type: {
                                        enumeration: visuals.legendPosition.type
                                    }
                                },
                                showTitle: {
                                    displayName: "Title",
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: "Legend Name",
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                    type: {
                                        text: !0
                                    }
                                },
                                labelColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "TextSize",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        categories: {
                            displayName: "Group",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    supportsHighlight: !0
                }, TornadoChart;
            }();
            samples.TornadoChart = TornadoChart;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                var XLabelMaxAllowedOverflow = 35, xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2, xLabels = xAxisProperties.values, y1Labels = y1AxisProperties.values, leftOverflow = 0, rightOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0, scaleIsOrdinal = visuals.AxisHelper.isOrdinalScale(xAxisProperties.scale), xLabelOuterPadding = 0;
                if (void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2)), 
                0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) || 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height)) {
                    var rotation;
                    if (rotation = scrollbarVisible ? visuals.AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar : visuals.AxisHelper.LabelLayoutStrategy.DefaultRotation, 
                    renderY1Axis) for (var i = 0, len = y1Labels.length; len > i; i++) y1AxisTextProperties.text = y1Labels[i], 
                    maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));
                    if (y2AxisProperties && renderY2Axis) for (var y2Labels = y2AxisProperties.values, i = 0, len = y2Labels.length; len > i; i++) y2AxisTextProperties.text = y2Labels[i], 
                    maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));
                    var textHeight = textHeightMeasurer(xAxisTextProperties), maxNumLines = Math.floor(bottomMarginLimit / textHeight), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                    if (renderXAxis && xLabels.length > 0) {
                        for (var i = 0, len = xLabels.length; len > i; i++) {
                            var height;
                            xAxisTextProperties.text = xLabels[i];
                            var width = textWidthMeasurer(xAxisTextProperties);
                            if (xAxisProperties.willLabelsWordBreak) {
                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                height = wordBreaks.length * textHeight, width = xAxisProperties.xLabelMaxWidth;
                            } else !xAxisProperties.willLabelsFit && scaleIsOrdinal ? (height = width * rotation.sine, 
                            width *= rotation.cosine) : height = textHeight;
                            if (0 === i) {
                                if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                                leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                    var xPos = xScale(xDomain[0]);
                                    leftOverflow = width / 2 - xPos, leftOverflow = Math.max(leftOverflow, 0);
                                }
                            } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                            rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                                var xPos = xScale(xDomain[1]);
                                rightOverflow = width / 2 - (viewport.width - xPos), rightOverflow = Math.max(rightOverflow, 0);
                            }
                            xMax = Math.max(xMax, height);
                        }
                        leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0, 
                        rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;
                    }
                }
                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                return showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
                rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
                rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), {
                    xMax: Math.ceil(bottomMargin),
                    yLeft: Math.ceil(leftMargin),
                    yRight: Math.ceil(rightMargin)
                };
            }
            function getLayerData(dataViews, currentIdx, totalLayers) {
                return totalLayers > 1 ? dataViews && dataViews.length > currentIdx ? [ dataViews[currentIdx] ] : [] : dataViews;
            }
            function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                return 0 === layerNumber && !!valueAxisProperties && !!valueAxisProperties.showAxisTitle || 1 === layerNumber && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties.secShowAxisTitle;
            }
            function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {
                var visualOptions = {
                    viewport: viewport,
                    margin: margin,
                    forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                    forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                    showCategoryAxisLabel: !1,
                    showValueAxisLabel: !1,
                    categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : visuals.axisScale.linear,
                    valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : visuals.axisScale.linear,
                    trimOrdinalDataOnOverflow: !1
                }, yAxisWillMerge = !1;
                valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain));
                for (var result, layerNumber = 0, len = layers.length; len > layerNumber; layerNumber++) {
                    var currentlayer = layers[layerNumber];
                    visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                    visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                    var axes = currentlayer.calculateAxesProperties(visualOptions);
                    0 === layerNumber && (result = {
                        x: axes[0],
                        y1: axes[1]
                    }), result.x.willLabelsFit = !1, result.x.willLabelsWordBreak = !1;
                }
                return result;
            }
            function createLayers(type, objects, interactivityService, animator, isScrollable) {
                void 0 === isScrollable && (isScrollable = !0);
                var layers = [], cartesianOptions = {
                    isScrollable: isScrollable,
                    animator: animator,
                    interactivityService: interactivityService
                };
                return layers.push(createMekkoChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions)), 
                layers;
            }
            function createMekkoChartLayer(type, defaultOptions) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    chartType: type
                };
                return new MekkoColumnChart(options);
            }
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, MekkoDataWrapper = function() {
                function MekkoDataWrapper(columnChartData, isScalar) {
                    this.data = columnChartData, this.isScalar = isScalar;
                }
                return MekkoDataWrapper.prototype.lookupXValue = function(index, type) {
                    var isDateTime = visuals.AxisHelper.isDateTime(type);
                    if (isDateTime && this.isScalar) return new Date(index);
                    var data = this.data;
                    if (type.text) return data.categories[index];
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            this.data.hasHighlights && (index = 2 * index);
                            var dataPoint = seriesValues[index];
                            if (dataPoint) return isDateTime ? new Date(dataPoint.categoryValue) : dataPoint.categoryValue;
                        }
                    }
                    return index;
                }, MekkoDataWrapper;
            }();
            samples.MekkoDataWrapper = MekkoDataWrapper;
            var MekkoColumnChartStrategy = function() {
                function MekkoColumnChartStrategy() {}
                return MekkoColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                    this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                    this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                    this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                    this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                    this.viewportWidth = columnChartProps.viewportWidth;
                }, MekkoColumnChartStrategy.prototype.setData = function(data) {
                    this.data = data;
                }, MekkoColumnChartStrategy.createFormatter = function(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                    void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                    var formatter;
                    if (dataType.dateTime) if (isScalar) {
                        var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                        1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: value,
                            value2: value2,
                            tickCount: bestTickCount
                        });
                    } else {
                        var minDate = getValueFn(0, dataType), maxDate = getValueFn(scaleDomain.length - 1, dataType);
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: minDate,
                            value2: maxDate,
                            tickCount: bestTickCount
                        });
                    } else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var domainMin = tickValues[1] - tickValues[0], domainMax = 0;
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: domainMin,
                            value2: domainMax,
                            allowFormatBeautification: !0
                        });
                    } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                    return formatter;
                }, MekkoColumnChartStrategy.formatAxisTickValues = function(axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                    var formattedTickValues = [];
                    return formatter ? !getValueFn || dataType.numeric && isScalar ? (axis.tickFormat(function(d) {
                        return formatter.format(d);
                    }), formattedTickValues = tickValues.map(function(d) {
                        return formatter.format(d);
                    })) : (axis.tickFormat(function(d) {
                        return formatter.format(getValueFn(d, dataType));
                    }), formattedTickValues = tickValues.map(function(d) {
                        return formatter.format(getValueFn(d, dataType));
                    })) : formattedTickValues = tickValues.map(function(d) {
                        return getValueFn(d, dataType);
                    }), formattedTickValues;
                }, MekkoColumnChartStrategy.prototype.createAxis = function(options) {
                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp), dataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn, isScalar), isLogScaleAllowed = visuals.AxisHelper.isLogScalePossible(dataDomain, dataType), scale = d3.scale.linear(), scaleDomain = [ 0, 1 ], bestTickCount = dataDomain.length || 1, borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings), chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
                    chartWidth < MekkoChart.MinOrdinalRectThickness && (chartWidth = MekkoChart.MinOrdinalRectThickness), 
                    scale.domain(scaleDomain).range([ 0, chartWidth ]);
                    var tickValues = dataDomain, formatter = MekkoColumnChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(dataDomain), formattedTickValues = [];
                    metaDataColumn && (formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn));
                    var xLabelMaxWidth;
                    if (!isScalar && categoryThickness) xLabelMaxWidth = Math.max(1, categoryThickness - 2 * visuals.CartesianChart.TickLabelPadding); else {
                        var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                        xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan, xLabelMaxWidth = Math.max(1, xLabelMaxWidth - 2 * visuals.CartesianChart.TickLabelPadding);
                    }
                    return {
                        scale: scale,
                        axis: axis,
                        formatter: formatter,
                        values: formattedTickValues,
                        axisType: dataType,
                        axisLabel: null,
                        isCategoryAxis: isCategoryAxis,
                        xLabelMaxWidth: xLabelMaxWidth,
                        categoryThickness: categoryThickness,
                        outerPadding: outerPadding,
                        usingDefaultDomain: !1,
                        isLogScaleAllowed: isLogScaleAllowed
                    };
                }, MekkoColumnChartStrategy.prototype.getCategoryAxis = function(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
                    var categoryThickness = layout.categoryThickness, isScalar = layout.isScalar, outerPaddingRatio = layout.outerPaddingRatio, dw = new MekkoDataWrapper(data, isScalar), domain = [];
                    if (data.series && data.series.length > 0 && data.series[0].data && data.series[0].data.length > 0) {
                        var domainDoubles = data.series[0].data.map(function(item) {
                            return item.originalPosition + item.value / 2;
                        });
                        domain = domainDoubles.filter(function(item, pos) {
                            return domainDoubles.indexOf(item) === pos;
                        });
                    }
                    var axisProperties = this.createAxis({
                        pixelSpan: size,
                        dataDomain: domain,
                        metaDataColumn: data.categoryMetadata,
                        formatStringProp: visuals.columnChartProps.general.formatString,
                        outerPadding: categoryThickness * outerPaddingRatio,
                        isCategoryAxis: !0,
                        isScalar: isScalar,
                        isVertical: isVertical,
                        categoryThickness: categoryThickness,
                        useTickIntervalForDisplayUnits: !0,
                        getValueFn: function(index, type) {
                            var domainIndex = domain.indexOf(index), value = dw.lookupXValue(domainIndex, type);
                            return value;
                        },
                        scaleType: axisScaleType,
                        borderSettings: data.borderSettings
                    });
                    return layout.categoryThickness = axisProperties.categoryThickness, axisProperties;
                }, MekkoColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
                    var forcedXMin, forcedXMax, width = this.width;
                    forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                    var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType);
                    return props;
                }, MekkoColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
                    var height = this.viewportHeight, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString), mekkoMekkoCreateAxisOptions = {
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: metadataColumn,
                        formatString: formatString,
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: axisScaleType,
                        axisDisplayUnits: 0,
                        axisPrecision: 0,
                        is100Pct: is100Pct,
                        shouldClamp: shouldClamp,
                        formatStringProp: void 0
                    };
                    return this.yProps = visuals.AxisHelper.createAxis(mekkoMekkoCreateAxisOptions), 
                    this.yProps;
                }, MekkoColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                    var data = this.data;
                    this.columnsCenters = null;
                    var result, shapes, axisOptions = {
                        columnWidth: 0,
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin
                    }, stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions), labelDataPoints = this.createMekkoLabelDataPoints(), series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    return this.animator && useAnimation && (result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedColumnLayout,
                        itemCS: MekkoColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = MekkoColumnChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                    {
                        shapesSelection: shapes,
                        viewport: {
                            height: this.height,
                            width: this.width
                        },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints
                    };
                }, MekkoColumnChartStrategy.drawDefaultShapes = function(data, series, layout, itemCS, filterZeros, hasSelection) {
                    var rectName = "rect";
                    filterZeros = !1;
                    var dataSelector;
                    dataSelector = filterZeros ? function(d) {
                        var filteredData = _.filter(d.data, function(datapoint) {
                            return !!datapoint.value;
                        });
                        return filteredData;
                    } : function(d) {
                        return d.data;
                    };
                    var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(dataSelector, function(d) {
                        return d.key;
                    });
                    shapes.enter().append(rectName).attr("class", function(d) {
                        return itemCS["class"].concat(d.highlight ? " highlight" : "");
                    }), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                    }).attr(layout.shapeLayout), shapes.exit().remove();
                    var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector), borders = borderSelection.data(dataSelector, function(d) {
                        return d.key;
                    }), borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
                    return borders.enter().append(rectName).classed(MekkoColumnChart.BorderClass["class"], !0), 
                    borders.style("fill", function(d) {
                        return borderColor;
                    }).style("fill-opacity", function(d) {
                        return data.hasHighlights ? visuals.ColumnUtil.DimmedOpacity : visuals.ColumnUtil.DefaultOpacity;
                    }).attr(layout.shapeBorder), borders.exit().remove(), shapes;
                }, MekkoColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                    this.moveHandle(selectedColumnIndex);
                }, MekkoColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                }, MekkoColumnChartStrategy.prototype.getColumnsCenters = function() {
                    var _this = this;
                    if (!this.columnsCenters) {
                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        if (this.data.series.length > 0) {
                            var xScaleOffset = 0;
                            this.categoryLayout.isScalar || (xScaleOffset = categoryWidth / 2);
                            var firstSeries = this.data.series[0];
                            firstSeries && firstSeries.data && (this.columnsCenters = firstSeries.data.map(function(d) {
                                return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset;
                            }));
                        }
                    }
                    return this.columnsCenters;
                }, MekkoColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                    var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex];
                    if (this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle;
                        handle.select("line").attr({
                            x1: x,
                            x2: x
                        }), handle.select("circle").attr({
                            cx: x
                        });
                    } else {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                        handle.append("line").classed("interactive-hover-line", !0).attr({
                            x1: x,
                            x2: x,
                            y1: 0,
                            y2: this.height
                        }), handle.append("circle").attr({
                            cx: x,
                            cy: this.height,
                            r: "6px"
                        }).classed("drag-handle", !0);
                    }
                }, MekkoColumnChartStrategy.getLayout = function(data, axisOptions) {
                    var xScale = axisOptions.xScale, yScale = axisOptions.yScale, scaledY0 = yScale(0), scaledX0 = xScale(0), borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings), columnWidthScale = function(d) {
                        var value = visuals.AxisHelper.diffScaled(xScale, d.value, 0);
                        return value;
                    }, columnStart = function(d) {
                        var value = scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) + borderWidth * d.categoryIndex;
                        return value;
                    }, borderStart = function(d) {
                        var value = scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) + visuals.AxisHelper.diffScaled(xScale, d.value, 0) + borderWidth * d.categoryIndex;
                        return value;
                    };
                    return {
                        shapeLayout: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                            },
                            height: function(d) {
                                return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            }
                        },
                        shapeBorder: {
                            width: function(d) {
                                return borderWidth;
                            },
                            x: borderStart,
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                            },
                            height: function(d) {
                                return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                            },
                            height: function(d) {
                                return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute);
                            }
                        },
                        zeroShapeLayout: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            },
                            height: function(d) {
                                return 0;
                            }
                        },
                        shapeXAxis: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                            },
                            height: function(d) {
                                return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            }
                        }
                    };
                }, MekkoColumnChartStrategy.prototype.createMekkoLabelDataPoints = function() {
                    for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, i = 0, ilen = series.length; ilen > i; i++) {
                        var currentSeries = series[i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (labelSettings.show && currentSeries.data) for (var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), j = 0; j < currentSeries.data.length; j++) {
                            var dataPoint = currentSeries.data[j];
                            if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                var parentRect = {
                                    left: shapeLayout.x(dataPoint),
                                    top: shapeLayout.y(dataPoint),
                                    width: shapeLayout.width(dataPoint),
                                    height: shapeLayout.height(dataPoint)
                                }, formatString = null, value = dataPoint.valueOriginal;
                                labelSettings.displayUnits || (formatString = NewDataLabelUtils.hundredPercentFormat, 
                                value = dataPoint.valueAbsolute);
                                var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value)), properties = {
                                    text: text,
                                    fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                                    fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,
                                    fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight
                                }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                                labelDataPoints.push({
                                    isPreferred: !0,
                                    text: text,
                                    textSize: {
                                        width: textWidth,
                                        height: textHeight
                                    },
                                    outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,
                                    insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,
                                    isParentRect: !0,
                                    parentShape: {
                                        rect: parentRect,
                                        orientation: 1,
                                        validPositions: MekkoColumnChartStrategy.validLabelPositions
                                    },
                                    identity: dataPoint.identity,
                                    parentType: 1
                                });
                            }
                        }
                    }
                    return labelDataPoints;
                }, MekkoColumnChartStrategy.classes = {
                    item: createClassAndSelector("column"),
                    highlightItem: createClassAndSelector("highlightColumn")
                }, MekkoColumnChartStrategy.validLabelPositions = [ 1 ], MekkoColumnChartStrategy;
            }();
            samples.MekkoColumnChartStrategy = MekkoColumnChartStrategy;
            var MekkoChart = function() {
                function MekkoChart(options) {
                    this.isScrollable = !1, options ? (this.type = options.chartType, options.isScrollable && (this.isScrollable = options.isScrollable), 
                    this.animator = options.animator, options.cartesianSmallViewPortProperties && (this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties), 
                    options.behavior && (this.behavior = options.behavior)) : this.behavior = new MekkoChartBehavior([ new visuals.ColumnChartWebBehavior() ]);
                }
                return MekkoChart.getTextProperties = function(fontSize) {
                    return void 0 === fontSize && (fontSize = MekkoChart.FontSize), {
                        fontFamily: "wf_segoe-ui_normal",
                        fontSize: jsCommon.PixelConverter.toString(fontSize)
                    };
                }, MekkoChart.prototype.init = function(options) {
                    this.visualInitOptions = options, this.layers = [];
                    var element = this.element = options.element, viewport = this.currentViewport = options.viewport;
                    this.hostServices = options.host, this.brush = d3.svg.brush(), element.addClass(MekkoChart.ClassName), 
                    this.margin = {
                        top: 1,
                        right: 1,
                        bottom: 1,
                        left: 1
                    }, this.yAxisOrientation = visuals.yAxisPosition.left, this.adjustMargins(viewport), 
                    this.sharedColorPalette = new visuals.SharedColorPalette(options.style.colorPalette.dataColors);
                    var showLinesOnX = !0, showLinesOnY = !0, svg = this.svg = d3.select(element.get(0)).append("svg");
                    svg.style("position", "absolute");
                    var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                    this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                    this.labelGraphicsContextScrollable = this.svgScrollable.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                    this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable));
                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                    this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.y2AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), 
                    this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), 
                    this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                    this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), 
                    this.behavior && (this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, !0);
                }, MekkoChart.prototype.renderAxesLabels = function(options) {
                    this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    var margin = this.margin, width = options.viewport.width - (margin.left + margin.right), height = options.viewport.height, fontSize = MekkoChart.FontSize, heightOffset = fontSize, showOnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                    if (!options.hideXAxisTitle) {
                        var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.x).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    transform: visuals.SVGUtil.translate(width / 2, height - heightOffset)
                                });
                            });
                        });
                        xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null), 
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!options.hideYAxisTitle) {
                        var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    transform: "rotate(-90)",
                                    y: showOnRight ? width + margin.right - fontSize : -margin.left,
                                    x: -((height - margin.top - options.legendMargin) / 2),
                                    dy: "1em"
                                });
                            });
                        });
                        yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null), 
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                        var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y2).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    transform: "rotate(-90)",
                                    y: showOnRight ? -margin.left : width + margin.right - fontSize,
                                    x: -((height - margin.top - options.legendMargin) / 2),
                                    dy: "1em"
                                });
                            });
                        });
                        y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null), 
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                }, MekkoChart.prototype.adjustMargins = function(viewport) {
                    var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), xAxis = this.element.find(".x.axis");
                    0 === visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) && 0 === visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) ? (this.margin = {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, xAxis.hide()) : xAxis.show();
                }, MekkoChart.prototype.translateAxes = function(viewport) {
                    this.adjustMargins(viewport);
                    var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), showY1OnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                    this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, height)), 
                    this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0)), 
                    this.y2AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0)), 
                    this.svg.attr({
                        width: viewport.width,
                        height: viewport.height
                    }), this.svg.style("top", this.legend.isVisible() ? this.legend.getMargins().height + "px" : 0), 
                    this.svgScrollable.attr({
                        width: viewport.width,
                        height: viewport.height
                    }), this.svgScrollable.attr({
                        x: 0
                    }), this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.labelGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.isXScrollBarVisible ? (this.svgScrollable.attr({
                        x: this.margin.left
                    }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                    this.labelGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                    this.svgScrollable.attr("width", width), this.svg.attr("width", viewport.width).attr("height", viewport.height + MekkoChart.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", height + margin.top), 
                    this.svg.attr("width", viewport.width + MekkoChart.ScrollBarWidth).attr("height", viewport.height));
                }, MekkoChart.getIsScalar = function(objects, propertyId, type) {
                    var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                    return objects && void 0 !== axisTypeValue ? axisTypeValue === visuals.axisType.scalar && !visuals.AxisHelper.isOrdinal(type) : !visuals.AxisHelper.isOrdinal(type);
                }, MekkoChart.prototype.populateObjectProperties = function(dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}), 
                        this.borderObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "columnBorder", {})) : (this.legendObjectProperties = {}, 
                        this.borderObjectProperties = {}), this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata), 
                        dataViewMetadata && dataViewMetadata.objects) {
                            var categoryAxis = dataViewMetadata.objects.categoryAxis, valueAxis = dataViewMetadata.objects.valueAxis;
                            categoryAxis && (this.categoryAxisProperties.showBorder = categoryAxis.showBorder, 
                            this.categoryAxisProperties.fontSize = categoryAxis.fontSize), valueAxis && (this.valueAxisProperties.fontSize = valueAxis.fontSize);
                        }
                        var axisPosition = this.valueAxisProperties.position;
                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                    }
                }, MekkoChart.prototype.update = function(options) {
                    var dataViews = this.dataViews = options.dataViews;
                    if (this.currentViewport = options.viewport, dataViews && !(this.currentViewport.width < MekkoChart.MinWidth || this.currentViewport.height < MekkoChart.MinHeight)) {
                        0 === this.layers.length && (this.layers = this.createAndInitLayers(dataViews));
                        var layers = this.layers;
                        if (dataViews && dataViews.length > 0) {
                            var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                            warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                        }
                        this.sharedColorPalette.clearPreferredScale();
                        for (var i = 0, len = layers.length; len > i; i++) layers[i].setData(getLayerData(dataViews, i, len)), 
                        len > 1 && this.sharedColorPalette.rotateScale();
                        this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend || this.renderLegend(), 
                        this.render(!this.hasSetData || options.suppressAnimations), this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0;
                    }
                }, MekkoChart.parseLabelSettings = function(objects) {
                    var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(!0), labelsObj = objects.labels, minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;
                    return visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings), 
                    labelSettings.precision < minPrecision && (labelSettings.precision = minPrecision), 
                    labelSettings.precision > maxPrecision && (labelSettings.precision = maxPrecision), 
                    labelSettings;
                }, MekkoChart.parseBorderSettings = function(objects) {
                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                    return width > maxWidth ? width = maxWidth : 0 > width && (width = 0), show || (width = 0), 
                    {
                        show: show,
                        color: color,
                        width: width
                    };
                }, MekkoChart.prototype.enumerateBorder = function(enumeration) {
                    var objects = {
                        columnBorder: this.borderObjectProperties
                    }, show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                    width > maxWidth ? width = maxWidth : 0 > width && (width = 0);
                    var instance = {
                        objectName: "columnBorder",
                        selector: null,
                        properties: {
                            show: show,
                            color: color,
                            width: width
                        }
                    };
                    enumeration.pushInstance(instance);
                }, MekkoChart.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), layersLength = this.layers ? this.layers.length : 0;
                    if ("columnBorder" === options.objectName) this.enumerateBorder(enumeration); else if ("legend" === options.objectName) {
                        if (!this.shouldShowLegendCard()) return;
                        var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : ""), fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: show,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                fontSize: fontSize
                            },
                            objectName: options.objectName
                        });
                    } else "categoryAxis" === options.objectName && this.hasCategoryAxis ? this.getCategoryAxisValues(enumeration) : "valueAxis" === options.objectName && this.getValueAxisValues(enumeration);
                    for (var i = 0, len = layersLength; len > i; i++) {
                        var layer = this.layers[i];
                        layer.enumerateObjectInstances && layer.enumerateObjectInstances(enumeration, options);
                    }
                    return enumeration.complete();
                }, MekkoChart.prototype.shouldShowLegendCard = function() {
                    var layers = this.layers, dataViews = this.dataViews;
                    if (layers && dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; layersLength > i; i++) {
                        if (layers[i].hasLegend()) return !0;
                        var dataView = dataViews[i];
                        if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && (layersWithValuesCtr++, 
                        layersWithValuesCtr > 1)) return !0;
                    }
                    return !1;
                }, MekkoChart.prototype.getCategoryAxisValues = function(enumeration) {
                    var supportedType = visuals.axisType.both, isScalar = !1, logPossible = !!this.axes.x.isLogScaleAllowed, scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ];
                    this.layers && this.layers[0].getSupportedCategoryAxisType && (supportedType = this.layers[0].getSupportedCategoryAxisType(), 
                    isScalar = supportedType === visuals.axisType.scalar ? !0 : visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties)), 
                    isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                    this.categoryAxisProperties.end = null);
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: "categoryAxis",
                        validValues: {
                            axisScale: scaleOptions
                        }
                    };
                    instance.properties.show = this.categoryAxisProperties && null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                    this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                    supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                    isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : visuals.axisScale.linear, 
                    instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                    instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null), 
                    instance.properties.showAxisTitle = this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !1, 
                    instance.properties.showBorder = this.categoryAxisProperties && null != this.categoryAxisProperties.showBorder ? this.categoryAxisProperties.showAxisTitle : !1, 
                    instance.properties.fontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                    enumeration.pushInstance(instance).pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null,
                            fontSize: this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                        },
                        objectName: "categoryAxis",
                        validValues: {
                            axisStyle: this.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                        }
                    });
                }, MekkoChart.prototype.getValueAxisValues = function(enumeration) {
                    var scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ], logPossible = !!this.axes.y1.isLogScaleAllowed, instance = {
                        selector: null,
                        properties: {},
                        objectName: "valueAxis",
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: scaleOptions
                        }
                    };
                    instance.properties.show = this.valueAxisProperties && null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                    this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                    instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : visuals.axisScale.linear, 
                    instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                    instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                    instance.properties.showAxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !1, 
                    instance.properties.fontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                    enumeration.pushInstance(instance).pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null,
                            fontSize: this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                        },
                        objectName: "valueAxis",
                        validValues: {
                            axisStyle: this.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                        }
                    }), 2 === this.layers.length && (instance.properties.secShow = this.valueAxisProperties && null != this.valueAxisProperties.secShow ? this.valueAxisProperties.secShow : this.y2AxisExists, 
                    instance.properties.secShow && (instance.properties.axisLabel = ""));
                }, MekkoChart.prototype.onClearSelection = function() {
                    if (this.hasSetData) for (var i = 0, len = this.layers.length; len > i; i++) {
                        var layer = this.layers[i];
                        layer.onClearSelection(), layer.render(!0);
                    }
                }, MekkoChart.prototype.createAndInitLayers = function(dataViews) {
                    var objects, _this = this;
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        dataViewMetadata && (objects = dataViewMetadata.objects);
                    }
                    var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable), cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                    cartesianOptions.svg = this.axisGraphicsContextScrollable, cartesianOptions.cartesianHost = {
                        updateLegend: function(data) {
                            return _this.legend.drawLegend(data, _this.currentViewport);
                        },
                        getSharedColors: function() {
                            return _this.sharedColorPalette;
                        },
                        triggerRender: void 0
                    };
                    for (var i = 0, len = layers.length; len > i; i++) layers[i].init(cartesianOptions);
                    return layers;
                }, MekkoChart.prototype.renderLegend = function() {
                    for (var layers = this.layers, legendData = {
                        title: "",
                        dataPoints: []
                    }, i = 0, len = layers.length; len > i; i++) this.layerLegendData = layers[i].calculateLegend(), 
                    this.layerLegendData && (legendData.title = 0 === i ? this.layerLegendData.title || "" : legendData.title, 
                    legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                    this.layerLegendData.grouped && (legendData.grouped = !0));
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        legendProperties.fontSize || (legendProperties.fontSize = NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                    } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                    (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []), 
                    this.legend.drawLegend(legendData, this.currentViewport);
                }, MekkoChart.prototype.hideLegends = function() {
                    return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                }, MekkoChart.prototype.addUnitTypeToAxisLabel = function(axes) {
                    var unitType = MekkoChart.getUnitType(axes, function(axis) {
                        return axis.x;
                    });
                    if (axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                    axes.x.axisLabel && unitType && (axes.x.isCategoryAxis ? axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType) : axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType)), 
                    unitType = MekkoChart.getUnitType(axes, function(axis) {
                        return axis.y1;
                    }), axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                    axes.y1.axisLabel && unitType && (axes.y1.isCategoryAxis ? axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType) : axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType)), 
                    axes.y2) {
                        var unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.y2;
                        });
                        this.secValueAxisHasUnitType = null !== unitType, axes.y2.axisLabel && unitType && this.valueAxisProperties && this.valueAxisProperties.secAxisStyle && (this.valueAxisProperties.secAxisStyle === visuals.axisStyle.showBoth ? axes.y2.axisLabel = axes.y2.axisLabel + " (" + unitType + ")" : this.valueAxisProperties.secAxisStyle === visuals.axisStyle.showUnitOnly && (axes.y2.axisLabel = unitType));
                    }
                }, MekkoChart.prototype.shouldRenderSecondaryAxis = function(axisProperties) {
                    return axisProperties && (!this.valueAxisProperties || null == this.valueAxisProperties.secShow || this.valueAxisProperties.secShow) ? axisProperties.values && axisProperties.values.length > 0 : !1;
                }, MekkoChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                    return void 0 === propertyName && (propertyName = "show"), axisProperties ? (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName]) && (axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) ? !1 : axisProperties.values && axisProperties.values.length > 0 : !1;
                }, MekkoChart.prototype.render = function(suppressAnimations) {
                    var legendMargins = this.legendMargins = this.legend.getMargins(), viewport = {
                        height: this.currentViewport.height - legendMargins.height,
                        width: this.currentViewport.width - legendMargins.width
                    }, maxMarginFactor = this.getMaxMarginFactor(), leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
                    this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
                    var xAxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.categoryAxisProperties.fontSize) || void 0), y1AxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.valueAxisProperties.fontSize) || void 0), margin = this.margin;
                    margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2, margin.bottom = MekkoChart.MinBottomMargin, 
                    margin.right = 0;
                    var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                    this.yAxisIsCategorical = axes.y1.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                    var mainAxisScale, preferredViewport, renderXAxis = this.shouldRenderAxis(axes.x), renderY1Axis = this.shouldRenderAxis(axes.y1), renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2), width = viewport.width - (margin.left + margin.right), isScalar = !1;
                    this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                    var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    if (this.layers && (this.layers[0].getVisualCategoryAxisIsScalar && (isScalar = this.layers[0].getVisualCategoryAxisIsScalar()), 
                    !isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea)) {
                        var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness, categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                        preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness), 
                        this.scrollX && preferredViewport && preferredViewport.width > viewport.width && (this.isXScrollBarVisible = !0, 
                        viewport.height -= MekkoChart.ScrollBarWidth), this.scrollY && preferredViewport && preferredViewport.height > viewport.height && (this.isYScrollBarVisible = !0, 
                        viewport.width -= MekkoChart.ScrollBarWidth, width = viewport.width - (margin.left + margin.right));
                    }
                    this.isXScrollBarVisible || this.isYScrollBarVisible ? this.brushGraphicsContext || (this.brushGraphicsContext = this.svg.append("g").classed("x brush", !0)) : (this.svg.selectAll(".brush").remove(), 
                    this.brushGraphicsContext = void 0), axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                    for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0, tickLabelMargins = void 0, chartHasAxisLabels = void 0, axisLabels = void 0; !doneWithMargins && maxIterations > numIterations; ) {
                        numIterations++, tickLabelMargins = getTickLabelMargins({
                            width: width,
                            height: viewport.height
                        }, leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, !1, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? tickLabelMargins.xMax / 1.8 : 0;
                        maxMainYaxisSide += MekkoChart.LeftPadding, maxSecondYaxisSide += MekkoChart.RightPadding, 
                        xMax += MekkoChart.BottomPadding, this.hideAxisLabels(legendMargins) && (axes.x.axisLabel = null, 
                        axes.y1.axisLabel = null, axes.y2 && (axes.y2.axisLabel = null)), this.addUnitTypeToAxisLabel(axes), 
                        axisLabels = {
                            x: axes.x.axisLabel,
                            y: axes.y1.axisLabel,
                            y2: axes.y2 ? axes.y2.axisLabel : null
                        }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                        null != axisLabels.x && (xMax += MekkoChart.XAxisLabelPadding), null != axisLabels.y && (maxMainYaxisSide += MekkoChart.YAxisLabelPadding), 
                        null != axisLabels.y2 && (maxSecondYaxisSide += MekkoChart.YAxisLabelPadding), margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                        margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, margin.bottom = xMax, 
                        this.margin = margin, width = viewport.width - (margin.left + margin.right);
                        var previousTickCountY1 = axes.y1.values.length, previousTickCountY2 = axes.y2 && axes.y2.values.length;
                        axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes), 
                        axes.y1.values.length !== previousTickCountY1 || axes.y2 && axes.y2.values.length !== previousTickCountY2 || (doneWithMargins = !0);
                    }
                    this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
                }, MekkoChart.prototype.hideAxisLabels = function(legendMargins) {
                    return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height + legendMargins.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.visualInitOptions.interactivity.isInteractiveLegend);
                }, MekkoChart.getUnitType = function(axis, axisPropertiesLookup) {
                    return axisPropertiesLookup(axis).formatter && axisPropertiesLookup(axis).formatter.displayUnit && axisPropertiesLookup(axis).formatter.displayUnit.value > 1 ? axisPropertiesLookup(axis).formatter.displayUnit.title : null;
                }, MekkoChart.prototype.getMaxMarginFactor = function() {
                    return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
                }, MekkoChart.getChartViewport = function(viewport, margin) {
                    return {
                        width: viewport.width - margin.left - margin.right,
                        height: viewport.height - margin.top - margin.bottom
                    };
                }, MekkoChart.wordBreak = function(text, axisProperties, columnsWidth, maxHeight, borderWidth) {
                    text.each(function(data, index) {
                        var width, allowedLength, node = d3.select(this);
                        columnsWidth.length >= index ? (width = columnsWidth[index], allowedLength = axisProperties.scale(width)) : allowedLength = axisProperties.xLabelMaxWidth, 
                        node.style("text-anchor", "middle").attr({
                            dx: "0em",
                            dy: "1em",
                            transform: "rotate(0)"
                        }), powerbi.TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);
                    });
                }, MekkoChart.prototype.renderChart = function(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
                    var xLabelColor, yLabelColor, y2LabelColor, xFontSize, yFontSize, bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, layers = this.layers, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
                    if (this.shouldRenderAxis(axes.x)) {
                        axes.x.isCategoryAxis ? (xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                        xFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (xLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                        xFontSize = this.valueAxisProperties && this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                        axes.x.axis.orient("bottom"), axes.x.willLabelsFit || axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        duration ? xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis) : xAxisGraphicsElement.call(axes.x.axis), 
                        xAxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, xLabelColor).call(MekkoChart.setAxisLabelFontSize, xFontSize);
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll("text"), columnWidth = [], borderWidth = 0;
                        this.layers && this.layers.length && (columnWidth = this.layers[0].getColumnsWidth(), 
                        borderWidth = this.layers[0].getBorderWidth()), xAxisGraphicsElement.call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8), 
                        xAxisTextNodes.call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
                    } else this.xAxisGraphicsContext.selectAll("*").remove();
                    if (this.shouldRenderAxis(axes.y1)) {
                        axes.y1.isCategoryAxis ? (yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                        yFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (yLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                        yFontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        axes.y1.axis.tickSize(-width).tickPadding(MekkoChart.TickPaddingY).orient(yAxisOrientation.toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        duration ? y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis) : y1AxisGraphicsElement.call(axes.y1.axis), 
                        y1AxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, yLabelColor).call(MekkoChart.setAxisLabelFontSize, yFontSize), 
                        tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis), 
                        !axes.y2 || this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow ? this.y2AxisGraphicsContext.selectAll("*").remove() : (y2LabelColor = this.valueAxisProperties && this.valueAxisProperties.secLabelColor ? this.valueAxisProperties.secLabelColor : null, 
                        axes.y2.axis.tickPadding(MekkoChart.TickPaddingY).orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase()), 
                        duration ? this.y2AxisGraphicsContext.transition().duration(duration).call(axes.y2.axis) : this.y2AxisGraphicsContext.call(axes.y2.axis), 
                        this.y2AxisGraphicsContext.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, y2LabelColor), 
                        tickLabelMargins.yRight >= leftRightMarginLimit && this.y2AxisGraphicsContext.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.RightPadding, powerbi.TextMeasurementService.svgEllipsis));
                    } else this.y1AxisGraphicsContext.selectAll("*").remove(), this.y2AxisGraphicsContext.selectAll("*").remove();
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1, renderAxisOptions = {
                            axisLabels: axisLabels,
                            legendMargin: this.legendMargins.height,
                            viewport: viewport,
                            hideXAxisTitle: hideXAxisTitle,
                            hideYAxisTitle: hideYAxisTitle,
                            hideY2AxisTitle: hideY2AxisTitle,
                            xLabelColor: xLabelColor,
                            yLabelColor: yLabelColor,
                            y2LabelColor: y2LabelColor,
                            margin: void 0
                        };
                        this.renderAxesLabels(renderAxisOptions);
                    } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    this.translateAxes(viewport);
                    var dataPoints = [], layerBehaviorOptions = [], labelDataPointsGroup = [];
                    if (this.behavior) {
                        for (var i = 0, len = layers.length; len > i; i++) {
                            var result = layers[i].render(suppressAnimations);
                            if (result) if (dataPoints = dataPoints.concat(result.dataPoints), layerBehaviorOptions.push(result.behaviorOptions), 
                            result.labelDataPointGroups) for (var resultLabelDataPointsGroups = result.labelDataPointGroups, j = 0, jlen = resultLabelDataPointsGroups.length; jlen > j; j++) {
                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
                                labelDataPointsGroup.push({
                                    labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels
                                });
                            } else {
                                var resultsLabelDataPoints = result.labelDataPoints, reducedDataPoints = resultsLabelDataPoints;
                                labelDataPointsGroup.push({
                                    labelDataPoints: reducedDataPoints,
                                    maxNumberOfLabels: reducedDataPoints.length
                                });
                            }
                        }
                        var labelLayoutOptions = {
                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
                            startingOffset: NewDataLabelUtils.startingLabelOffset
                        }, labelLayout = new powerbi.LabelLayout(labelLayoutOptions), dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
                        if (layers.length > 1 && NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", .7), 
                        this.animator && !suppressAnimations ? NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration()) : NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels), 
                        this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none"), 
                        this.interactivityService) {
                            var behaviorOptions = {
                                layerOptions: layerBehaviorOptions,
                                clearCatcher: this.clearCatcher
                            };
                            this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                        }
                    }
                }, MekkoChart.darkenZeroLine = function(g) {
                    var zeroTick = g.selectAll("g.tick").filter(function(data) {
                        return 0 === data;
                    }).node();
                    zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                }, MekkoChart.setAxisLabelColor = function(g, fill) {
                    g.selectAll("g.tick text").style("fill", fill ? fill.solid.color : null);
                }, MekkoChart.setAxisLabelFontSize = function(g, fontSize) {
                    var value = jsCommon.PixelConverter.toString(fontSize);
                    g.selectAll("g.tick text").attr("font-size", value);
                }, MekkoChart.moveBorder = function(g, scale, borderWidth, yOffset) {
                    void 0 === yOffset && (yOffset = 0), g.selectAll("g.tick").attr("transform", function(value, index) {
                        return visuals.SVGUtil.translate(scale(value) + borderWidth * index, yOffset);
                    });
                }, MekkoChart.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Category"
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Series"
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Y Axis"
                    }, {
                        name: "Width",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Axis width"
                    } ],
                    objects: {
                        columnBorder: {
                            displayName: "Column Border",
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                width: {
                                    displayName: "Width",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                showSeries: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                    type: {
                                        numeric: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                showAll: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_ShowAll"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                    type: {
                                        formatting: {
                                            legendPosition: !0
                                        }
                                    }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: "Title text",
                                    type: {
                                        text: !0
                                    }
                                },
                                fontSize: {
                                    displayName: "Text size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                    type: {
                                        formatting: {
                                            yAxisPosition: !0
                                        }
                                    }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                    type: {
                                        formatting: {
                                            axisScale: !0
                                        }
                                    }
                                },
                                axisType: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                                    type: {
                                        formatting: {
                                            axisType: !0
                                        }
                                    }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                    type: {
                                        formatting: {
                                            axisStyle: !0
                                        }
                                    }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        valueAxis: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                    type: {
                                        formatting: {
                                            yAxisPosition: !0
                                        }
                                    }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                    type: {
                                        formatting: {
                                            axisScale: !0
                                        }
                                    }
                                },
                                intersection: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Intersection"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                    type: {
                                        formatting: {
                                            axisStyle: !0
                                        }
                                    }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                    type: {
                                        fillRule: {}
                                    },
                                    rule: {
                                        inputRole: "Gradient",
                                        output: {
                                            property: "fill",
                                            selector: [ "Category" ]
                                        }
                                    }
                                }
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                min: 0,
                                max: 1
                            },
                            Series: {
                                min: 0,
                                max: 1
                            },
                            Y: {
                                min: 0,
                                max: 1
                            },
                            Width: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        "for": {
                                            "in": "Y"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Width"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            },
                            rowCount: {
                                preferred: {
                                    min: 1,
                                    max: 1
                                },
                                supported: {
                                    min: 0
                                }
                            }
                        }
                    } ],
                    supportsHighlight: !0,
                    sorting: {
                        "default": {}
                    },
                    drilldown: {
                        roles: [ "Category" ]
                    }
                }, MekkoChart.properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    columnBorder: {
                        show: {
                            objectName: "columnBorder",
                            propertyName: "show"
                        },
                        color: {
                            objectName: "columnBorder",
                            propertyName: "color"
                        },
                        width: {
                            objectName: "columnBorder",
                            propertyName: "width"
                        }
                    }
                }, MekkoChart.DefaultSettings = {
                    columnBorder: {
                        show: !0,
                        color: "#fff",
                        width: 2,
                        maxWidth: 5
                    },
                    labelSettings: {
                        maxPrecision: 4,
                        minPrecision: 0
                    }
                }, MekkoChart.MinOrdinalRectThickness = 20, MekkoChart.MinScalarRectThickness = 2, 
                MekkoChart.OuterPaddingRatio = .4, MekkoChart.InnerPaddingRatio = .2, MekkoChart.TickLabelPadding = 2, 
                MekkoChart.ClassName = "cartesianChart", MekkoChart.AxisGraphicsContextClassName = "axisGraphicsContext", 
                MekkoChart.MaxMarginFactor = .25, MekkoChart.MinBottomMargin = 50, MekkoChart.LeftPadding = 10, 
                MekkoChart.RightPadding = 10, MekkoChart.BottomPadding = 16, MekkoChart.YAxisLabelPadding = 20, 
                MekkoChart.XAxisLabelPadding = 20, MekkoChart.TickPaddingY = 10, MekkoChart.TickPaddingRotatedX = 5, 
                MekkoChart.FontSize = 11, MekkoChart.MaxNumberOfLabels = 100, MekkoChart.MinWidth = 100, 
                MekkoChart.MinHeight = 100, MekkoChart.ScrollBarWidth = 10, MekkoChart;
            }();
            samples.MekkoChart = MekkoChart, samples.createLayers = createLayers;
            var EnumExtensions = jsCommon.EnumExtensions, ArrayExtensions = jsCommon.ArrayExtensions, flagBar = 2, flagStacked = 16, RoleNames = {
                category: "Category",
                series: "Series",
                y: "Y",
                width: "Width"
            }, MekkoColumnChart = function() {
                function MekkoColumnChart(options) {
                    var chartType = options.chartType;
                    this.chartType = chartType, this.categoryAxisType = null, this.animator = options.animator, 
                    this.isScrollable = options.isScrollable, this.interactivityService = options.interactivityService;
                }
                return MekkoColumnChart.prototype.init = function(options) {
                    this.svg = options.svg, this.unclippedGraphicsContext = this.svg.append("g").classed("columnChartUnclippedGraphicsContext", !0), 
                    this.mainGraphicsContext = this.unclippedGraphicsContext.append("svg").classed("columnChartMainGraphicsContext", !0), 
                    this.labelGraphicsContext = this.svg.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                    this.style = options.style, this.currentViewport = options.viewport, this.hostService = options.host, 
                    this.interactivity = options.interactivity, this.colors = this.style.colorPalette.dataColors, 
                    this.cartesianVisualHost = options.cartesianHost, this.options = options, this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                    var element = this.element = options.element;
                    element.addClass(MekkoColumnChart.ColumnChartClassName), this.columnChart = new MekkoColumnChartStrategy();
                }, MekkoColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                    var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right), metaDataColumn = this.data ? this.data.categoryMetadata : void 0, categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isScalar = this.data ? this.data.scalarCategoryAxis : !1, domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                    return visuals.CartesianChart.getLayout(this.data, {
                        availableWidth: availableWidth,
                        categoryCount: numCategoryValues,
                        domain: domain,
                        isScalar: isScalar,
                        isScrollable: this.isScrollable,
                        trimOrdinalDataOnOverflow: !1
                    });
                }, MekkoColumnChart.getBorderWidth = function(border) {
                    if (!border || !border.show || !border.width) return 0;
                    var width = border.width;
                    return 0 > width ? 0 : width > border.maxWidth ? border.maxWidth : width;
                }, MekkoColumnChart.getBorderColor = function(border) {
                    return border ? border.color : MekkoChart.DefaultSettings.columnBorder.color;
                }, MekkoColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                    void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                    void 0 === supportsOverflow && (supportsOverflow = !1), void 0 === dataViewMetadata && (dataViewMetadata = null);
                    var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties), dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                    var converterStrategy = new ColumnChartConverterHelper(dataView), categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString), categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : void 0, borderSettings = MekkoChart.DefaultSettings.columnBorder, labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(!0), defaultDataPointColor = void 0, showAllDataPoints = void 0;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints), 
                        labelSettings = MekkoChart.parseLabelSettings(objects), borderSettings = MekkoChart.parseBorderSettings(objects);
                    }
                    for (var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor), legend = legendAndSeriesInfo.legend.dataPoints, seriesSources = legendAndSeriesInfo.seriesSources, result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata), columnSeries = result.series, valuesMetadata = [], j = 0, jlen = legend.length; jlen > j; j++) valuesMetadata.push(seriesSources[j]);
                    var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                    return {
                        categories: categories,
                        categoriesWidth: result.categoriesWidth,
                        categoryFormatter: categoryFormatter,
                        series: columnSeries,
                        valuesMetadata: valuesMetadata,
                        legendData: legendAndSeriesInfo.legend,
                        hasHighlights: result.hasHighlights,
                        categoryMetadata: categoryMetadata,
                        scalarCategoryAxis: isScalar,
                        borderSettings: borderSettings,
                        labelSettings: labelSettings,
                        axesLabels: {
                            x: labels.xAxisLabel,
                            y: labels.yAxisLabel
                        },
                        hasDynamicSeries: result.hasDynamicSeries,
                        defaultDataPointColor: defaultDataPointColor,
                        showAllDataPoints: showAllDataPoints,
                        isMultiMeasure: !1
                    };
                }, MekkoColumnChart.getStackedMultiplier = function(rawValues, rowIdx, seriesCount, categoryCount) {
                    for (var pos = 0, neg = 0, i = 0; seriesCount > i; i++) {
                        var value = rawValues[i][rowIdx];
                        value = visuals.AxisHelper.normalizeNonFiniteNumber(value), value > 0 ? pos += value : 0 > value && (neg -= value);
                    }
                    var absTotal = pos + neg;
                    return {
                        pos: pos ? pos / absTotal / pos : 1,
                        neg: neg ? neg / absTotal / neg : 1
                    };
                }, MekkoColumnChart.createDataPoints = function(dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
                    void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                    void 0 === supportsOverflow && (supportsOverflow = !1);
                    var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : void 0, categoryCount = categories.length, seriesCount = legend.length, columnSeries = [];
                    if (1 > seriesCount || 1 > categoryCount || null === categories[0]) return {
                        series: columnSeries,
                        hasHighlights: !1,
                        hasDynamicSeries: !1,
                        categoriesWidth: []
                    };
                    var dvCategories = dataViewCat.categories;
                    categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                    var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata), isDateTime = visuals.AxisHelper.isDateTime(categoryType), baseValuesPos = [], baseValuesNeg = [], rawValues = [], rawHighlightValues = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source), widthColumns = [], widthIndex = -1, seriesIndex = 0, highlightsOverflow = !1, hasHighlights = converterStrategy.hasHighlightValues(0);
                    for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width] && !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
                        widthIndex = seriesIndex;
                        for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; valuesLen > i; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                    } else {
                        for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                            var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                            if (seriesValues[categoryIndex] = value, hasHighlights) {
                                var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                seriesHighlightValues[categoryIndex] = highlightValue, value >= 0 && highlightValue >= 0 && value >= highlightValue || 0 >= value && 0 >= highlightValue && highlightValue >= value || (highlightsOverflow = !0);
                            }
                        }
                        rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                    }
                    if (highlightsOverflow && !supportsOverflow && (highlightsOverflow = !1, hasHighlights = !1, 
                    rawValues = rawHighlightValues), widthColumns.length < 1) for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
                        widthIndex = seriesIndex;
                        for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; valuesLen > i; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                    } else ;
                    if (widthColumns.length < 1) for (seriesIndex = 0; categoryCount > seriesIndex; seriesIndex++) widthColumns.push(1);
                    var totalSum = d3.sum(widthColumns), linearScale = d3.scale.linear().domain([ 0, totalSum ]).range([ 0, 1 ]), columnStartX = [ 0 ], columnWidth = [];
                    for (seriesIndex = 0; categoryCount - 1 > seriesIndex; seriesIndex++) {
                        var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
                        columnStartX.push(stepWidth);
                    }
                    for (seriesIndex = 0; categoryCount > seriesIndex; seriesIndex++) columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]), 
                    columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
                    var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                    for (seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                        var seriesLabelSettings, seriesDataPoints = [], legendItem = legend[seriesIndex];
                        if (!hasDynamicSeries) {
                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                            labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                        }
                        var series = {
                            displayName: legendItem.label,
                            key: "series" + seriesIndex,
                            index: seriesIndex,
                            data: seriesDataPoints,
                            identity: legendItem.identity,
                            color: legendItem.color,
                            labelSettings: seriesLabelSettings
                        };
                        seriesCount > 1 && (dataPointObjects = seriesObjectsList[seriesIndex]);
                        for (var metadata = dataViewCat.values[seriesIndex].source, categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                            0 === seriesIndex && (baseValuesPos.push(0), baseValuesNeg.push(0));
                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                            if (!(null == value && seriesIndex > 0)) {
                                var originalValue = value, categoryValue = categories[categoryIndex];
                                if (isDateTime && categoryValue && (categoryValue = categoryValue.getTime()), !isScalar || null != categoryValue && !isNaN(categoryValue)) {
                                    var multipliers;
                                    is100PercentStacked && (multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount));
                                    var unadjustedValue = value, isNegative = 0 > value;
                                    multipliers && (value *= isNegative ? multipliers.neg : multipliers.pos);
                                    var position, valueAbsolute = Math.abs(value);
                                    isNegative ? (position = baseValuesNeg[categoryIndex], isNaN(valueAbsolute) || (baseValuesNeg[categoryIndex] -= valueAbsolute)) : (isNaN(valueAbsolute) || (baseValuesPos[categoryIndex] += valueAbsolute), 
                                    position = baseValuesPos[categoryIndex]);
                                    var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null, category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataViewCat.values, columnGroup).withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex)).createSelectionId(), rawCategoryValue = categories[categoryIndex], color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects), seriesData = [];
                                    if (columnGroup) {
                                        var seriesValueColumn = {
                                            values: [],
                                            source: dataViewCat.values.source
                                        };
                                        seriesData.push({
                                            value: columnGroup.name,
                                            metadata: seriesValueColumn
                                        });
                                        for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
                                            var columnValues = columnGroup.values[columnIndex];
                                            seriesData.push({
                                                value: columnValues.values[categoryIndex],
                                                metadata: columnValues
                                            });
                                        }
                                    }
                                    var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, rawCategoryValue, originalValue, [ category ], seriesData, null, categoryIndex), dataPointLabelSettings = series && series.labelSettings ? series.labelSettings : defaultLabelSettings, labelColor = dataPointLabelSettings.labelColor, lastValue = void 0;
                                    EnumExtensions.hasFlag(chartType, flagStacked) && (lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues), 
                                    labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor), 
                                    value = columnWidth[categoryIndex];
                                    var originalPosition = columnStartX[categoryIndex], dataPoint = {
                                        categoryValue: categoryValue,
                                        value: value,
                                        position: position,
                                        valueAbsolute: valueAbsolute,
                                        valueOriginal: unadjustedValue,
                                        seriesIndex: seriesIndex,
                                        labelSettings: dataPointLabelSettings,
                                        categoryIndex: categoryIndex,
                                        color: color,
                                        selected: !1,
                                        originalValue: value,
                                        originalPosition: originalPosition,
                                        originalValueAbsolute: valueAbsolute,
                                        identity: identity,
                                        key: identity.getKey(),
                                        tooltipInfo: tooltipInfo,
                                        labelFill: labelColor,
                                        labelFormatString: metadata.format,
                                        lastSeries: lastValue,
                                        chartType: chartType
                                    };
                                    if (seriesDataPoints.push(dataPoint), hasHighlights) {
                                        var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex], unadjustedValueHighlight = valueHighlight, highlightedTooltip = !0;
                                        null === valueHighlight && (valueHighlight = 0, highlightedTooltip = !1), is100PercentStacked && (valueHighlight *= multipliers.pos);
                                        var absoluteValueHighlight = Math.abs(valueHighlight), highlightPosition = position;
                                        valueHighlight > 0 ? highlightPosition -= valueAbsolute - absoluteValueHighlight : 0 === valueHighlight && value > 0 && (highlightPosition -= valueAbsolute);
                                        var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), rawCategoryValue = categories[categoryIndex];
                                        highlightedTooltip && (dataPoint.tooltipInfo = tooltipInfo);
                                        var highlightDataPoint = {
                                            categoryValue: categoryValue,
                                            value: value,
                                            position: highlightPosition,
                                            valueAbsolute: absoluteValueHighlight,
                                            valueOriginal: unadjustedValueHighlight,
                                            seriesIndex: seriesIndex,
                                            labelSettings: dataPointLabelSettings,
                                            categoryIndex: categoryIndex,
                                            color: color,
                                            selected: !1,
                                            highlight: !0,
                                            originalValue: value,
                                            originalPosition: originalPosition,
                                            originalValueAbsolute: valueAbsolute,
                                            drawThinner: highlightsOverflow,
                                            identity: highlightIdentity,
                                            key: highlightIdentity.getKey(),
                                            tooltipInfo: tooltipInfo,
                                            labelFormatString: metadata.format,
                                            labelFill: labelColor,
                                            lastSeries: lastValue,
                                            chartType: chartType
                                        };
                                        seriesDataPoints.push(highlightDataPoint);
                                    }
                                }
                            }
                        }
                        columnSeries.push(series);
                    }
                    return {
                        series: columnSeries,
                        categoriesWidth: columnWidth,
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: hasDynamicSeries
                    };
                }, MekkoColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                    if (dataPointObjects) {
                        var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                        if (colorOverride) return colorOverride;
                    }
                    return legendItem.color;
                }, MekkoColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                    for (var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && 1 !== seriesCount), i = seriesIndex + 1; seriesCount > i; i++) {
                        var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                        if (null !== nextValues && ((!isNegative || isNegative && 0 === seriesIndex) && nextValues > 0 || isNegative && 0 !== seriesIndex)) {
                            lastValue = !1;
                            break;
                        }
                    }
                    return lastValue;
                }, MekkoColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                    void 0 === startIndex && (startIndex = 0);
                    var newSeries = [];
                    if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) {
                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        iNewSeries.data = series[i].data.filter(function(d) {
                            return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                        });
                    }
                    return newSeries;
                }, MekkoColumnChart.getInteractiveColumnChartDomElement = function(element) {
                    return element.children("svg").get(0);
                }, MekkoColumnChart.prototype.getColumnsWidth = function() {
                    var data = this.data;
                    return data && data.series && data.series[0] && data.series[0].data ? data.categoriesWidth : [];
                }, MekkoColumnChart.prototype.getBorderWidth = function() {
                    return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
                }, MekkoColumnChart.prototype.setData = function(dataViews) {
                    var is100PctStacked = !0;
                    if (this.data = {
                        categories: [],
                        categoriesWidth: [],
                        categoryFormatter: null,
                        series: [],
                        valuesMetadata: [],
                        legendData: null,
                        hasHighlights: !1,
                        categoryMetadata: null,
                        scalarCategoryAxis: !1,
                        borderSettings: null,
                        labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                        axesLabels: {
                            x: null,
                            y: null
                        },
                        hasDynamicSeries: !1,
                        defaultDataPointColor: null,
                        isMultiMeasure: !1
                    }, dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView && dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), !0, !1, this.supportsOverflow, dataView.metadata, this.chartType);
                            for (var series = this.data.series, i = 0, ilen = series.length; ilen > i; i++) {
                                var currentSeries = series[i];
                                this.interactivityService && this.interactivityService.applySelectionStateToData(currentSeries.data);
                            }
                        }
                    }
                }, MekkoColumnChart.prototype.calculateLegend = function() {
                    if (this.interactivity && this.interactivity.isInteractiveLegend) return this.createInteractiveMekkoLegendDataPoints(0);
                    var legendData = this.data ? this.data.legendData : null, MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
                    return ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints) ? null : legendData;
                }, MekkoColumnChart.prototype.hasLegend = function() {
                    return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
                }, MekkoColumnChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                    switch (options.objectName) {
                      case "dataPoint":
                        visuals.GradientUtils.hasGradientRole(this.dataViewCat) || this.enumerateDataPoints(enumeration);
                        break;

                      case "labels":
                        this.enumerateDataLabels(enumeration);
                    }
                }, MekkoColumnChart.prototype.enumerateDataLabels = function(enumeration) {
                    var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
                    if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !1)), 
                    0 !== seriesCount && !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) for (var i = 0; seriesCount > i; i++) {
                        var series = data.series[i], labelSettings = series.labelSettings ? series.labelSettings : this.data.labelSettings;
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !0, series));
                    }
                }, MekkoColumnChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, isSeries, series) {
                    var is100PctStacked = !0;
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !isSeries,
                        displayUnits: is100PctStacked,
                        precision: !0,
                        selector: series && series.identity ? series.identity.getSelector() : null
                    };
                }, MekkoColumnChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data && data.series) {
                        var seriesCount = data.series.length;
                        if (0 !== seriesCount) if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) for (var i = 0; seriesCount > i; i++) {
                            var series = data.series[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: series.displayName,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: series.color
                                        }
                                    }
                                }
                            });
                        } else {
                            var singleSeriesData = data.series[0].data, categoryFormatter = data.categoryFormatter;
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: {
                                            color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                        }
                                    }
                                }
                            }).pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    showAllDataPoints: !!data.showAllDataPoints
                                }
                            });
                            for (var i = 0; i < singleSeriesData.length; i++) {
                                var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                    selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), !0),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: singleSeriesDataPoints.color
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }, MekkoColumnChart.prototype.calculateAxesProperties = function(options) {
                    var data = this.data;
                    this.currentViewport = options.viewport;
                    var margin = this.margin = options.margin, origCatgSize = data && data.categories ? data.categories.length : 0, chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                        categoryCount: 0,
                        categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                        outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                        isScalar: !1
                    };
                    this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null, this.columnChart.setData(data);
                    var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                    preferredPlotArea.width === this.currentViewport.width && (preferredPlotArea.width -= margin.left + margin.right), 
                    preferredPlotArea.height -= margin.top + margin.bottom;
                    var is100Pct = !0, chartContext = {
                        height: preferredPlotArea.height,
                        width: preferredPlotArea.width,
                        duration: 0,
                        hostService: this.hostService,
                        unclippedGraphicsContext: this.unclippedGraphicsContext,
                        mainGraphicsContext: this.mainGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        margin: this.margin,
                        layout: chartLayout,
                        animator: this.animator,
                        interactivityService: this.interactivityService,
                        viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                        viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                        is100Pct: is100Pct,
                        isComboChart: !0
                    };
                    this.ApplyInteractivity(chartContext), this.columnChart.setupVisualProps(chartContext);
                    var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                    if (isBarChart) {
                        var temp = options.forcedXDomain;
                        options.forcedXDomain = options.forcedYDomain, options.forcedYDomain = temp;
                    }
                    return this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType), 
                    this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType), 
                    options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis ? this.xAxisProperties.axisLabel = data.axesLabels.x : this.xAxisProperties.axisLabel = null, 
                    options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis ? this.yAxisProperties.axisLabel = data.axesLabels.y : this.yAxisProperties.axisLabel = null, 
                    [ this.xAxisProperties, this.yAxisProperties ];
                }, MekkoColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                    var viewport = {
                        height: this.currentViewport.height,
                        width: this.currentViewport.width
                    };
                    if (this.isScrollable && !isScalar) {
                        var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                        EnumExtensions.hasFlag(this.chartType, flagBar) ? viewport.height = Math.max(preferredWidth, viewport.height) : viewport.width = Math.max(preferredWidth, viewport.width);
                    }
                    return viewport;
                }, MekkoColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                    var _this = this, interactivity = this.interactivity;
                    if (interactivity && (interactivity.dragDataPoint && (chartContext.onDragStart = function(datum) {
                        datum.identity && _this.hostService.onDragStart({
                            event: d3.event,
                            data: {
                                data: datum.identity.getSelector()
                            }
                        });
                    }), interactivity.isInteractiveLegend)) {
                        var dragMove = function() {
                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]), x = mousePoint[0], y = mousePoint[1], index = _this.columnChart.getClosestColumnIndex(x, y);
                            _this.selectColumn(index);
                        }, ColumnChartSvg = visuals.ColumnChart.getInteractiveColumnChartDomElement(this.element);
                        this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove);
                        var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                        this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                    }
                }, MekkoColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                    if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== indexOfColumnSelected) {
                        var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected), MekkoLegendDataPoints = legendData.dataPoints;
                        this.cartesianVisualHost.updateLegend(legendData), MekkoLegendDataPoints.length > 0 && this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex), 
                        this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                    }
                }, MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function(columnIndex) {
                    var data = this.data;
                    if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) return {
                        dataPoints: []
                    };
                    for (var formatStringProp = visuals.columnChartProps.general.formatString, MekkoLegendDataPoints = [], category = data.categories && data.categories[columnIndex], allSeries = data.series, dataPoints = data.legendData && data.legendData.dataPoints, converterStrategy = new ColumnChartConverterHelper(this.dataViewCat), i = 0, len = allSeries.length; len > i; i++) {
                        var dataPointColor, measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex), valueMetadata = data.valuesMetadata[i], formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                        if (1 === allSeries.length) {
                            var series = allSeries[0];
                            dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                        } else dataPointColor = dataPoints.length > i && dataPoints[i].color;
                        MekkoLegendDataPoints.push({
                            color: dataPointColor,
                            icon: visuals.LegendIcon.Box,
                            label: formattedLabel,
                            category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                            identity: visuals.SelectionId.createNull(),
                            selected: !1
                        });
                    }
                    return {
                        dataPoints: MekkoLegendDataPoints
                    };
                }, MekkoColumnChart.prototype.overrideXScale = function(xProperties) {
                    this.xAxisProperties = xProperties;
                }, MekkoColumnChart.prototype.render = function(suppressAnimations) {
                    var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations), data = this.data, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right);
                    this.mainGraphicsContext.attr("height", height).attr("width", width), visuals.TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                    var allDataPoints = [], behaviorOptions = void 0;
                    if (this.interactivityService) {
                        for (var i = 0, ilen = data.series.length; ilen > i; i++) allDataPoints = allDataPoints.concat(data.series[i].data);
                        behaviorOptions = {
                            datapoints: allDataPoints,
                            bars: MekkoColumnChartDrawInfo.shapesSelection,
                            hasHighlights: data.hasHighlights,
                            eventGroup: this.mainGraphicsContext,
                            mainGraphicsContext: this.mainGraphicsContext,
                            viewport: MekkoColumnChartDrawInfo.viewport,
                            axisOptions: MekkoColumnChartDrawInfo.axisOptions,
                            showLabel: data.labelSettings.show
                        };
                    }
                    return this.interactivity && this.interactivity.isInteractiveLegend && this.data.series.length > 0 && this.selectColumn(0, !0), 
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                        dataPoints: allDataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
                        labelsAreNumeric: !0
                    };
                }, MekkoColumnChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                    return this.data ? this.data.scalarCategoryAxis : !1;
                }, MekkoColumnChart.prototype.getSupportedCategoryAxisType = function() {
                    var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                    return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                }, MekkoColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                    var data = powerbi.Prototype.inherit(this.data);
                    return data.series = visuals.ColumnChart.sliceSeries(data.series, endIndex, startIndex), 
                    data.categories = data.categories.slice(startIndex, endIndex), this.columnChart.setData(data), 
                    data;
                }, MekkoColumnChart.ColumnChartClassName = "columnChart", MekkoColumnChart.SeriesClasses = createClassAndSelector("series"), 
                MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder"), MekkoColumnChart;
            }();
            samples.MekkoColumnChart = MekkoColumnChart;
            var ColumnChartConverterHelper = function() {
                function ColumnChartConverterHelper(dataView) {
                    this.dataView = dataView;
                }
                return ColumnChartConverterHelper.hasRole = function(column, name) {
                    var roles = column.roles;
                    return roles && roles[name];
                }, ColumnChartConverterHelper.prototype.getLegend = function(colors, defaultColor) {
                    var legend = [], seriesSources = [], seriesObjects = [], grouped = !1, colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor), legendTitle = void 0;
                    if (this.dataView && this.dataView.values) {
                        for (var allValues = this.dataView.values, valueGroups = allValues.grouped(), hasDynamicSeries = !(!allValues || !allValues.source), formatStringProp = visuals.columnChartProps.general.formatString, valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsLen > valueGroupsIndex; valueGroupsIndex++) for (var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values, valueIndex = 0, valuesLen = values.length; valuesLen > valueIndex; valueIndex++) {
                            var series = values[valueIndex], source = series.source;
                            if (!ColumnChartConverterHelper.hasRole(source, "Width") || ColumnChartConverterHelper.hasRole(source, "Y")) {
                                seriesSources.push(source), seriesObjects.push(series.objects);
                                var selectionId = series.identity ? visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex)), label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                                legend.push({
                                    icon: visuals.LegendIcon.Box,
                                    color: color,
                                    label: label,
                                    identity: selectionId,
                                    selected: !1
                                }), series.identity && void 0 !== source.groupName && (grouped = !0);
                            }
                        }
                        var dvValues = this.dataView.values;
                        legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                    }
                    var legendData = {
                        title: legendTitle,
                        dataPoints: legend,
                        grouped: grouped
                    };
                    return {
                        legend: legendData,
                        seriesSources: seriesSources,
                        seriesObjects: seriesObjects
                    };
                }, ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                    return this.dataView.values[series].values[category];
                }, ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                    return this.dataView.values[index].source.queryName;
                }, ColumnChartConverterHelper.prototype.hasHighlightValues = function(series) {
                    var column = this.dataView && this.dataView.values ? this.dataView.values[series] : void 0;
                    return column && !!column.highlights;
                }, ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                    return this.dataView.values[series].highlights[category];
                }, ColumnChartConverterHelper;
            }(), MekkoChartBehavior = function() {
                function MekkoChartBehavior(behaviors) {
                    this.behaviors = behaviors;
                }
                return MekkoChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; ilen > i; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                    options.clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, MekkoChartBehavior.prototype.renderSelection = function(hasSelection) {
                    for (var i = 0; i < this.behaviors.length; i++) this.behaviors[i].renderSelection(hasSelection);
                }, MekkoChartBehavior;
            }();
            samples.MekkoChartBehavior = MekkoChartBehavior;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, SankeyDiagram = function() {
                function SankeyDiagram(constructorOptions) {
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }, this.nodeWidth = 21.5, this.curvatureOfLinks = .5, constructorOptions && (this.svg = constructorOptions.svg, 
                    this.margin = constructorOptions.margin || this.margin, this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks);
                }
                return SankeyDiagram.getProperties = function(capabilities) {
                    var result = {};
                    for (var objectKey in capabilities.objects) {
                        result[objectKey] = {};
                        for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                            objectName: objectKey,
                            propertyName: propKey
                        };
                    }
                    return result;
                }, Object.defineProperty(SankeyDiagram.prototype, "textProperties", {
                    get: function() {
                        return {
                            fontFamily: this.root.style("font-family"),
                            fontSize: jsCommon.PixelConverter.fromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)
                        };
                    },
                    enumerable: !0,
                    configurable: !0
                }), SankeyDiagram.prototype.init = function(visualsInitOptions) {
                    this.svg ? this.root = this.svg : this.root = d3.select(visualsInitOptions.element.get(0)).append("svg"), 
                    this.selectionManager = new SelectionManager({
                        hostServices: visualsInitOptions.host
                    });
                    var style = visualsInitOptions.style;
                    this.colours = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                    this.root.classed(SankeyDiagram.ClassName, !0), this.main = this.root.append("g"), 
                    this.links = this.main.append("g").classed(SankeyDiagram.Links["class"], !0), this.nodes = this.main.append("g").classed(SankeyDiagram.Nodes["class"], !0);
                }, SankeyDiagram.prototype.update = function(visualUpdateOptions) {
                    if (visualUpdateOptions && visualUpdateOptions.dataViews) {
                        var sankeyDiagramDataView, dataView = visualUpdateOptions.dataViews[0];
                        this.updateViewport(visualUpdateOptions.viewport), sankeyDiagramDataView = this.converter(dataView), 
                        this.findNodePosition(sankeyDiagramDataView), this.dataView = sankeyDiagramDataView, 
                        this.render(sankeyDiagramDataView);
                    }
                }, SankeyDiagram.prototype.updateViewport = function(viewport) {
                    var height, width;
                    height = this.getPositiveNumber(viewport.height), width = this.getPositiveNumber(viewport.width), 
                    this.viewport = {
                        height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
                        width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
                    }, this.updateElements(height, width);
                }, SankeyDiagram.prototype.getPositiveNumber = function(value) {
                    return 0 > value || isNaN(value) || value === 1 / 0 || value === -(1 / 0) ? 0 : value;
                }, SankeyDiagram.prototype.updateElements = function(height, width) {
                    this.root.attr({
                        height: height,
                        width: width
                    }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                }, SankeyDiagram.prototype.converter = function(dataView) {
                    var _this = this;
                    if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[1] && dataView.categorical.categories[0].values && dataView.categorical.categories[1].values)) return {
                        nodes: [],
                        links: [],
                        settings: {
                            scale: {
                                x: 1,
                                y: 1
                            },
                            colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                            fontSize: SankeyDiagram.DefaultSettings.fontSize
                        }
                    };
                    var allCategories, valueFormatterForCategories, valuesFormatterForWeigth, objects, labelColour, settings, shiftOfColour, nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = valuesColumn && valuesColumn.values && valuesColumn.values.map(function(x) {
                        return x || 0;
                    }) || [], formatOfWeigth = "g", linksObjects = dataView.categorical.categories[0].objects || [], identities = [];
                    return dataView.categorical.categories[0].identity && (identities = identities.concat(dataView.categorical.categories[0].identity)), 
                    dataView.categorical.categories[1].identity && (identities = identities.concat(dataView.categorical.categories[1].identity)), 
                    objects = this.getObjectsFromDataView(dataView), labelColour = this.getColour(SankeyDiagram.Properties.labels.fill, SankeyDiagram.DefaultSettings.colourOfLabels, objects), 
                    valuesColumn && valuesColumn.source && (formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties.general.formatString)), 
                    dataPoints = categories.map(function(item, index) {
                        return {
                            source: item,
                            destination: secondCategories[index],
                            weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1
                        };
                    }), allCategories = categories.concat(secondCategories), valueFormatterForCategories = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties.general.formatString),
                        value: allCategories[0],
                        value2: allCategories[allCategories.length - 1]
                    }), valuesFormatterForWeigth = ValueFormatter.create({
                        format: formatOfWeigth,
                        value: Math.max(d3.max(weightValues) || 1, 1)
                    }), allCategories.forEach(function(item, index) {
                        if (!nodes.some(function(node) {
                            return item === node.label.name ? (node.selectionIds.push(visuals.SelectionId.createWithId(identities[index])), 
                            !0) : !1;
                        })) {
                            var label, selectionId, formattedValue = valueFormatterForCategories.format(item), textProperties = {
                                text: formattedValue,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            };
                            label = {
                                name: item,
                                formattedName: valueFormatterForCategories.format(item),
                                width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                                height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
                                colour: labelColour
                            }, selectionId = visuals.SelectionId.createWithId(identities[index]), nodes.push({
                                label: label,
                                links: [],
                                inputWeight: 0,
                                outputWeight: 0,
                                width: _this.nodeWidth,
                                height: 0,
                                colour: SankeyDiagram.DefaultColourOfNode,
                                tooltipData: [],
                                selectionIds: [ selectionId ]
                            });
                        }
                    }), shiftOfColour = this.colours.getAllColors().length / nodes.length, nodes.forEach(function(node, index) {
                        node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
                    }), dataPoints.forEach(function(dataPoint, index) {
                        var sourceNode, destinationNode, link, linkColour;
                        dataPoint.source !== dataPoint.destination && (nodes.forEach(function(node) {
                            node.label.name === dataPoint.source && (sourceNode = node), node.label.name === dataPoint.destination && (destinationNode = node);
                        }), linkColour = _this.getColour(SankeyDiagram.Properties.links.fill, SankeyDiagram.DefaultColourOfLink, linksObjects[index]), 
                        link = {
                            source: sourceNode,
                            destination: destinationNode,
                            weigth: dataPoint.weigth,
                            height: dataPoint.weigth,
                            colour: linkColour,
                            tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
                            selectionId: visuals.SelectionId.createWithId(identities[index])
                        }, links.push(link), sourceNode.links.push(link), destinationNode.links.push(link), 
                        _this.updateValueOfNode(sourceNode), _this.updateValueOfNode(destinationNode), sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight), 
                        destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight));
                    }), settings = this.parseSettings(objects), settings.colourOfLabels = labelColour, 
                    {
                        nodes: nodes,
                        links: links,
                        settings: settings
                    };
                }, SankeyDiagram.prototype.getObjectsFromDataView = function(dataView) {
                    return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                }, SankeyDiagram.prototype.getColour = function(properties, defaultColor, objects) {
                    var colorHelper;
                    return colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor), 
                    colorHelper.getColorForMeasure(objects, "");
                }, SankeyDiagram.prototype.getTooltipDataForLink = function(valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
                    var formattedLinkWeight;
                    return formattedLinkWeight = valueFormatter && valueFormatter.format ? valueFormatter.format(linkWeight) : linkWeight.toString(), 
                    [ {
                        displayName: SankeyDiagram.RoleNames.rows,
                        value: sourceNodeName
                    }, {
                        displayName: SankeyDiagram.RoleNames.columns,
                        value: destinationNodeName
                    }, {
                        displayName: SankeyDiagram.RoleNames.values,
                        value: formattedLinkWeight
                    } ];
                }, SankeyDiagram.prototype.updateValueOfNode = function(node) {
                    node.inputWeight = node.links.reduce(function(previousValue, currentValue) {
                        return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);
                    }, 0), node.outputWeight = node.links.reduce(function(previousValue, currentValue) {
                        return previousValue + (currentValue.source === node ? currentValue.weigth : 0);
                    }, 0);
                }, SankeyDiagram.prototype.getTooltipForNode = function(valueFormatter, nodeName, nodeWeight) {
                    var formattedNodeWeigth;
                    return formattedNodeWeigth = valueFormatter && valueFormatter.format ? valueFormatter.format(nodeWeight) : nodeWeight.toString(), 
                    [ {
                        displayName: "Name",
                        value: nodeName
                    }, {
                        displayName: SankeyDiagram.RoleNames.values,
                        value: formattedNodeWeigth
                    } ];
                }, SankeyDiagram.prototype.parseSettings = function(objects) {
                    var isVisibleLabels = !1;
                    return isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.show, SankeyDiagram.DefaultSettings.isVisibleLabels), 
                    {
                        isVisibleLabels: isVisibleLabels,
                        scale: {
                            x: SankeyDiagram.DefaultSettings.scale.x,
                            y: SankeyDiagram.DefaultSettings.scale.y
                        },
                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                        fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.fontSize, SankeyDiagram.DefaultSettings.fontSize)
                    };
                }, SankeyDiagram.prototype.findNodePosition = function(sankeyDiagramDataView) {
                    this.findNodePositionByX(sankeyDiagramDataView), this.findNodePositionByY(sankeyDiagramDataView);
                }, SankeyDiagram.prototype.findNodePositionByX = function(sankeyDiagramDataView) {
                    for (var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = !1; nodes.length > 0; ) nextNodes = [], 
                    nodes.forEach(function(node) {
                        node.x = x, node.links.forEach(function(link) {
                            node === link.source && node !== link.destination && nextNodes.every(function(item) {
                                return item !== link.destination;
                            }) && nextNodes.push(link.destination);
                        });
                    }), isRecursiveDependencies = nextNodes.length === previousNodes.length && previousNodes.every(function(previousNode) {
                        return nextNodes.some(function(nextNode) {
                            return nextNode === previousNode;
                        });
                    }), isRecursiveDependencies ? (previousNodes.forEach(function(element) {
                        element.x = x, x++;
                    }), nodes = []) : (nodes = nextNodes, previousNodes = nodes, x++);
                    sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1), this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);
                }, SankeyDiagram.prototype.scaleByAxisX = function(nodes, scale) {
                    nodes.forEach(function(node) {
                        node.x *= scale;
                    });
                }, SankeyDiagram.prototype.getScaleByAxisX = function(numberOfColumns) {
                    return void 0 === numberOfColumns && (numberOfColumns = 1), this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
                }, SankeyDiagram.prototype.findNodePositionByY = function(sankeyDiagramDataView) {
                    var nodes = sankeyDiagramDataView.nodes, links = sankeyDiagramDataView.links, currentX = 0, index = 0, maxIndex = 0, sumValueOfNodes = 0, maxValueOfNodes = 0;
                    nodes = nodes.sort(function(firstNode, secondNode) {
                        return firstNode.x - secondNode.x;
                    }), nodes.forEach(function(node) {
                        currentX !== node.x && (index = 0, currentX = node.x, sumValueOfNodes = 0), sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight), 
                        sumValueOfNodes > maxValueOfNodes && (maxValueOfNodes = sumValueOfNodes), index > maxIndex && (maxIndex = index), 
                        index++;
                    }), sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes), 
                    this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);
                }, SankeyDiagram.prototype.getScaleByAxisY = function(numberOfRows, sumValueOfNodes) {
                    return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);
                }, SankeyDiagram.prototype.scaleByAxisY = function(nodes, links, scale) {
                    var shiftByAxisY = 0, currentX = 0, index = 0;
                    nodes.forEach(function(node) {
                        currentX !== node.x && (currentX = node.x, shiftByAxisY = 0, index = 0), node.height = Math.max(node.inputWeight, node.outputWeight) * scale, 
                        node.y = shiftByAxisY + SankeyDiagram.NodePadding * index, shiftByAxisY += node.height, 
                        index++;
                    }), nodes.forEach(function(node) {
                        node.links = node.links.sort(function(firstLink, secondLink) {
                            var firstY, secondY;
                            return firstY = firstLink.source === node ? firstLink.destination.y : firstLink.source.y, 
                            secondY = secondLink.source === node ? secondLink.destination.y : secondLink.source.y, 
                            firstY - secondY;
                        });
                        var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
                        node.links.forEach(function(link) {
                            var shiftByAxisY = 0;
                            link.height = link.weigth * scale, link.source.x < node.x || link.destination.x < node.x ? (shiftByAxisY = shiftByAxisYOfLeftLink, 
                            shiftByAxisYOfLeftLink += link.height) : (link.source.x > node.x || link.destination.x > node.x) && (shiftByAxisY = shiftByAxisYOfRightLink, 
                            shiftByAxisYOfRightLink += link.height), link.source === node ? link.dySource = shiftByAxisY : link.destination === node && (link.dyDestination = shiftByAxisY);
                        });
                    });
                }, SankeyDiagram.prototype.render = function(sankeyDiagramDataView) {
                    var nodesSelection, linksSelection;
                    linksSelection = this.renderLinks(sankeyDiagramDataView), nodesSelection = this.renderNodes(sankeyDiagramDataView), 
                    this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
                }, SankeyDiagram.prototype.renderNodes = function(sankeyDiagramDataView) {
                    var nodesEnterSelection, nodesSelection, nodeElements, _this = this;
                    return nodeElements = this.main.select(SankeyDiagram.Nodes.selector).selectAll(SankeyDiagram.Node.selector), 
                    nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function(x) {
                        return x.height > 0;
                    })), nodesEnterSelection = nodesSelection.enter().append("g"), nodesSelection.attr("transform", function(node) {
                        return visuals.SVGUtil.translate(node.x, node.y);
                    }).classed(SankeyDiagram.Node["class"], !0), nodesEnterSelection.append("rect").classed(SankeyDiagram.NodeRect["class"], !0), 
                    nodesEnterSelection.append("text").classed(SankeyDiagram.NodeLabel["class"], !0), 
                    nodesSelection.select(SankeyDiagram.NodeRect.selector).style({
                        fill: function(node) {
                            return node.colour;
                        },
                        stroke: function(node) {
                            return d3.rgb(node.colour).darker(1.5);
                        }
                    }).attr({
                        x: 0,
                        y: 0,
                        height: function(node) {
                            return node.height;
                        },
                        width: function(node) {
                            return node.width;
                        }
                    }), nodesSelection.select(SankeyDiagram.NodeLabel.selector).attr({
                        x: function(node) {
                            return _this.getLabelPositionByAxisX(node);
                        },
                        y: function(node) {
                            return node.height / 2;
                        },
                        dy: "0.35em"
                    }).style("fill", function(node) {
                        return node.label.colour;
                    }).style("font-size", this.textProperties.fontSize).style("display", function(node) {
                        var isNotVisibleLabel = !1, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
                        return isNotVisibleLabel = labelPositionByAxisX >= _this.viewport.width || 0 >= labelPositionByAxisX || node.height + SankeyDiagram.NodePadding < node.label.height, 
                        isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel ? "none" : null;
                    }).style("text-anchor", function(node) {
                        return _this.isLabelLargerWidth(node) ? "end" : null;
                    }).text(function(node) {
                        var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;
                        return _this.getCurrentPositionOfLabelByAxisX(node) > maxWidth ? powerbi.TextMeasurementService.getTailoredTextOrDefault({
                            text: node.label.formattedName,
                            fontFamily: _this.textProperties.fontFamily,
                            fontSize: _this.textProperties.fontSize
                        }, maxWidth) : node.label.formattedName;
                    }), nodesSelection.exit().remove(), this.renderTooltip(nodesSelection), nodesSelection;
                }, SankeyDiagram.prototype.getLabelPositionByAxisX = function(node) {
                    return this.isLabelLargerWidth(node) ? -SankeyDiagram.LabelPadding : node.width + SankeyDiagram.LabelPadding;
                }, SankeyDiagram.prototype.isLabelLargerWidth = function(node) {
                    var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelPadding;
                    return shiftByAxisX + node.label.width > this.viewport.width;
                }, SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function(node) {
                    var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
                    return labelPositionByAxisX = labelPositionByAxisX > 0 ? labelPositionByAxisX + node.x + node.label.width + node.width : node.x + labelPositionByAxisX - node.label.width - node.width;
                }, SankeyDiagram.prototype.renderLinks = function(sankeyDiagramDataView) {
                    var linksSelection, linksElements, _this = this;
                    return linksElements = this.main.select(SankeyDiagram.Links.selector).selectAll(SankeyDiagram.Link.selector), 
                    linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function(x) {
                        return x.height > 0;
                    })), linksSelection.enter().append("path").classed(SankeyDiagram.Link["class"], !0), 
                    linksSelection.attr("d", function(link) {
                        return _this.getSvgPath(link);
                    }).style({
                        "stroke-width": function(link) {
                            return link.height;
                        },
                        stroke: function(link) {
                            return link.colour;
                        }
                    }), linksSelection.exit().remove(), this.renderTooltip(linksSelection), linksSelection;
                }, SankeyDiagram.prototype.getSvgPath = function(link) {
                    var x0, x1, xi, x2, x3, y0, y1;
                    return link.destination.x < link.source.x ? (x0 = link.source.x, x1 = link.destination.x + link.destination.width) : (x0 = link.source.x + link.source.width, 
                    x1 = link.destination.x), xi = d3.interpolateNumber(x0, x1), x2 = xi(this.curvatureOfLinks), 
                    x3 = xi(1 - this.curvatureOfLinks), y0 = link.source.y + link.dySource + link.height / 2, 
                    y1 = link.destination.y + link.dyDestination + link.height / 2, "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
                }, SankeyDiagram.prototype.renderTooltip = function(selection) {
                    visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipData;
                    });
                }, SankeyDiagram.prototype.bindSelectionHandler = function(sankeyDiagramDataView, nodesSelection, linksSelection) {
                    var _this = this;
                    nodesSelection.on("click", function(node) {
                        var selectionIds = _.isEqual(node.selectionIds.map(function(x) {
                            return x.getKey();
                        }), _this.selectionManager.getSelectionIds().map(function(x) {
                            return x.getKey();
                        })) ? [] : node.selectionIds;
                        _this.selectMany(selectionIds, !0).then(function() {
                            return _this.setSelection(nodesSelection, linksSelection);
                        }), d3.event.stopPropagation();
                    }), linksSelection.on("click", function(link) {
                        _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function() {
                            return _this.setSelection(nodesSelection, linksSelection);
                        }), d3.event.stopPropagation();
                    }), this.root.on("click", function() {
                        _this.selectionManager.clear().then(function() {
                            return _this.setSelection(nodesSelection, linksSelection);
                        });
                    }), this.setSelection(nodesSelection, linksSelection);
                }, SankeyDiagram.prototype.selectMany = function(selectionIds, clear) {
                    var _this = this;
                    if (void 0 === clear && (clear = !1), clear) return this.selectionManager.clear().then(function() {
                        return _this.selectMany(selectionIds, !1);
                    });
                    var selectionDeffered = selectionIds.map(function(id) {
                        return _this.selectionManager.select(id, !0);
                    });
                    return $.when.apply(null, selectionDeffered);
                }, SankeyDiagram.prototype.setSelection = function(nodes, links) {
                    var selectionIds = this.selectionManager.getSelectionIds();
                    if (nodes.classed("selected", selectionIds.length > 0), links.classed("selected", !1), 
                    0 !== selectionIds.length) {
                        var selectedNodesSelection = nodes.filter(function(node) {
                            return selectionIds.some(function(selectedId) {
                                return node.selectionIds.some(function(x) {
                                    return x.getKey() === selectedId.getKey();
                                });
                            });
                        }), selectedLinksSelection = links.filter(function(link) {
                            return selectionIds.some(function(selectionId) {
                                return selectionId.getKey() === link.selectionId.getKey();
                            });
                        });
                        selectedNodesSelection.classed("selected", !1), selectedLinksSelection.classed("selected", !0);
                    }
                }, SankeyDiagram.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    if (!this.dataView) return [];
                    switch (options.objectName) {
                      case "labels":
                        this.enumerateLabels(enumeration);
                        break;

                      case "links":
                        this.enumerateLinks(enumeration);
                    }
                    return enumeration.complete();
                }, SankeyDiagram.prototype.enumerateLabels = function(enumeration) {
                    var labels, settings = this.dataView.settings;
                    settings && (labels = {
                        objectName: "labels",
                        displayName: "labels",
                        selector: null,
                        properties: {
                            show: settings.isVisibleLabels,
                            fill: settings.colourOfLabels,
                            fontSize: settings.fontSize
                        }
                    }, enumeration.pushInstance(labels));
                }, SankeyDiagram.prototype.enumerateLinks = function(enumeration) {
                    var links = this.dataView.links;
                    links && links.length > 0 && links.forEach(function(link) {
                        enumeration.pushInstance({
                            objectName: "links",
                            displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
                            selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), !1),
                            properties: {
                                fill: {
                                    solid: {
                                        color: link.colour
                                    }
                                }
                            }
                        });
                    });
                }, SankeyDiagram.ClassName = "sankeyDiagram", SankeyDiagram.Nodes = {
                    "class": "nodes",
                    selector: ".nodes"
                }, SankeyDiagram.Node = {
                    "class": "node",
                    selector: ".node"
                }, SankeyDiagram.NodeRect = {
                    "class": "nodeRect",
                    selector: ".nodeRect"
                }, SankeyDiagram.NodeLabel = {
                    "class": "nodeLabel",
                    selector: ".nodeLabel"
                }, SankeyDiagram.Links = {
                    "class": "links",
                    selector: ".links"
                }, SankeyDiagram.Link = {
                    "class": "link",
                    selector: ".link"
                }, SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)", SankeyDiagram.DefaultColourOfLink = "black", 
                SankeyDiagram.DefaultSettings = {
                    isVisibleLabels: !0,
                    scale: {
                        x: 1,
                        y: 1
                    },
                    colourOfLabels: "black",
                    fontSize: 12
                }, SankeyDiagram.MinWidthOfLabel = 35, SankeyDiagram.NodePadding = 5, SankeyDiagram.LabelPadding = 4, 
                SankeyDiagram.RoleNames = {
                    rows: "Source",
                    columns: "Destination",
                    values: "Weight"
                }, SankeyDiagram.capabilities = {
                    dataRoles: [ {
                        name: SankeyDiagram.RoleNames.rows,
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: SankeyDiagram.RoleNames.rows
                    }, {
                        name: SankeyDiagram.RoleNames.columns,
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: SankeyDiagram.RoleNames.columns
                    }, {
                        name: SankeyDiagram.RoleNames.values,
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: SankeyDiagram.RoleNames.values
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Source: {
                                min: 0,
                                max: 1
                            },
                            Destination: {
                                min: 0,
                                max: 1
                            },
                            Weight: {
                                min: 0,
                                max: 0
                            }
                        }, {
                            Source: {
                                min: 0,
                                max: 1
                            },
                            Destination: {
                                min: 0,
                                max: 1
                            },
                            Weight: {
                                min: 1,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": SankeyDiagram.RoleNames.rows
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: SankeyDiagram.RoleNames.columns
                                    }
                                }, {
                                    bind: {
                                        to: SankeyDiagram.RoleNames.values
                                    }
                                } ]
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        links: {
                            displayName: "Links",
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities), 
                SankeyDiagram;
            }();
            samples.SankeyDiagram = SankeyDiagram;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var PixelConverter = jsCommon.PixelConverter;
            samples.bulletChartProps = {
                values: {
                    targetValue: {
                        objectName: "values",
                        propertyName: "targetValue"
                    },
                    minimumPercent: {
                        objectName: "values",
                        propertyName: "minimumPercent"
                    },
                    needsImprovementPercent: {
                        objectName: "values",
                        propertyName: "needsImprovementPercent"
                    },
                    satisfactoryPercent: {
                        objectName: "values",
                        propertyName: "satisfactoryPercent"
                    },
                    goodPercent: {
                        objectName: "values",
                        propertyName: "goodPercent"
                    },
                    veryGoodPercent: {
                        objectName: "values",
                        propertyName: "veryGoodPercent"
                    },
                    maximumPercent: {
                        objectName: "values",
                        propertyName: "maximumPercent"
                    },
                    targetValue2: {
                        objectName: "values",
                        propertyName: "targetValue2"
                    }
                },
                orientation: {
                    orientation: {
                        objectName: "orientation",
                        propertyName: "orientation"
                    }
                },
                colors: {
                    badColor: {
                        objectName: "colors",
                        propertyName: "badColor"
                    },
                    needsImprovementColor: {
                        objectName: "colors",
                        propertyName: "needsImprovementColor"
                    },
                    satisfactoryColor: {
                        objectName: "colors",
                        propertyName: "satisfactoryColor"
                    },
                    goodColor: {
                        objectName: "colors",
                        propertyName: "goodColor"
                    },
                    veryGoodColor: {
                        objectName: "colors",
                        propertyName: "veryGoodColor"
                    },
                    bulletColor: {
                        objectName: "colors",
                        propertyName: "bulletColor"
                    }
                },
                axis: {
                    axis: {
                        objectName: "axis",
                        propertyName: "axis"
                    },
                    axisColor: {
                        objectName: "axis",
                        propertyName: "axisColor"
                    },
                    measureUnits: {
                        objectName: "axis",
                        propertyName: "measureUnits"
                    },
                    unitsColor: {
                        objectName: "axis",
                        propertyName: "unitsColor"
                    }
                },
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                },
                labels: {
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    },
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    labelColor: {
                        objectName: "labels",
                        propertyName: "labelColor"
                    }
                }
            }, samples.bulletChartRoleNames = {
                value: "Value",
                targetValue: "TargetValue",
                minValue: "Minimum",
                needsImprovementValue: "NeedsImprovement",
                satisfactoryValue: "Satisfactory",
                goodValue: "Good",
                veryGoodValue: "VeryGood",
                maxValue: "Maximum",
                targetValue2: "TargetValue2"
            };
            var Orientation;
            !function(Orientation) {
                Orientation.HORIZONTALLEFT = "Horizontal Left", Orientation.HORIZONTALRIGHT = "Horizontal Right", 
                Orientation.VERTICALTOP = "Vertical Top", Orientation.VERTICALBOTTOM = "Vertical Bottom", 
                Orientation.type = powerbi.createEnumType([ {
                    value: Orientation.HORIZONTALLEFT,
                    displayName: Orientation.HORIZONTALLEFT
                }, {
                    value: Orientation.HORIZONTALRIGHT,
                    displayName: Orientation.HORIZONTALRIGHT
                }, {
                    value: Orientation.VERTICALTOP,
                    displayName: Orientation.VERTICALTOP
                }, {
                    value: Orientation.VERTICALBOTTOM,
                    displayName: Orientation.VERTICALBOTTOM
                } ]);
            }(Orientation || (Orientation = {}));
            var BulletChart = function() {
                function BulletChart() {
                    this.baselineDelta = 0;
                }
                return Object.defineProperty(BulletChart.prototype, "reverse", {
                    get: function() {
                        return this.model.bulletChartSettings.orientation.reverse;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BulletChart.prototype, "vertical", {
                    get: function() {
                        return this.model.bulletChartSettings.orientation.vertical;
                    },
                    enumerable: !0,
                    configurable: !0
                }), BulletChart.DefaultStyleProperties = function() {
                    return {
                        values: {
                            targetValue: 0,
                            targetValue2: 0,
                            minimumPercent: 0,
                            needsImprovementPercent: 25,
                            satisfactoryPercent: 50,
                            goodPercent: 100,
                            veryGoodPercent: 125,
                            maximumPercent: 200
                        },
                        orientation: {
                            orientation: Orientation.HORIZONTALLEFT,
                            reverse: !1,
                            vertical: !1
                        },
                        colors: {
                            badColor: "Darkred",
                            needsImprovementColor: "Red",
                            satisfactoryColor: "Yellow",
                            goodColor: "Green",
                            veryGoodColor: "Darkgreen",
                            bulletColor: "Black"
                        },
                        axis: {
                            axis: !0,
                            axisColor: "Grey",
                            measureUnits: "",
                            unitsColor: "Grey"
                        },
                        labelSettings: {
                            fontSize: 11,
                            show: !0,
                            labelColor: "Black"
                        }
                    };
                }, Object.defineProperty(BulletChart.prototype, "viewportIn", {
                    get: function() {
                        return {
                            width: this.viewport.width,
                            height: this.viewport.height
                        };
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BulletChart.prototype, "viewportScroll", {
                    get: function() {
                        var viewportIn = this.viewportIn;
                        return {
                            width: viewportIn.width - BulletChart.ScrollBarSize,
                            height: viewportIn.height - BulletChart.ScrollBarSize
                        };
                    },
                    enumerable: !0,
                    configurable: !0
                }), BulletChart.getTextProperties = function(text, fontSize) {
                    return {
                        fontFamily: BulletChart.FontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize),
                        text: text
                    };
                }, BulletChart.converter = function(dataView, options) {
                    var defaultSettings = BulletChart.DefaultStyleProperties(), bulletModel = {
                        bulletValueFormatString: null,
                        bulletChartSettings: defaultSettings,
                        bars: [],
                        barRects: [],
                        valueRects: [],
                        targetValues: []
                    };
                    if (!(dataView && dataView.categorical && dataView.categorical.values && 0 !== dataView.categorical.values.length && dataView.metadata && dataView.metadata.columns && 0 !== dataView.metadata.columns.length)) return bulletModel;
                    var objects = dataView.metadata.objects, settings = bulletModel.bulletChartSettings;
                    objects && (settings.values.targetValue = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue, defaultSettings.values.targetValue), 
                    settings.values.targetValue2 = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2), 
                    settings.values.minimumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent), 
                    settings.values.needsImprovementPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent), 
                    settings.values.satisfactoryPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent), 
                    settings.values.goodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent), 
                    settings.values.veryGoodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent), 
                    settings.values.maximumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent), 
                    settings.orientation.orientation = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation), 
                    settings.colors.badColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.badColor, defaultSettings.colors.badColor), 
                    settings.colors.needsImprovementColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor), 
                    settings.colors.satisfactoryColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor), 
                    settings.colors.goodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor), 
                    settings.colors.veryGoodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor), 
                    settings.colors.bulletColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor), 
                    settings.axis.axis = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.axis, defaultSettings.axis.axis), 
                    settings.axis.axisColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor), 
                    settings.axis.measureUnits = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth), 
                    settings.axis.unitsColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor), 
                    settings.labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize), 
                    settings.labelSettings.show = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.show, defaultSettings.labelSettings.show), 
                    settings.labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor)), 
                    settings.orientation.orientation !== Orientation.HORIZONTALRIGHT && settings.orientation.orientation !== Orientation.VERTICALBOTTOM || (settings.orientation.reverse = !0), 
                    settings.orientation.orientation !== Orientation.VERTICALTOP && settings.orientation.orientation !== Orientation.VERTICALBOTTOM || (settings.orientation.vertical = !0);
                    var categories, categoryValues, categoryFormatString, categoryValuesLen = 1;
                    dataView.categorical.categories && (categories = dataView.categorical.categories[0], 
                    categoryValues = categories.values, categoryValuesLen = categoryValues.length, categoryFormatString = visuals.valueFormatter.getFormatString(categories.source, samples.bulletChartProps.formatString)), 
                    bulletModel.bulletValueFormatString = visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps.formatString);
                    for (var idx = 0; categoryValuesLen > idx; idx++) {
                        var toolTipItems = [], category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0, highlight = !1, categoryIdentity = void 0;
                        if (categoryValues) {
                            var categoryValue = categoryValues[idx];
                            category = visuals.valueFormatter.format(categoryValue, categoryFormatString), categoryIdentity = categories.identity ? categories.identity[idx] : null;
                            var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);
                            category = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);
                            var labelWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                            BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth), 
                            BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);
                        }
                        var values = dataView.categorical.values;
                        targetValue = settings.values.targetValue, targetValue2 = settings.values.targetValue2;
                        for (var i = 0; i < values.length; i++) {
                            var col = values[i].source, currentVal = values[i].values[idx] || 0;
                            col && col.roles && (col.roles[samples.bulletChartRoleNames.value] ? (values[i].highlights && (highlight = null !== values[i].highlights[idx]), 
                            toolTipItems.push({
                                value: currentVal,
                                metadata: values[i]
                            }), value = currentVal) : col.roles[samples.bulletChartRoleNames.targetValue] ? (toolTipItems.push({
                                value: currentVal,
                                metadata: values[i]
                            }), targetValue = currentVal) : col.roles[samples.bulletChartRoleNames.targetValue2] ? (toolTipItems.push({
                                value: currentVal,
                                metadata: values[i]
                            }), targetValue2 = currentVal) : col.roles[samples.bulletChartRoleNames.minValue] ? minimum = currentVal : col.roles[samples.bulletChartRoleNames.needsImprovementValue] ? needsImprovement = currentVal : col.roles[samples.bulletChartRoleNames.satisfactoryValue] ? satisfactory = currentVal : col.roles[samples.bulletChartRoleNames.goodValue] ? good = currentVal : col.roles[samples.bulletChartRoleNames.veryGoodValue] ? veryGood = currentVal : col.roles[samples.bulletChartRoleNames.maxValue] && (maximum = currentVal));
                        }
                        minimum || (minimum = settings.values.minimumPercent * targetValue / 100), needsImprovement || (needsImprovement = settings.values.needsImprovementPercent * targetValue / 100), 
                        satisfactory || (satisfactory = settings.values.satisfactoryPercent * targetValue / 100), 
                        good || (good = settings.values.goodPercent * targetValue / 100), veryGood || (veryGood = settings.values.veryGoodPercent * targetValue / 100), 
                        maximum || (maximum = settings.values.maximumPercent * targetValue / 100);
                        var viewportLength = (settings.orientation.vertical ? options.viewport.height - BulletChart.MaxLabelHeight : options.viewport.width - BulletChart.MaxLabelWidth) - BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize, sortedRanges = [ minimum, needsImprovement, satisfactory, good, veryGood, maximum ].sort(d3.descending), scale = d3.scale.linear().clamp(!0).domain([ minimum, Math.max(sortedRanges[0], targetValue, value) ]).range(settings.orientation.vertical ? [ viewportLength, 0 ] : [ 0, viewportLength ]), firstScale = scale(minimum), secondScale = scale(needsImprovement), thirdScale = scale(satisfactory), fourthScale = scale(good), fifthScale = scale(veryGood), lastScale = scale(maximum), valueScale = scale(value), firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity), 
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity), 
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity), 
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity), 
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity), 
                        BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity), 
                        bulletModel.targetValues.push({
                            barIndex: idx,
                            value: scale(targetValue),
                            fill: settings.colors.bulletColor,
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),
                            value2: scale(targetValue2)
                        });
                        var xAxis = null;
                        if (settings.axis.axis) {
                            xAxis = d3.svg.axis(), xAxis.orient(settings.orientation.vertical ? "left" : "bottom");
                            var minTickSize = Math.round(Math.max(3, viewportLength / 100)), axisValues = [ value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood ].filter(function(x) {
                                return !isNaN(x);
                            });
                            xAxis.tickFormat(visuals.valueFormatter.create({
                                format: bulletModel.bulletValueFormatString,
                                value: axisValues.length ? Math.max.apply(null, axisValues) : 0
                            }).format), xAxis.ticks(minTickSize), xAxis.scale(scale);
                        }
                        var bar = {
                            scale: scale,
                            barIndex: idx,
                            categoryLabel: category,
                            x: settings.orientation.vertical ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,
                            y: settings.orientation.vertical ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,
                            axis: xAxis,
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey()
                        };
                        bulletModel.bars.push(bar);
                    }
                    return bulletModel;
                }, BulletChart.addItemToBarArray = function(collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity) {
                    collection.push({
                        barIndex: barIndex,
                        start: start,
                        end: end,
                        fill: fill,
                        tooltipInfo: visuals.TooltipBuilder.createTooltipInfo(samples.bulletChartProps.formatString, null, null, null, null, tooltipInfo),
                        selected: !1,
                        identity: visuals.SelectionId.createWithId(categoryIdentity),
                        key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, start + " " + end).getKey()
                    });
                }, BulletChart.prototype.init = function(options) {
                    var body = d3.select(options.element.get(0));
                    this.hostService = options.host, this.bulletBody = body.append("div").classed("bulletChart", !0), 
                    this.scrollContainer = this.bulletBody.append("svg").classed("bullet-scroll-region", !0), 
                    this.clearCatcher = visuals.appendClearCatcher(this.scrollContainer), this.labelGraphicsContext = this.scrollContainer.append("g"), 
                    this.bulletGraphicsContext = this.scrollContainer.append("g"), this.behavior = new BulletWebBehavior(), 
                    this.interactivityService = visuals.createInteractivityService(options.host);
                }, BulletChart.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;
                        var dataView = options.dataViews[0];
                        this.viewport = options.viewport, this.model = BulletChart.converter(dataView, options), 
                        this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.model.bulletChartSettings.labelSettings.fontSize)), 
                        this.ClearViewport(), this.model && (this.interactivityService && this.interactivityService.applySelectionStateToData(this.model.barRects), 
                        this.bulletBody.style({
                            height: this.viewportIn.height + "px",
                            width: this.viewportIn.width + "px"
                        }), this.vertical ? this.scrollContainer.attr({
                            width: this.model.bars.length * BulletChart.SpaceRequiredForBarVertically + "px",
                            height: this.viewportScroll.height + "px"
                        }) : this.scrollContainer.attr({
                            height: this.model.bars.length * BulletChart.SpaceRequiredForBar + "px",
                            width: this.viewportScroll.width + "px"
                        }), this.vertical ? this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse) : this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse));
                    }
                }, BulletChart.prototype.ClearViewport = function() {
                    this.labelGraphicsContext.selectAll("text").remove(), this.bulletGraphicsContext.selectAll("rect").remove(), 
                    this.bulletGraphicsContext.selectAll("axis").remove(), this.bulletGraphicsContext.selectAll("path").remove(), 
                    this.bulletGraphicsContext.selectAll("line").remove(), this.bulletGraphicsContext.selectAll("tick").remove(), 
                    this.bulletGraphicsContext.selectAll("g").remove();
                }, BulletChart.prototype.calculateLabelWidth = function(barData, bar, reversed) {
                    if (reversed) return BulletChart.StartMarginHorizontal + (bar ? bar.start : 0);
                    var textSize = powerbi.TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                    return textSize > BulletChart.BiggestLabelWidth ? barData.x + BulletChart.MaxLabelWidth + (bar ? bar.start : 0) : barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + (bar ? bar.start : 0);
                }, BulletChart.prototype.calculateLabelHeight = function(barData, bar, reversed) {
                    if (reversed) return BulletChart.StartMarginVertical + (bar ? bar.end : 0);
                    var textSize = powerbi.TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                    return textSize > BulletChart.BiggestLabelHeight ? barData.y + BulletChart.MaxLabelHeight + (bar ? bar.end : 0) : barData.y + textSize + BulletChart.BarMargin + (bar ? bar.end : 0);
                }, BulletChart.prototype.setUpBulletsHorizontally = function(bulletBody, model, reveresed) {
                    var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                        return d.key;
                    }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                        return d.key;
                    }), bullets = rectSelection.enter().append("rect").attr({
                        x: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed);
                        },
                        y: function(d) {
                            return bars[d.barIndex].y - BulletChart.BulletSize / 2;
                        },
                        width: function(d) {
                            return d.end - d.start;
                        },
                        height: BulletChart.BulletSize
                    }).classed("range", !0).style({
                        fill: function(d) {
                            return d.fill;
                        }
                    });
                    rectSelection.exit();
                    var valueSelection = this.bulletGraphicsContext.selectAll("rect").data(valueRects, function(d) {
                        return d.key;
                    });
                    valueSelection.enter().append("rect").attr({
                        x: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed);
                        },
                        y: function(d) {
                            return bars[d.barIndex].y - BulletChart.BulletSize / 8;
                        },
                        width: function(d) {
                            return d.end - d.start;
                        },
                        height: 1 * BulletChart.BulletSize / 4
                    }).classed("value", !0).style({
                        fill: function(d) {
                            return d.fill;
                        }
                    }), valueSelection.exit();
                    var markerSelection = this.bulletGraphicsContext.selectAll("values").data(targetValues, function(d) {
                        return d.key;
                    });
                    if (markerSelection.enter().append("line").attr({
                        x1: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                        },
                        x2: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                        },
                        y1: function(d) {
                            return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                        },
                        y2: function(d) {
                            return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                        }
                    }).style({
                        stroke: function(d) {
                            return d.fill;
                        },
                        "stroke-width": 2
                    }), markerSelection.enter().append("line").attr({
                        x1: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        x2: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        y1: function(d) {
                            return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                        },
                        y2: function(d) {
                            return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                        }
                    }).style({
                        stroke: function(d) {
                            return d.fill;
                        },
                        "stroke-width": 2,
                        transform: "rotate(45deg)",
                        "transform-origin": "50% 50% 0"
                    }), markerSelection.enter().append("line").attr({
                        x1: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        x2: function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        y1: function(d) {
                            return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                        },
                        y2: function(d) {
                            return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                        }
                    }).style({
                        stroke: function(d) {
                            return d.fill;
                        },
                        "stroke-width": 2,
                        transform: "rotate(315deg)",
                        "transform-origin": "50% 50% 0"
                    }), markerSelection.exit(), model.bulletChartSettings.axis.axis) for (var idx = 0; idx < bars.length; idx++) {
                        var bar = bars[idx];
                        this.bulletGraphicsContext.append("g").attr({
                            transform: function() {
                                var xLocation = _this.calculateLabelWidth(bar, null, reveresed), yLocation = bar.y + BulletChart.BulletSize / 2;
                                return "translate(" + xLocation + "," + yLocation + ")";
                            }
                        }).classed("axis", !0).call(bar.axis.scale(bar.scale)).style({
                            fill: model.bulletChartSettings.axis.axisColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                        }).selectAll("line").style({
                            stroke: model.bulletChartSettings.axis.axisColor
                        });
                    }
                    if (model.bulletChartSettings.labelSettings.show && barSelection.enter().append("text").classed("title", !0).attr({
                        x: function(d) {
                            return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().width + BulletChart.StartMarginHorizontal : d.x;
                        },
                        y: function(d) {
                            return d.y + _this.baselineDelta;
                        },
                        fill: model.bulletChartSettings.labelSettings.labelColor,
                        "font-size": PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize)
                    }).text(function(d) {
                        return d.categoryLabel;
                    }), model.bulletChartSettings.axis.measureUnits && barSelection.enter().append("text").attr({
                        x: function(d) {
                            return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin : d.x - BulletChart.SubtitleMargin;
                        },
                        y: function(d) {
                            return d.y + BulletChart.BulletSize;
                        },
                        fill: model.bulletChartSettings.axis.unitsColor,
                        "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                    }).text(model.bulletChartSettings.axis.measureUnits), this.interactivityService) {
                        var behaviorOptions = {
                            rects: bullets,
                            valueRects: valueSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                            bulletChartSettings: this.model.bulletChartSettings,
                            hasHighlights: !1
                        }, targetCollection = this.model.barRects.concat(this.model.valueRects);
                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                    }
                    barSelection.exit(), visuals.TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }, !0), visuals.TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }, !0);
                }, BulletChart.prototype.setUpBulletsVertically = function(bulletBody, model, reveresed) {
                    var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                        return d.key;
                    }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                        return d.key;
                    }), bullets = rectSelection.enter().append("rect").attr({
                        x: function(d) {
                            return bars[d.barIndex].x;
                        },
                        y: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed);
                        },
                        height: function(d) {
                            return d.start - d.end;
                        },
                        width: BulletChart.BulletSize
                    }).classed("range", !0).style({
                        fill: function(d) {
                            return d.fill;
                        }
                    });
                    rectSelection.exit();
                    var valueSelection = this.bulletGraphicsContext.selectAll("rect").data(valueRects, function(d) {
                        return d.key;
                    });
                    valueSelection.enter().append("rect").attr({
                        x: function(d) {
                            return bars[d.barIndex].x + BulletChart.BulletSize / 3;
                        },
                        y: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed);
                        },
                        height: function(d) {
                            return d.start - d.end;
                        },
                        width: 1 * BulletChart.BulletSize / 4
                    }).classed("value", !0).style({
                        fill: function(d) {
                            return d.fill;
                        }
                    }), valueSelection.exit();
                    var markerSelection = this.bulletGraphicsContext.selectAll("values").data(targetValues, function(d) {
                        return d.key;
                    });
                    if (markerSelection.enter().append("line").attr({
                        x2: function(d) {
                            return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                        },
                        x1: function(d) {
                            return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                        },
                        y2: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                        },
                        y1: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                        }
                    }).style({
                        stroke: function(d) {
                            return d.fill;
                        },
                        "stroke-width": 2
                    }), markerSelection.enter().append("line").attr({
                        y1: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        y2: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        x1: function(d) {
                            return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                        },
                        x2: function(d) {
                            return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                        }
                    }).style({
                        stroke: function(d) {
                            return d.fill;
                        },
                        "stroke-width": 2,
                        transform: "rotate(45deg)",
                        "transform-origin": "50% 50% 0"
                    }), markerSelection.enter().append("line").attr({
                        y1: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        y2: function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                        },
                        x1: function(d) {
                            return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                        },
                        x2: function(d) {
                            return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                        }
                    }).style({
                        stroke: function(d) {
                            return d.fill;
                        },
                        "stroke-width": 2,
                        transform: "rotate(315deg)",
                        "transform-origin": "50% 50% 0"
                    }), markerSelection.exit(), model.bulletChartSettings.axis.axis) for (var idx = 0; idx < bars.length; idx++) {
                        var bar = bars[idx];
                        this.bulletGraphicsContext.append("g").attr({
                            transform: function() {
                                var xLocation = bar.x, yLocation = _this.calculateLabelHeight(bar, null, reveresed);
                                return "translate(" + xLocation + "," + yLocation + ")";
                            }
                        }).classed("axis", !0).call(bar.axis.scale(bar.scale)).style({
                            fill: model.bulletChartSettings.axis.axisColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                        }).selectAll("line").style({
                            stroke: model.bulletChartSettings.axis.axisColor
                        });
                    }
                    if (model.bulletChartSettings.labelSettings.show && barSelection.enter().append("text").classed("title", !0).attr({
                        x: function(d) {
                            return d.x;
                        },
                        y: function(d) {
                            return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize : d.y + powerbi.TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel, model.bulletChartSettings.labelSettings.fontSize)) / 2;
                        },
                        fill: model.bulletChartSettings.labelSettings.labelColor,
                        "font-size": PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize)
                    }).text(function(d) {
                        return d.categoryLabel;
                    }), model.bulletChartSettings.axis.measureUnits && barSelection.enter().append("text").attr({
                        x: function(d) {
                            return d.x + BulletChart.BulletSize;
                        },
                        y: function(d) {
                            return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin : d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;
                        },
                        fill: model.bulletChartSettings.axis.unitsColor,
                        "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                    }).text(model.bulletChartSettings.axis.measureUnits), this.interactivityService) {
                        var behaviorOptions = {
                            rects: bullets,
                            valueRects: valueSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                            bulletChartSettings: this.model.bulletChartSettings,
                            hasHighlights: !1
                        }, targetCollection = this.model.barRects.concat(this.model.valueRects);
                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                    }
                    barSelection.exit(), visuals.TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }, !0), visuals.TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }, !0);
                }, BulletChart.prototype.destroy = function() {}, BulletChart.prototype.enumerateObjectInstances = function(options) {
                    var data = this.model;
                    if (data) {
                        var objectName = options.objectName;
                        switch (objectName) {
                          case "labels":
                            return this.enumerateLabels(data);

                          case "values":
                            return this.enumerateValues(data);

                          case "orientation":
                            return this.enumerateOrientation(data);

                          case "axis":
                            return this.enumerateAxis(data);

                          case "colors":
                            return this.enumerateColors(data);
                        }
                    }
                }, BulletChart.prototype.enumerateLabels = function(data) {
                    return [ {
                        selector: null,
                        objectName: "labels",
                        properties: {
                            show: this.model.bulletChartSettings.labelSettings.show,
                            labelColor: this.model.bulletChartSettings.labelSettings.labelColor,
                            fontSize: this.model.bulletChartSettings.labelSettings.fontSize
                        }
                    } ];
                }, BulletChart.prototype.enumerateValues = function(data) {
                    return [ {
                        selector: null,
                        objectName: "values",
                        properties: {
                            targetValue: this.model.bulletChartSettings.values.targetValue,
                            targetValue2: this.model.bulletChartSettings.values.targetValue2,
                            minimumPercent: this.model.bulletChartSettings.values.minimumPercent,
                            needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,
                            satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,
                            goodPercent: this.model.bulletChartSettings.values.goodPercent,
                            veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,
                            maximumPercent: this.model.bulletChartSettings.values.maximumPercent
                        }
                    } ];
                }, BulletChart.prototype.enumerateOrientation = function(data) {
                    return [ {
                        selector: null,
                        objectName: "orientation",
                        properties: {
                            orientation: this.model.bulletChartSettings.orientation.orientation
                        }
                    } ];
                }, BulletChart.prototype.enumerateAxis = function(data) {
                    return [ {
                        selector: null,
                        objectName: "axis",
                        properties: {
                            axis: this.model.bulletChartSettings.axis.axis,
                            axisColor: this.model.bulletChartSettings.axis.axisColor,
                            measureUnits: this.model.bulletChartSettings.axis.measureUnits,
                            unitsColor: this.model.bulletChartSettings.axis.unitsColor
                        }
                    } ];
                }, BulletChart.prototype.enumerateColors = function(data) {
                    return [ {
                        selector: null,
                        objectName: "colors",
                        properties: {
                            badColor: this.model.bulletChartSettings.colors.badColor,
                            needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,
                            satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,
                            goodColor: this.model.bulletChartSettings.colors.goodColor,
                            veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,
                            bulletColor: this.model.bulletChartSettings.colors.bulletColor
                        }
                    } ];
                }, BulletChart.ScrollBarSize = 13, BulletChart.SpaceRequiredForBar = 60, BulletChart.SpaceRequiredForBarVertically = 100, 
                BulletChart.StartMarginHorizontal = 30, BulletChart.StartMarginVertical = 50, BulletChart.BulletSize = 25, 
                BulletChart.DefaultSubtitleFontSizeInPt = 9, BulletChart.BarMargin = 10, BulletChart.MaxLabelWidth = 80, 
                BulletChart.MaxLabelHeight = 60, BulletChart.SubtitleMargin = 10, BulletChart.AxisFontSizeInPt = 8, 
                BulletChart.BiggestLabelWidth = 0, BulletChart.BiggestLabelHeight = 0, BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3, 
                BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4, BulletChart.FontFamily = "Segoe UI", 
                BulletChart.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Category"
                    }, {
                        name: "Value",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Value"
                    }, {
                        name: "TargetValue",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Target Value"
                    }, {
                        name: "Minimum",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Minimum"
                    }, {
                        name: "NeedsImprovement",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Needs Improvement"
                    }, {
                        name: "Satisfactory",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Satisfactory"
                    }, {
                        name: "Good",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Good"
                    }, {
                        name: "VeryGood",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Very Good"
                    }, {
                        name: "Maximum",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Maximum"
                    }, {
                        name: "TargetValue2",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Target Value 2"
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        values: {
                            displayName: "Data values",
                            properties: {
                                targetValue: {
                                    displayName: "Target Value",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                targetValue2: {
                                    displayName: "Target Value 2",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                minimumPercent: {
                                    displayName: "Minimum %",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                needsImprovementPercent: {
                                    displayName: "Needs Improvement %",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                satisfactoryPercent: {
                                    displayName: "Satisfactory %",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                goodPercent: {
                                    displayName: "Good %",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                veryGoodPercent: {
                                    displayName: "Very Good %",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                maximumPercent: {
                                    displayName: "Maximum %",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: "Category labels",
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        orientation: {
                            displayName: "Orientation",
                            properties: {
                                orientation: {
                                    displayName: "Orientation",
                                    type: {
                                        enumeration: Orientation.type
                                    }
                                }
                            }
                        },
                        colors: {
                            displayName: "Colors",
                            properties: {
                                badColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Bad Color"
                                },
                                needsImprovementColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Needs Improvement Color"
                                },
                                satisfactoryColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Satisfactory Color"
                                },
                                goodColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Good Color"
                                },
                                veryGoodColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Very Good Color"
                                },
                                bulletColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Bullet Color"
                                }
                            }
                        },
                        axis: {
                            displayName: "Axis",
                            properties: {
                                axis: {
                                    displayName: "Axis",
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Axis Color"
                                },
                                measureUnits: {
                                    type: {
                                        text: !0
                                    },
                                    displayName: "Measure Units "
                                },
                                unitsColor: {
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    },
                                    displayName: "Units Color"
                                }
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Value: {
                                max: 1
                            },
                            TargetValue: {
                                max: 1
                            },
                            Minimum: {
                                max: 1
                            },
                            NeedsImprovement: {
                                max: 1
                            },
                            Satisfactory: {
                                max: 1
                            },
                            Good: {
                                max: 1
                            },
                            VeryGood: {
                                max: 1
                            },
                            Maximum: {
                                max: 1
                            },
                            TargetValue2: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Value"
                                    }
                                }, {
                                    bind: {
                                        to: "TargetValue"
                                    }
                                }, {
                                    bind: {
                                        to: "TargetValue2"
                                    }
                                }, {
                                    bind: {
                                        to: "Minimum"
                                    }
                                }, {
                                    bind: {
                                        to: "NeedsImprovement"
                                    }
                                }, {
                                    bind: {
                                        to: "Satisfactory"
                                    }
                                }, {
                                    bind: {
                                        to: "Good"
                                    }
                                }, {
                                    bind: {
                                        to: "VeryGood"
                                    }
                                }, {
                                    bind: {
                                        to: "Maximum"
                                    }
                                } ]
                            }
                        }
                    } ],
                    supportsHighlight: !0,
                    sorting: {
                        "default": {}
                    },
                    drilldown: {
                        roles: [ "Category" ]
                    }
                }, BulletChart;
            }();
            samples.BulletChart = BulletChart;
            var TextMeasurementHelper;
            !function(TextMeasurementHelper) {
                function estimateSvgTextBaselineDelta(textProperties) {
                    var rect = estimateSvgTextRect(textProperties);
                    return rect.y + rect.height;
                }
                function ensureDOM() {
                    spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                        height: "0px",
                        width: "0px",
                        position: "absolute"
                    }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                }
                function measureSvgTextRect(textProperties) {
                    return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                        visibility: "hidden",
                        "font-family": textProperties.fontFamily,
                        "font-size": textProperties.fontSize,
                        "font-weight": textProperties.fontWeight,
                        "font-style": textProperties.fontStyle,
                        "white-space": textProperties.whiteSpace || "nowrap"
                    }), svgTextElement.node().getBBox();
                }
                function estimateSvgTextRect(textProperties) {
                    var estimatedTextProperties = {
                        fontFamily: textProperties.fontFamily,
                        fontSize: textProperties.fontSize,
                        text: "M"
                    }, rect = measureSvgTextRect(estimatedTextProperties);
                    return rect;
                }
                var spanElement, svgTextElement, canvasCtx;
                TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
            }(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
            var BulletWebBehavior = function() {
                function BulletWebBehavior() {}
                return BulletWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.options = options;
                    var clearCatcher = options.clearCatcher;
                    options.valueRects.on("click", function(d, i) {
                        d3.event.stopPropagation(), selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }), options.rects.on("click", function(d, i) {
                        d3.event.stopPropagation(), selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }), clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, BulletWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var options = this.options;
                    options.valueRects.style("opacity", function(d) {
                        return hasSelection ? d.selected ? "1" : "0.4" : "1";
                    }), options.rects.style("opacity", function(d) {
                        return hasSelection ? d.selected ? "1" : "0.4" : "1";
                    });
                }, BulletWebBehavior;
            }();
            samples.BulletWebBehavior = BulletWebBehavior;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            !function(WordCloudScaleType) {
                WordCloudScaleType[WordCloudScaleType.logn = 0] = "logn", WordCloudScaleType[WordCloudScaleType.sqrt = 1] = "sqrt", 
                WordCloudScaleType[WordCloudScaleType.value = 2] = "value";
            }(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
            var WordCloudScaleType = samples.WordCloudScaleType, VisualLayout = function() {
                function VisualLayout(defaultViewport, defaultMargin) {
                    this.defaultViewport = defaultViewport || {
                        width: 0,
                        height: 0
                    }, this.defaultMargin = defaultMargin || {
                        top: 0,
                        bottom: 0,
                        right: 0,
                        left: 0
                    };
                }
                return Object.defineProperty(VisualLayout.prototype, "margin", {
                    get: function() {
                        return this.marginValue || (this.margin = this.defaultMargin);
                    },
                    set: function(value) {
                        this.marginValue = VisualLayout.restrictToMinMax(value), this.update();
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(VisualLayout.prototype, "viewport", {
                    get: function() {
                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
                    },
                    set: function(value) {
                        this.viewportValue = VisualLayout.restrictToMinMax(value), this.update();
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                    get: function() {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                    get: function() {
                        return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                    },
                    enumerable: !0,
                    configurable: !0
                }), VisualLayout.prototype.update = function() {
                    this.viewportInValue = VisualLayout.restrictToMinMax({
                        width: this.viewport.width - (this.margin.left + this.margin.right),
                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
                    });
                }, VisualLayout.restrictToMinMax = function(value) {
                    var result = $.extend({}, value);
                    return d3.keys(value).forEach(function(x) {
                        return result[x] = Math.max(0, value[x]);
                    }), result;
                }, VisualLayout;
            }(), WordCloud = function() {
                function WordCloud(options) {
                    this.durationAnimations = 500, this.fakeViewport = {
                        width: 1500,
                        height: 1e3
                    }, this.canvasViewport = {
                        width: 128,
                        height: 2048
                    }, options && (this.svg = options.svg || this.svg, this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin), 
                    options.animator && (this.animator = options.animator));
                }
                return WordCloud.prototype.init = function(options) {
                    var _this = this;
                    this.svg ? this.root = this.svg : this.root = d3.select(options.element.get(0)).append("svg"), 
                    WordCloud.colors = options.style.colorPalette.dataColors, this.hostService = options.host, 
                    this.selectionManager = new visuals.utility.SelectionManager({
                        hostServices: this.hostService
                    }), this.layout || (this.layout = new VisualLayout(null, WordCloud.DefaultMargin)), 
                    this.root.classed(WordCloud.ClassName, !0), this.root.on("click", function() {
                        _this.selectionManager.clear(), _this.setSelection(_this.wordsSelection);
                    }), this.fontFamily = this.root.style("font-family"), this.main = this.root.append("g"), 
                    this.wordsContainerSelection = this.main.append("g").classed(WordCloud.Words["class"], !0), 
                    this.canvas = document.createElement("canvas");
                }, WordCloud.prototype.converter = function(dataView) {
                    var _this = this;
                    if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length && dataView.categorical.categories[0].values.length > 0)) return null;
                    var frequencies, texts, categories = dataView.categorical.categories[0].values, settings = WordCloud.parseSettings(dataView, categories[0]);
                    return settings ? (_.isEmpty(dataView.categorical.values) || _.isEmpty(dataView.categorical.values[0]) || _.isEmpty(dataView.categorical.values[0].values) || (frequencies = dataView.categorical.values[0].values), 
                    texts = categories.map(function(item, index) {
                        var color, categoryObject = dataView.categorical.categories[0];
                        return color = categoryObject.objects && categoryObject.objects[index] ? _this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]) : _this.wordCloudTexts && _this.wordCloudTexts[index] ? _this.wordCloudTexts[index].color : explore.util.getRandomColor(), 
                        {
                            text: item,
                            count: frequencies && frequencies[index] && !isNaN(frequencies[index]) ? frequencies[index] : 1,
                            index: index,
                            selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),
                            color: color
                        };
                    }), {
                        settings: settings,
                        texts: texts
                    }) : null;
                }, WordCloud.prototype.getColor = function(properties, defaultColor, objects) {
                    var colorHelper;
                    return colorHelper = new visuals.ColorHelper(WordCloud.colors, properties, defaultColor), 
                    explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, ""));
                }, WordCloud.parseSettings = function(dataView, value) {
                    if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                    var valueFormatter, minFontSize, maxFontSize, minAngle, maxAngle, maxNumberOfOrientations, stopWords, stopWordsArray, maxNumberOfWords, objects = dataView.metadata.objects, isRotateText = !1, isBrokenText = !0, isRemoveStopWords = !0, isDefaultStopWords = !1;
                    return maxNumberOfWords = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords), 
                    minFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.minFontSize, WordCloud.DefaultSettings.minFontSize), 
                    maxFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxFontSize, WordCloud.DefaultSettings.maxFontSize), 
                    minAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.minAngle, WordCloud.DefaultSettings.minAngle), 
                    maxAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxAngle, WordCloud.DefaultSettings.maxAngle), 
                    isRotateText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.rotateText.show, WordCloud.DefaultSettings.isRotateText), 
                    maxNumberOfOrientations = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxNumberOfOrientations, WordCloud.DefaultSettings.maxNumberOfOrientations), 
                    valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, WordCloud.Properties.general.formatString),
                        value: value
                    }), isBrokenText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.general.isBrokenText, WordCloud.DefaultSettings.isBrokenText), 
                    isRemoveStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.show, WordCloud.DefaultSettings.isRemoveStopWords), 
                    stopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.words, WordCloud.DefaultSettings.stopWords), 
                    stopWordsArray = "string" == typeof stopWords ? stopWords.split(WordCloud.StopWordsDelemiter) : WordCloud.DefaultSettings.stopWordsArray, 
                    isDefaultStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.isDefaultStopWords, WordCloud.DefaultSettings.isDefaultStopWords), 
                    {
                        minFontSize: minFontSize,
                        maxFontSize: maxFontSize,
                        minAngle: minAngle,
                        maxAngle: maxAngle,
                        maxNumberOfOrientations: maxNumberOfOrientations,
                        valueFormatter: valueFormatter,
                        isRotateText: isRotateText,
                        isBrokenText: isBrokenText,
                        isRemoveStopWords: isRemoveStopWords,
                        stopWords: stopWords,
                        stopWordsArray: stopWordsArray,
                        isDefaultStopWords: isDefaultStopWords,
                        maxNumberOfWords: maxNumberOfWords
                    };
                }, WordCloud.getNumberFromObjects = function(objects, properties, defaultValue) {
                    return objects ? powerbi.DataViewObjects.getValue(objects, properties, defaultValue) : defaultValue;
                }, WordCloud.prototype.parseNumber = function(value, defaultValue, minValue, maxValue) {
                    void 0 === defaultValue && (defaultValue = 0), void 0 === minValue && (minValue = -Number.MAX_VALUE), 
                    void 0 === maxValue && (maxValue = Number.MAX_VALUE);
                    var parsedValue = Number(value);
                    return isNaN(parsedValue) || "string" == typeof value && 0 === value.length ? defaultValue : minValue > parsedValue ? minValue : parsedValue > maxValue ? maxValue : parsedValue;
                }, WordCloud.prototype.computePositions = function(words, onPositionsComputed) {
                    var maxNumberOfWords, _this = this, context = this.getCanvasContext(), surface = [], borders = null;
                    if (!(words && words.length > 0)) return null;
                    maxNumberOfWords = Math.abs(this.parseNumber(this.settings.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords, -1 * words.length, words.length)), 
                    words.length > maxNumberOfWords && (words = words.slice(0, maxNumberOfWords));
                    for (var i = void 0; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) surface[i] = 0;
                    setTimeout(function() {
                        return _this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0);
                    }, 0);
                }, WordCloud.prototype.computeCycle = function(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
                    void 0 === wordsForDraw && (wordsForDraw = []), void 0 === index && (index = 0);
                    var word = words[index], ratio = 1;
                    words.length <= 10 ? ratio = 5 : words.length <= 25 ? ratio = 3 : words.length <= 75 ? ratio = 1.5 : words.length <= 100 && (ratio = 1.25), 
                    word.x = this.specialViewport.width / ratio * (Math.random() + .5) >> 1, word.y = this.specialViewport.height / ratio * (Math.random() + .5) >> 1, 
                    this.generateSprites(context, word, words, index), word.sprite && this.findPosition(surface, word, borders) && (wordsForDraw.push(word), 
                    borders = this.updateBorders(word, borders), word.x -= this.specialViewport.width >> 1, 
                    word.y -= this.specialViewport.height >> 1), ++index < words.length && this.root ? this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) : onPositionsComputed({
                        data: wordsForDraw,
                        leftBorder: borders && borders[0],
                        rightBorder: borders && borders[1]
                    });
                }, WordCloud.prototype.updateBorders = function(word, borders) {
                    if (borders && 2 === borders.length) {
                        var leftBorder = borders[0], rightBorder = borders[1];
                        word.x + word.x0 < leftBorder.x && (leftBorder.x = word.x + word.x0), word.y + word.y0 < leftBorder.y && (leftBorder.y = word.y + word.y0), 
                        word.x + word.x1 > rightBorder.x && (rightBorder.x = word.x + word.x1), word.y + word.y1 > rightBorder.y && (rightBorder.y = word.y + word.y1);
                    } else borders = [ {
                        x: word.x + word.x0,
                        y: word.y + word.y0
                    }, {
                        x: word.x + word.x1,
                        y: word.y + word.y1
                    } ];
                    return borders;
                }, WordCloud.prototype.generateSprites = function(context, currentWord, words, index) {
                    if (!currentWord.sprite) {
                        context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
                        for (var pixels, x = 0, y = 0, maxHeight = 0, quantityOfWords = words.length, sprite = [], i = index; quantityOfWords > i; i++) {
                            var currentWordData = words[i], widthOfWord = 0, heightOfWord = 0;
                            if (context.save(), context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily, 
                            widthOfWord = context.measureText(currentWordData.text + "m").width, heightOfWord = currentWordData.size << 1, 
                            currentWordData.rotate) {
                                var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
                                widthOfWord = Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31 >> 5 << 5, 
                                heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
                            } else widthOfWord = widthOfWord + 31 >> 5 << 5;
                            heightOfWord > maxHeight && (maxHeight = heightOfWord), x + widthOfWord >= this.canvasViewport.width << 5 && (x = 0, 
                            y += maxHeight, maxHeight = 0), context.translate(x + (widthOfWord >> 1), y + (heightOfWord >> 1)), 
                            currentWordData.rotate && context.rotate(currentWordData.rotate * WordCloud.Radians), 
                            context.fillText(currentWordData.text, 0, 0), currentWordData.padding && (context.lineWidth = 2 * currentWordData.padding, 
                            context.strokeText(currentWordData.text, 0, 0)), context.restore(), currentWordData.width = widthOfWord, 
                            currentWordData.height = heightOfWord, currentWordData.xOff = x, currentWordData.yOff = y, 
                            currentWordData.x1 = widthOfWord >> 1, currentWordData.y1 = heightOfWord >> 1, currentWordData.x0 = -currentWordData.x1, 
                            currentWordData.y0 = -currentWordData.y1, x += widthOfWord;
                        }
                        pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data, 
                        sprite = [];
                        for (var i = quantityOfWords - 1; i >= 0; i--) {
                            var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x_1 = 0, y_1 = 0, seen = 0, seenRow = 0;
                            if (currentWordData.xOff + width >= this.canvasViewport.width << 5 || currentWordData.yOff + height >= this.canvasViewport.height) currentWordData.sprite = null; else {
                                for (var j = 0; height * width32 > j; j++) sprite[j] = 0;
                                if (null === currentWordData.xOff) return;
                                x_1 = currentWordData.xOff, y_1 = currentWordData.yOff, seen = 0, seenRow = -1;
                                for (var j = 0; height > j; j++) {
                                    for (var k = 0; width > k; k++) {
                                        var l = width32 * j + (k >> 5), index_1 = (y_1 + j) * (this.canvasViewport.width << 5) + (x_1 + k) << 2, m = pixels[index_1] ? 1 << 31 - k % 32 : 0;
                                        sprite[l] |= m, seen |= m;
                                    }
                                    seen ? seenRow = j : (currentWordData.y0++, height--, j--, y_1++);
                                }
                                currentWordData.y1 = currentWordData.y0 + seenRow, currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
                            }
                        }
                    }
                }, WordCloud.prototype.findPosition = function(surface, word, borders) {
                    for (var point, dx, dy, startPoint = {
                        x: word.x,
                        y: word.y
                    }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), dt = Math.random() < .5 ? 1 : -1, shift = -dt; ;) {
                        if (shift += dt, point = this.archimedeanSpiral(shift), dx = Math.floor(point.x), 
                        dy = Math.floor(point.y), Math.min(Math.abs(dx), Math.abs(dy)) >= delta) break;
                        if (word.x = startPoint.x + dx, word.y = startPoint.y + dy, !(word.x + word.x0 < 0 || word.y + word.y0 < 0 || word.x + word.x1 > this.specialViewport.width || word.y + word.y1 > this.specialViewport.height) && (!borders || !this.checkIntersect(word, surface)) && (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1]))) {
                            for (var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = 127 & lx, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; height > i; i++) {
                                for (var lastSprite = 0, j = 0; width >= j; j++) {
                                    var leftMask = lastSprite << msx, rightMask = void 0;
                                    width > j && (lastSprite = sprite[i * width + j]), rightMask = width > j ? lastSprite >>> sx : 0, 
                                    surface[x + j] |= leftMask | rightMask;
                                }
                                x += shiftWidth;
                            }
                            return word.sprite = null, !0;
                        }
                    }
                    return !1;
                }, WordCloud.prototype.archimedeanSpiral = function(value) {
                    var ratio = this.specialViewport.width / this.specialViewport.height;
                    return value = .1 * value, {
                        x: ratio * value * Math.cos(value),
                        y: value * Math.sin(value)
                    };
                }, WordCloud.prototype.checkIntersect = function(word, surface) {
                    for (var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = 127 & lx, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; heightOfWord > i; i++) {
                        for (var lastSprite = 0, j = 0; widthOfWord >= j; j++) {
                            var mask = 0, leftMask = void 0, intersectMask = 0;
                            if (leftMask = lastSprite << msx, widthOfWord > j && (lastSprite = sprite[i * widthOfWord + j]), 
                            mask = widthOfWord > j ? lastSprite >>> sx : 0, intersectMask = (leftMask | mask) & surface[x + j]) return !0;
                        }
                        x += shiftWidth;
                    }
                    return !1;
                }, WordCloud.prototype.checkIntersectOfRectangles = function(word, leftBorder, rightBorder) {
                    return word.x + word.x1 > leftBorder.x && word.x + word.x0 < rightBorder.x && word.y + word.y1 > leftBorder.y && word.y + word.y0 < rightBorder.y;
                }, WordCloud.prototype.getCanvasContext = function() {
                    if (!this.canvasViewport) return null;
                    this.canvas.width = 1, this.canvas.height = 1;
                    var context = this.canvas.getContext("2d");
                    return this.canvas.width = this.canvasViewport.width << 5, this.canvas.height = this.canvasViewport.height, 
                    context = this.canvas.getContext("2d"), context.fillStyle = context.strokeStyle = "red", 
                    context.textAlign = "center", context;
                }, WordCloud.prototype.getReducedText = function(texts) {
                    var brokenStrings = [];
                    return brokenStrings = this.getBrokenWords(texts), brokenStrings.reduce(function(previousValue, currentValue) {
                        return previousValue.some(function(value) {
                            return value.index !== currentValue.index && value.text === currentValue.text ? (value.count += currentValue.count, 
                            !0) : !1;
                        }) || previousValue.push(currentValue), previousValue;
                    }, []);
                }, WordCloud.prototype.getBrokenWords = function(words) {
                    var punctuatuinRegExp, _this = this, brokenStrings = [], whiteSpaceRegExp = /\s/;
                    return this.settings.isBrokenText ? (punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim"), 
                    words.forEach(function(item) {
                        if ("string" == typeof item.text) {
                            var words_1;
                            if (words_1 = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp), 
                            _this.settings.isRemoveStopWords) {
                                var stopWords_1 = _this.settings.stopWordsArray;
                                _this.settings.isDefaultStopWords && (stopWords_1 = stopWords_1.concat(WordCloud.StopWords)), 
                                words_1 = words_1.filter(function(value) {
                                    return value.length > 0 && !stopWords_1.some(function(removeWord) {
                                        return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
                                    });
                                });
                            }
                            words_1.forEach(function(element) {
                                element.length > 0 && !whiteSpaceRegExp.test(element) && brokenStrings.push({
                                    text: element,
                                    count: item.count,
                                    index: item.index,
                                    selectionId: item.selectionId,
                                    color: item.color
                                });
                            });
                        } else brokenStrings.push(item);
                    }), brokenStrings) : words;
                }, WordCloud.prototype.getWords = function(values) {
                    var sortedValues, _this = this, minValue = 0, maxValue = 0, valueFormatter = this.settings.valueFormatter;
                    if (!(values && values.length >= 1)) return [];
                    sortedValues = values.sort(function(a, b) {
                        return b.count - a.count;
                    }), minValue = sortedValues[sortedValues.length - 1].count, maxValue = sortedValues[0].count;
                    var returnValues = values.map(function(value) {
                        return {
                            text: valueFormatter.format(value.text),
                            size: _this.getFontSize(value.count, minValue, maxValue),
                            x: 0,
                            y: 0,
                            rotate: _this.getAngle(),
                            padding: 1,
                            width: 0,
                            height: 0,
                            xOff: 0,
                            yOff: 0,
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            color: value.color,
                            selectionId: value.selectionId,
                            wordIndex: value.index
                        };
                    });
                    return this.dataBeforeRender = returnValues, returnValues;
                }, WordCloud.prototype.getFontSize = function(value, minValue, maxValue, scaleType) {
                    void 0 === scaleType && (scaleType = WordCloudScaleType.value);
                    var weight, fontSize, maxFontSize, minFontSize;
                    if (minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize)), 
                    maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize)), 
                    minFontSize > maxFontSize) {
                        var buffer = minFontSize;
                        minFontSize = maxFontSize, maxFontSize = buffer;
                    }
                    switch (scaleType) {
                      case WordCloudScaleType.logn:
                        weight = Math.log(value);

                      case WordCloudScaleType.sqrt:
                        weight = Math.sqrt(value);

                      case WordCloudScaleType.value:
                        weight = value;
                    }
                    return fontSize = weight > minValue ? maxFontSize * (weight - minValue) / (maxValue - minValue) : 0, 
                    fontSize = 100 * fontSize / maxFontSize, fontSize = fontSize * (maxFontSize - minFontSize) / 100 + minFontSize;
                }, WordCloud.prototype.getAngle = function() {
                    if (!this.settings || !this.settings.isRotateText) return 0;
                    var minAngle, maxAngle, maxNumberOfOrientations, angle;
                    if (maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0)), 
                    minAngle = this.parseNumber(this.settings.minAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle), 
                    maxAngle = this.parseNumber(this.settings.maxAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle), 
                    minAngle > maxAngle) {
                        var buffer = minAngle;
                        minAngle = maxAngle, maxAngle = buffer;
                    }
                    return angle = Math.abs((maxAngle - minAngle) / maxNumberOfOrientations * Math.floor(Math.random() * maxNumberOfOrientations)), 
                    0 !== maxNumberOfOrientations ? minAngle + angle : 0;
                }, WordCloud.prototype.update = function(visualUpdateOptions) {
                    var _this = this;
                    if (visualUpdateOptions && visualUpdateOptions.viewport && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0] && visualUpdateOptions.viewport && visualUpdateOptions.viewport.height >= 0 && visualUpdateOptions.viewport.width >= 0) {
                        this.visualUpdateOptions = visualUpdateOptions, this.layout.viewport = this.visualUpdateOptions.viewport;
                        var dataView = visualUpdateOptions.dataViews[0];
                        this.layout.viewportInIsZero || (this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                        this.UpdateSize(), this.data = this.converter(dataView), this.data && (this.settings = this.data.settings, 
                        this.wordCloudTexts = this.data.texts, this.computePositions(this.getWords(this.getReducedText(this.data.texts)), function(wordCloudDataView) {
                            return _this.render(wordCloudDataView);
                        }), visualUpdateOptions !== this.visualUpdateOptions && this.update(this.visualUpdateOptions)));
                    }
                }, WordCloud.prototype.UpdateSize = function() {
                    var fakeWidth, fakeHeight, ratio;
                    ratio = Math.sqrt(this.fakeViewport.width * this.fakeViewport.height / (this.layout.viewportIn.width * this.layout.viewportIn.height)), 
                    isNaN(ratio) ? fakeHeight = fakeWidth = 1 : (fakeHeight = this.layout.viewportIn.height * ratio, 
                    fakeWidth = this.layout.viewportIn.width * ratio), this.specialViewport = {
                        height: fakeHeight,
                        width: fakeWidth
                    }, this.root.attr({
                        height: this.layout.viewport.height,
                        width: this.layout.viewport.width
                    });
                }, WordCloud.prototype.render = function(wordCloudDataView) {
                    var _this = this;
                    if (wordCloudDataView && wordCloudDataView.data) {
                        this.wordCloudDataView = wordCloudDataView;
                        var animatedWordSelection, wordElements = this.main.select(WordCloud.Words.selector).selectAll(WordCloud.Word.selector);
                        this.wordsSelection = wordElements.data(wordCloudDataView.data), this.animation(this.wordsSelection, this.durationAnimations).attr("transform", function(item) {
                            return visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")";
                        }).style({
                            "font-size": function(item) {
                                return "" + item.size + WordCloud.Size;
                            },
                            fill: function(item) {
                                return item.color;
                            }
                        }), animatedWordSelection = this.wordsSelection.enter().append("svg:text").attr("transform", function(item) {
                            return visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")";
                        }).style("font-size", "1px"), this.wordsSelection.on("click", function(item) {
                            _this.selectionManager.select(item.selectionId, d3.event.ctrlKey).then(function() {
                                return _this.setSelection(_this.wordsSelection);
                            }), d3.event.stopPropagation();
                        }), this.animation(animatedWordSelection, this.durationAnimations).style({
                            "font-size": function(item) {
                                return "" + item.size + WordCloud.Size;
                            },
                            fill: function(item) {
                                return item.color;
                            }
                        }), this.wordsSelection.text(function(item) {
                            return item.text;
                        }).classed(WordCloud.Word["class"], !0), this.wordsSelection.exit().remove(), this.setSelection(this.wordsSelection), 
                        setTimeout(function() {
                            _this.root && _this.scaleMainView(wordCloudDataView, wordElements[0].length && _this.durationAnimations);
                        }, this.durationAnimations + WordCloud.RenderDelay);
                    }
                }, WordCloud.prototype.setSelection = function(selection) {
                    var selectionIds = this.selectionManager.getSelectionIds();
                    if (selectionIds.some(function(x) {
                        return !selection.data().some(function(d) {
                            return d.selectionId.getKey() === x.getKey();
                        });
                    }) && (this.selectionManager.clear(), selectionIds = []), !selectionIds.length) return void this.setOpacity(selection, WordCloud.MaxOpacity, !0);
                    var selectedColumns = selection.filter(function(x) {
                        return selectionIds.some(function(y) {
                            return y.getKey() === x.selectionId.getKey();
                        });
                    });
                    this.setOpacity(selection, WordCloud.MinOpacity), this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
                }, WordCloud.prototype.setOpacity = function(element, opacityValue, disableAnimation) {
                    void 0 === disableAnimation && (disableAnimation = !1);
                    var elementAnimation = disableAnimation ? element : this.animation(element);
                    elementAnimation.style("fill-opacity", opacityValue);
                }, WordCloud.prototype.scaleMainView = function(wordCloudDataView, durationAnimation) {
                    if (void 0 === durationAnimation && (durationAnimation = 0), wordCloudDataView && wordCloudDataView.leftBorder && wordCloudDataView.rightBorder) {
                        var width2, height2, scaleByX, scaleByY, scale = 1, mainSVGRect = this.main.node().getBBox(), leftBorder = wordCloudDataView.leftBorder, rightBorder = wordCloudDataView.rightBorder;
                        scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x), 
                        scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y), 
                        scale = Math.min(scaleByX, scaleByY), width2 = this.layout.margin.left + mainSVGRect.x * scale * -1 + (this.layout.viewportIn.width - mainSVGRect.width * scale) / 2, 
                        height2 = this.layout.margin.top + mainSVGRect.y * scale * -1 + (this.layout.viewportIn.height - mainSVGRect.height * scale) / 2, 
                        this.animation(this.main, durationAnimation).attr("transform", visuals.SVGUtil.translate(width2, height2) + "scale(" + scale + ")");
                    }
                }, WordCloud.prototype.enumerateObjectInstances = function(options) {
                    var _this = this, instances = [];
                    if (!this.settings) return instances;
                    switch (options.objectName) {
                      case "general":
                        var general = {
                            objectName: "general",
                            displayName: "general",
                            selector: null,
                            properties: {
                                maxNumberOfWords: this.settings.maxNumberOfWords,
                                minFontSize: this.settings.minFontSize,
                                maxFontSize: this.settings.maxFontSize,
                                isBrokenText: this.settings.isBrokenText
                            }
                        };
                        instances.push(general);
                        break;

                      case "dataPoint":
                        if (!this.wordCloudDataView || !this.wordCloudDataView.data) return;
                        var dataPoints = this.dataBeforeRender, wordCategoriesIndex_1 = [];
                        dataPoints.forEach(function(item) {
                            -1 === wordCategoriesIndex_1.indexOf(item.wordIndex) && (wordCategoriesIndex_1.push(item.wordIndex), 
                            instances.push({
                                objectName: "dataPoint",
                                displayName: _this.data.texts[item.wordIndex].text,
                                selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: item.color
                                        }
                                    }
                                }
                            }));
                        });
                        break;

                      case "rotateText":
                        var rotateText = {
                            objectName: "rotateText",
                            displayName: "Rotate Text",
                            selector: null,
                            properties: {
                                show: this.settings.isRotateText,
                                minAngle: this.settings.minAngle,
                                maxAngle: this.settings.maxAngle,
                                maxNumberOfOrientations: this.settings.maxNumberOfOrientations
                            }
                        };
                        instances.push(rotateText);
                        break;

                      case "stopWords":
                        var stopWords = {
                            objectName: "stopWords",
                            displayName: "Stop Words",
                            selector: null,
                            properties: {
                                show: this.settings.isRemoveStopWords,
                                isDefaultStopWords: this.settings.isDefaultStopWords,
                                words: this.settings.stopWords || this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)
                            }
                        };
                        instances.push(stopWords);
                    }
                    return instances;
                }, WordCloud.prototype.animation = function(element, duration, callback) {
                    return void 0 === duration && (duration = 0), element.transition().duration(duration).each("end", callback);
                }, WordCloud.prototype.destroy = function() {
                    this.root = null, this.canvas = null;
                }, WordCloud.ClassName = "wordCloud", WordCloud.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        },
                        maxNumberOfWords: {
                            objectName: "general",
                            propertyName: "maxNumberOfWords"
                        },
                        minFontSize: {
                            objectName: "general",
                            propertyName: "minFontSize"
                        },
                        maxFontSize: {
                            objectName: "general",
                            propertyName: "maxFontSize"
                        },
                        isBrokenText: {
                            objectName: "general",
                            propertyName: "isBrokenText"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    stopWords: {
                        show: {
                            objectName: "stopWords",
                            propertyName: "show"
                        },
                        isDefaultStopWords: {
                            objectName: "stopWords",
                            propertyName: "isDefaultStopWords"
                        },
                        words: {
                            objectName: "stopWords",
                            propertyName: "words"
                        }
                    },
                    rotateText: {
                        show: {
                            objectName: "rotateText",
                            propertyName: "show"
                        },
                        minAngle: {
                            objectName: "rotateText",
                            propertyName: "minAngle"
                        },
                        maxAngle: {
                            objectName: "rotateText",
                            propertyName: "maxAngle"
                        },
                        maxNumberOfOrientations: {
                            objectName: "rotateText",
                            propertyName: "maxNumberOfOrientations"
                        }
                    }
                }, WordCloud.Words = {
                    "class": "words",
                    selector: ".words"
                }, WordCloud.Word = {
                    "class": "word",
                    selector: ".word"
                }, WordCloud.Size = "px", WordCloud.StopWordsDelemiter = " ", WordCloud.Radians = Math.PI / 180, 
                WordCloud.MinAngle = -180, WordCloud.MaxAngle = 180, WordCloud.MaxNumberOfWords = 2500, 
                WordCloud.MinOpacity = .2, WordCloud.MaxOpacity = 1, WordCloud.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Category"
                    }, {
                        name: "Values",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Values"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                min: 1,
                                max: 1
                            },
                            Values: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {
                                        count: WordCloud.MaxNumberOfWords
                                    }
                                }
                            },
                            values: {
                                "for": {
                                    "in": "Values"
                                }
                            }
                        }
                    } ],
                    sorting: {
                        implicit: {
                            clauses: [ {
                                role: "Values",
                                direction: 2
                            } ]
                        }
                    },
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                },
                                maxNumberOfWords: {
                                    displayName: "Max number of words",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                minFontSize: {
                                    displayName: "Min Font",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                maxFontSize: {
                                    displayName: "Max Font",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                isBrokenText: {
                                    displayName: "Word-breaking",
                                    type: {
                                        bool: !0
                                    }
                                },
                                isRemoveStopWords: {
                                    displayName: "Stop Words",
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: "Data colors",
                            properties: {
                                fill: {
                                    displayName: "Fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        stopWords: {
                            displayName: "Stop Words",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                isDefaultStopWords: {
                                    displayName: "Default Stop Words",
                                    type: {
                                        bool: !0
                                    }
                                },
                                words: {
                                    displayName: "Words",
                                    type: {
                                        text: !0
                                    }
                                }
                            }
                        },
                        rotateText: {
                            displayName: "Rotate Text",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                minAngle: {
                                    displayName: "Min Angle",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                maxAngle: {
                                    displayName: "Max Angle",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                maxNumberOfOrientations: {
                                    displayName: "Max number of orientations",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        }
                    }
                }, WordCloud.Punctuation = [ "!", ".", ":", "'", ";", ",", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "[", "]", '"', "\\", "/", "-", "_", "+", "=" ], 
                WordCloud.StopWords = [ "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an", "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot", "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get", "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i", "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may", "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often", "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should", "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these", "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what", "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet", "you", "your" ], 
                WordCloud.DefaultSettings = {
                    minFontSize: 20,
                    maxFontSize: 100,
                    minAngle: -60,
                    maxAngle: 90,
                    maxNumberOfOrientations: 2,
                    isRotateText: !1,
                    isBrokenText: !0,
                    isRemoveStopWords: !1,
                    stopWordsArray: [],
                    stopWords: void 0,
                    isDefaultStopWords: !1,
                    maxNumberOfWords: 200
                }, WordCloud.RenderDelay = 50, WordCloud.DefaultMargin = {
                    top: 10,
                    right: 10,
                    bottom: 10,
                    left: 10
                }, WordCloud;
            }();
            samples.WordCloud = WordCloud;
            var explore;
            !function(explore) {
                var util;
                !function(util) {
                    function hexToRgb(hex) {
                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                            return r + r + g + g + b + b;
                        });
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
                    }
                    function getRandomColor() {
                        var red = Math.floor(255 * Math.random()), green = Math.floor(255 * Math.random()), blue = Math.floor(255 * Math.random());
                        return "rgb(" + red + "," + green + "," + blue + ")";
                    }
                    util.hexToRgb = hexToRgb, util.getRandomColor = getRandomColor;
                }(util = explore.util || (explore.util = {}));
            }(explore || (explore = {}));
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var TableViewFactory, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter;
            !function(TableViewFactory) {
                function createTableView(options) {
                    return new TableView(options);
                }
                TableViewFactory.createTableView = createTableView;
            }(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
            var TableView = function() {
                function TableView(options) {
                    this.options = $.extend(!0, {}, options), this.options.baseContainer.style("overflow-y", "auto").attr("drag-resize-disabled", !0), 
                    this.scrollContainer = options.baseContainer.append("div").attr("class", "scrollRegion"), 
                    this.visibleGroupContainer = this.scrollContainer.append("div").attr("class", "visibleGroup"), 
                    TableView.SetDefaultOptions(options);
                }
                return TableView.SetDefaultOptions = function(options) {
                    options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
                }, TableView.prototype.rowHeight = function(rowHeight) {
                    return this.options.rowHeight = Math.ceil(rowHeight), this;
                }, TableView.prototype.columnWidth = function(columnWidth) {
                    return this.options.columnWidth = Math.ceil(columnWidth), this;
                }, TableView.prototype.orientation = function(orientation) {
                    return this.options.orientation = orientation, this;
                }, TableView.prototype.rows = function(rows) {
                    return this.options.rows = Math.ceil(rows), this;
                }, TableView.prototype.columns = function(columns) {
                    return this.options.columns = Math.ceil(columns), this;
                }, TableView.prototype.data = function(data, getDatumIndex, dataReset) {
                    return void 0 === dataReset && (dataReset = !1), this._data = data, this.getDatumIndex = getDatumIndex, 
                    this.setTotalRows(), dataReset && $(this.options.baseContainer.node()).scrollTop(0), 
                    this;
                }, TableView.prototype.viewport = function(viewport) {
                    return this.options.viewport = viewport, this;
                }, TableView.prototype.empty = function() {
                    this._data = [], this.render();
                }, TableView.prototype.setTotalRows = function() {
                    var count = this._data.length, rows = Math.min(this.options.rows, count), columns = Math.min(this.options.columns, count);
                    columns > 0 && rows > 0 ? (this._totalColumns = columns, this._totalRows = rows) : rows > 0 ? (this._totalRows = rows, 
                    this._totalColumns = Math.ceil(count / rows)) : columns > 0 ? (this._totalColumns = columns, 
                    this._totalRows = Math.ceil(count / columns)) : (this._totalColumns = TableView.defaultColumns, 
                    this._totalRows = Math.ceil(count / TableView.defaultColumns));
                }, TableView.prototype.render = function() {
                    var options = this.options, visibleGroupContainer = this.visibleGroupContainer, rowHeight = options.rowHeight || TableView.defaultRowHeight, groupedData = [], totalRows = options.rows, totalColumns = options.columns, totalItems = this._data.length, totalRows = options.rows > totalItems ? totalItems : options.rows, totalColumns = options.columns > totalItems ? totalItems : options.columns;
                    if (0 === totalColumns && 0 === totalRows ? options.orientation === Orientation.HORIZONTAL ? (totalColumns = totalItems, 
                    totalRows = 1) : (totalColumns = 1, totalRows = totalItems) : 0 === totalColumns && totalRows > 0 ? totalColumns = Math.ceil(totalItems / totalRows) : totalColumns > 0 && 0 === totalRows && (totalRows = Math.ceil(totalItems / totalColumns)), 
                    this.options.orientation === Orientation.VERTICAL) {
                        var n = totalRows;
                        totalRows = totalColumns, totalColumns = n;
                    } else this.options.orientation === Orientation.HORIZONTAL && (0 === totalRows && (totalRows = this._totalRows), 
                    0 === totalColumns && (totalColumns = this._totalColumns));
                    for (var m = 0, k = 0, i = 0; totalRows > i; i++) if (this.options.orientation === Orientation.VERTICAL && 0 === options.rows && totalItems % options.columns > 0 && options.columns <= totalItems) totalItems % options.columns > i ? (m = i * Math.ceil(totalItems / options.columns), 
                    k = m + Math.ceil(totalItems / options.columns), groupedData.push(this._data.slice(m, k))) : (groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns))), 
                    k += Math.floor(totalItems / options.columns)); else if (this.options.orientation === Orientation.HORIZONTAL && 0 === options.columns && totalItems % options.rows > 0 && options.rows <= totalItems) totalItems % options.rows > i ? (m = i * Math.ceil(totalItems / options.rows), 
                    k = m + Math.ceil(totalItems / options.rows), groupedData.push(this._data.slice(m, k))) : (groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows))), 
                    k += Math.floor(totalItems / options.rows)); else {
                        var k = i * totalColumns;
                        groupedData.push(this._data.slice(k, k + totalColumns));
                    }
                    visibleGroupContainer.selectAll(".row").remove();
                    var cellSelection = visibleGroupContainer.selectAll(".row").data(groupedData).enter().append("div").classed("row", !0).selectAll(".cell").data(function(d) {
                        return d;
                    });
                    cellSelection.enter().append("div").classed("cell", !0).call(function(d) {
                        return options.enter(d);
                    }), cellSelection.order();
                    var cellUpdateSelection = visibleGroupContainer.selectAll(".cell:not(.transitioning)");
                    if (cellUpdateSelection.call(function(d) {
                        return options.update(d);
                    }), cellUpdateSelection.style({
                        height: rowHeight > 0 ? rowHeight + "px" : "auto"
                    }), this.options.orientation === Orientation.VERTICAL) {
                        for (var realColumnNumber = 0, i = 0; i < groupedData.length; i++) 0 !== groupedData[i].length && (realColumnNumber = i + 1);
                        cellUpdateSelection.style({
                            width: "100%"
                        });
                        var rowUpdateSelection = visibleGroupContainer.selectAll("div.row");
                        rowUpdateSelection.style({
                            width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / realColumnNumber + "%"
                        });
                    } else cellUpdateSelection.style({
                        width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / totalColumns + "%"
                    });
                    cellSelection.exit().call(function(d) {
                        return options.exit(d);
                    }).remove();
                }, TableView.defaultRowHeight = 0, TableView.defaultColumns = 1, TableView;
            }();
            samples.chicletSlicerProps = {
                general: {
                    orientation: {
                        objectName: "general",
                        propertyName: "orientation"
                    },
                    columns: {
                        objectName: "general",
                        propertyName: "columns"
                    },
                    rows: {
                        objectName: "general",
                        propertyName: "rows"
                    },
                    showDisabled: {
                        objectName: "general",
                        propertyName: "showDisabled"
                    },
                    multiselect: {
                        objectName: "general",
                        propertyName: "multiselect"
                    },
                    selection: {
                        objectName: "general",
                        propertyName: "selection"
                    }
                },
                header: {
                    show: {
                        objectName: "header",
                        propertyName: "show"
                    },
                    title: {
                        objectName: "header",
                        propertyName: "title"
                    },
                    fontColor: {
                        objectName: "header",
                        propertyName: "fontColor"
                    },
                    background: {
                        objectName: "header",
                        propertyName: "background"
                    },
                    outline: {
                        objectName: "header",
                        propertyName: "outline"
                    },
                    textSize: {
                        objectName: "header",
                        propertyName: "textSize"
                    },
                    outlineColor: {
                        objectName: "header",
                        propertyName: "outlineColor"
                    },
                    outlineWeight: {
                        objectName: "header",
                        propertyName: "outlineWeight"
                    }
                },
                rows: {
                    fontColor: {
                        objectName: "rows",
                        propertyName: "fontColor"
                    },
                    textSize: {
                        objectName: "rows",
                        propertyName: "textSize"
                    },
                    height: {
                        objectName: "rows",
                        propertyName: "height"
                    },
                    width: {
                        objectName: "rows",
                        propertyName: "width"
                    },
                    background: {
                        objectName: "rows",
                        propertyName: "background"
                    },
                    transparency: {
                        objectName: "rows",
                        propertyName: "transparency"
                    },
                    selectedColor: {
                        objectName: "rows",
                        propertyName: "selectedColor"
                    },
                    unselectedColor: {
                        objectName: "rows",
                        propertyName: "unselectedColor"
                    },
                    disabledColor: {
                        objectName: "rows",
                        propertyName: "disabledColor"
                    },
                    outline: {
                        objectName: "rows",
                        propertyName: "outline"
                    },
                    outlineColor: {
                        objectName: "rows",
                        propertyName: "outlineColor"
                    },
                    outlineWeight: {
                        objectName: "rows",
                        propertyName: "outlineWeight"
                    },
                    borderStyle: {
                        objectName: "rows",
                        propertyName: "borderStyle"
                    }
                },
                images: {
                    imageSplit: {
                        objectName: "images",
                        propertyName: "imageSplit"
                    },
                    stretchImage: {
                        objectName: "images",
                        propertyName: "stretchImage"
                    },
                    bottomImage: {
                        objectName: "images",
                        propertyName: "bottomImage"
                    }
                },
                selectedPropertyIdentifier: {
                    objectName: "general",
                    propertyName: "selected"
                },
                filterPropertyIdentifier: {
                    objectName: "general",
                    propertyName: "filter"
                },
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                },
                hasSavedSelection: !0
            };
            var ChicletBorderStyle;
            !function(ChicletBorderStyle) {
                ChicletBorderStyle.ROUNDED = "Rounded", ChicletBorderStyle.CUT = "Cut", ChicletBorderStyle.SQUARE = "Square", 
                ChicletBorderStyle.type = powerbi.createEnumType([ {
                    value: ChicletBorderStyle.ROUNDED,
                    displayName: ChicletBorderStyle.ROUNDED
                }, {
                    value: ChicletBorderStyle.CUT,
                    displayName: ChicletBorderStyle.CUT
                }, {
                    value: ChicletBorderStyle.SQUARE,
                    displayName: ChicletBorderStyle.SQUARE
                } ]);
            }(ChicletBorderStyle || (ChicletBorderStyle = {}));
            var ChicletSlicerShowDisabled;
            !function(ChicletSlicerShowDisabled) {
                ChicletSlicerShowDisabled.INPLACE = "Inplace", ChicletSlicerShowDisabled.BOTTOM = "Bottom", 
                ChicletSlicerShowDisabled.HIDE = "Hide", ChicletSlicerShowDisabled.type = powerbi.createEnumType([ {
                    value: ChicletSlicerShowDisabled.INPLACE,
                    displayName: ChicletSlicerShowDisabled.INPLACE
                }, {
                    value: ChicletSlicerShowDisabled.BOTTOM,
                    displayName: ChicletSlicerShowDisabled.BOTTOM
                }, {
                    value: ChicletSlicerShowDisabled.HIDE,
                    displayName: ChicletSlicerShowDisabled.HIDE
                } ]);
            }(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
            var Orientation;
            !function(Orientation) {
                Orientation.HORIZONTAL = "Horizontal", Orientation.VERTICAL = "Vertical", Orientation.type = powerbi.createEnumType([ {
                    value: Orientation.HORIZONTAL,
                    displayName: Orientation.HORIZONTAL
                }, {
                    value: Orientation.VERTICAL,
                    displayName: Orientation.VERTICAL
                } ]);
            }(Orientation || (Orientation = {}));
            var ChicletSlicer = function() {
                function ChicletSlicer(options) {
                    options && options.behavior && (this.behavior = options.behavior), this.behavior || (this.behavior = new ChicletSlicerWebBehavior());
                }
                return ChicletSlicer.DefaultStyleProperties = function() {
                    return {
                        general: {
                            orientation: Orientation.VERTICAL,
                            columns: 3,
                            rows: 0,
                            multiselect: !0,
                            showDisabled: ChicletSlicerShowDisabled.INPLACE,
                            selection: null
                        },
                        margin: {
                            top: 50,
                            bottom: 50,
                            right: 50,
                            left: 50
                        },
                        header: {
                            borderBottomWidth: 1,
                            show: !0,
                            outline: "BottomOnly",
                            fontColor: "#a6a6a6",
                            background: null,
                            textSize: 10,
                            outlineColor: "#a6a6a6",
                            outlineWeight: 1,
                            title: ""
                        },
                        headerText: {
                            marginLeft: 8,
                            marginTop: 0
                        },
                        slicerText: {
                            textSize: 10,
                            height: 0,
                            width: 0,
                            fontColor: "#666666",
                            hoverColor: "#212121",
                            selectedColor: "#BDD7EE",
                            unselectedColor: "#ffffff",
                            disabledColor: "grey",
                            marginLeft: 8,
                            outline: "Frame",
                            background: null,
                            transparency: 0,
                            outlineColor: "#000000",
                            outlineWeight: 1,
                            borderStyle: "Cut"
                        },
                        slicerItemContainer: {
                            marginTop: 5,
                            marginLeft: 0
                        },
                        images: {
                            imageSplit: 50,
                            stretchImage: !1,
                            bottomImage: !1
                        }
                    };
                }, ChicletSlicer.converter = function(dataView, localizedSelectAllText, interactivityService) {
                    if (dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0) {
                        var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
                        converter.convert();
                        var slicerData, defaultSettings = this.DefaultStyleProperties(), objects = dataView.metadata.objects;
                        objects && (defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation), 
                        defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns), 
                        defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows), 
                        defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect), 
                        defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled), 
                        defaultSettings.general.selection = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection), 
                        defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show), 
                        defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title), 
                        defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor), 
                        defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background), 
                        defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize), 
                        defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline), 
                        defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor), 
                        defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight), 
                        defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize), 
                        defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height), 
                        defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width), 
                        defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor), 
                        defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor), 
                        defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor), 
                        defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background), 
                        defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency), 
                        defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor), 
                        defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline), 
                        defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor), 
                        defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight), 
                        defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle), 
                        defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit), 
                        defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage), 
                        defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage));
                        var categories = dataView.categorical.categories[0];
                        return slicerData = {
                            categorySourceName: categories.source.displayName,
                            formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
                            slicerSettings: defaultSettings,
                            slicerDataPoints: converter.dataPoints
                        }, slicerData.hasSelectionOverride = converter.hasSelectionOverride, slicerData;
                    }
                }, ChicletSlicer.prototype.init = function(options) {
                    this.element = options.element, this.currentViewport = options.viewport, this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                    this.hostServices = options.host, this.settings = ChicletSlicer.DefaultStyleProperties(), 
                    this.initContainer();
                }, ChicletSlicer.prototype.update = function(options) {
                    if (options && options.dataViews && options.dataViews[0] && options.viewport) {
                        var existingDataView = this.dataView;
                        this.dataView = options.dataViews[0];
                        var resetScrollbarPosition = !0;
                        existingDataView && (resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView)), 
                        options.viewport.height === this.currentViewport.height && options.viewport.width === this.currentViewport.width ? this.waitingForData = !1 : this.currentViewport = options.viewport, 
                        this.updateInternal(resetScrollbarPosition);
                    }
                }, ChicletSlicer.prototype.onResizing = function(finalViewport) {
                    this.currentViewport = finalViewport, this.updateInternal(!1);
                }, ChicletSlicer.prototype.enumerateObjectInstances = function(options) {
                    var data = this.slicerData;
                    if (data) {
                        var objectName = options.objectName;
                        switch (objectName) {
                          case "rows":
                            return this.enumerateRows(data);

                          case "header":
                            return this.enumerateHeader(data);

                          case "general":
                            return this.enumerateGeneral(data);

                          case "images":
                            return this.enumerateImages(data);
                        }
                    }
                }, ChicletSlicer.prototype.enumerateHeader = function(data) {
                    var slicerSettings = this.settings;
                    return [ {
                        selector: null,
                        objectName: "header",
                        properties: {
                            show: slicerSettings.header.show,
                            title: slicerSettings.header.title,
                            fontColor: slicerSettings.header.fontColor,
                            background: slicerSettings.header.background,
                            textSize: slicerSettings.header.textSize,
                            outline: slicerSettings.header.outline,
                            outlineColor: slicerSettings.header.outlineColor,
                            outlineWeight: slicerSettings.header.outlineWeight
                        }
                    } ];
                }, ChicletSlicer.prototype.enumerateRows = function(data) {
                    var slicerSettings = this.settings;
                    return [ {
                        selector: null,
                        objectName: "rows",
                        properties: {
                            textSize: slicerSettings.slicerText.textSize,
                            height: slicerSettings.slicerText.height,
                            width: slicerSettings.slicerText.width,
                            background: slicerSettings.slicerText.background,
                            transparency: slicerSettings.slicerText.transparency,
                            selectedColor: slicerSettings.slicerText.selectedColor,
                            unselectedColor: slicerSettings.slicerText.unselectedColor,
                            disabledColor: slicerSettings.slicerText.disabledColor,
                            outline: slicerSettings.slicerText.outline,
                            outlineColor: slicerSettings.slicerText.outlineColor,
                            outlineWeight: slicerSettings.slicerText.outlineWeight,
                            fontColor: slicerSettings.slicerText.fontColor,
                            borderStyle: slicerSettings.slicerText.borderStyle
                        }
                    } ];
                }, ChicletSlicer.prototype.enumerateGeneral = function(data) {
                    var slicerSettings = this.settings;
                    return [ {
                        selector: null,
                        objectName: "general",
                        properties: {
                            orientation: slicerSettings.general.orientation,
                            columns: slicerSettings.general.columns,
                            rows: slicerSettings.general.rows,
                            showDisabled: slicerSettings.general.showDisabled,
                            multiselect: slicerSettings.general.multiselect
                        }
                    } ];
                }, ChicletSlicer.prototype.enumerateImages = function(data) {
                    var slicerSettings = this.settings;
                    return [ {
                        selector: null,
                        objectName: "images",
                        properties: {
                            imageSplit: slicerSettings.images.imageSplit,
                            stretchImage: slicerSettings.images.stretchImage,
                            bottomImage: slicerSettings.images.bottomImage
                        }
                    } ];
                }, ChicletSlicer.prototype.updateInternal = function(resetScrollbarPosition) {
                    var _this = this;
                    this.updateSlicerBodyDimensions();
                    var localizedSelectAllText = "Select All", data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);
                    if (!data) return void this.tableView.empty();
                    this.interactivityService && this.interactivityService.applySelectionStateToData(data.slicerDataPoints), 
                    data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight, 
                    data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight, 
                    data.slicerSettings.general.getSavedSelection = function() {
                        try {
                            return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];
                        } catch (ex) {
                            return [];
                        }
                    }, data.slicerSettings.general.setSavedSelection = function(selectionIds) {
                        _this.isSelectionSaved = !0, _this.hostServices.persistProperties({
                            merge: [ {
                                objectName: "general",
                                selector: null,
                                properties: {
                                    selection: selectionIds && JSON.stringify(selectionIds) || ""
                                }
                            } ]
                        });
                    }, this.slicerData ? this.isSelectionSaved ? this.isSelectionLoaded = !0 : this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection : this.isSelectionLoaded = !1, 
                    this.slicerData = data, this.settings = this.slicerData.slicerSettings, this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM ? data.slicerDataPoints.sort(function(a, b) {
                        return a.selectable === b.selectable ? 0 : a.selectable && !b.selectable ? -1 : 1;
                    }) : this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE && (data.slicerDataPoints = data.slicerDataPoints.filter(function(x) {
                        return x.selectable;
                    }));
                    var height = this.settings.slicerText.height;
                    if (0 === height) {
                        var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders, textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;
                        var hasImage = _.any(data.slicerDataPoints, function(x) {
                            return "" !== x.imageURL && "undefined" != typeof x.imageURL;
                        });
                        hasImage && (height += 100);
                    }
                    this.tableView.rowHeight(height).columnWidth(this.settings.slicerText.width).orientation(this.settings.general.orientation).rows(this.settings.general.rows).columns(this.settings.general.columns).data(data.slicerDataPoints, function(d) {
                        return $.inArray(d, data.slicerDataPoints);
                    }, resetScrollbarPosition).viewport(this.getSlicerBodyViewport(this.currentViewport)).render();
                }, ChicletSlicer.prototype.initContainer = function() {
                    var _this = this, settings = this.settings, slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport), slicerContainer = d3.select(this.element.get(0)).append("div").classed(ChicletSlicer.Container["class"], !0);
                    this.slicerHeader = slicerContainer.append("div").classed(ChicletSlicer.Header["class"], !0), 
                    this.slicerHeader.append("span").classed(ChicletSlicer.Clear["class"], !0).attr("title", "Clear"), 
                    this.slicerHeader.append("div").classed(ChicletSlicer.HeaderText["class"], !0).style({
                        "margin-left": PixelConverter.toString(settings.headerText.marginLeft),
                        "margin-top": PixelConverter.toString(settings.headerText.marginTop),
                        "border-style": this.getBorderStyle(settings.header.outline),
                        "border-color": settings.header.outlineColor,
                        "border-width": this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                        "font-size": PixelConverter.fromPoint(settings.header.textSize)
                    }), this.slicerBody = slicerContainer.append("div").classed(ChicletSlicer.Body["class"], !0).classed("slicerBody-horizontal", settings.general.orientation === Orientation.HORIZONTAL).classed("slicerBody-vertical", settings.general.orientation === Orientation.VERTICAL).style({
                        height: PixelConverter.toString(slicerBodyViewport.height),
                        width: "100%"
                    });
                    var rowEnter = function(rowSelection) {
                        var settings = _this.settings, listItemElement = rowSelection.append("li").classed(ChicletSlicer.ItemContainer["class"], !0).style({
                            "margin-left": PixelConverter.toString(settings.slicerItemContainer.marginLeft)
                        });
                        listItemElement.append("div").classed("slicer-img-wrapper", !0), listItemElement.append("div").classed("slicer-text-wrapper", !0).append("span").classed(ChicletSlicer.LabelText["class"], !0).style({
                            "font-size": PixelConverter.fromPoint(settings.slicerText.textSize)
                        });
                    }, rowUpdate = function(rowSelection) {
                        var settings = _this.settings, data = _this.slicerData;
                        if (data && settings) {
                            _this.slicerHeader.classed("hidden", !settings.header.show), _this.slicerHeader.select(ChicletSlicer.HeaderText.selector).text("" !== settings.header.title.trim() ? settings.header.title.trim() : _this.slicerData.categorySourceName).style({
                                "border-style": _this.getBorderStyle(settings.header.outline),
                                "border-color": settings.header.outlineColor,
                                "border-width": _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                                color: settings.header.fontColor,
                                "background-color": settings.header.background,
                                "font-size": PixelConverter.fromPoint(settings.header.textSize)
                            }), _this.slicerBody.classed("slicerBody-horizontal", settings.general.orientation === Orientation.HORIZONTAL).classed("slicerBody-vertical", settings.general.orientation === Orientation.VERTICAL);
                            var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector), textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize), formatString = data.formatString;
                            slicerText.text(function(d) {
                                var text = visuals.valueFormatter.format(d.category, formatString);
                                return textProperties.text = text, 0 === _this.settings.slicerText.width ? powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.currentViewport.width / _this.settings.general.columns - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight) : powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
                            });
                            var slicerImg = rowSelection.selectAll(".slicer-img-wrapper");
                            if (slicerImg.style("height", settings.images.imageSplit + "%").classed("hidden", function(d) {
                                return d.imageURL ? settings.images.imageSplit < 10 ? !0 : void 0 : !0;
                            }).style("display", function(d) {
                                return d.imageURL ? "flex" : "none";
                            }).classed("stretchImage", settings.images.stretchImage).classed("bottomImage", settings.images.bottomImage).style("background-image", function(d) {
                                return d.imageURL ? "url(" + d.imageURL + ")" : "";
                            }), rowSelection.selectAll(".slicer-text-wrapper").style("height", function(d) {
                                return d.imageURL ? 100 - settings.images.imageSplit + "%" : "100%";
                            }).classed("hidden", function(d) {
                                return settings.images.imageSplit > 90 ? !0 : void 0;
                            }), rowSelection.selectAll(".slicerItemContainer").style({
                                color: settings.slicerText.fontColor,
                                "border-style": _this.getBorderStyle(settings.slicerText.outline),
                                "border-color": settings.slicerText.outlineColor,
                                "border-width": _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
                                "font-size": PixelConverter.fromPoint(settings.slicerText.textSize),
                                "border-radius": _this.getBorderRadius(settings.slicerText.borderStyle)
                            }), settings.slicerText.background ? _this.slicerBody.style("background-color", explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100)) : _this.slicerBody.style("background-color", null), 
                            _this.interactivityService && _this.slicerBody) {
                                var slicerBody = _this.slicerBody.attr("width", _this.currentViewport.width), slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector), slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector), slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector), slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector), behaviorOptions = {
                                    dataPoints: data.slicerDataPoints,
                                    slicerItemContainers: slicerItemContainers,
                                    slicerItemLabels: slicerItemLabels,
                                    slicerItemInputs: slicerItemInputs,
                                    slicerClear: slicerClear,
                                    interactivityService: _this.interactivityService,
                                    slicerSettings: data.slicerSettings,
                                    isSelectionLoaded: _this.isSelectionLoaded
                                };
                                _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {
                                    overrideSelectionFromData: !0,
                                    hasSelectionOverride: data.hasSelectionOverride
                                }), _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());
                            } else _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), !1);
                        }
                    }, rowExit = function(rowSelection) {
                        rowSelection.remove();
                    }, tableViewOptions = {
                        rowHeight: this.getRowHeight(),
                        columnWidth: this.settings.slicerText.width,
                        orientation: this.settings.general.orientation,
                        rows: this.settings.general.rows,
                        columns: this.settings.general.columns,
                        enter: rowEnter,
                        exit: rowExit,
                        update: rowUpdate,
                        loadMoreData: function() {
                            return _this.onLoadMoreData();
                        },
                        scrollEnabled: !0,
                        viewport: this.getSlicerBodyViewport(this.currentViewport),
                        baseContainer: this.slicerBody
                    };
                    this.tableView = TableViewFactory.createTableView(tableViewOptions);
                }, ChicletSlicer.prototype.onLoadMoreData = function() {
                    !this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment && (this.hostServices.loadMoreData(), 
                    this.waitingForData = !0);
                }, ChicletSlicer.prototype.getSlicerBodyViewport = function(currentViewport) {
                    var settings = this.settings, headerHeight = settings.header.show ? this.getHeaderHeight() : 0, slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                    return {
                        height: slicerBodyHeight,
                        width: currentViewport.width
                    };
                }, ChicletSlicer.prototype.updateSlicerBodyDimensions = function() {
                    var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                    this.slicerBody.style({
                        height: PixelConverter.toString(slicerViewport.height),
                        width: "100%"
                    });
                }, ChicletSlicer.getChicletTextProperties = function(textSize) {
                    return {
                        fontFamily: ChicletSlicer.DefaultFontFamily,
                        fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt)
                    };
                }, ChicletSlicer.prototype.getHeaderHeight = function() {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
                }, ChicletSlicer.prototype.getRowHeight = function() {
                    var textSettings = this.settings.slicerText;
                    return 0 !== textSettings.height ? textSettings.height : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
                }, ChicletSlicer.prototype.getBorderStyle = function(outlineElement) {
                    return "0px" === outlineElement ? "none" : "solid";
                }, ChicletSlicer.prototype.getBorderWidth = function(outlineElement, outlineWeight) {
                    switch (outlineElement) {
                      case "None":
                        return "0px";

                      case "BottomOnly":
                        return "0px 0px " + outlineWeight + "px 0px";

                      case "TopOnly":
                        return outlineWeight + "px 0px 0px 0px";

                      case "TopBottom":
                        return outlineWeight + "px 0px " + outlineWeight + "px 0px";

                      case "LeftRight":
                        return "0px " + outlineWeight + "px 0px " + outlineWeight + "px";

                      case "Frame":
                        return outlineWeight + "px";

                      default:
                        return outlineElement.replace("1", outlineWeight.toString());
                    }
                }, ChicletSlicer.prototype.getBorderRadius = function(borderType) {
                    switch (borderType) {
                      case ChicletBorderStyle.ROUNDED:
                        return "10px";

                      case ChicletBorderStyle.SQUARE:
                        return "0px";

                      default:
                        return "5px";
                    }
                }, ChicletSlicer.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Field")
                    }, {
                        name: "Values",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                    }, {
                        name: "Image",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Image"
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                selection: {
                                    displayName: "Selection",
                                    type: {
                                        text: !0
                                    }
                                },
                                orientation: {
                                    displayName: "Orientation",
                                    type: {
                                        enumeration: Orientation.type
                                    }
                                },
                                columns: {
                                    displayName: "Columns",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                rows: {
                                    displayName: "Rows",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                showDisabled: {
                                    displayName: "Show Disabled",
                                    type: {
                                        enumeration: ChicletSlicerShowDisabled.type
                                    }
                                },
                                multiselect: {
                                    displayName: "Multiple selection",
                                    type: {
                                        bool: !0
                                    }
                                },
                                selected: {
                                    type: {
                                        bool: !0
                                    }
                                },
                                filter: {
                                    type: {
                                        filter: {}
                                    },
                                    rule: {
                                        output: {
                                            property: "selected",
                                            selector: [ "Category" ]
                                        }
                                    }
                                },
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        header: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Header"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                title: {
                                    displayName: "Title",
                                    type: {
                                        text: !0
                                    }
                                },
                                fontColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_FontColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                background: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                outline: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                    type: {
                                        formatting: {
                                            outline: !0
                                        }
                                    }
                                },
                                textSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                outlineColor: {
                                    displayName: "Outline Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                outlineWeight: {
                                    displayName: "Outline Weight",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        rows: {
                            displayName: "Chiclets",
                            properties: {
                                fontColor: {
                                    displayName: "Text color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                textSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                height: {
                                    displayName: "Height",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                width: {
                                    displayName: "Width",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                selectedColor: {
                                    displayName: "Selected Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                unselectedColor: {
                                    displayName: "Unselected Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                disabledColor: {
                                    displayName: "Disabled Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                background: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                transparency: {
                                    displayName: "Transparency",
                                    description: "Set transparency for background color",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                outline: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                    type: {
                                        formatting: {
                                            outline: !0
                                        }
                                    }
                                },
                                outlineColor: {
                                    displayName: "Outline Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                outlineWeight: {
                                    displayName: "Outline Weight",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                borderStyle: {
                                    displayName: "Outline Style",
                                    type: {
                                        enumeration: ChicletBorderStyle.type
                                    }
                                }
                            }
                        },
                        images: {
                            displayName: "Images",
                            properties: {
                                imageSplit: {
                                    displayName: "Image Split",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                stretchImage: {
                                    displayName: "Stretch image",
                                    type: {
                                        bool: !0
                                    }
                                },
                                bottomImage: {
                                    displayName: "Bottom image",
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Image: {
                                min: 0,
                                max: 1
                            },
                            Values: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Image",
                                    select: [ {
                                        bind: {
                                            to: "Values"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            },
                            includeEmptyGroups: !0
                        }
                    } ],
                    supportsHighlight: !0,
                    sorting: {
                        "default": {}
                    },
                    suppressDefaultTitle: !0
                }, ChicletSlicer.DefaultFontFamily = "Segoe UI, Tahoma, Verdana, Geneva, sans-serif", 
                ChicletSlicer.DefaultFontSizeInPt = 11, ChicletSlicer.cellTotalInnerPaddings = 8, 
                ChicletSlicer.cellTotalInnerBorders = 2, ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14, 
                ChicletSlicer.ItemContainer = createClassAndSelector("slicerItemContainer"), ChicletSlicer.HeaderText = createClassAndSelector("headerText"), 
                ChicletSlicer.Container = createClassAndSelector("chicletSlicer"), ChicletSlicer.LabelText = createClassAndSelector("slicerText"), 
                ChicletSlicer.Header = createClassAndSelector("slicerHeader"), ChicletSlicer.Input = createClassAndSelector("slicerCheckbox"), 
                ChicletSlicer.Clear = createClassAndSelector("clear"), ChicletSlicer.Body = createClassAndSelector("slicerBody"), 
                ChicletSlicer;
            }();
            samples.ChicletSlicer = ChicletSlicer;
            var ChicletSlicerChartConversion;
            !function(ChicletSlicerChartConversion) {
                var ChicletSlicerConverter = function() {
                    function ChicletSlicerConverter(dataView, interactivityService) {
                        var dataViewCategorical = dataView.categorical;
                        this.dataViewCategorical = dataViewCategorical, this.dataViewMetadata = dataView.metadata, 
                        dataViewCategorical.categories && dataViewCategorical.categories.length > 0 && (this.category = dataViewCategorical.categories[0], 
                        this.categoryIdentities = this.category.identity, this.categoryValues = this.category.values, 
                        this.categoryColumnRef = this.category.identityFields, this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString)), 
                        this.dataPoints = [], this.interactivityService = interactivityService, this.hasSelectionOverride = !1;
                    }
                    return ChicletSlicerConverter.prototype.convert = function() {
                        if (this.dataPoints = [], this.numberOfCategoriesSelectedInData = 0, this.categoryValues) {
                            var numberOfScopeIds, objects = this.dataViewMetadata ? this.dataViewMetadata.objects : void 0, isInvertedSelectionMode = void 0;
                            if (objects && objects.general && objects.general.filter) {
                                if (!this.categoryColumnRef) return;
                                var filter = objects.general.filter, scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
                                scopeIds ? (isInvertedSelectionMode = scopeIds.isNot, numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0) : isInvertedSelectionMode = !1;
                            }
                            this.interactivityService && (void 0 === isInvertedSelectionMode ? isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted() : this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode));
                            for (var hasSelection = void 0, idx = 0; idx < this.categoryValues.length; idx++) {
                                var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
                                if (null != selected) {
                                    hasSelection = selected;
                                    break;
                                }
                            }
                            for (var dataViewCategorical = this.dataViewCategorical, formatStringProp = samples.chicletSlicerProps.formatString, value = -(1 / 0), imageURL = "", categoryIndex = 0, categoryCount = this.categoryValues.length; categoryCount > categoryIndex; categoryIndex++) {
                                var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null, categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex), selectable = !0;
                                null != hasSelection && (isInvertedSelectionMode ? (null == this.category.objects && (categoryIsSelected = void 0), 
                                null != categoryIsSelected ? categoryIsSelected = hasSelection : null == categoryIsSelected && (categoryIsSelected = !hasSelection)) : null == categoryIsSelected && (categoryIsSelected = !hasSelection)), 
                                categoryIsSelected && this.numberOfCategoriesSelectedInData++;
                                var categoryValue = this.categoryValues[categoryIndex], categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                                if (this.dataViewCategorical.values) for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
                                    var seriesData = dataViewCategorical.values[seriesIndex];
                                    null != seriesData.values[categoryIndex] && (value = seriesData.values[categoryIndex], 
                                    seriesData.highlights && (selectable = !(null === seriesData.highlights[categoryIndex])), 
                                    seriesData.source.groupName && "" !== seriesData.source.groupName && (imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp), 
                                    /^(ftp|http|https):\/\/[^ "]+$/.test(imageURL) || (imageURL = void 0)));
                                }
                                this.dataPoints.push({
                                    identity: visuals.SelectionId.createWithId(categoryIdentity),
                                    category: categoryLabel,
                                    imageURL: imageURL,
                                    value: value,
                                    selected: categoryIsSelected,
                                    selectable: selectable
                                });
                            }
                            null != numberOfScopeIds && numberOfScopeIds > this.numberOfCategoriesSelectedInData && (this.hasSelectionOverride = !0);
                        }
                    }, ChicletSlicerConverter;
                }();
                ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
            }(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
            var ChicletSlicerTextMeasurementHelper;
            !function(ChicletSlicerTextMeasurementHelper) {
                function estimateSvgTextBaselineDelta(textProperties) {
                    var rect = estimateSvgTextRect(textProperties);
                    return rect.y + rect.height;
                }
                function ensureDOM() {
                    spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                        height: "0px",
                        width: "0px",
                        position: "absolute"
                    }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                }
                function measureSvgTextRect(textProperties) {
                    return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                        visibility: "hidden",
                        "font-family": textProperties.fontFamily,
                        "font-size": textProperties.fontSize,
                        "font-weight": textProperties.fontWeight,
                        "font-style": textProperties.fontStyle,
                        "white-space": textProperties.whiteSpace || "nowrap"
                    }), svgTextElement.node().getBBox();
                }
                function estimateSvgTextRect(textProperties) {
                    var estimatedTextProperties = {
                        fontFamily: textProperties.fontFamily,
                        fontSize: textProperties.fontSize,
                        text: "M"
                    }, rect = measureSvgTextRect(estimatedTextProperties);
                    return rect;
                }
                var spanElement, svgTextElement, canvasCtx;
                ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
            }(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
            var ChicletSlicerWebBehavior = function() {
                function ChicletSlicerWebBehavior() {}
                return ChicletSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var _this = this, filterPropertyId = samples.chicletSlicerProps.filterPropertyIdentifier, slicers = this.slicers = options.slicerItemContainers;
                    this.slicerItemLabels = options.slicerItemLabels, this.slicerItemInputs = options.slicerItemInputs;
                    var slicerClear = options.slicerClear;
                    this.dataPoints = options.dataPoints, this.interactivityService = options.interactivityService, 
                    this.slicerSettings = options.slicerSettings, this.options = options, this.options.isSelectionLoaded || this.loadSelection(selectionHandler), 
                    slicers.on("mouseover", function(d) {
                        d.selectable && (d.mouseOver = !0, d.mouseOut = !1, _this.renderMouseover());
                    }), slicers.on("mouseout", function(d) {
                        d.selectable && (d.mouseOver = !1, d.mouseOut = !0, _this.renderMouseover());
                    }), slicers.on("click", function(d, index) {
                        if (d.selectable) {
                            var settings = _this.slicerSettings;
                            if (d3.event.preventDefault(), d3.event.altKey && settings.general.multiselect) {
                                var selectedIndexes = jQuery.map(_this.dataPoints, function(d, index) {
                                    return d.selected ? index : void 0;
                                }), selIndex = selectedIndexes.length > 0 ? selectedIndexes[selectedIndexes.length - 1] : 0;
                                if (selIndex > index) {
                                    var temp = index;
                                    index = selIndex, selIndex = temp;
                                }
                                selectionHandler.handleClearSelection();
                                for (var i = selIndex; index >= i; i++) selectionHandler.handleSelection(_this.dataPoints[i], !0);
                            } else d3.event.ctrlKey && settings.general.multiselect ? selectionHandler.handleSelection(d, !0) : selectionHandler.handleSelection(d, !1);
                            selectionHandler.persistSelectionFilter(filterPropertyId), _this.saveSelection(selectionHandler);
                        }
                    }), slicerClear.on("click", function(d) {
                        selectionHandler.handleClearSelection(), selectionHandler.persistSelectionFilter(filterPropertyId), 
                        _this.saveSelection(selectionHandler);
                    });
                }, ChicletSlicerWebBehavior.prototype.loadSelection = function(selectionHandler) {
                    selectionHandler.handleClearSelection();
                    var savedSelectionIds = this.slicerSettings.general.getSavedSelection();
                    if (savedSelectionIds.length) {
                        var selectedDataPoints = this.dataPoints.filter(function(d) {
                            return savedSelectionIds.some(function(x) {
                                return d.identity.getKey() === x;
                            });
                        });
                        selectedDataPoints.forEach(function(x) {
                            return selectionHandler.handleSelection(x, !0);
                        }), selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);
                    }
                }, ChicletSlicerWebBehavior.prototype.saveSelection = function(selectionHandler) {
                    var selectionIdKeys = selectionHandler.selectedIds.map(function(x) {
                        return x.getKey();
                    });
                    this.slicerSettings.general.setSavedSelection(selectionIdKeys);
                }, ChicletSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                    hasSelection || this.interactivityService.isSelectionModeInverted() ? this.styleSlicerInputs(this.slicers, hasSelection) : this.slicers.style("background", this.slicerSettings.slicerText.unselectedColor);
                }, ChicletSlicerWebBehavior.prototype.renderMouseover = function() {
                    var _this = this;
                    this.slicerItemLabels.style({
                        color: function(d) {
                            return d.mouseOver ? _this.slicerSettings.slicerText.hoverColor : d.mouseOut ? d.selected ? _this.slicerSettings.slicerText.fontColor : _this.slicerSettings.slicerText.fontColor : void 0;
                        }
                    });
                }, ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function(slicers, hasSelection) {
                    var settings = this.slicerSettings, selectedItems = [];
                    slicers.each(function(d) {
                        d.selectable && d.selected && selectedItems.push(d), d3.select(this).style({
                            background: d.selectable ? d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor : settings.slicerText.disabledColor
                        }), d3.select(this).classed("slicerItem-disabled", !d.selectable);
                    });
                }, ChicletSlicerWebBehavior;
            }();
            samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
            var explore;
            !function(explore) {
                var util;
                !function(util) {
                    function hexToRGBString(hex, transparency) {
                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                            return r + r + g + g + b + b;
                        });
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex), rgb = result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                        return null === rgb ? "" : transparency || 0 === transparency ? "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")" : "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                    }
                    util.hexToRGBString = hexToRGBString;
                }(util = explore.util || (explore.util = {}));
            }(explore || (explore = {}));
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var ChordChart = function() {
                function ChordChart() {}
                return ChordChart.converter = function(dataView, colors, prevAxisVisible) {
                    var catDv = dataView.categorical, defaultDataPointColor = ChordChart.getDefaultDataPointColor(dataView).solid.color, labelColor = ChordChart.getLabelsColor(dataView), labelFontSize = ChordChart.getLabelsFontSize(dataView);
                    if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {
                        for (var cat = catDv.categories[0], catValues = cat.values, values = catDv.values, dataMatrix = [], legendData = {
                            dataPoints: [],
                            title: values[0] && values[0].source ? values[0].source.displayName : ""
                        }, toolTipData = [], sliceTooltipData = [], max = 1e3, seriesName = [], seriesIndex = [], catIndex = [], isDiffFromTo = !1, labelData = [], colorHelper = new visuals.ColorHelper(colors, ChordChart.chordChartProps.dataPoint.fill, defaultDataPointColor), i = 0, iLen = catValues.length; iLen > i; i++) catIndex[catValues[i]] = i;
                        for (var i = 0, iLen = values.length; iLen > i; i++) {
                            var seriesNameStr = visuals.converterHelper.getSeriesName(values[i].source);
                            seriesName.push(seriesNameStr), seriesIndex[seriesNameStr] = i;
                        }
                        var totalFields = this.union_arrays(catValues, seriesName);
                        ChordChart.getValidArrayLength(totalFields) === ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName) && (isDiffFromTo = !0);
                        for (var formatStringProp = ChordChart.chordChartProps.general.formatString, categorySourceFormatString = visuals.valueFormatter.getFormatString(cat.source, formatStringProp), i = 0, iLen = totalFields.length; iLen > i; i++) {
                            var id = null, color = "", isCategory = !1;
                            if (void 0 !== catIndex[totalFields[i]]) {
                                var index = catIndex[totalFields[i]];
                                id = visuals.SelectionIdBuilder.builder().withCategory(cat, catIndex[totalFields[i]]).createSelectionId(), 
                                isCategory = !0;
                                var thisCategoryObjects = cat.objects ? cat.objects[index] : void 0;
                                color = colorHelper.getColorForSeriesValue(thisCategoryObjects, void 0, catValues[index]);
                            } else if (void 0 !== seriesIndex[totalFields[i]]) {
                                var index = seriesIndex[totalFields[i]], seriesData = values[index], seriesObjects = seriesData && seriesData.objects && seriesData.objects[0], seriesNameStr = visuals.converterHelper.getSeriesName(seriesData.source);
                                id = visuals.SelectionId.createWithId(seriesData.identity), isCategory = !1, color = colorHelper.getColorForSeriesValue(seriesObjects, void 0, seriesNameStr);
                            }
                            labelData.push({
                                label: totalFields[i],
                                labelColor: labelColor,
                                barColor: color,
                                isCategory: isCategory,
                                identity: id,
                                selected: !1
                            }), dataMatrix.push([]), toolTipData.push([]);
                            for (var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString), j = 0, jLen = totalFields.length; jLen > j; j++) {
                                var elementValue = 0, tooltipInfo = [];
                                if (void 0 !== catIndex[totalFields[i]] && void 0 !== seriesIndex[totalFields[j]]) {
                                    var row = catIndex[totalFields[i]], col = seriesIndex[totalFields[j]];
                                    null !== values[col].values[row] && (elementValue = values[col].values[row], elementValue > max && (max = elementValue), 
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, elementValue, null, null, col, row));
                                } else if (isDiffFromTo && void 0 !== catIndex[totalFields[j]] && void 0 !== seriesIndex[totalFields[i]]) {
                                    var row = catIndex[totalFields[j]], col = seriesIndex[totalFields[i]];
                                    null !== values[col].values[row] && (elementValue = values[col].values[row]);
                                }
                                dataMatrix[i].push(elementValue), toolTipData[i].push({
                                    tooltipInfo: tooltipInfo
                                });
                            }
                            var totalSum = d3.sum(dataMatrix[i]);
                            sliceTooltipData.push({
                                tooltipInfo: [ {
                                    displayName: totalFields[i],
                                    value: ChordChart.isInt(totalSum) ? totalSum.toFixed(0) : totalSum.toFixed(2)
                                } ]
                            });
                        }
                        var chordLayout = d3.layout.chord().padding(.1).matrix(dataMatrix), unitLength = Math.round(max / 5).toString().length - 1;
                        return {
                            dataMatrix: dataMatrix,
                            labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),
                            legendData: legendData,
                            tooltipData: toolTipData,
                            sliceTooltipData: sliceTooltipData,
                            tickUnit: Math.pow(10, unitLength),
                            differentFromTo: isDiffFromTo,
                            defaultDataPointColor: defaultDataPointColor,
                            prevAxisVisible: prevAxisVisible,
                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                            showLabels: ChordChart.getLabelsShow(dataView),
                            showAxis: ChordChart.getAxisShow(dataView),
                            labelFontSize: labelFontSize
                        };
                    }
                    return {
                        dataMatrix: [],
                        labelDataPoints: [],
                        legendData: null,
                        tooltipData: [],
                        sliceTooltipData: [],
                        tickUnit: 1e3,
                        differentFromTo: !1,
                        defaultDataPointColor: defaultDataPointColor,
                        prevAxisVisible: prevAxisVisible,
                        showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                        showLabels: ChordChart.getLabelsShow(dataView),
                        showAxis: ChordChart.getAxisShow(dataView),
                        labelFontSize: labelFontSize
                    };
                }, ChordChart.getValidArrayLength = function(array) {
                    for (var len = 0, i = 0, iLen = array.length; iLen > i; i++) void 0 !== array[i] && len++;
                    return len;
                }, ChordChart.convertToChordArcDescriptor = function(groups, datum) {
                    for (var labelDataPoints = [], i = 0, iLen = groups.length; iLen > i; i++) {
                        var labelDataPoint = groups[i];
                        labelDataPoint.data = datum[i], labelDataPoints.push(labelDataPoint);
                    }
                    return labelDataPoints;
                }, ChordChart.prototype.calculateRadius = function(viewport) {
                    if (this.data && this.data.showLabels) {
                        var hw = viewport.height / viewport.width, denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                        return Math.min(viewport.height, viewport.width) / denom;
                    }
                    return Math.min(viewport.height, viewport.width) / 2;
                }, ChordChart.drawDefaultCategoryLabels = function(graphicsContext, chordData, radius, viewport) {
                    var arc = d3.svg.arc().innerRadius(0).outerRadius(radius * ChordChart.InnerArcRadiusRatio), outerArc = d3.svg.arc().innerRadius(radius * ChordChart.OuterArcRadiusRatio).outerRadius(radius * ChordChart.OuterArcRadiusRatio);
                    if (chordData.showLabels) {
                        var labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);
                        ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints, graphicsContext, labelLayout, viewport, radius, arc, outerArc);
                    } else visuals.dataLabelUtils.cleanDataLabels(graphicsContext, !0);
                }, ChordChart.prototype.init = function(options) {
                    var element = this.element = options.element;
                    this.selectionManager = new visuals.utility.SelectionManager({
                        hostServices: options.host
                    }), this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(ChordChart.VisualClassName, !0), 
                    this.mainGraphicsContext = this.svg.append("g"), this.mainGraphicsContext.append("g").classed("slices", !0), 
                    this.mainGraphicsContext.append("g").classed("ticks", !0), this.mainGraphicsContext.append("g").classed("chords", !0), 
                    this.colors = options.style.colorPalette.dataColors;
                }, ChordChart.prototype.update = function(options) {
                    var _this = this;
                    if (options.dataViews && options.dataViews[0]) {
                        var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration, dataView = this.dataView = options.dataViews[0], prevAxisShow = this.data ? this.data.showAxis : !ChordChart.getAxisShow(dataView), data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow), viewport = options.viewport, chordLayout = this.chordLayout = d3.layout.chord().padding(.1).matrix(data.dataMatrix), width = viewport.width, height = viewport.height, radius = this.calculateRadius(viewport), sm = this.selectionManager, innerRadius = radius, outerRadius = radius * ChordChart.InnerArcRadiusRatio, arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);
                        this.svg.attr({
                            width: width,
                            height: height
                        });
                        var mainGraphicsContext = this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(width / 2, height / 2)), sliceShapes = this.svg.select(".slices").selectAll("path" + ChordChart.sliceClass.selector).data(chordLayout.groups);
                        sliceShapes.enter().insert("path").classed(ChordChart.sliceClass["class"], !0), 
                        sliceShapes.style("fill", function(d, i) {
                            return data.labelDataPoints[i].data.barColor;
                        }).style("stroke", function(d, i) {
                            return data.labelDataPoints[i].data.barColor;
                        }).on("click", function(d, i) {
                            var _this = this;
                            sm.select(data.labelDataPoints[i].data.identity).then(function(ids) {
                                ids.length > 0 ? (mainGraphicsContext.selectAll(".chords path.chord").style("opacity", 1), 
                                mainGraphicsContext.selectAll(".slices path.slice").style("opacity", .3), mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                    return d.source.index !== i && d.target.index !== i;
                                }).style("opacity", .3), d3.select(_this).style("opacity", 1)) : (sliceShapes.style("opacity", 1), 
                                mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                    return d.source.index !== i && d.target.index !== i;
                                }).style("opacity", 1));
                            }), d3.event.stopPropagation();
                        }).transition().duration(duration).attr("d", arc), sliceShapes.exit().remove(), 
                        visuals.TooltipManager.addTooltip(sliceShapes, function(tooltipEvent) {
                            return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
                        });
                        var chordShapes = this.svg.select(".chords").selectAll("path" + ChordChart.chordClass.selector).data(chordLayout.chords);
                        chordShapes.enter().insert("path").classed(ChordChart.chordClass["class"], !0), 
                        chordShapes.style("fill", function(d, i) {
                            return data.labelDataPoints[d.target.index].data.barColor;
                        }).style("opacity", 1).transition().duration(duration).attr("d", d3.svg.chord().radius(innerRadius)), 
                        chordShapes.exit().remove(), this.svg.on("click", function() {
                            return _this.selectionManager.clear().then(function() {
                                sliceShapes.style("opacity", 1), chordShapes.style("opacity", 1);
                            });
                        }), ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport), 
                        ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport), 
                        visuals.TooltipManager.addTooltip(chordShapes, function(tooltipEvent) {
                            var tooltipInfo = [];
                            return data.differentFromTo ? tooltipInfo = data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].tooltipInfo : (tooltipInfo.push({
                                displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label + "->" + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
                                value: data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
                            }), tooltipInfo.push({
                                displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label + "->" + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
                                value: data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
                            })), tooltipInfo;
                        });
                    }
                }, ChordChart.prototype.destroy = function() {}, ChordChart.cleanTicks = function(context) {
                    var empty = [], tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);
                    tickLines.exit().remove();
                    var tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);
                    tickTexts.exit().remove(), context.selectAll(ChordChart.tickPairClass.selector).remove(), 
                    context.selectAll(ChordChart.sliceTicksClass.selector).remove();
                }, ChordChart.drawTicks = function(graphicsContext, chordData, chordLayout, outerRadius, duration, viewport) {
                    if (chordData.showAxis) {
                        var tickShapes = graphicsContext.select(".ticks").selectAll("g" + ChordChart.sliceTicksClass.selector).data(chordLayout.groups), animDuration = chordData.prevAxisVisible === chordData.showAxis ? duration : 0;
                        tickShapes.enter().insert("g").classed(ChordChart.sliceTicksClass["class"], !0);
                        var tickPairs = tickShapes.selectAll("g" + ChordChart.tickPairClass.selector).data(function(d) {
                            var k = (d.endAngle - d.startAngle) / d.value, range = d3.range(0, d.value, d.value - 1 < .15 ? .15 : d.value - 1), retval = range.map(function(v, i) {
                                var divider = 1e3, unitStr = "k";
                                chordData.tickUnit >= 1e6 ? (divider = 1e6, unitStr = "m") : chordData.tickUnit >= 1e3 ? (divider = 1e3, 
                                unitStr = "k") : (divider = 1, unitStr = "");
                                var retv = {
                                    angle: v * k + d.startAngle,
                                    label: Math.floor(v / divider) + unitStr
                                };
                                return retv;
                            });
                            return retval;
                        });
                        tickPairs.enter().insert("g").classed(ChordChart.tickPairClass["class"], !0), tickPairs.transition().duration(animDuration).attr("transform", function(d) {
                            return "rotate(" + (180 * d.angle / Math.PI - 90) + ")translate(" + outerRadius + ",0)";
                        }), tickPairs.selectAll("line" + ChordChart.tickLineClass.selector).data(function(d) {
                            return [ d ];
                        }).enter().insert("line").classed(ChordChart.tickLineClass["class"], !0).style("stroke", "#000").attr("x1", 1).attr("y1", 0).attr("x2", 5).attr("y2", 0), 
                        tickPairs.selectAll("text" + ChordChart.tickTextClass.selector).data(function(d) {
                            return [ d ];
                        }).enter().insert("text").classed(ChordChart.tickTextClass["class"], !0).style("text-anchor", function(d) {
                            return d.angle > Math.PI ? "end" : null;
                        }).text(function(d) {
                            return d.label;
                        }).attr("transform", function(d) {
                            return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
                        }).attr("x", 8).attr("dy", ".35em"), tickPairs.exit().remove(), tickShapes.exit().remove();
                    } else ChordChart.cleanTicks(graphicsContext);
                }, ChordChart.getAxisShow = function(dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var axis = objects.axis;
                            if (axis && axis.hasOwnProperty("show")) return axis.show;
                        }
                    }
                    return !0;
                }, ChordChart.getLabelsShow = function(dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects.labels;
                            if (labels && labels.hasOwnProperty("show")) return labels.show;
                        }
                    }
                    return !0;
                }, ChordChart.getLabelsColor = function(dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects.labels;
                            if (labels && labels.hasOwnProperty("color")) return labels.color.solid.color;
                        }
                    }
                    return ChordChart.DefaultLabelColor;
                }, ChordChart.getLabelsFontSize = function(dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects.labels;
                            if (labels && labels.hasOwnProperty("fontSize")) return labels.fontSize;
                        }
                    }
                    return ChordChart.DefaultLabelsFontSize;
                }, ChordChart.selectLabels = function(filteredData, context, isDonut, forAnimation) {
                    if (void 0 === isDonut && (isDonut = !1), void 0 === forAnimation && (forAnimation = !1), 
                    0 === filteredData.length) return visuals.dataLabelUtils.cleanDataLabels(context, !0), 
                    null;
                    context.select(ChordChart.labelGraphicsContextClass.selector).empty() && context.append("g").classed(ChordChart.labelGraphicsContextClass["class"], !0);
                    var hasKey = null !== filteredData[0].key, hasDataPointIdentity = null !== filteredData[0].identity, getIdentifier = hasKey ? function(d) {
                        return d.key;
                    } : hasDataPointIdentity ? function(d) {
                        return d.identity.getKey();
                    } : void 0, labels = isDonut ? context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, function(d) {
                        return d.data.identity.getKey();
                    }) : null !== getIdentifier ? context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier) : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData), newLabels = labels.enter().append("text").classed(ChordChart.labelsClass["class"], !0);
                    return forAnimation && newLabels.style("opacity", 0), labels;
                }, ChordChart.drawDefaultLabelsForChordChart = function(data, context, layout, viewport, radius, arc, outerArc) {
                    var dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, !0), labels = ChordChart.selectLabels(filteredData, context, !0);
                    if (labels) {
                        labels.attr({
                            x: function(d) {
                                return d.labelX;
                            },
                            y: function(d) {
                                return d.labelY;
                            },
                            dy: ".35em"
                        }).text(function(d) {
                            return d.labeltext;
                        }).style(layout.style), labels.exit().remove(), context.select(ChordChart.linesGraphicsContextClass.selector).empty() && context.append("g").classed(ChordChart.linesGraphicsContextClass["class"], !0);
                        var lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll("polyline").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }), innerLinePointMultiplier = 2.05, midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        };
                        lines.enter().append("polyline").classed(ChordChart.lineClass["class"], !0), lines.attr("points", function(d) {
                            var textPoint = outerArc.centroid(d);
                            textPoint[0] = .95 * radius * (midAngle(d) < Math.PI ? 1 : -1);
                            var midPoint = outerArc.centroid(d), chartPoint = arc.centroid(d);
                            return chartPoint[0] *= innerLinePointMultiplier, chartPoint[1] *= innerLinePointMultiplier, 
                            [ chartPoint, midPoint, textPoint ];
                        }).style({
                            opacity: function(d) {
                                return ChordChart.PolylineOpacity;
                            },
                            stroke: function(d) {
                                return d.data.labelColor;
                            }
                        }), lines.exit().remove();
                    }
                }, ChordChart.getChordChartLabelLayout = function(radius, outerArc, viewport, labelFontSize) {
                    var midAngle = function(d) {
                        return d.startAngle + (d.endAngle - d.startAngle) / 2;
                    }, spaceAvaliableForLabels = viewport.width / 2 - radius, minAvailableSpace = Math.min(spaceAvaliableForLabels, visuals.dataLabelUtils.maxLabelWidth), PixelConverter = jsCommon.PixelConverter;
                    return {
                        labelText: function(d) {
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: d.data.label,
                                maxWidth: minAvailableSpace,
                                fontSize: labelFontSize
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return radius * (midAngle(d) < Math.PI ? 1 : -1);
                            },
                            y: function(d) {
                                var pos = outerArc.centroid(d);
                                return pos[1];
                            }
                        },
                        filter: function(d) {
                            return null !== d && null !== d.data && null !== d.data.label;
                        },
                        style: {
                            fill: function(d) {
                                return d.data.labelColor;
                            },
                            "text-anchor": function(d) {
                                return midAngle(d) < Math.PI ? "start" : "end";
                            },
                            "font-size": function(d) {
                                return PixelConverter.fromPointToPixel(labelFontSize);
                            }
                        }
                    };
                }, ChordChart.getDefaultDataPointColor = function(dataView, defaultValue) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var dataPoint = objects.dataPoint;
                            if (dataPoint && dataPoint.hasOwnProperty("defaultColor")) {
                                var defaultColor = dataPoint.defaultColor;
                                if (defaultColor) return defaultColor;
                            }
                        }
                    }
                    return {
                        solid: {
                            color: defaultValue
                        }
                    };
                }, ChordChart.getShowAllDataPoints = function(dataView) {
                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) return !1;
                    var objects = dataView.metadata.objects, dataPoint = objects.dataPoint;
                    return dataPoint && dataPoint.hasOwnProperty("showAllDataPoints") ? dataPoint.showAllDataPoints : !1;
                }, ChordChart.prototype.enumerateObjectInstances = function(options) {
                    var axis, instances = [];
                    switch (options.objectName) {
                      case "axis":
                        axis = {
                            objectName: "axis",
                            displayName: "Axis",
                            selector: null,
                            properties: {
                                show: ChordChart.getAxisShow(this.dataView)
                            }
                        }, instances.push(axis);
                        break;

                      case "labels":
                        axis = {
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: ChordChart.getLabelsShow(this.dataView),
                                color: ChordChart.getLabelsColor(this.dataView),
                                fontSize: ChordChart.getLabelsFontSize(this.dataView)
                            }
                        }, instances.push(axis);
                        break;

                      case "dataPoint":
                        var defaultColor = {
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                defaultColor: {
                                    solid: {
                                        color: this.data && this.data.defaultDataPointColor ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value
                                    }
                                }
                            }
                        };
                        instances.push(defaultColor);
                        var showAllDataPoints = {
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                showAllDataPoints: this.data ? !!this.data.showAllDataPoints : !1
                            }
                        };
                        if (instances.push(showAllDataPoints), this.data && this.data.labelDataPoints) for (var i = 0, iLen = this.data.labelDataPoints.length; iLen > i; i++) {
                            var labelDataPoint = this.data.labelDataPoints[i].data;
                            if (labelDataPoint.isCategory) {
                                var colorInstance = {
                                    objectName: "dataPoint",
                                    displayName: labelDataPoint.label,
                                    selector: visuals.ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: labelDataPoint.barColor
                                            }
                                        }
                                    }
                                };
                                instances.push(colorInstance);
                            }
                        }
                    }
                    return instances;
                }, ChordChart.isInt = function(n) {
                    return n % 1 === 0;
                }, ChordChart.union_arrays = function(x, y) {
                    for (var obj = {}, i = 0; i < x.length; i++) obj[x[i]] = x[i];
                    for (var i = 0; i < y.length; i++) obj[y[i]] = y[i];
                    var res = [];
                    for (var k in obj) obj.hasOwnProperty(k) && res.push(obj[k]);
                    return res;
                }, ChordChart.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "From"
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "To"
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                min: 1,
                                max: 1
                            },
                            Y: {
                                max: 1
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            Y: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            },
                            rowCount: {
                                preferred: {
                                    min: 2
                                },
                                supported: {
                                    min: 1
                                }
                            }
                        }
                    } ],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        axis: {
                            displayName: "Axis",
                            properties: {
                                show: {
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: "Labels",
                            properties: {
                                show: {
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, ChordChart.chordChartProps = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    dataPoint: {
                        defaultColor: {
                            objectName: "dataPoint",
                            propertyName: "defaultColor"
                        },
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        },
                        showAllDataPoints: {
                            objectName: "dataPoint",
                            propertyName: "showAllDataPoints"
                        }
                    },
                    axis: {
                        show: {
                            objectName: "axis",
                            propertyName: "show"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        color: {
                            objectName: "labels",
                            propertyName: "color"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        }
                    }
                }, ChordChart.PolylineOpacity = .5, ChordChart.OuterArcRadiusRatio = .9, ChordChart.InnerArcRadiusRatio = .8, 
                ChordChart.DefaultLabelColor = "#777777", ChordChart.DefaultLabelsFontSize = 12, 
                ChordChart.VisualClassName = "chordChart", ChordChart.sliceClass = {
                    "class": "slice",
                    selector: ".slice"
                }, ChordChart.chordClass = {
                    "class": "chord",
                    selector: ".chord"
                }, ChordChart.sliceTicksClass = {
                    "class": "slice-ticks",
                    selector: ".slice-ticks"
                }, ChordChart.tickPairClass = {
                    "class": "tick-pair",
                    selector: ".tick-pair"
                }, ChordChart.tickLineClass = {
                    "class": "tick-line",
                    selector: ".tick-line"
                }, ChordChart.tickTextClass = {
                    "class": "tick-text",
                    selector: ".tick-text"
                }, ChordChart.labelGraphicsContextClass = {
                    "class": "labels",
                    selector: ".labels"
                }, ChordChart.labelsClass = {
                    "class": "data-labels",
                    selector: ".data-labels"
                }, ChordChart.linesGraphicsContextClass = {
                    "class": "lines",
                    selector: ".lines"
                }, ChordChart.lineClass = {
                    "class": "line-label",
                    selector: ".line-label"
                }, ChordChart;
            }();
            samples.ChordChart = ChordChart;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var DataRoleHelper = powerbi.data.DataRoleHelper, EnhancedScatterChart = function() {
                function EnhancedScatterChart() {
                    this.AxisGraphicsContextClassName = "axisGraphicsContext", this.ScrollBarWidth = 10, 
                    this.textProperties = {
                        fontFamily: "wf_segoe-ui_normal",
                        fontSize: jsCommon.PixelConverter.toString(EnhancedScatterChart.AxisFontSize)
                    };
                }
                return Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
                    get: function() {
                        return this._margin || {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        };
                    },
                    set: function(value) {
                        this._margin = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
                    get: function() {
                        return this._viewport || {
                            width: 0,
                            height: 0
                        };
                    },
                    set: function(value) {
                        this._viewport = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
                    get: function() {
                        return this._viewportIn || this.viewport;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
                    get: function() {
                        return this.legend.getMargins();
                    },
                    enumerable: !0,
                    configurable: !0
                }), EnhancedScatterChart.substractMargin = function(viewport, margin) {
                    return {
                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                    };
                }, EnhancedScatterChart.getCustomSymbolType = function(shape) {
                    var customSymbolTypes = d3.map({
                        circle: function(size) {
                            var r = Math.sqrt(size / Math.PI);
                            return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
                        },
                        cross: function(size) {
                            var r = Math.sqrt(size / 5) / 2;
                            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                        },
                        diamond: function(size) {
                            var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
                            return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
                        },
                        square: function(size) {
                            var r = Math.sqrt(size) / 2;
                            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
                        },
                        "triangle-up": function(size) {
                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                        },
                        "triangle-down": function(size) {
                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                        },
                        star: function(size) {
                            for (var outerRadius = Math.sqrt(size / 2), innerRadius = Math.sqrt(size / 10), results = "", angle = Math.PI / 5, i = 0; 10 > i; i++) {
                                var r = 0 === (1 & i) ? outerRadius : innerRadius, currX = Math.cos(i * angle) * r, currY = Math.sin(i * angle) * r;
                                0 === i ? results = "M" + currX + "," + currY + "L" : results += " " + currX + "," + currY;
                            }
                            return results + "Z";
                        },
                        hexagon: function(size) {
                            var r = Math.sqrt(size / (6 * Math.sqrt(3))), r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
                            return "M0," + 2 * r + "L" + -r2 + "," + r + " " + -r2 + "," + -r + " 0," + -2 * r + " " + r2 + "," + -r + " " + r2 + "," + r + "Z";
                        },
                        x: function(size) {
                            var r = Math.sqrt(size / 10);
                            return "M0," + r + "L" + -r + "," + 2 * r + " " + -2 * r + "," + r + " " + -r + ",0 " + -2 * r + "," + -r + " " + -r + "," + -2 * r + " 0," + -r + " " + r + "," + -2 * r + " " + 2 * r + "," + -r + " " + r + ",0 " + 2 * r + "," + r + " " + r + "," + 2 * r + "Z";
                        },
                        uparrow: function(size) {
                            var r = Math.sqrt(size / 12);
                            return "M" + r + "," + 3 * r + "L" + -r + "," + 3 * r + " " + -r + "," + -r + " " + -2 * r + "," + -r + " 0," + -3 * r + " " + 2 * r + "," + -r + " " + r + "," + -r + "Z";
                        },
                        downarrow: function(size) {
                            var r = Math.sqrt(size / 12);
                            return "M0," + 3 * r + "L" + -2 * r + "," + r + " " + -r + "," + r + " " + -r + "," + -3 * r + " " + r + "," + -3 * r + " " + r + "," + r + " " + 2 * r + "," + r + "Z";
                        }
                    }), defaultValue = customSymbolTypes.entries()[0].value;
                    if (shape) {
                        if (isNaN(shape)) return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
                        var result = customSymbolTypes.entries()[Math.floor(shape)];
                        return result ? result.value : defaultValue;
                    }
                    return defaultValue;
                }, EnhancedScatterChart.prototype.init = function(options) {
                    this.options = options, this.animator = new visuals.BaseAnimator(), this.behavior = new visuals.CartesianChartBehavior([ new visuals.ScatterChartWebBehavior() ]);
                    var element = this.element = options.element;
                    this.viewport = _.clone(options.viewport), this.style = options.style, this.hostServices = options.host, 
                    this.colors = this.style.colorPalette.dataColors, this.interactivity = options.interactivity, 
                    this.margin = {
                        top: 1,
                        right: 1,
                        bottom: 1,
                        left: 1
                    }, this.yAxisOrientation = visuals.yAxisPosition.left, this.adjustMargins();
                    var showLinesOnX = this.scrollY = !0, showLinesOnY = this.scrollX = !0, svg = this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(EnhancedScatterChart.ClassName, !0), axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(this.AxisGraphicsContextClassName, !0);
                    this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(this.AxisGraphicsContextClassName, !0);
                    this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                    this.backgroundGraphicsContext = axisGraphicsContext.append("svg:image"), this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                    this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), 
                    this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                    this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                    this.legend = visuals.createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, !0), 
                    this.mainGraphicsG = this.axisGraphicsContextScrollable.append("g").classed(EnhancedScatterChart.MainGraphicsContextClassName, !0), 
                    this.mainGraphicsContext = this.mainGraphicsG.append("svg"), this.svgDefaultImage = "http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg", 
                    this.keyArray = [];
                }, EnhancedScatterChart.prototype.adjustMargins = function() {
                    var xAxis = this.element.find(".x.axis");
                    0 === visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) && 0 === visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) ? (this.margin = {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, xAxis.hide()) : xAxis.show();
                }, EnhancedScatterChart.prototype.getValueAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata) return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var valueAxisObject = objects.valueAxis;
                        valueAxisObject && (toReturn = {
                            show: valueAxisObject.show,
                            position: valueAxisObject.position,
                            axisScale: valueAxisObject.axisScale,
                            start: valueAxisObject.start,
                            end: valueAxisObject.end,
                            showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                            axisStyle: valueAxisObject.axisStyle,
                            axisColor: valueAxisObject.axisColor,
                            secShow: valueAxisObject.secShow,
                            secPosition: valueAxisObject.secPosition,
                            secAxisScale: valueAxisObject.secAxisScale,
                            secStart: valueAxisObject.secStart,
                            secEnd: valueAxisObject.secEnd,
                            secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                            secAxisStyle: valueAxisObject.secAxisStyle,
                            labelDisplayUnits: valueAxisObject.labelDisplayUnits
                        });
                    }
                    return toReturn;
                }, EnhancedScatterChart.prototype.getCategoryAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata) return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var categoryAxisObject = objects.categoryAxis;
                        categoryAxisObject && (toReturn = {
                            show: categoryAxisObject.show,
                            axisType: categoryAxisObject.axisType,
                            axisScale: categoryAxisObject.axisScale,
                            axisColor: categoryAxisObject.axisColor,
                            start: categoryAxisObject.start,
                            end: categoryAxisObject.end,
                            showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                            axisStyle: categoryAxisObject.axisStyle,
                            labelDisplayUnits: categoryAxisObject.labelDisplayUnits
                        });
                    }
                    return toReturn;
                }, EnhancedScatterChart.converter = function(dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                    var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, dataViewCategorical = dataView.categorical, dataViewMetadata = dataView.metadata;
                    dataViewCategorical.categories && dataViewCategorical.categories.length > 0 ? (categoryValues = dataViewCategorical.categories[0].values, 
                    categoryFormatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString),
                        value: categoryValues[0],
                        value2: categoryValues[categoryValues.length - 1]
                    }), categoryIdentities = dataViewCategorical.categories[0].identity, categoryObjects = dataViewCategorical.categories[0].objects, 
                    categoryQueryName = dataViewCategorical.categories[0].source.queryName) : (categoryValues = [ null ], 
                    categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null));
                    var categories = dataViewCategorical.categories, dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), useShape = !(DataRoleHelper.getMeasureIndexOfRole(grouped, "Image") >= 0), useCustomColor = DataRoleHelper.getMeasureIndexOfRole(grouped, "ColorFill") >= 0, dvSource = dataValues.source, scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource), dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), fillPoint = !1, backdrop = {
                        show: !1,
                        url: ""
                    }, crosshair = !1, outline = !1, defaultDataPointColor = "", showAllDataPoints = !0;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                        var labelsObj = objects.categoryLabels;
                        labelsObj && (dataLabelsSettings.show = void 0 !== labelsObj.show ? labelsObj.show : dataLabelsSettings.show, 
                        dataLabelsSettings.fontSize = void 0 !== labelsObj.fontSize ? labelsObj.fontSize : dataLabelsSettings.fontSize, 
                        void 0 !== labelsObj.color && (dataLabelsSettings.labelColor = labelsObj.color.solid.color)), 
                        fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, fillPoint);
                        var backdropObject = objects.backdrop;
                        void 0 !== backdropObject && (backdrop.show = backdropObject.show, backdrop.show && (backdrop.url = backdropObject.url));
                        var crosshairObject = objects.crosshair;
                        void 0 !== crosshairObject && (crosshair = crosshairObject.show);
                        var outlineObject = objects.outline;
                        void 0 !== outlineObject && (outline = outlineObject.show);
                    }
                    var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
                    interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                    var legendItems = hasDynamicSeries ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor) : [], legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                    legendTitle || (legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : "");
                    var legendData = {
                        title: legendTitle,
                        dataPoints: legendItems
                    }, sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                    if (categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && categoryAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.x = null), 
                    valueAxisProperties && null !== valueAxisProperties.showAxisTitle && valueAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.y = null), 
                    dataPoints && dataPoints[0]) {
                        var point = dataPoints[0];
                        null != point.backdrop && (backdrop.show = !0, backdrop.url = point.backdrop), null != point.xStart && (categoryAxisProperties.start = point.xStart), 
                        null != point.xEnd && (categoryAxisProperties.end = point.xEnd), null != point.yStart && (valueAxisProperties.start = point.yStart), 
                        null != point.yEnd && (valueAxisProperties.end = point.yEnd);
                    }
                    return {
                        xCol: scatterMetadata.cols.x,
                        yCol: scatterMetadata.cols.y,
                        dataPoints: dataPoints,
                        legendData: legendData,
                        axesLabels: scatterMetadata.axesLabels,
                        selectedIds: [],
                        size: scatterMetadata.cols.size,
                        sizeRange: sizeRange,
                        dataLabelsSettings: dataLabelsSettings,
                        defaultDataPointColor: defaultDataPointColor,
                        hasDynamicSeries: hasDynamicSeries,
                        showAllDataPoints: showAllDataPoints,
                        fillPoint: fillPoint,
                        useShape: useShape,
                        useCustomColor: useCustomColor,
                        backdrop: backdrop,
                        crosshair: crosshair,
                        outline: outline
                    };
                }, EnhancedScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                    for (var grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), legendItems = [], i = 0, len = grouped.length; len > i; i++) {
                        var grouping = grouped[i], color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        legendItems.push({
                            color: color,
                            icon: visuals.LegendIcon.Circle,
                            label: visuals.valueFormatter.format(grouping.name, formatString),
                            identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                            selected: !1
                        });
                    }
                    return legendItems;
                }, EnhancedScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                    var result = {};
                    return dataViewValueGroups && dataViewValueGroups.forEach(function(group) {
                        var sizeColumn = visuals.ScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                        (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                        (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                    }), result;
                }, EnhancedScatterChart.getMetadata = function(grouped, source) {
                    var xCol, yCol, sizeCol, colorFillCol, shapeCol, imageCol, rotationCol, backdropCol, xStartCol, xEndCol, yStartCol, yEndCol, xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y"), sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Gradient"), colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "ColorFill"), shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Shape"), imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Image"), rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Rotation"), backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Backdrop"), xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X Start"), xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X End"), yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y Start"), yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y End"), xAxisLabel = "", yAxisLabel = "";
                    if (grouped && grouped.length) {
                        var firstGroup = grouped[0], measureCount = firstGroup.values.length;
                        xIndex >= 0 || (xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        yIndex >= 0 || (yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        sizeIndex >= 0 || (sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        colorFillIndex >= 0 || (colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        shapeIndex >= 0 || (shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        imageIndex >= 0 || (imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        rotationIndex >= 0 || (rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        backdropIndex >= 0 || (backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        xStartIndex >= 0 || (xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                        xEndIndex >= 0 || (xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex ])), 
                        yStartIndex >= 0 || (yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex ])), 
                        yEndIndex >= 0 || (yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex ])), 
                        xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                        yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                        sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source), colorFillIndex >= 0 && (colorFillCol = firstGroup.values[colorFillIndex].source), 
                        shapeIndex >= 0 && (shapeCol = firstGroup.values[shapeIndex].source), imageIndex >= 0 && (imageCol = firstGroup.values[imageIndex].source), 
                        rotationIndex >= 0 && (rotationCol = firstGroup.values[rotationIndex].source), backdropIndex >= 0 && (backdropCol = firstGroup.values[backdropIndex].source), 
                        xStartIndex >= 0 && (xStartCol = firstGroup.values[xStartIndex].source), xEndIndex >= 0 && (xEndCol = firstGroup.values[xEndIndex].source), 
                        yStartIndex >= 0 && (yStartCol = firstGroup.values[yStartIndex].source), yEndIndex >= 0 && (yEndCol = firstGroup.values[yEndIndex].source);
                    }
                    return {
                        idx: {
                            x: xIndex,
                            y: yIndex,
                            size: sizeIndex,
                            colorFill: colorFillIndex,
                            shape: shapeIndex,
                            image: imageIndex,
                            rotation: rotationIndex,
                            backdrop: backdropIndex,
                            xStart: xStartIndex,
                            xEnd: xEndIndex,
                            yStart: yStartIndex,
                            yEnd: yEndIndex
                        },
                        cols: {
                            x: xCol,
                            y: yCol,
                            size: sizeCol,
                            colorFill: colorFillCol,
                            shape: shapeCol,
                            image: imageCol,
                            rotation: rotationCol,
                            backdrop: backdropCol,
                            xStart: xStartCol,
                            xEnd: xEndCol,
                            yStart: yStartCol,
                            yEnd: yEndCol
                        },
                        axesLabels: {
                            x: xAxisLabel,
                            y: yAxisLabel
                        }
                    };
                }, EnhancedScatterChart.getDefaultMeasureIndex = function(count, usedIndexes) {
                    for (var i = 0; count > i; i++) {
                        for (var found = !0, j = 0; j < usedIndexes.length; j++) if (i === usedIndexes[j]) {
                            found = !1;
                            break;
                        }
                        if (found === !0) return i;
                    }
                    return -1;
                }, EnhancedScatterChart.createLazyFormattedCategory = function(formatter, value) {
                    return new jsCommon.Lazy(function() {
                        return formatter.format(value);
                    });
                }, EnhancedScatterChart.createDataPoints = function(dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
                    for (var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), categoryIdx = 0, ilen = categoryValues.length; ilen > categoryIdx; categoryIdx++) for (var categoryValue = categoryValues[categoryIdx], seriesIdx = 0, len = grouped.length; len > seriesIdx; seriesIdx++) {
                        var grouping = grouped[seriesIdx], seriesValues = grouping.values, measureX = visuals.ScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = visuals.ScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = visuals.ScatterChart.getMeasureValue(indicies.size, seriesValues), measureColorFill = visuals.ScatterChart.getMeasureValue(indicies.colorFill, seriesValues), measureShape = visuals.ScatterChart.getMeasureValue(indicies.shape, seriesValues), measureImage = visuals.ScatterChart.getMeasureValue(indicies.image, seriesValues), measureRotation = visuals.ScatterChart.getMeasureValue(indicies.rotation, seriesValues), measureBackdrop = visuals.ScatterChart.getMeasureValue(indicies.backdrop, seriesValues), measureXStart = visuals.ScatterChart.getMeasureValue(indicies.xStart, seriesValues), measureXEnd = visuals.ScatterChart.getMeasureValue(indicies.xEnd, seriesValues), measureYStart = visuals.ScatterChart.getMeasureValue(indicies.yStart, seriesValues), measureYEnd = visuals.ScatterChart.getMeasureValue(indicies.yEnd, seriesValues), xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null, yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0, size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null, colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null, shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]), image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null, rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0, backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null, xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null, xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null, yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null, yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null, hasNullValue = null == xVal || null == yVal;
                        if (!hasNullValue) {
                            var color = void 0;
                            if (hasDynamicSeries) color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else {
                                var measureSource = null != measureSize ? measureSize.source.queryName : "";
                                color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                            }
                            var category = categories && categories.length > 0 ? categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIdx).withSeries(dataValues, grouping).createSelectionId(), seriesData = [];
                            dataValueSource && seriesData.push({
                                value: grouping.name,
                                metadata: {
                                    source: dataValueSource,
                                    values: []
                                }
                            }), measureX && seriesData.push({
                                value: xVal,
                                metadata: measureX
                            }), measureY && seriesData.push({
                                value: yVal,
                                metadata: measureY
                            }), measureSize && measureSize.values && measureSize.values.length > 0 && seriesData.push({
                                value: measureSize.values[categoryIdx],
                                metadata: measureSize
                            }), measureColorFill && measureColorFill.values && measureColorFill.values.length > 0 && seriesData.push({
                                value: measureColorFill.values[categoryIdx],
                                metadata: measureColorFill
                            }), measureShape && measureShape.values && measureShape.values.length > 0 && seriesData.push({
                                value: measureShape.values[categoryIdx],
                                metadata: measureShape
                            }), measureImage && measureImage.values && measureImage.values.length > 0 && seriesData.push({
                                value: measureImage.values[categoryIdx],
                                metadata: measureImage
                            }), measureRotation && measureRotation.values && measureRotation.values.length > 0 && seriesData.push({
                                value: measureRotation.values[categoryIdx],
                                metadata: measureRotation
                            }), measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0 && seriesData.push({
                                value: measureBackdrop.values[categoryIdx],
                                metadata: measureBackdrop
                            }), measureXStart && measureXStart.values && measureXStart.values.length > 0 && seriesData.push({
                                value: measureXStart.values[categoryIdx],
                                metadata: measureXStart
                            }), measureXEnd && measureXEnd.values && measureXEnd.values.length > 0 && seriesData.push({
                                value: measureXEnd.values[categoryIdx],
                                metadata: measureXEnd
                            }), measureYStart && measureYStart.values && measureYStart.values.length > 0 && seriesData.push({
                                value: measureYStart.values[categoryIdx],
                                metadata: measureYStart
                            }), measureYEnd && measureYEnd.values && measureYEnd.values.length > 0 && seriesData.push({
                                value: measureYEnd.values[categoryIdx],
                                metadata: measureYEnd
                            });
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData), dataPoint = {
                                x: xVal,
                                y: yVal,
                                size: size,
                                radius: {
                                    sizeMeasure: measureSize,
                                    index: categoryIdx
                                },
                                fill: color,
                                formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),
                                selected: !1,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                labelFill: labelSettings.labelColor,
                                labelFontSize: labelSettings.fontSize,
                                colorFill: colorFill,
                                shapeSymbolType: shapeSymbolType,
                                svgurl: image,
                                rotation: rotation,
                                backdrop: backdrop,
                                xStart: xStart,
                                xEnd: xEnd,
                                yStart: yStart,
                                yEnd: yEnd
                            };
                            dataPoints.push(dataPoint);
                        }
                    }
                    return dataPoints;
                }, EnhancedScatterChart.prototype.setData = function(dataViews) {
                    if (this.data = {
                        xCol: void 0,
                        yCol: void 0,
                        dataPoints: [],
                        legendData: {
                            dataPoints: []
                        },
                        axesLabels: {
                            x: "",
                            y: ""
                        },
                        selectedIds: [],
                        sizeRange: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                        defaultDataPointColor: null,
                        hasDynamicSeries: !1,
                        useShape: !0,
                        useCustomColor: !1
                    }, dataViews.length > 0) {
                        var dataView = dataViews[0];
                        dataView && (this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, !0), 
                        this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, !0), this.dataView = dataView, 
                        dataView.categorical && dataView.categorical.values && (this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties)));
                    }
                }, EnhancedScatterChart.prototype.update = function(options) {
                    var dataViews = this.dataViews = options.dataViews;
                    if (this.viewport = _.clone(options.viewport), dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                            warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                        }
                        this.setData(dataViews), this.options.interactivity && this.options.interactivity.isInteractiveLegend || this.renderLegend(), 
                        this.render(options.suppressAnimations);
                    }
                }, EnhancedScatterChart.prototype.populateObjectProperties = function(dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        dataViewMetadata ? this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}) : this.legendObjectProperties = {}, 
                        this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata), 
                        this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
                        var axisPosition = this.valueAxisProperties.position;
                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                    }
                }, EnhancedScatterChart.prototype.renderLegend = function() {
                    var legendData = {
                        title: "",
                        dataPoints: []
                    }, legend = this.legend;
                    this.layerLegendData = this.data.legendData, this.layerLegendData && (legendData.title = this.layerLegendData.title || "", 
                    legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                    legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault, 
                    this.layerLegendData.grouped && (legendData.grouped = !0));
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        position && legend.changeOrientation(visuals.LegendPosition[position]);
                    } else legend.changeOrientation(visuals.LegendPosition.Top);
                    (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []);
                    var viewport = this.viewport;
                    legend.drawLegend(legendData, {
                        height: viewport.height,
                        width: viewport.width
                    }), visuals.Legend.positionChartArea(this.svg, legend);
                }, EnhancedScatterChart.prototype.hideLegends = function() {
                    return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                }, EnhancedScatterChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                    return void 0 === propertyName && (propertyName = "show"), axisProperties ? (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName]) && (axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) ? !1 : axisProperties.values && axisProperties.values.length > 0 : !1;
                }, EnhancedScatterChart.prototype.getMaxMarginFactor = function() {
                    return this.options.style.maxMarginFactor || .25;
                }, EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function() {
                    var img = new Image(), that = this;
                    if (img.src = this.data.backdrop.url, img.onload = function() {
                        that.oldBackdrop !== this.src && (that.render(!0), that.oldBackdrop = this.src);
                    }, img.width > 0 && img.height > 0) if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
                        var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
                        this.viewport = {
                            width: this.viewport.width - deltaWidth,
                            height: this.viewport.height
                        };
                    } else {
                        var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
                        this.viewport = {
                            width: this.viewport.width,
                            height: this.viewport.height - deltaHeight
                        };
                    }
                }, EnhancedScatterChart.prototype.render = function(suppressAnimations) {
                    if (this.viewport.height -= this.legendViewport.height, this.viewport.width -= this.legendViewport.width, 
                    0 !== this.viewportIn.width && 0 !== this.viewportIn.height) {
                        var maxMarginFactor = this.getMaxMarginFactor();
                        this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
                        var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
                        this.margin.top = 8, this.margin.bottom = bottomMarginLimit, this.margin.right = 0, 
                        this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                        this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
                        var mainAxisScale, renderXAxis = this.shouldRenderAxis(this.xAxisProperties), renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
                        this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                        var tickLabelMargins, axisLabels, chartHasAxisLabels, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0);
                        for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && maxIterations > numIterations; ) {
                            numIterations++, tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                                width: this.viewportIn.width,
                                height: this.viewport.height
                            }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, {
                                x: this.xAxisProperties,
                                y1: this.yAxisProperties
                            }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                            maxMainYaxisSide += 10, maxSecondYaxisSide += 10, xMax += 12, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 20), 
                            !showY1OnRight && renderY1Axis && (maxMainYaxisSide += 20), this.hideAxisLabels() && (this.xAxisProperties.axisLabel = null, 
                            this.yAxisProperties.axisLabel = null), this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), 
                            axisLabels = {
                                x: this.xAxisProperties.axisLabel,
                                y: this.yAxisProperties.axisLabel,
                                y2: null
                            }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                            null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                            null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                            this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                            var previousTickCountY1 = this.yAxisProperties.values.length;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                            this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                        }
                        if (this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url) for (this.adjustViewportbyBackdrop(), 
                        doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && maxIterations > numIterations; ) {
                            numIterations++, tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                                width: this.viewportIn.width,
                                height: this.viewport.height
                            }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, {
                                x: this.xAxisProperties,
                                y1: this.yAxisProperties
                            }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                            maxMainYaxisSide += 10, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 15), 
                            xMax += 12, this.hideAxisLabels() && (this.xAxisProperties.axisLabel = null, this.yAxisProperties.axisLabel = null), 
                            this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), axisLabels = {
                                x: this.xAxisProperties.axisLabel,
                                y: this.yAxisProperties.axisLabel,
                                y2: null
                            }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                            null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                            null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                            this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                            var previousTickCountY1 = this.yAxisProperties.values.length;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                            this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                        }
                        if (this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations), 
                        this.updateAxis(), this.data) {
                            var data = this.data, dataPoints = this.data.dataPoints, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                            this.mainGraphicsContext.attr("width", this.viewportIn.width).attr("height", this.viewportIn.height);
                            var sortedData = dataPoints.sort(function(a, b) {
                                return b.radius.sizeMeasure ? b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index] : 0;
                            }), duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration), dataLabelsSettings = this.data.dataLabelsSettings;
                            if (dataLabelsSettings.show) {
                                var layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange), clonedDataPoints = this.cloneDataPoints(dataPoints);
                                visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);
                                var offset = dataLabelsSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;
                                this.mainGraphicsG.select(".labels").attr("transform", visuals.SVGUtil.translate(offset, 0));
                            } else visuals.dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
                            var behaviorOptions = void 0;
                            if (this.interactivityService && (behaviorOptions = {
                                dataPointsSelection: scatterMarkers,
                                data: this.data,
                                plotContext: this.mainGraphicsContext
                            }), visuals.TooltipManager.addTooltip(scatterMarkers, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), this.behavior) {
                                var layerBehaviorOptions = [];
                                if (layerBehaviorOptions.push(behaviorOptions), this.interactivityService) {
                                    var cbehaviorOptions = {
                                        layerOptions: layerBehaviorOptions,
                                        clearCatcher: this.clearCatcher
                                    };
                                    this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
                                }
                            }
                        }
                    }
                }, EnhancedScatterChart.prototype.cloneDataPoints = function(dataPoints) {
                    for (var clonedDataPoints = new Array(), _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i], clonedDataPoint = _.clone(dataPoint);
                        clonedDataPoints.push(clonedDataPoint);
                    }
                    return clonedDataPoints;
                }, EnhancedScatterChart.prototype.darkenZeroLine = function(g) {
                    var zeroTick = g.selectAll("g.tick").filter(function(data) {
                        return 0 === data;
                    }).node();
                    zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                }, EnhancedScatterChart.prototype.getCategoryAxisFill = function() {
                    if (this.dataView && this.dataView.metadata.objects) {
                        var label = this.dataView.metadata.objects.categoryAxis;
                        if (label) return label.axisColor;
                    }
                    return {
                        solid: {
                            color: "#333"
                        }
                    };
                }, EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function(labelSettings, viewport, sizeRange) {
                    var xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize), offset = labelSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;
                    return {
                        labelText: function(d) {
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: d.formattedCategory.getValue(),
                                fontSize: labelSettings.fontSize,
                                maxWidth: viewport.width
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return xScale(d.x) - offset;
                            },
                            y: function(d) {
                                var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + visuals.dataLabelUtils.labelMargin;
                                return 0 === labelSettings.position ? yScale(d.y) - margin : yScale(d.y) + margin;
                            }
                        },
                        filter: function(d) {
                            return null != d && null != d.formattedCategory.getValue();
                        },
                        style: {
                            fill: function(d) {
                                return d.labelFill;
                            },
                            "font-size": fontSizeInPx
                        }
                    };
                }, EnhancedScatterChart.prototype.getValueAxisFill = function() {
                    if (this.dataView && this.dataView.metadata.objects) {
                        var label = this.dataView.metadata.objects.valueAxis;
                        if (label) return label.axisColor;
                    }
                    return {
                        solid: {
                            color: "#333"
                        }
                    };
                }, EnhancedScatterChart.prototype.renderCrossHair = function() {
                    var _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, mainGraphicsContext = this.mainGraphicsContext;
                    if (mainGraphicsContext.selectAll(".crosshairCanvas").remove(), this.data.crosshair) {
                        var canvas = mainGraphicsContext.append("g").attr("class", "crosshairCanvas").attr("id", "crosshairCanvas"), crossHair = canvas.append("g").attr("class", "crosshair"), hLine_1 = crossHair.append("line").attr("id", "h_crosshair").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).style("stroke", "gray").style("stroke-width", "1px").style("stroke-dasharray", "5,5").style("display", "none"), vLine_1 = crossHair.append("line").attr("id", "v_crosshair").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).style("stroke", "gray").style("stroke-width", "1px").style("stroke-dasharray", "5,5").style("display", "none"), text_1 = crossHair.append("text").attr("id", "crosshair_text").style("font-size", "10px").style("stroke", "gray").style("stroke-width", "0.5px"), addCrossHair_1 = function(xCoord, yCoord) {
                            hLine_1.attr("x1", 0).attr("y1", yCoord).attr("x2", _this.viewportIn.width).attr("y2", yCoord).style("display", "block"), 
                            vLine_1.attr("x1", xCoord).attr("y1", 0).attr("x2", xCoord).attr("y2", _this.viewportIn.height).style("display", "block"), 
                            text_1.attr("transform", "translate(" + (xCoord + 5) + "," + (yCoord - 5) + ")").text("(" + Math.round(100 * xScale.invert(xCoord)) / 100 + " , " + Math.round(100 * yScale.invert(yCoord)) / 100 + ")");
                        };
                        this.axisGraphicsContextScrollable.on("mousemove", function() {
                            var coordinates = d3.mouse(this), svgNode = this.viewportElement, scaledRect = svgNode.getBoundingClientRect(), domRect = svgNode.getBBox(), ratioX = scaledRect.width / domRect.width, ratioY = scaledRect.height / domRect.height;
                            domRect.width > 0 && !powerbi.Double.equalWithPrecision(ratioX, 1, 1e-5) && (coordinates[0] = coordinates[0] / ratioX), 
                            domRect.height > 0 && !powerbi.Double.equalWithPrecision(ratioY, 1, 1e-5) && (coordinates[1] = coordinates[1] / ratioY), 
                            addCrossHair_1(coordinates[0], coordinates[1]);
                        }).on("mouseover", function() {
                            d3.selectAll(".crosshair").style("display", "block");
                        }).on("mouseout", function() {
                            d3.selectAll(".crosshair").style("display", "none");
                        });
                    }
                }, EnhancedScatterChart.prototype.renderBackground = function() {
                    this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url ? this.backgroundGraphicsContext.attr("xlink:href", this.data.backdrop.url).attr("x", 0).attr("y", 0).attr("width", this.viewportIn.width).attr("height", this.viewportIn.height) : this.backgroundGraphicsContext.attr("width", 0).attr("height", 0);
                }, EnhancedScatterChart.prototype.renderChart = function(mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
                    var bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    if (this.renderBackground(), this.shouldRenderAxis(xAxis)) {
                        xAxis.axis.orient("bottom"), xAxis.willLabelsFit || xAxis.axis.tickPadding(5);
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        duration ? xAxisGraphicsElement.transition().duration(duration).call(xAxis.axis).call(this.darkenZeroLine) : xAxisGraphicsElement.call(xAxis.axis).call(this.darkenZeroLine);
                        var xZeroTick = xAxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        });
                        if (xZeroTick) {
                            var xZeroColor = this.getValueAxisFill();
                            xZeroColor && xZeroTick.selectAll("line").style({
                                stroke: xZeroColor.solid.color
                            });
                        }
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
                        xAxis.willLabelsWordBreak ? xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit) : xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, visuals.CartesianChart.AxisTextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                    } else this.xAxisGraphicsContext.selectAll("*").remove();
                    if (this.shouldRenderAxis(yAxis)) {
                        var yAxisOrientation = this.yAxisOrientation;
                        yAxis.axis.tickSize(-this.viewportIn.width).tickPadding(10).orient(yAxisOrientation.toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        duration ? y1AxisGraphicsElement.transition().duration(duration).call(yAxis.axis).call(this.darkenZeroLine) : y1AxisGraphicsElement.call(yAxis.axis).call(this.darkenZeroLine);
                        var yZeroTick = y1AxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        });
                        if (yZeroTick) {
                            var yZeroColor = this.getCategoryAxisFill();
                            yZeroColor && yZeroTick.selectAll("line").style({
                                stroke: yZeroColor.solid.color
                            });
                        }
                        tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - 10, powerbi.TextMeasurementService.svgEllipsis);
                    } else this.y1AxisGraphicsContext.selectAll("*").remove();
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1;
                        this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                    } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    this.renderCrossHair();
                }, EnhancedScatterChart.prototype.renderAxesLabels = function(axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                    this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    var margin = this.margin, width = this.viewportIn.width, height = this.viewport.height, fontSize = EnhancedScatterChart.AxisFontSize, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    if (!hideXAxisTitle) {
                        var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.x).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    transform: visuals.SVGUtil.translate(width / 2, height - fontSize - 2)
                                });
                            });
                        });
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!hideYAxisTitle) {
                        var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    transform: "rotate(-90)",
                                    y: showY1OnRight ? width + margin.right - fontSize : -margin.left,
                                    x: -((height - margin.top - legendMargin) / 2),
                                    dy: "1em"
                                });
                            });
                        });
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!hideY2AxisTitle && axisLabels.y2) {
                        var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y2).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    transform: "rotate(-90)",
                                    y: showY1OnRight ? -margin.left : width + margin.right - fontSize,
                                    x: -((height - margin.top - legendMargin) / 2),
                                    dy: "1em"
                                });
                            });
                        });
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                }, EnhancedScatterChart.prototype.updateAxis = function() {
                    this.adjustMargins();
                    var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, this.viewportIn.height)), 
                    this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0)), 
                    this.svg.attr({
                        width: this.viewport.width,
                        height: this.viewport.height
                    }), this.svgScrollable.attr({
                        width: this.viewport.width,
                        height: this.viewport.height
                    }), this.svgScrollable.attr({
                        x: 0
                    });
                    var left = this.margin.left, top = this.margin.top;
                    this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(left, top)), 
                    this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(left, top)), 
                    this.clearCatcher.attr("transform", visuals.SVGUtil.translate(-left, -top)), this.isXScrollBarVisible ? (this.svgScrollable.attr({
                        x: left
                    }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, top)), 
                    this.svgScrollable.attr("width", this.viewportIn.width), this.svg.attr("width", this.viewport.width).attr("height", this.viewport.height + this.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", this.viewportIn.height + top), 
                    this.svg.attr("width", this.viewport.width + this.ScrollBarWidth).attr("height", this.viewport.height));
                }, EnhancedScatterChart.prototype.getUnitType = function(xAxis) {
                    return xAxis.formatter && xAxis.formatter.displayUnit && xAxis.formatter.displayUnit.value > 1 ? xAxis.formatter.displayUnit.title : null;
                }, EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function(xAxis, yAxis) {
                    var unitType = this.getUnitType(xAxis);
                    xAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                    xAxis.axisLabel && unitType && (xAxis.isCategoryAxis ? xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType) : xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType)), 
                    unitType = this.getUnitType(yAxis), yAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                    yAxis.axisLabel && unitType && (yAxis.isCategoryAxis ? yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType) : yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType));
                }, EnhancedScatterChart.prototype.hideAxisLabels = function() {
                    return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.viewport.height + this.legendViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.options.interactivity.isInteractiveLegend);
                }, EnhancedScatterChart.prototype.drawScatterMarkers = function(scatterData, hasSelection, sizeRange, duration) {
                    var markers, _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint, useCustomColor = this.data.useCustomColor;
                    this.data.useShape ? (this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove(), 
                    markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function(d) {
                        return d.identity.getKey();
                    }), markers.enter().append("path").classed(EnhancedScatterChart.DotClasses["class"], !0).attr("id", "markershape"), 
                    markers.style({
                        "stroke-opacity": function(d) {
                            return visuals.ScatterChart.getBubbleOpacity(d, hasSelection);
                        },
                        "stroke-width": "1px",
                        stroke: function(d) {
                            var color = useCustomColor ? d.colorFill : d.fill;
                            return _this.data.outline ? d3.rgb(color).darker() : d3.rgb(color);
                        },
                        fill: function(d) {
                            return d3.rgb(useCustomColor ? d.colorFill : d.fill);
                        },
                        "fill-opacity": function(d) {
                            return null != d.size || shouldEnableFill ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0;
                        }
                    }).attr("d", function(d) {
                        var r = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport), area = 4 * r * r;
                        return d.shapeSymbolType(area);
                    }).transition().duration(function(d) {
                        return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                    }).attr("transform", function(d) {
                        return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")";
                    })) : (this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove(), 
                    markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function(d) {
                        return d.identity.getKey();
                    }), markers.enter().append("svg:image").classed(EnhancedScatterChart.ImageClasses["class"], !0).attr("id", "markerimage"), 
                    markers.attr("xlink:href", function(d) {
                        return void 0 !== d.svgurl && null != d.svgurl && "" !== d.svgurl ? d.svgurl : _this.svgDefaultImage;
                    }).attr("width", function(d) {
                        return 2 * visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                    }).attr("height", function(d) {
                        return 2 * visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                    }).transition().duration(function(d) {
                        return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                    }).attr("transform", function(d) {
                        var radius = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
                    })), markers.exit().remove(), this.keyArray = [];
                    for (var i = 0; i < scatterData.length; i++) this.keyArray.push(scatterData[i].identity.getKey());
                    return markers;
                }, EnhancedScatterChart.prototype.calculateAxes = function(categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
                    var visualOptions = {
                        viewport: this.viewport,
                        margin: this.margin,
                        forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                        forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : null,
                        valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : null,
                        valueAxisDisplayUnits: valueAxisProperties && null != valueAxisProperties.labelDisplayUnits ? valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                        categoryAxisDisplayUnits: categoryAxisProperties && null != categoryAxisProperties.labelDisplayUnits ? categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                        trimOrdinalDataOnOverflow: !1
                    };
                    valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain)), 
                    visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                    visualOptions.showValueAxisLabel = !0;
                    var width = this.viewport.width - (this.margin.left + this.margin.right), axes = this.calculateAxesProperties(visualOptions);
                    return axes[0].willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                    axes[0].willLabelsWordBreak = !axes[0].willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                    axes;
                }, EnhancedScatterChart.prototype.calculateAxesProperties = function(options) {
                    var data = this.data, dataPoints = data.dataPoints;
                    this.margin = options.margin, this.viewport = options.viewport;
                    var minY = 0, maxY = 10, minX = 0, maxX = 10;
                    dataPoints.length > 0 && (minY = d3.min(dataPoints, function(d) {
                        return d.y;
                    }), maxY = d3.max(dataPoints, function(d) {
                        return d.y;
                    }), minX = d3.min(dataPoints, function(d) {
                        return d.x;
                    }), maxX = d3.max(dataPoints, function(d) {
                        return d.x;
                    }));
                    var xDomain = [ minX, maxX ], combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);
                    this.xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewportIn.width,
                        dataDomain: combinedXDomain,
                        metaDataColumn: data.xCol,
                        formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !1,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !0,
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits
                    }), this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0), this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                    var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ minY, maxY ]);
                    return this.yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewportIn.height,
                        dataDomain: combinedDomain,
                        metaDataColumn: data.yCol,
                        formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: options.valueAxisScaleType,
                        axisDisplayUnits: options.valueAxisDisplayUnits
                    }), this.yAxisProperties.axisLabel = this.data.axesLabels.y, [ this.xAxisProperties, this.yAxisProperties ];
                }, EnhancedScatterChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data) {
                        var seriesCount = data.dataPoints.length;
                        if (data.hasDynamicSeries) for (var legendDataPointLength = data.legendData.dataPoints.length, i = 0; legendDataPointLength > i; i++) {
                            var series = data.legendData.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: series.label,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: series.color
                                        }
                                    }
                                }
                            });
                        } else {
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: {
                                            color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                        }
                                    }
                                }
                            }).pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    showAllDataPoints: !!data.showAllDataPoints
                                }
                            });
                            for (var i = 0; seriesCount > i; i++) {
                                var seriesDataPoints = data.dataPoints[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: seriesDataPoints.formattedCategory.getValue(),
                                    selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), !0),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: seriesDataPoints.fill
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }, EnhancedScatterChart.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "dataPoint":
                        var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                        visuals.GradientUtils.hasGradientRole(categoricalDataView) || this.enumerateDataPoints(enumeration);
                        break;

                      case "categoryAxis":
                        this.getCategoryAxisValues(enumeration);
                        break;

                      case "valueAxis":
                        this.getValueAxisValues(enumeration);
                        break;

                      case "categoryLabels":
                        this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, !0) : visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, !0);
                        break;

                      case "fillPoint":
                        var sizeRange = this.data.sizeRange;
                        if (sizeRange && sizeRange.min) break;
                        enumeration.pushInstance({
                            objectName: "fillPoint",
                            selector: null,
                            properties: {
                                show: this.data.fillPoint
                            }
                        });
                        break;

                      case "backdrop":
                        enumeration.pushInstance({
                            objectName: "backdrop",
                            displayName: "Backdrop",
                            selector: null,
                            properties: {
                                show: this.data.backdrop ? this.data.backdrop.show : !1,
                                url: this.data.backdrop ? this.data.backdrop.url : null
                            }
                        });
                        break;

                      case "crosshair":
                        enumeration.pushInstance({
                            objectName: "crosshair",
                            selector: null,
                            properties: {
                                show: this.data.crosshair
                            }
                        });
                        break;

                      case "outline":
                        enumeration.pushInstance({
                            objectName: "outline",
                            selector: null,
                            properties: {
                                show: this.data.outline
                            }
                        });
                        break;

                      case "legend":
                        this.getLegendValue(enumeration);
                    }
                    return enumeration.complete();
                }, EnhancedScatterChart.prototype.hasLegend = function() {
                    return this.data && this.data.hasDynamicSeries;
                }, EnhancedScatterChart.prototype.getLegendValue = function(enumeration) {
                    if (this.hasLegend()) {
                        var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : ""), legendLabelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                        this.legendLabelFontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault), 
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: show,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                labelColor: legendLabelColor,
                                fontSize: this.legendLabelFontSize
                            },
                            objectName: "legend"
                        });
                    }
                }, EnhancedScatterChart.prototype.getCategoryAxisValues = function(enumeration) {
                    var supportedType = visuals.axisType.both, isScalar = !0, logPossible = !1, scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ];
                    isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                    this.categoryAxisProperties.end = null);
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: "categoryAxis",
                        validValues: {
                            axisScale: scaleOptions
                        }
                    };
                    instance.properties.show = this.categoryAxisProperties && null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                    this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                    supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                    isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : visuals.axisScale.linear, 
                    instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                    instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null, 
                    instance.properties.labelDisplayUnits = this.categoryAxisProperties && null != this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault), 
                    instance.properties.showAxisTitle = this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !0, 
                    enumeration.pushInstance(instance).pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null
                        },
                        objectName: "categoryAxis",
                        validValues: {
                            axisStyle: this.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                        }
                    });
                }, EnhancedScatterChart.prototype.getValueAxisValues = function(enumeration) {
                    var scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ], logPossible = !1, instance = {
                        selector: null,
                        properties: {},
                        objectName: "valueAxis",
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: scaleOptions
                        }
                    };
                    instance.properties.show = this.valueAxisProperties && null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                    this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                    instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : visuals.axisScale.linear, 
                    instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                    instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                    instance.properties.showAxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !0, 
                    instance.properties.labelDisplayUnits = this.valueAxisProperties && null != this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault, 
                    enumeration.pushInstance(instance).pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null
                        },
                        objectName: "valueAxis",
                        validValues: {
                            axisStyle: this.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                        }
                    });
                }, EnhancedScatterChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, EnhancedScatterChart.DefaultBubbleOpacity = .85, EnhancedScatterChart.DimmedBubbleOpacity = .4, 
                EnhancedScatterChart.DataLabelsOffset = 5, EnhancedScatterChart.ClassName = "enhancedScatterChart", 
                EnhancedScatterChart.MainGraphicsContextClassName = "mainGraphicsContext", EnhancedScatterChart.LegendLabelFontSizeDefault = 9, 
                EnhancedScatterChart.LabelDisplayUnitsDefault = 0, EnhancedScatterChart.AxisFontSize = 11, 
                EnhancedScatterChart.DotClasses = {
                    "class": "dot",
                    selector: ".dot"
                }, EnhancedScatterChart.ImageClasses = {
                    "class": "img",
                    selector: ".img"
                }, EnhancedScatterChart.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                    }, {
                        name: "X",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_X")
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y")
                    }, {
                        name: "Size",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size")
                    }, {
                        name: "Gradient",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
                    }, {
                        name: "ColorFill",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Customized Color"
                    }, {
                        name: "Shape",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Shape"
                    }, {
                        name: "Image",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Image"
                    }, {
                        name: "Rotation",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Rotation"
                    }, {
                        name: "Backdrop",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Backdrop"
                    }, {
                        name: "X Start",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "X Start"
                    }, {
                        name: "X End",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "X End"
                    }, {
                        name: "Y Start",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Y Start"
                    }, {
                        name: "Y End",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Y End"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 1
                            },
                            X: {
                                max: 1
                            },
                            Y: {
                                max: 1
                            },
                            Size: {
                                max: 1
                            },
                            Gradient: {
                                max: 0
                            },
                            ColorFill: {
                                max: 1
                            },
                            Shape: {
                                max: 1
                            },
                            Image: {
                                max: 0
                            },
                            Rotation: {
                                max: 1
                            },
                            Backdrop: {
                                max: 1
                            },
                            "X Start": {
                                max: 1
                            },
                            "X End": {
                                max: 1
                            },
                            "Y Start": {
                                max: 1
                            },
                            "Y End": {
                                max: 1
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            X: {
                                max: 1
                            },
                            Y: {
                                max: 1
                            },
                            Size: {
                                max: 1
                            },
                            Gradient: {
                                max: 1
                            },
                            ColorFill: {
                                max: 1
                            },
                            Shape: {
                                max: 1
                            },
                            Image: {
                                max: 0
                            },
                            Rotation: {
                                max: 1
                            },
                            Backdrop: {
                                max: 1
                            },
                            "X Start": {
                                max: 1
                            },
                            "X End": {
                                max: 1
                            },
                            "Y Start": {
                                max: 1
                            },
                            "Y End": {
                                max: 1
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 1
                            },
                            X: {
                                max: 1
                            },
                            Y: {
                                max: 1
                            },
                            Size: {
                                max: 1
                            },
                            Gradient: {
                                max: 0
                            },
                            ColorFill: {
                                max: 0
                            },
                            Shape: {
                                max: 0
                            },
                            Image: {
                                max: 1
                            },
                            Rotation: {
                                max: 1
                            },
                            Backdrop: {
                                max: 1
                            },
                            "X Start": {
                                max: 1
                            },
                            "X End": {
                                max: 1
                            },
                            "Y Start": {
                                max: 1
                            },
                            "Y End": {
                                max: 1
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            X: {
                                max: 1
                            },
                            Y: {
                                max: 1
                            },
                            Size: {
                                max: 1
                            },
                            Gradient: {
                                max: 1
                            },
                            ColorFill: {
                                max: 0
                            },
                            Shape: {
                                max: 0
                            },
                            Image: {
                                max: 1
                            },
                            Rotation: {
                                max: 1
                            },
                            Backdrop: {
                                max: 1
                            },
                            "X Start": {
                                max: 1
                            },
                            "X End": {
                                max: 1
                            },
                            "Y Start": {
                                max: 1
                            },
                            "Y End": {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    sample: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        bind: {
                                            to: "X"
                                        }
                                    }, {
                                        bind: {
                                            to: "Y"
                                        }
                                    }, {
                                        bind: {
                                            to: "Size"
                                        }
                                    }, {
                                        bind: {
                                            to: "Gradient"
                                        }
                                    }, {
                                        bind: {
                                            to: "ColorFill"
                                        }
                                    }, {
                                        bind: {
                                            to: "Shape"
                                        }
                                    }, {
                                        bind: {
                                            to: "Image"
                                        }
                                    }, {
                                        bind: {
                                            to: "Rotation"
                                        }
                                    }, {
                                        bind: {
                                            to: "Backdrop"
                                        }
                                    }, {
                                        bind: {
                                            to: "X Start"
                                        }
                                    }, {
                                        bind: {
                                            to: "X End"
                                        }
                                    }, {
                                        bind: {
                                            to: "Y Start"
                                        }
                                    }, {
                                        bind: {
                                            to: "Y End"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            },
                            rowCount: {
                                preferred: {
                                    min: 2
                                }
                            }
                        }
                    } ],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                useShape: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_UseImage"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                    type: {
                                        fillRule: {}
                                    },
                                    rule: {
                                        inputRole: "Gradient",
                                        output: {
                                            property: "fill",
                                            selector: [ "Category" ]
                                        }
                                    }
                                }
                            }
                        },
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                    type: {
                                        formatting: {
                                            axisScale: !0
                                        }
                                    }
                                },
                                start: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                end: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                    type: {
                                        formatting: {
                                            axisStyle: !0
                                        }
                                    }
                                },
                                axisColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: "Display Units",
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    }
                                }
                            }
                        },
                        valueAxis: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                    type: {
                                        formatting: {
                                            yAxisPosition: !0
                                        }
                                    }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                    type: {
                                        formatting: {
                                            axisScale: !0
                                        }
                                    }
                                },
                                start: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                end: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                    type: {
                                        formatting: {
                                            axisStyle: !0
                                        }
                                    }
                                },
                                axisColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: "Display Units",
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                    type: {
                                        enumeration: visuals.legendPosition.type
                                    }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: "Legend Name",
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                    type: {
                                        text: !0
                                    }
                                },
                                labelColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        categoryLabels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        fillPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_FillPoint"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        },
                        backdrop: {
                            displayName: "Backdrop",
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                url: {
                                    displayName: "Image URL",
                                    type: {
                                        text: !0
                                    }
                                }
                            }
                        },
                        crosshair: {
                            displayName: "Crosshair",
                            properties: {
                                show: {
                                    displayName: "Crosshair",
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        },
                        outline: {
                            displayName: "Outline",
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        }
                    }
                }, EnhancedScatterChart;
            }();
            samples.EnhancedScatterChart = EnhancedScatterChart;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var THREE, WebGLHeatmap, GlobeMapCanvasLayers, powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var DataRoleHelper = powerbi.data.DataRoleHelper, GlobeMap = function() {
                function GlobeMap() {
                    this.renderData = [], this.locationsToLoad = 0, this.locationsLoaded = 0, this.renderLoopEnabled = !0, 
                    this.needsRender = !1;
                }
                return GlobeMap.converter = function(dataView) {
                    return {};
                }, GlobeMap.prototype.init = function(options) {
                    this.container = options.element, this.viewport = options.viewport, this.readyToRender = !1, 
                    this.globeMapLocationCache || (this.globeMapLocationCache = {}), THREE || loadGlobeMapLibs(), 
                    THREE && this.setup();
                }, GlobeMap.prototype.setup = function() {
                    this.initSettings(), this.initTextures(), this.initMercartorSphere(), this.initZoomControl(), 
                    this.initScene(), this.initHeatmap(), this.readyToRender = !0, this.composeRenderData(), 
                    this.initRayCaster();
                }, GlobeMap.prototype.initSettings = function() {
                    var settings = this.settings = {};
                    settings.autoRotate = !1, settings.earthRadius = 30, settings.cameraRadius = 100, 
                    settings.earthSegments = 100, settings.heatmapSize = 1e3, settings.heatPointSize = 7, 
                    settings.heatIntensity = 10, settings.heatmapScaleOnZoom = .95, settings.barWidth = .3, 
                    settings.barHeight = 5, settings.rotateSpeed = .5, settings.zoomSpeed = .8, settings.cameraAnimDuration = 1e3, 
                    settings.clickInterval = 200;
                }, GlobeMap.prototype.initScene = function() {
                    var viewport = this.viewport, settings = this.settings, clock = new THREE.Clock(), renderer = this.renderer = new THREE.WebGLRenderer({
                        antialias: !0,
                        preserveDrawingBuffer: !0
                    });
                    this.container.append(renderer.domElement), this.domElement = renderer.domElement;
                    var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, .1, 1e4), orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement), scene = this.scene = new THREE.Scene();
                    renderer.setSize(viewport.width, viewport.height), renderer.setClearColor(12240082, 1), 
                    camera.position.z = settings.cameraRadius, orbitControls.maxDistance = settings.cameraRadius, 
                    orbitControls.minDistance = settings.earthRadius + 1, orbitControls.rotateSpeed = settings.rotateSpeed, 
                    orbitControls.zoomSpeed = settings.zoomSpeed, orbitControls.autoRotate = settings.autoRotate;
                    var ambientLight = new THREE.AmbientLight(0), light1 = new THREE.DirectionalLight(16777215, .4), light2 = new THREE.DirectionalLight(16777215, .4), earth = this.earth = this.createEarth();
                    scene.add(ambientLight), scene.add(light1), scene.add(light2), scene.add(earth), 
                    light1.position.set(20, 20, 20), light2.position.set(0, 0, -20);
                    var _zis = this;
                    requestAnimationFrame(function render() {
                        try {
                            if (_zis.renderLoopEnabled && requestAnimationFrame(render), !_zis.shouldRender()) return;
                            orbitControls.update(clock.getDelta()), _zis.setEarthTexture(), _zis.intersectBars(), 
                            _zis.heatmap.display(), renderer.render(scene, camera), _zis.needsRender = !1;
                        } catch (e) {}
                    });
                }, GlobeMap.prototype.shouldRender = function() {
                    return this.readyToRender && this.needsRender;
                }, GlobeMap.prototype.createEarth = function() {
                    var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments), material = new THREE.MeshPhongMaterial({
                        map: this.mapTextures[0],
                        side: THREE.DoubleSide,
                        shininess: 1,
                        emissive: 11184810
                    });
                    return new THREE.Mesh(geometry, material);
                }, GlobeMap.prototype.zoomClicked = function(zoomDirection) {
                    this.orbitControls.enabled !== !1 && this.orbitControls.enableZoom !== !1 && (-1 === zoomDirection ? this.orbitControls.constraint.dollyOut(Math.pow(.95, this.settings.zoomSpeed)) : 1 === zoomDirection && this.orbitControls.constraint.dollyIn(Math.pow(.95, this.settings.zoomSpeed)), 
                    this.orbitControls.update(), this.animateCamera(this.camera.position));
                }, GlobeMap.prototype.rotateCam = function(deltaX, deltaY) {
                    this.orbitControls.enabled !== !1 && this.orbitControls.enableRotate !== !1 && (this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed), 
                    this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed), 
                    this.orbitControls.update(), this.animateCamera(this.camera.position));
                }, GlobeMap.prototype.initZoomControl = function() {
                    var _this = this, radius = 17, zoomControlWidth = 8.5 * radius, zoomControlHeight = 8.5 * radius, startX = 3 * radius, startY = radius + 3, gap = 2 * radius, zoomCss = {
                        position: "absolute",
                        left: "calc(100% - " + zoomControlWidth + "px)",
                        top: "calc(100% - " + zoomControlHeight + "px)",
                        zIndex: "1000"
                    }, zoomContainer = d3.select(this.container[0]).append("div").style(zoomCss);
                    this.zoomControl = zoomContainer.append("svg").attr({
                        width: zoomControlWidth,
                        height: zoomControlHeight
                    });
                    var bottom = this.zoomControl.append("g").on("click", function() {
                        return _this.rotateCam(0, -5);
                    });
                    bottom.append("circle").attr({
                        cx: startX + gap,
                        cy: startY + 2 * gap,
                        r: radius,
                        fill: "white",
                        opacity: .5,
                        stroke: "gray"
                    }), bottom.append("path").attr({
                        d: "M" + (startX + 2 * radius) + " " + (startY + 4.7 * radius) + " l12 -20 a40,70 0 0,1 -24,0z",
                        fill: "gray"
                    });
                    var left = this.zoomControl.append("g").on("click", function() {
                        return _this.rotateCam(5, 0);
                    });
                    left.append("circle").attr({
                        cx: startX,
                        cy: startY + gap,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: .5
                    }), left.append("path").attr({
                        d: "M" + (startX - radius / 1.5) + " " + (startY + 2 * radius) + " l20 -12 a70,40 0 0,0 0,24z",
                        fill: "gray"
                    });
                    var top = this.zoomControl.append("g").on("click", function() {
                        return _this.rotateCam(0, 5);
                    });
                    top.append("circle").attr({
                        cx: startX + gap,
                        cy: startY,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: .5
                    }), top.append("path").attr({
                        d: "M" + (startX + 2 * radius) + " " + (startY - radius / 1.5) + " l12 20 a40,70 0 0,0 -24,0z",
                        fill: "gray"
                    });
                    var right = this.zoomControl.append("g").on("click", function() {
                        return _this.rotateCam(-5, 0);
                    });
                    right.append("circle").attr({
                        cx: startX + 2 * gap,
                        cy: startY + gap,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: .5
                    }), right.append("path").attr({
                        d: "M" + (startX + 4.7 * radius) + " " + (startY + 2 * radius) + " l-20 -12 a70,40 0 0,1 0,24z",
                        fill: "gray"
                    });
                    var zoomIn = this.zoomControl.append("g").on("click", function() {
                        return _this.zoomClicked(-1);
                    });
                    zoomIn.append("circle").attr({
                        cx: startX + 4 * radius,
                        cy: startY + 6 * radius,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: .5
                    }), zoomIn.append("rect").attr({
                        x: startX + 3.5 * radius,
                        y: startY + 5.9 * radius,
                        width: radius,
                        height: radius / 3,
                        fill: "gray"
                    }), zoomIn.append("rect").attr({
                        x: startX + 4 * radius - radius / 6,
                        y: startY + 5.55 * radius,
                        width: radius / 3,
                        height: radius,
                        fill: "gray"
                    });
                    var zoomOut = this.zoomControl.append("g").on("click", function() {
                        return _this.zoomClicked(1);
                    });
                    zoomOut.append("circle").attr({
                        cx: startX,
                        cy: startY + 6 * radius,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: "0.50"
                    }), zoomOut.append("rect").attr({
                        x: startX - radius / 2,
                        y: startY + 5.9 * radius,
                        width: radius,
                        height: radius / 3,
                        fill: "gray"
                    });
                }, GlobeMap.prototype.initTextures = function() {
                    var _this = this;
                    if (!GlobeMapCanvasLayers) {
                        GlobeMapCanvasLayers = [];
                        for (var level = 2; 5 >= level; ++level) {
                            var canvas = this.getBingMapCanvas(level);
                            GlobeMapCanvasLayers.push(canvas);
                        }
                    }
                    var createTexture = function(canvas) {
                        var texture = new THREE.Texture(canvas.get(0));
                        return texture.needsUpdate = !0, canvas.on("ready", function(e, resolution) {
                            texture.needsUpdate = !0, _this.needsRender = !0;
                        }), texture;
                    };
                    this.mapTextures = [];
                    for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
                }, GlobeMap.prototype.initHeatmap = function() {
                    var settings = this.settings;
                    try {
                        var heatmap = this.heatmap = new WebGLHeatmap({
                            width: settings.heatmapSize,
                            height: settings.heatmapSize,
                            intensityToAlpha: !0
                        });
                    } catch (e) {}
                    var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
                    texture.needsUpdate = !0;
                    var material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: !0
                    }), geometry = new THREE.SphereGeometry(settings.earthRadius + .01, settings.earthSegments, settings.earthSegments), mesh = new THREE.Mesh(geometry, material);
                    window.heatmap = heatmap, window.heatmapTexture = texture, this.scene.add(mesh);
                }, GlobeMap.prototype.setEarthTexture = function() {
                    if (this.camera) {
                        var texture, maxDistance = this.settings.cameraRadius - this.settings.earthRadius, distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;
                        texture = .2 >= distance ? this.mapTextures[3] : .4 >= distance ? this.mapTextures[2] : .6 >= distance ? this.mapTextures[1] : this.mapTextures[0], 
                        this.earth.material.map !== texture && (this.earth.material.map = texture), this.selectedBar ? this.orbitControls.rotateSpeed = this.settings.rotateSpeed : this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;
                    }
                }, GlobeMap.prototype.update = function(options) {
                    if (this.needsRender = !0, this.cleanHeatAndBar(), options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {
                        var viewport = this.viewport = options.viewport;
                        return void (this.camera && this.renderer && (this.camera.aspect = viewport.width / viewport.height, 
                        this.camera.updateProjectionMatrix(), this.renderer.setSize(viewport.width, viewport.height)));
                    }
                    options.dataViews[0] && options.dataViews[0].categorical && this.composeRenderData(options.dataViews[0].categorical);
                }, GlobeMap.prototype.cleanHeatAndBar = function() {
                    this.heatmap.clear(), this.heatTexture.needsUpdate = !0, this.barsGroup && this.scene.remove(this.barsGroup);
                }, GlobeMap.prototype.renderMagic = function() {
                    if (!this.readyToRender) return void this.defferedRender();
                    var renderData = this.renderData, heatmap = this.heatmap, settings = this.settings;
                    heatmap.clear(), this.barsGroup && this.scene.remove(this.barsGroup), this.barsGroup = new THREE.Object3D(), 
                    this.scene.add(this.barsGroup);
                    var barMaterials = [ new THREE.MeshPhongMaterial({
                        color: 16711935,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 16776986,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 16711680,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 65535,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 10046720,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 11783372,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 11331072,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }), new THREE.MeshPhongMaterial({
                        color: 5395066,
                        side: THREE.DoubleSide,
                        shading: THREE.FlatShading,
                        transparent: !0
                    }) ];
                    this.averageBarVector = new THREE.Vector3();
                    for (var i = 0, len = renderData.length; len > i; ++i) {
                        var renderDatum = renderData[i];
                        if (renderDatum.lat && renderDatum.lng) {
                            if (renderDatum.heat > .001) {
                                renderDatum.heat < .1 && (renderDatum.heat = .1);
                                var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize, y = (1 - (90 + renderDatum.lat) / 180) * settings.heatmapSize;
                                heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);
                            }
                            if (renderDatum.height >= 0) {
                                renderDatum.height < .01 && (renderDatum.height = .01);
                                var latRadians = renderDatum.lat / 180 * Math.PI, lngRadians = renderDatum.lng / 180 * Math.PI, x = Math.cos(lngRadians) * Math.cos(latRadians), z = -Math.sin(lngRadians) * Math.cos(latRadians), y = Math.sin(latRadians), v = new THREE.Vector3(x, y, z);
                                this.averageBarVector.add(v);
                                var barHeight = settings.barHeight * renderDatum.height, measuresBySeries = [], dataPointToolTip = [];
                                if (renderDatum.heightBySeries) for (var c = 0; c < renderDatum.heightBySeries.length; c++) renderDatum.heightBySeries[c] && measuresBySeries.push(renderDatum.heightBySeries[c]), 
                                dataPointToolTip.push(renderDatum.seriesToolTipData[c]); else measuresBySeries.push(1);
                                for (var previousMeasureValue = 0, j = 0; j < measuresBySeries.length; j++) {
                                    previousMeasureValue += measuresBySeries[j];
                                    var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]), bar = new THREE.Mesh(geometry, barMaterials[j % (barMaterials.length - 1)]);
                                    bar.position = v.clone().multiplyScalar(settings.earthRadius + barHeight / 2 * previousMeasureValue), 
                                    bar.lookAt(v), bar.toolTipData = 0 === dataPointToolTip.length ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]), 
                                    this.barsGroup.add(bar), previousMeasureValue += measuresBySeries[j];
                                }
                            }
                        }
                    }
                    this.barsGroup.children.length > 0 && this.camera && (this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length), 
                    this.locationsLoaded === this.locationsToLoad && this.animateCamera(this.averageBarVector)), 
                    heatmap.update(), heatmap.blur(), this.heatTexture.needsUpdate = !0, this.needsRender = !0;
                }, GlobeMap.prototype.getToolTipDataForSeries = function(toolTipData, dataPointToolTip) {
                    var result = jQuery.extend(!0, {
                        series: {
                            displayName: dataPointToolTip.displayName,
                            value: dataPointToolTip.value
                        }
                    }, toolTipData);
                    return result.height.value = dataPointToolTip.dataPointValue, result;
                }, GlobeMap.prototype.composeRenderData = function(categoricalView) {
                    categoricalView ? this.categoricalView = categoricalView : categoricalView = this.categoricalView, 
                    this.renderData = [];
                    var locations = [], globeMapLocationCache = this.globeMapLocationCache;
                    if (categoricalView) {
                        var categories = categoricalView.categories, grouped = categoricalView.values.grouped(), heightIndex = 0, intensityIndex = 0;
                        try {
                            heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Height"), intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Heat");
                            var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                        } catch (e) {}
                        var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;
                        if (void 0 !== heightIndex && categoricalView.values[heightIndex] && void 0 !== categoricalView.values) {
                            var locationCategory = categories[0];
                            locations = locationCategory.values, locationDispName = locationCategory.source.displayName, 
                            locationType = locationCategory.source.type.category ? locationCategory.source.type.category.toLowerCase() : "";
                        } else locations = [];
                        if (void 0 !== heightIndex && categoricalView.values[heightIndex]) if (heightDispName = categoricalView.values[heightIndex].source.displayName, 
                        heightFormat = categoricalView.values[heightIndex].source.format, grouped.length > 1) {
                            heights = new Array(locations.length), heightsBySeries = new Array(locations.length), 
                            toolTipDataBySeries = new Array(locations.length);
                            for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[heightIndex].values, j = 0; j < values.length; j++) heights[j] || (heights[j] = 0), 
                            heights[j] += values[j] ? values[j] : 0, heightsBySeries[j] || (heightsBySeries[j] = []), 
                            heightsBySeries[j][i] = values[j], toolTipDataBySeries[j] || (toolTipDataBySeries[j] = []), 
                            toolTipDataBySeries[j][i] = {
                                displayName: categoricalView.values.source.displayName,
                                value: grouped[i].name,
                                dataPointValue: values[j]
                            };
                            for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[heightIndex].values, j = 0; j < values.length; j++) heightsBySeries[j][i] = values[j] / heights[j];
                        } else heights = categoricalView.values[heightIndex].values, heightsBySeries = new Array(grouped.length); else heightsBySeries = new Array(locations.length), 
                        heights = new Array(locations.length);
                        if (void 0 !== intensityIndex && categoricalView.values[intensityIndex]) {
                            if (grouped.length > 1) {
                                heats = new Array(locations.length);
                                for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[intensityIndex].values, j = 0; j < values.length; j++) heats[j] || (heats[j] = 0), 
                                heats[j] += values[j] ? values[j] : 0;
                            } else heats = categoricalView.values[intensityIndex].values;
                            heatDispName = categoricalView.values[intensityIndex].source.displayName, heatFormat = categoricalView.values[intensityIndex].source.format;
                        } else heats = new Array(locations.length);
                        void 0 !== longitudeIndex && categoricalView.values[longitudeIndex] && void 0 !== latitudeIndex && categoricalView.values[latitudeIndex] ? (longitudes = categoricalView.values[longitudeIndex].values, 
                        latitudes = categoricalView.values[latitudeIndex].values) : (longitudes = null, 
                        latitudes = null);
                        for (var maxHeight = Math.max.apply(null, heights) || 1, maxHeat = Math.max.apply(null, heats) || 1, heatFormatter = visuals.valueFormatter.create({
                            format: heatFormat,
                            value: heats[0],
                            value2: heats[1]
                        }), heightFormatter = visuals.valueFormatter.create({
                            format: heightFormat,
                            value: heights[0],
                            value2: heights[1]
                        }), i = 0, len = locations.length; len > i; ++i) {
                            var lat, lng, latlng, height, heat, place = locations[i];
                            if (place && "string" == typeof place) {
                                place = place.toLowerCase();
                                var placeKey = place + "/" + locationType;
                                !longitudes && globeMapLocationCache[placeKey] ? (latlng = globeMapLocationCache[placeKey], 
                                lat = latlng.latitude, lng = latlng.longitude) : longitudes && (lat = latitudes[i], 
                                lng = longitudes[i]), height = heights[i] / maxHeight, heat = heats[i] / maxHeat;
                                var renderDatum = {
                                    lat: lat,
                                    lng: lng,
                                    height: height ? height || .01 : void 0,
                                    heightBySeries: heightsBySeries[i],
                                    seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : void 0,
                                    heat: heat || 0,
                                    toolTipData: {
                                        location: {
                                            displayName: locationDispName,
                                            value: locations[i]
                                        },
                                        height: {
                                            displayName: heightDispName,
                                            value: heightFormatter.format(heights[i])
                                        },
                                        heat: {
                                            displayName: heatDispName,
                                            value: heatFormatter.format(heats[i])
                                        }
                                    }
                                };
                                this.renderData.push(renderDatum), longitudes || latlng || this.geocodeRenderDatum(renderDatum, place, locationType);
                            }
                        }
                        try {
                            this.renderMagic();
                        } catch (e) {}
                    }
                }, GlobeMap.prototype.geocodeRenderDatum = function(renderDatum, place, locationType) {
                    var _this = this, placeKey = place + "/" + locationType;
                    this.globeMapLocationCache[placeKey] = {}, this.locationsToLoad++;
                    try {
                        var geocoder = powerbi.visuals.BI.Services.GeocodingManager.geocode;
                    } catch (e) {
                        geocoder = visuals.services.geocode;
                    }
                    geocoder && geocoder(place, locationType).always(function(latlng) {
                        _this.globeMapLocationCache[placeKey] = latlng, _this.locationsLoaded++, latlng.latitude && latlng.longitude && (renderDatum.lat = latlng.latitude, 
                        renderDatum.lng = latlng.longitude, _this.defferedRender());
                    });
                }, GlobeMap.prototype.defferedRender = function() {
                    var _this = this;
                    this.deferredRenderTimerId || (this.deferredRenderTimerId = setTimeout(function() {
                        _this.deferredRenderTimerId = null, _this.composeRenderData();
                    }, 500));
                }, GlobeMap.prototype.initRayCaster = function() {
                    var _this = this;
                    this.rayCaster = new THREE.Raycaster();
                    var mouseDownTime, settings = this.settings, mousePosNormalized = this.mousePosNormalized = new THREE.Vector2(), mousePos = this.mousePos = new THREE.Vector2(), element = this.container.get(0);
                    $(this.domElement).on("mousemove", function(event) {
                        var rect = element.getBoundingClientRect();
                        mousePos.x = event.clientX, mousePos.y = event.clientY, mousePosNormalized.x = (event.clientX - rect.left) / rect.width * 2 - 1, 
                        mousePosNormalized.y = 2 * -((event.clientY - rect.top) / rect.height) + 1, _this.needsRender = !0;
                    }).on("mousedown", function(event) {
                        mouseDownTime = Date.now();
                    }).on("mouseup", function(event) {
                        Date.now() - mouseDownTime > settings.clickInterval || (_this.hoveredBar && event.shiftKey ? (_this.selectedBar = _this.hoveredBar, 
                        _this.animateCamera(_this.selectedBar.position, function() {
                            _this.selectedBar && (_this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius)), 
                            _this.orbitControls.minDistance = 1);
                        })) : _this.selectedBar && (_this.animateCamera(_this.selectedBar.position, function() {
                            _this.orbitControls.center.set(0, 0, 0), _this.orbitControls.minDistance = settings.earthRadius + 1;
                        }), _this.selectedBar = null));
                    }).on("mousewheel DOMMouseScroll", function(e) {
                        if (_this.needsRender = !0, _this.orbitControls.enabled && _this.orbitControls.enableZoom) {
                            _this.heatTexture.needsUpdate = !0, e = e.originalEvent;
                            var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1, scale = delta > 0 ? _this.settings.heatmapScaleOnZoom : 1 / _this.settings.heatmapScaleOnZoom;
                            _this.heatmap.multiply(scale), _this.heatmap.update();
                        }
                    });
                }, GlobeMap.prototype.intersectBars = function() {
                    if (this.rayCaster && this.barsGroup) {
                        var rayCaster = this.rayCaster;
                        rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
                        var intersects = rayCaster.intersectObjects(this.barsGroup.children);
                        if (intersects && intersects.length > 0) {
                            var object = intersects[0].object;
                            if (!object || !object.toolTipData) return;
                            var toolTipData = object.toolTipData, toolTipItems = [];
                            toolTipData.location.displayName && toolTipItems.push(toolTipData.location), toolTipData.series && toolTipItems.push(toolTipData.series), 
                            toolTipData.height.displayName && toolTipItems.push(toolTipData.height), toolTipData.heat.displayName && toolTipItems.push(toolTipData.heat), 
                            this.hoveredBar = object, visuals.TooltipManager.ToolTipInstance.show(toolTipItems, {
                                x: this.mousePos.x,
                                y: this.mousePos.y,
                                width: 0,
                                height: 0
                            });
                        } else this.hoveredBar = null, visuals.TooltipManager.ToolTipInstance.hide();
                    }
                }, GlobeMap.prototype.animateCamera = function(to, done) {
                    var _this = this;
                    if (this.camera) {
                        var startTime = Date.now(), duration = this.settings.cameraAnimDuration, endTime = startTime + duration, startPos = this.camera.position.clone().normalize(), endPos = to.clone().normalize(), length = this.camera.position.length(), easeInOut = function(t) {
                            return t *= 2, 1 > t ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
                        }, onUpdate = function() {
                            var now = Date.now(), t = (now - startTime) / duration;
                            t > 1 && (t = 1), t = easeInOut(t);
                            var pos = new THREE.Vector3().add(startPos.clone().multiplyScalar(1 - t)).add(endPos.clone().multiplyScalar(t)).normalize().multiplyScalar(length);
                            _this.camera.position = pos, endTime > now ? requestAnimationFrame(onUpdate) : done && done(), 
                            _this.needsRender = !0;
                        };
                        requestAnimationFrame(onUpdate);
                    }
                }, GlobeMap.prototype.destroy = function() {
                    if (clearTimeout(this.deferredRenderTimerId), this.renderLoopEnabled = !1, this.scene = null, 
                    this.heatmap = null, this.heatTexture = null, this.camera = null, this.renderer) {
                        if (this.renderer.context) {
                            var extension = this.renderer.context.getExtension("WEBGL_lose_context");
                            extension && extension.loseContext(), this.renderer.context = null;
                        }
                        this.renderer.domElement = null;
                    }
                    this.renderer = null, this.renderData = null, this.barsGroup = null, this.orbitControls && this.orbitControls.dispose(), 
                    this.orbitControls = null, this.domElement && $(this.domElement).off("mousemove mouseup mousedown mousewheel DOMMouseScroll"), 
                    this.domElement = null, this.container && this.container.empty();
                }, GlobeMap.prototype.initMercartorSphere = function() {
                    if (!GlobeMap.MercartorSphere) {
                        var MercartorSphere = function(radius, widthSegments, heightSegments) {
                            function interplolate(a, b, t) {
                                return (1 - t) * a + t * b;
                            }
                            function interpolateVertex(u, v, t) {
                                var maxLng = 2 * Math.PI, maxLat = Math.PI, radius = this.radius, sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat), sphereY = -radius * Math.cos(v * maxLat), sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat), planeX = u * radius * 2 - radius, planeY = v * radius * 2 - radius, planeZ = 0, x = interplolate(sphereX, planeX, t), y = interplolate(sphereY, planeY, t), z = interplolate(sphereZ, planeZ, t);
                                return new THREE.Vector3(x, y, z);
                            }
                            function interpolateUV(u, v, t) {
                                var lat = 90 * (v - .5) * 2 / 180 * Math.PI, sin = Math.sin(lat), normalizedV = .5 + .25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
                                return new THREE.Vector2(u, normalizedV);
                            }
                            THREE.Geometry.call(this), this.radius = radius, this.widthSegments = widthSegments, 
                            this.heightSegments = heightSegments, this.t = 0;
                            var x, y, vertices = [], uvs = [];
                            for (y = 0; heightSegments >= y; y++) {
                                var verticesRow = [], uvsRow = [];
                                for (x = 0; widthSegments >= x; x++) {
                                    var u = x / widthSegments, v = y / heightSegments;
                                    this.vertices.push(interpolateVertex.call(this, u, v, this.t)), uvsRow.push(interpolateUV.call(this, u, v, this.t)), 
                                    verticesRow.push(this.vertices.length - 1);
                                }
                                vertices.push(verticesRow), uvs.push(uvsRow);
                            }
                            for (y = 0; y < this.heightSegments; y++) for (x = 0; x < this.widthSegments; x++) {
                                var v1 = vertices[y][x + 1], v2 = vertices[y][x], v3 = vertices[y + 1][x], v4 = vertices[y + 1][x + 1], n1 = this.vertices[v1].clone().normalize(), n2 = this.vertices[v2].clone().normalize(), n3 = this.vertices[v3].clone().normalize(), n4 = this.vertices[v4].clone().normalize(), uv1 = uvs[y][x + 1].clone(), uv2 = uvs[y][x].clone(), uv3 = uvs[y + 1][x].clone(), uv4 = uvs[y + 1][x + 1].clone(), normals = [ n1, n2, n3, n4 ];
                                this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals)), this.faceVertexUvs[0].push([ uv1, uv2, uv3, uv4 ]);
                            }
                            this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
                        };
                        MercartorSphere.prototype = Object.create(THREE.Geometry.prototype), GlobeMap.MercartorSphere = MercartorSphere;
                    }
                }, GlobeMap.prototype.getBingMapCanvas = function(resolution) {
                    function generateQuads(res, quad) {
                        resolution >= res && (res === resolution && loadTile(quad), generateQuads(res + 1, quad + "0"), 
                        generateQuads(res + 1, quad + "1"), generateQuads(res + 1, quad + "2"), generateQuads(res + 1, quad + "3"));
                    }
                    function loadTile(quad) {
                        var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}", numServers = 7, server = Math.round(Math.random() * numServers), language = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language, url = template.replace("{server}", server).replace("{quad}", quad).replace("{language}", language), coords = getCoords(quad), tile = new Image();
                        tile.onload = function() {
                            tilesLoaded++, canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize), 
                            tilesLoaded === numTiles && canvas.trigger("ready", resolution);
                        }, tile.crossOrigin = "", tile.src = url;
                    }
                    function getCoords(quad) {
                        for (var x = 0, y = 0, last = quad.length - 1, i = last; i >= 0; i--) {
                            var chr = quad.charAt(i), pow = Math.pow(2, last - i);
                            "1" === chr ? x += pow : "2" === chr ? y += pow : "3" === chr && (x += pow, y += pow);
                        }
                        return {
                            x: x,
                            y: y
                        };
                    }
                    var tileSize = 256, numSegments = Math.pow(2, resolution), numTiles = numSegments * numSegments, tilesLoaded = 0, canvasSize = tileSize * numSegments, canvas = $("<canvas/>").attr({
                        width: canvasSize,
                        height: canvasSize
                    }), canvasElem = canvas.get(0), canvasContext = canvasElem.getContext("2d");
                    return generateQuads(0, ""), canvas;
                }, GlobeMap.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                        preferredTypes: [ {
                            geography: {
                                address: !0
                            }
                        }, {
                            geography: {
                                city: !0
                            }
                        }, {
                            geography: {
                                continent: !0
                            }
                        }, {
                            geography: {
                                country: !0
                            }
                        }, {
                            geography: {
                                county: !0
                            }
                        }, {
                            geography: {
                                place: !0
                            }
                        }, {
                            geography: {
                                postalCode: !0
                            }
                        }, {
                            geography: {
                                region: !0
                            }
                        }, {
                            geography: {
                                stateOrProvince: !0
                            }
                        } ]
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Legend"
                    }, {
                        name: "X",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Longitude",
                        description: "Use to override the longitude of locations",
                        preferredTypes: [ {
                            geography: {
                                longitude: !0
                            }
                        } ]
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Latitude",
                        description: "Use to override the latitude of locations",
                        preferredTypes: [ {
                            geography: {
                                latitude: !0
                            }
                        } ]
                    }, {
                        name: "Height",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Bar Height"
                    }, {
                        name: "Heat",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Heat Intensity"
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                    type: {
                                        formatting: {
                                            legendPosition: !0
                                        }
                                    }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                                    type: {
                                        text: !0
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                    type: {
                                        fillRule: {}
                                    },
                                    rule: {
                                        inputRole: "Gradient",
                                        output: {
                                            property: "fill",
                                            selector: [ "Category" ]
                                        }
                                    }
                                }
                            }
                        },
                        categoryLabels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 1
                            },
                            Height: {
                                max: 1
                            },
                            Heat: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        bind: {
                                            to: "Height"
                                        }
                                    }, {
                                        bind: {
                                            to: "Heat"
                                        }
                                    }, {
                                        bind: {
                                            to: "X"
                                        }
                                    }, {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            },
                            rowCount: {
                                preferred: {
                                    min: 2
                                }
                            }
                        }
                    } ],
                    sorting: {
                        custom: {}
                    }
                }, GlobeMap;
            }();
            samples.GlobeMap = GlobeMap;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var SelectionManager = visuals.utility.SelectionManager, CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, RadarChartWebBehavior = function() {
                function RadarChartWebBehavior() {}
                return RadarChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var selection = this.selection = options.selection, clearCatcher = options.clearCatcher;
                    selection.on("click", function(d) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                    }), clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, RadarChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    this.selection.style("opacity", function(d) {
                        return hasSelection && !d.selected ? RadarChart.DimmedAreaFillOpacity : RadarChart.AreaFillOpacity;
                    });
                }, RadarChartWebBehavior;
            }();
            samples.RadarChartWebBehavior = RadarChartWebBehavior;
            var RadarChart = function() {
                function RadarChart(options) {
                    options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                    options.margin && (this.margin = options.margin));
                }
                return RadarChart.converter = function(dataView, colors) {
                    if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories.length > 0 && dataView.categorical.categories[0] && dataView.categorical.values && dataView.categorical.values.length > 0)) return {
                        legendData: {
                            dataPoints: []
                        },
                        settings: {
                            showLegend: !0
                        },
                        series: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings()
                    };
                    for (var catDv = dataView.categorical, values = catDv.values, series = [], colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill), legendData = {
                        fontSize: 8.25,
                        dataPoints: [],
                        title: ""
                    }, legendSettings = RadarChart.parseSettings(dataView), dataLabelsSettings = RadarChart.parseLabelSettings(dataView), i = 0, iLen = values.length; iLen > i; i++) {
                        var color = colors.getColorByIndex(i).value, serieIdentity = void 0, queryName = void 0, displayName = void 0, dataPoints = [];
                        if (values[i].source) {
                            var source = values[i].source;
                            if (source.queryName && (queryName = source.queryName, serieIdentity = visuals.SelectionId.createWithMeasure(queryName)), 
                            source.displayName && (displayName = source.displayName), source.objects) {
                                var objects = source.objects;
                                color = colorHelper.getColorForMeasure(objects, queryName);
                            }
                        }
                        legendData.dataPoints.push({
                            label: displayName,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            selected: !1,
                            identity: serieIdentity
                        });
                        for (var k = 0, kLen = values[i].values.length; kLen > k; k++) {
                            var dataPointIdentity = visuals.SelectionIdBuilder.builder().withMeasure(queryName).withCategory(catDv.categories[0], k).withSeries(dataView.categorical.values, dataView.categorical.values[i]).createSelectionId(), tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i), labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp), fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                            dataPoints.push({
                                x: k,
                                y: values[i].values[k],
                                color: color,
                                identity: dataPointIdentity,
                                selected: !1,
                                tooltipInfo: tooltipInfo,
                                value: values[i].values[k],
                                labelFormatString: labelFormatString,
                                labelFontSize: fontSizeInPx
                            });
                        }
                        dataPoints.length > 0 && series.push({
                            fill: color,
                            name: displayName,
                            data: dataPoints,
                            identity: serieIdentity
                        });
                    }
                    return {
                        legendData: legendData,
                        settings: legendSettings,
                        series: series,
                        dataLabelsSettings: dataLabelsSettings
                    };
                }, RadarChart.prototype.init = function(options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({
                        hostServices: options.host
                    }), this.svg || (this.svg = d3.select(element.get(0)).append("svg"), this.svg.style("position", "absolute")), 
                    this.margin || (this.margin = RadarChart.DefaultMargin), this.svg.classed(RadarChart.VisualClassName, !0), 
                    this.interactivityService = visuals.createInteractivityService(options.host), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                    this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top), 
                    this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = this.svg.append("g"), 
                    this.segments = this.mainGroupElement.append("g").classed(RadarChart.Segments["class"], !0), 
                    this.axis = this.mainGroupElement.append("g").classed(RadarChart.Axis["class"], !0), 
                    this.chart = this.mainGroupElement.append("g").classed(RadarChart.Chart["class"], !0);
                }, RadarChart.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        var dataView = options.dataViews[0];
                        this.radarChartData = RadarChart.converter(dataView, this.colors);
                        var dataViewMetadataColumn, categories = [], series = this.radarChartData.series, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
                        dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && (categories = dataView.categorical.categories[0].values), 
                        dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0 && (dataViewMetadataColumn = dataView.metadata.columns[0]), 
                        this.viewport = {
                            height: options.viewport.height > 0 ? options.viewport.height : 0,
                            width: options.viewport.width > 0 ? options.viewport.width : 0
                        }, this.parseLegendProperties(dataView), this.renderLegend(this.radarChartData), 
                        this.updateViewport(), this.svg.attr({
                            height: this.viewport.height,
                            width: this.viewport.width
                        });
                        var mainGroup = this.mainGroupElement;
                        mainGroup.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                        var width = this.viewport.width - this.margin.left - this.margin.right, height = this.viewport.height - this.margin.top - this.margin.bottom;
                        this.angle = RadarChart.Radians / categories.length, this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2, 
                        this.drawCircularSegments(categories), this.drawAxes(categories), this.drawAxesLabels(categories, dataViewMetadataColumn), 
                        this.drawChart(series, duration), this.drawDataLabels(series);
                    }
                }, RadarChart.prototype.getRadarChartLabelLayout = function(labelSettings, allDataPoints) {
                    var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), angle = this.angle, radius = this.radius, dataPoints = this.getDataPoints(this.radarChartData.series), stack = d3.layout.stack(), layers = stack(dataPoints), viewport = this.viewport, halfHeight = this.viewport.height / 2, halfWidth = this.viewport.width / 2, y = d3.scale.linear().domain([ 0, d3.max(layers, function(layer) {
                        return d3.max(layer, function(d) {
                            return d.y0 + d.y;
                        });
                    }) ]).range([ 0, radius ]);
                    return {
                        labelText: function(d) {
                            var formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);
                            if (0 === labelSettings.displayUnits) {
                                var maxDataPoint = _.max(allDataPoints, function(d) {
                                    return d.value;
                                }), maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;
                                formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);
                            }
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: formmater.format(d.value),
                                maxWidth: viewport.width,
                                fontSize: labelSettings.fontSize
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth;
                            },
                            y: function(d) {
                                return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 10;
                            }
                        },
                        filter: function(d) {
                            return null != d && null != d.value;
                        },
                        style: {
                            fill: labelSettings.labelColor,
                            "font-size": function(d) {
                                return PixelConverter.fromPoint(labelSettings.fontSize);
                            }
                        }
                    };
                }, RadarChart.prototype.drawCircularSegments = function(values) {
                    for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius, level = 0; levels - 1 > level; level++) for (var levelFactor = radius * ((level + 1) / levels), transform = -1 * levelFactor, i = 0; i < values.length; i++) data.push({
                        x1: levelFactor * (1 - factor * Math.sin(i * angle)),
                        y1: levelFactor * (1 - factor * Math.cos(i * angle)),
                        x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
                        y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
                        translate: visuals.SVGUtil.translate(transform, transform)
                    });
                    var selection = this.mainGroupElement.select(RadarChart.Segments.selector).selectAll(RadarChart.SegmentNode.selector).data(data);
                    selection.enter().append("svg:line").classed(RadarChart.SegmentNode["class"], !0), 
                    selection.attr({
                        x1: function(item) {
                            return item.x1;
                        },
                        y1: function(item) {
                            return item.y1;
                        },
                        x2: function(item) {
                            return item.x2;
                        },
                        y2: function(item) {
                            return item.y2;
                        },
                        transform: function(item) {
                            return item.translate;
                        }
                    }), selection.exit().remove();
                }, RadarChart.prototype.drawDataLabels = function(series) {
                    var allDataPoints = this.getAllDataPointsList(series);
                    if (this.radarChartData.dataLabelsSettings.show) {
                        var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints), viewport = this.viewport, labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);
                        labels && labels.attr("transform", visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));
                    } else visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);
                }, RadarChart.prototype.drawAxes = function(values) {
                    var angle = this.angle, radius = -1 * this.radius, selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisNode.selector), axis = selection.data(values);
                    axis.enter().append("svg:line"), axis.attr({
                        x1: 0,
                        y1: 0,
                        x2: function(name, i) {
                            return radius * Math.sin(i * angle);
                        },
                        y2: function(name, i) {
                            return radius * Math.cos(i * angle);
                        }
                    }).classed(RadarChart.AxisNode["class"], !0), axis.exit().remove();
                }, RadarChart.prototype.drawAxesLabels = function(values, dataViewMetadataColumn) {
                    var angle = this.angle, radius = -1 * this.radius, length = values.length, formatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, !0),
                        value: values[0],
                        value2: values[length - 1]
                    }), selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisLabel.selector), labels = selection.data(values);
                    labels.enter().append("svg:text"), labels.attr({
                        "text-anchor": "middle",
                        dy: "1.5em",
                        transform: visuals.SVGUtil.translate(0, -10),
                        x: function(name, i) {
                            return (radius - 20) * Math.sin(i * angle);
                        },
                        y: function(name, i) {
                            return (radius - 10) * Math.cos(i * angle);
                        }
                    }).text(function(item) {
                        return formatter.format(item);
                    }).classed(RadarChart.AxisLabel["class"], !0), labels.exit().remove();
                }, RadarChart.prototype.drawChart = function(series, duration) {
                    var angle = this.angle, radius = this.radius, dotRadius = 5, dataPoints = this.getDataPoints(series), stack = d3.layout.stack(), layers = stack(dataPoints), y = d3.scale.linear().domain([ 0, d3.max(layers, function(layer) {
                        return d3.max(layer, function(d) {
                            return d.y0 + d.y;
                        });
                    }) ]).range([ 0, radius ]), calculatePoints = function(points) {
                        return points.map(function(value) {
                            var x1 = -1 * y(value.y) * Math.sin(value.x * angle), y1 = -1 * y(value.y) * Math.cos(value.x * angle);
                            return x1 + "," + y1;
                        }).join(" ");
                    }, selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
                    selection.enter().append("g").classed(RadarChart.ChartNode["class"], !0);
                    var polygon = selection.selectAll(RadarChart.ChartPolygon.selector).data(function(d) {
                        return d && d.length > 0 ? [ d ] : [];
                    });
                    polygon.enter().append("polygon").classed(RadarChart.ChartPolygon["class"], !0), 
                    polygon.style("fill", function(d) {
                        return d[0].color;
                    }).style("opacity", RadarChart.DimmedAreaFillOpacity).on("mouseover", function(d) {
                        d3.select(this).transition().duration(duration).style("opacity", RadarChart.AreaFillOpacity);
                    }).on("mouseout", function(d) {
                        d3.select(this).transition().duration(duration).style("opacity", RadarChart.DimmedAreaFillOpacity);
                    }).attr("points", calculatePoints), polygon.exit().remove();
                    var dots = selection.selectAll(RadarChart.ChartDot.selector).data(function(d) {
                        return d.filter(function(d) {
                            return null != d.y;
                        });
                    });
                    dots.enter().append("svg:circle").classed(RadarChart.ChartDot["class"], !0), dots.attr("r", dotRadius).attr({
                        cx: function(value) {
                            return -1 * y(value.y) * Math.sin(value.x * angle);
                        },
                        cy: function(value) {
                            return -1 * y(value.y) * Math.cos(value.x * angle);
                        }
                    }).style("fill", function(d) {
                        return d.color;
                    }), dots.exit().remove(), visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }, !0), selection.exit().remove();
                    var behaviorOptions = void 0;
                    if (this.interactivityService) {
                        var dataPointsToBind = this.getAllDataPointsList(series);
                        behaviorOptions = {
                            selection: dots,
                            clearCatcher: this.svg
                        }, this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);
                    }
                }, RadarChart.prototype.renderLegend = function(radarChartData) {
                    if (radarChartData.legendData) {
                        var legendData = radarChartData.legendData;
                        if (this.legendObjectProperties) {
                            visuals.LegendData.update(legendData, this.legendObjectProperties);
                            var position = this.legendObjectProperties[visuals.legendProps.position];
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                        } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                        var viewport = this.viewport;
                        this.legend.drawLegend(legendData, {
                            height: viewport.height,
                            width: viewport.width
                        }), visuals.Legend.positionChartArea(this.svg, this.legend);
                    }
                }, RadarChart.prototype.getDataPoints = function(series) {
                    for (var dataPoints = [], _i = 0, series_3 = series; _i < series_3.length; _i++) {
                        var serie = series_3[_i];
                        dataPoints.push(serie.data);
                    }
                    return dataPoints;
                }, RadarChart.prototype.getAllDataPointsList = function(series) {
                    for (var dataPoints = [], _i = 0, series_4 = series; _i < series_4.length; _i++) {
                        var serie = series_4[_i];
                        dataPoints = dataPoints.concat(serie.data);
                    }
                    return dataPoints;
                }, RadarChart.prototype.parseLegendProperties = function(dataView) {
                    return dataView && dataView.metadata ? void (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})) : void (this.legendObjectProperties = {});
                }, RadarChart.parseSettings = function(dataView) {
                    var objects;
                    return objects = dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null, 
                    {
                        showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, !0)
                    };
                }, RadarChart.parseLabelSettings = function(dataView) {
                    var objects;
                    objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null;
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), labelsObj = {
                        show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),
                        labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),
                        displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),
                        precision: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),
                        fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),
                        position: dataLabelsSettings.position
                    };
                    return labelsObj;
                }, RadarChart.prototype.enumerateObjectInstances = function(options) {
                    var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                    if (!this.radarChartData || !this.radarChartData.settings) return [];
                    switch (settings = this.radarChartData.settings, options.objectName) {
                      case "legend":
                        enumeration.pushInstance(this.enumerateLegend(settings));
                        break;

                      case "dataPoint":
                        this.enumerateDataPoint(enumeration);
                        break;

                      case "labels":
                        this.enumerateDataLabels(enumeration);
                    }
                    return enumeration.complete();
                }, RadarChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings) {
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !0,
                        displayUnits: !0,
                        precision: !0,
                        fontSize: !0
                    };
                }, RadarChart.prototype.enumerateDataLabels = function(enumeration) {
                    var labelSettings = this.radarChartData.dataLabelsSettings;
                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));
                }, RadarChart.prototype.enumerateLegend = function(settings) {
                    var legend, labelColor, showTitle = !0, titleText = "", fontSize = 8;
                    return showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                    titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                    labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor), 
                    fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize), 
                    legend = {
                        objectName: "legend",
                        displayName: "legend",
                        selector: null,
                        properties: {
                            show: settings.showLegend,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: fontSize
                        }
                    };
                }, RadarChart.prototype.enumerateDataPoint = function(enumeration) {
                    if (this.radarChartData && this.radarChartData.series) for (var series = this.radarChartData.series, _i = 0, series_5 = series; _i < series_5.length; _i++) {
                        var serie = series_5[_i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: serie.name,
                            selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), !1),
                            properties: {
                                fill: {
                                    solid: {
                                        color: serie.fill
                                    }
                                }
                            }
                        });
                    }
                }, RadarChart.prototype.updateViewport = function() {
                    var legendPosition, legendMargins = this.legend.getMargins();
                    switch (legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]]) {
                      case visuals.LegendPosition.Top:
                      case visuals.LegendPosition.TopCenter:
                      case visuals.LegendPosition.Bottom:
                      case visuals.LegendPosition.BottomCenter:
                        this.viewport.height -= legendMargins.height;
                        break;

                      case visuals.LegendPosition.Left:
                      case visuals.LegendPosition.LeftCenter:
                      case visuals.LegendPosition.Right:
                      case visuals.LegendPosition.RightCenter:
                        this.viewport.width -= legendMargins.width;
                    }
                }, RadarChart.capabilities = {
                    dataRoles: [ {
                        displayName: "Category",
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping
                    }, {
                        displayName: "Y Axis",
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                min: 1,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Y"
                                    }
                                } ]
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                    type: {
                                        enumeration: visuals.legendPosition.type
                                    }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                    type: {
                                        text: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                    type: {
                                        numeric: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, RadarChart.formatStringProp = {
                    objectName: "general",
                    propertyName: "formatString"
                }, RadarChart.Properties = {
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        color: {
                            objectName: "labels",
                            propertyName: "color"
                        },
                        displayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        precision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        }
                    }
                }, RadarChart.VisualClassName = "radarChart", RadarChart.Segments = CreateClassAndSelector("segments"), 
                RadarChart.SegmentNode = CreateClassAndSelector("segmentNode"), RadarChart.Axis = CreateClassAndSelector("axis"), 
                RadarChart.AxisNode = CreateClassAndSelector("axisNode"), RadarChart.AxisLabel = CreateClassAndSelector("axisLabel"), 
                RadarChart.Chart = CreateClassAndSelector("chart"), RadarChart.ChartNode = CreateClassAndSelector("chartNode"), 
                RadarChart.ChartPolygon = CreateClassAndSelector("chartPolygon"), RadarChart.ChartDot = CreateClassAndSelector("chartDot"), 
                RadarChart.DefaultMargin = {
                    top: 50,
                    bottom: 50,
                    right: 100,
                    left: 100
                }, RadarChart.SegmentLevels = 6, RadarChart.SegmentFactor = 1, RadarChart.Radians = 2 * Math.PI, 
                RadarChart.Scale = 1, RadarChart.AreaFillOpacity = 1, RadarChart.DimmedAreaFillOpacity = .4, 
                RadarChart;
            }();
            samples.RadarChart = RadarChart;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration, HistogramChartWarning = function() {
                function HistogramChartWarning(message) {
                    this.message = message;
                }
                return Object.defineProperty(HistogramChartWarning.prototype, "code", {
                    get: function() {
                        return "BulletChartWarning";
                    },
                    enumerable: !0,
                    configurable: !0
                }), HistogramChartWarning.prototype.getMessages = function(resourceProvider) {
                    return {
                        message: this.message,
                        title: resourceProvider.get(""),
                        detail: resourceProvider.get("")
                    };
                }, HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big", 
                HistogramChartWarning;
            }();
            samples.HistogramChartWarning = HistogramChartWarning;
            var Histogram = function() {
                function Histogram(histogramConstructorOptions) {
                    this.ColumnPadding = 1, this.MinColumnHeight = 1, this.MinOpacity = .3, this.MaxOpacity = 1, 
                    this.NumberOfLabelsOnAxisY = 5, this.MinNumberOfBins = 0, this.MaxNumberOfBins = 100, 
                    this.MinPrecision = 0, this.MaxPrecision = 17, this.TooltipDisplayName = "Range", 
                    this.SeparatorNumbers = ", ", this.LegendSize = 50, this.AxisSize = 30, this.ExcludeBrackets = {
                        left: "(",
                        right: ")"
                    }, this.IncludeBrackets = {
                        left: "[",
                        right: "]"
                    }, this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }, this.durationAnimations = 200, histogramConstructorOptions && (histogramConstructorOptions.svg && (this.svg = histogramConstructorOptions.svg), 
                    histogramConstructorOptions.animator && (this.animator = histogramConstructorOptions.animator), 
                    this.margin = histogramConstructorOptions.margin || this.margin);
                }
                return Object.defineProperty(Histogram.prototype, "columnsSelection", {
                    get: function() {
                        return this.main.select(Histogram.Columns.selector).selectAll(Histogram.Column.selector);
                    },
                    enumerable: !0,
                    configurable: !0
                }), Histogram.prototype.init = function(visualsOptions) {
                    this.hostService = visualsOptions.host, this.svg ? this.root = this.svg : this.root = d3.select(visualsOptions.element.get(0)).append("svg");
                    var style = visualsOptions.style;
                    this.colors = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                    this.root.classed(Histogram.ClassName, !0), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(Histogram.Axes["class"], !0), 
                    this.axisX = this.axes.append("g").classed(Histogram.Axis["class"], !0), this.axisY = this.axes.append("g").classed(Histogram.Axis["class"], !0), 
                    this.legend = this.main.append("g").classed(Histogram.Legends["class"], !0), this.columns = this.main.append("g").classed(Histogram.Columns["class"], !0), 
                    this.selectionManager = new SelectionManager({
                        hostServices: visualsOptions.host
                    });
                }, Histogram.prototype.converter = function(dataView) {
                    var _this = this;
                    if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0)) return null;
                    var settings, histogramLayout, values, data, xScale, yScale, valueFormatter, numericalValues = [], frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0;
                    return dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && (frequencies = dataView.categorical.values[0].values), 
                    dataView.categorical.categories[0].identity && dataView.categorical.categories[0].identity.length > 0 && (identities = dataView.categorical.categories[0].identity), 
                    (settings = this.parseSettings(dataView)) ? (values = this.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities), 
                    values.forEach(function(value) {
                        numericalValues.push(value.value), sumFrequency += value.frequency;
                    }), histogramLayout = d3.layout.histogram(), settings.bins && settings.bins > this.MinNumberOfBins && (histogramLayout = histogramLayout.bins(settings.bins)), 
                    data = histogramLayout.frequency(settings.frequency)(numericalValues), data.forEach(function(bin, index) {
                        var filteredValues, frequency;
                        filteredValues = values.filter(function(value) {
                            return _this.isValueContainedInRange(value, bin, index);
                        }), frequency = filteredValues.reduce(function(previousValue, currentValue) {
                            return previousValue + currentValue.frequency;
                        }, 0), bin.y = settings.frequency ? frequency : frequency / sumFrequency, shiftByValues += bin.length;
                    }), xScale = d3.scale.linear().domain([ d3.min(data, function(item) {
                        return d3.min(item);
                    }), d3.max(data, function(item) {
                        return d3.max(item);
                    }) ]).range([ 0, this.viewport.width - this.LegendSize - this.AxisSize ]), yScale = d3.scale.linear().domain([ 0, d3.max(data, function(item) {
                        return item.y;
                    }) ]).range([ this.viewport.height - this.LegendSize, 0 ]), valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties.general.formatString),
                        value: values[0].value,
                        value2: values[values.length - 1].value,
                        precision: settings.precision
                    }), {
                        xScale: xScale,
                        yScale: yScale,
                        settings: settings,
                        data: this.getData(values, numericalValues, data, settings, valueFormatter),
                        formatter: valueFormatter
                    }) : null;
                }, Histogram.prototype.getValuesByFrequencies = function(sourceValues, frequencies, identities) {
                    var values = [];
                    return sourceValues.forEach(function(item, index) {
                        var frequency = 1, value = Number(item);
                        value = isNaN(value) ? 0 : value, frequencies && frequencies[index] && !isNaN(frequencies[index]) && frequencies[index] > 1 && (frequency = frequencies[index]), 
                        values.push({
                            value: value,
                            frequency: frequency,
                            selectionId: visuals.SelectionId.createWithId(identities[index])
                        });
                    }), values;
                }, Histogram.prototype.getData = function(values, numericalValues, data, settings, valueFormatter) {
                    var _this = this, minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues);
                    return data.map(function(bin, index) {
                        return bin.range = _this.getRange(minValue, maxValue, bin.dx, index), bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, 0 === index, valueFormatter), 
                        bin.selectionIds = _this.getSelectionIds(values, bin, index), bin;
                    });
                }, Histogram.prototype.getRange = function(minValue, maxValue, step, index) {
                    var leftBorder = minValue + index * step, rightBorder = leftBorder + step;
                    return [ leftBorder, rightBorder ];
                }, Histogram.prototype.getTooltipData = function(value, range, settings, includeLeftBorder, valueFormatter) {
                    return [ {
                        displayName: this.getLegendText(settings),
                        value: valueFormatter.format(value)
                    }, {
                        displayName: this.TooltipDisplayName,
                        value: this.rangeToString(range, includeLeftBorder, valueFormatter)
                    } ];
                }, Histogram.prototype.getSelectionIds = function(values, bin, index) {
                    var _this = this, selectionIds = [];
                    return values.forEach(function(value) {
                        _this.isValueContainedInRange(value, bin, index) && selectionIds.push(value.selectionId);
                    }), selectionIds;
                }, Histogram.prototype.isValueContainedInRange = function(value, bin, index) {
                    return (0 === index && value.value >= bin.x || value.value > bin.x) && value.value <= bin.x + bin.dx;
                }, Histogram.prototype.parseSettings = function(dataView) {
                    if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                    var objects, colorHelper, histogramSettings = {};
                    return colorHelper = new visuals.ColorHelper(this.colors, Histogram.Properties.dataPoint.fill, Histogram.DefaultHistogramSettings.fillColor), 
                    histogramSettings.displayName = Histogram.DefaultHistogramSettings.displayName, 
                    histogramSettings.fillColor = Histogram.DefaultHistogramSettings.fillColor, histogramSettings.bins = Histogram.DefaultHistogramSettings.bins, 
                    histogramSettings.frequency = Histogram.DefaultHistogramSettings.frequency, histogramSettings.displayName = dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName, 
                    objects = this.getObjectsFromDataView(dataView), objects && (histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, ""), 
                    histogramSettings.bins = this.getBins(objects), histogramSettings.frequency = this.getFrequency(objects), 
                    histogramSettings.precision = this.getPrecision(objects)), histogramSettings;
                }, Histogram.prototype.getBins = function(objects) {
                    var binsNumber;
                    return binsNumber = Number(powerbi.DataViewObjects.getValue(objects, Histogram.Properties.general.bins, Histogram.DefaultHistogramSettings.bins)), 
                    !binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins ? Histogram.DefaultHistogramSettings.bins : binsNumber > this.MaxNumberOfBins ? this.MaxNumberOfBins : binsNumber;
                }, Histogram.prototype.getFrequency = function(objects) {
                    return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.general.frequency, Histogram.DefaultHistogramSettings.frequency);
                }, Histogram.prototype.getPrecision = function(objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.labelPrecision, Histogram.DefaultHistogramSettings.precision);
                    return precision <= this.MinPrecision ? this.MinPrecision : precision >= this.MaxPrecision ? this.MaxPrecision : precision;
                }, Histogram.prototype.validateData = function(data) {
                    return data && data.data.some(function(x) {
                        return x.range.some(function(x) {
                            return isNaN(x) || x === 1 / 0 || x === -(1 / 0);
                        });
                    }) ? (this.hostService.setWarnings([ new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues) ]), 
                    !1) : !0;
                }, Histogram.prototype.update = function(visualUpdateOptions) {
                    if (visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0]) {
                        var dataView = visualUpdateOptions.dataViews[0];
                        this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                        this.setSize(visualUpdateOptions.viewport), this.histogramDataView = this.converter(dataView), 
                        this.validateData(this.histogramDataView) || (this.histogramDataView.data = []), 
                        this.render();
                    }
                }, Histogram.prototype.setSize = function(viewport) {
                    var height, width;
                    height = viewport.height - this.margin.top - this.margin.bottom, width = viewport.width - this.margin.left - this.margin.right, 
                    this.viewport = {
                        height: height,
                        width: width
                    }, this.updateElements(viewport.height, viewport.width);
                }, Histogram.prototype.updateElements = function(height, width) {
                    var shiftToRight = this.margin.left + this.LegendSize;
                    this.root.attr({
                        height: height,
                        width: width
                    }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                    this.legend.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                    this.columns.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0)), this.axes.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0)), 
                    this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.LegendSize));
                }, Histogram.prototype.render = function() {
                    if (this.histogramDataView && this.histogramDataView.settings) {
                        this.renderAxes();
                        var columnsSelection = this.renderColumns();
                        this.renderLegend(), this.bindSelectionHandler(columnsSelection);
                    }
                }, Histogram.prototype.renderColumns = function() {
                    var widthOfColumn, updateColumnsSelection, _this = this, data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length;
                    return widthOfColumn = countOfValues && (this.viewport.width - this.AxisSize - this.LegendSize) / countOfValues - this.ColumnPadding, 
                    0 > widthOfColumn && (widthOfColumn = 0), updateColumnsSelection = this.columnsSelection.data(data), 
                    updateColumnsSelection.enter().append("svg:rect"), updateColumnsSelection.attr("x", this.ColumnPadding / 2).attr("width", widthOfColumn).attr("height", function(item) {
                        return _this.getColumnHeight(item, yScale);
                    }).style("fill", this.histogramDataView.settings.fillColor).attr("class", Histogram.Column["class"]).attr("transform", function(item, index) {
                        return visuals.SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5);
                    }), countOfValues && updateColumnsSelection.classed(Histogram.Column["class"]), 
                    updateColumnsSelection.exit().remove(), this.renderTooltip(updateColumnsSelection), 
                    updateColumnsSelection;
                }, Histogram.prototype.renderTooltip = function(selection) {
                    visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                }, Histogram.prototype.getColumnHeight = function(column, y) {
                    var height = this.viewport.height - this.LegendSize - y(column.y);
                    return height > 0 ? height : this.MinColumnHeight;
                }, Histogram.prototype.renderAxes = function() {
                    var xAxis, yAxis, xScale = this.histogramDataView.xScale, yScale = this.histogramDataView.yScale, valueFormatter = this.histogramDataView.formatter;
                    xAxis = d3.svg.axis().scale(xScale).orient("bottom").tickValues(this.rangesToArray(this.histogramDataView.data)).tickFormat(function(item) {
                        return valueFormatter.format(item);
                    }), yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(this.NumberOfLabelsOnAxisY), 
                    this.axisX.call(xAxis), this.axisY.call(yAxis);
                }, Histogram.prototype.rangesToArray = function(data) {
                    return data.reduce(function(previousValue, currentValue, index) {
                        var range;
                        return range = 0 === index ? currentValue.range : currentValue.range.slice(1), previousValue.concat(range);
                    }, []);
                }, Histogram.prototype.rangeToString = function(range, includeLeftBorder, valueFormatter) {
                    var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
                    return leftBracket = includeLeftBorder ? this.IncludeBrackets.left : this.ExcludeBrackets.left, 
                    "" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;
                }, Histogram.prototype.renderLegend = function() {
                    var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);
                    legendElements = this.main.select(Histogram.Legends.selector).selectAll(Histogram.Legend.selector), 
                    legendSelection = legendElements.data(datalegends), legendSelection.enter().append("svg:text"), 
                    legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                        return item.dx;
                    }).attr("dy", function(item) {
                        return item.dy;
                    }).attr("transform", function(item) {
                        return item.transform;
                    }).attr("class", Histogram.Legend["class"]).text(function(item) {
                        return item.text;
                    }).classed(Histogram.Legend["class"], !0), legendSelection.exit().remove();
                }, Histogram.prototype.getDataLegends = function(settings) {
                    var bottomLegendText = this.getLegendText(settings);
                    return [ {
                        transform: visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
                        text: settings.displayName,
                        dx: "1em",
                        dy: "-1em"
                    }, {
                        transform: visuals.SVGUtil.translateAndRotate(0, this.viewport.height / 2, 0, 0, 270),
                        text: bottomLegendText,
                        dx: "3em"
                    } ];
                }, Histogram.prototype.getLegendText = function(settings) {
                    return settings.frequency ? Histogram.FrequencyText : Histogram.DensityText;
                }, Histogram.prototype.bindSelectionHandler = function(columnsSelection) {
                    var _this = this;
                    this.setSelection(columnsSelection), columnsSelection.on("click", function(data) {
                        _this.selectionManager.clear(), data.selectionIds.forEach(function(selectionId) {
                            _this.selectionManager.select(selectionId, !0).then(function(selectionIds) {
                                selectionIds.length > 0 ? _this.setSelection(columnsSelection, data) : _this.setSelection(columnsSelection);
                            });
                        }), d3.event.stopPropagation();
                    }), this.root.on("click", function() {
                        _this.selectionManager.clear(), _this.setSelection(columnsSelection);
                    });
                }, Histogram.prototype.setSelection = function(columnsSelection, data) {
                    columnsSelection.transition().duration(this.durationAnimations).style("fill-opacity", this.MaxOpacity), 
                    data && columnsSelection.filter(function(columnSelection) {
                        return columnSelection !== data;
                    }).transition().duration(this.durationAnimations).style("fill-opacity", this.MinOpacity);
                }, Histogram.prototype.enumerateObjectInstances = function(options) {
                    var settings, instances = [];
                    if (!this.histogramDataView || !this.histogramDataView.settings) return instances;
                    switch (settings = this.histogramDataView.settings, options.objectName) {
                      case "general":
                        var general = {
                            objectName: "general",
                            displayName: "general",
                            selector: null,
                            properties: {
                                bins: settings.bins,
                                frequency: settings.frequency
                            }
                        };
                        instances.push(general);
                        break;

                      case "dataPoint":
                        var dataPoint = {
                            objectName: "dataPoint",
                            displayName: "dataPoint",
                            selector: null,
                            properties: {
                                fill: settings.fillColor
                            }
                        };
                        instances.push(dataPoint);
                        break;

                      case "labels":
                        var labels = {
                            objectName: "labels",
                            displayName: "labels",
                            selector: null,
                            properties: {
                                labelPrecision: settings.precision
                            }
                        };
                        instances.push(labels);
                    }
                    return instances;
                }, Histogram.prototype.getObjectsFromDataView = function(dataView) {
                    return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                }, Histogram.prototype.destroy = function() {
                    this.root = null;
                }, Histogram.ClassName = "histogram", Histogram.FrequencyText = "Frequency", Histogram.DensityText = "Density", 
                Histogram.Properties = {
                    general: {
                        bins: {
                            objectName: "general",
                            propertyName: "bins"
                        },
                        frequency: {
                            objectName: "general",
                            propertyName: "frequency"
                        },
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    labels: {
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        }
                    }
                }, Histogram.DefaultHistogramSettings = {
                    frequency: !0,
                    displayName: "Histogram",
                    bins: null,
                    fillColor: "cadetblue",
                    precision: 2
                }, Histogram.Axes = {
                    "class": "axes",
                    selector: ".axes"
                }, Histogram.Axis = {
                    "class": "axis",
                    selector: ".axis"
                }, Histogram.Columns = {
                    "class": "columns",
                    selector: ".columns"
                }, Histogram.Column = {
                    "class": "column",
                    selector: ".column"
                }, Histogram.Legends = {
                    "class": "legends",
                    selector: ".legends"
                }, Histogram.Legend = {
                    "class": "legend",
                    selector: ".legend"
                }, Histogram.capabilities = {
                    dataRoles: [ {
                        name: "Values",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                    }, {
                        name: "Frequency",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Frequency"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Values: {
                                min: 1,
                                max: 1
                            },
                            Frequency: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                bind: {
                                    to: "Values"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                "for": {
                                    "in": "Frequency"
                                }
                            }
                        }
                    } ],
                    sorting: {
                        implicit: {
                            clauses: [ {
                                role: "Values",
                                direction: 1
                            } ]
                        }
                    },
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                },
                                bins: {
                                    displayName: "Bins",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                frequency: {
                                    displayName: "Frequency",
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                            properties: {
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        }
                    }
                }, Histogram;
            }();
            samples.Histogram = Histogram;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration, CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, AxisScale = powerbi.visuals.axisScale, PixelConverter = jsCommon.PixelConverter, MaxXAxisHeight = 40, LabelMargin = 15, DefaultRadius = 5, DefaultStrokeWidth = 1, DefaultDataPointColor = "#00B8AA", MinPrecision = 0, MaxPrecision = 17;
            samples.DotPlotProperties = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    },
                    labelPrecision: {
                        objectName: "labels",
                        propertyName: "labelPrecision"
                    },
                    labelDisplayUnits: {
                        objectName: "labels",
                        propertyName: "labelDisplayUnits"
                    },
                    labelColor: {
                        objectName: "labels",
                        propertyName: "labelColor"
                    }
                },
                dataPoint: {
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                categories: {
                    show: {
                        objectName: "categories",
                        propertyName: "show"
                    },
                    fontColor: {
                        objectName: "categories",
                        propertyName: "fontColor"
                    },
                    fontSize: {
                        objectName: "categories",
                        propertyName: "fontSize"
                    }
                }
            };
            var DotPlot = function() {
                function DotPlot(options) {
                    this.DefaultMargin = {
                        top: 10,
                        bottom: 10,
                        right: 20,
                        left: 20
                    }, this.durationAnimations = 200, this.scaleType = AxisScale.linear, this.textProperties = {
                        fontFamily: "wf_segoe-ui_normal",
                        fontSize: jsCommon.PixelConverter.toString(9)
                    }, this.dotPlotSelectors = {
                        svgPlotSelector: CreateClassAndSelector("dotplot"),
                        plotSelector: CreateClassAndSelector("dotplotSelector"),
                        plotGroupSelector: CreateClassAndSelector("dotplotGroup"),
                        axisSelector: CreateClassAndSelector("axisGraphicsContext"),
                        xAxisSelector: CreateClassAndSelector("x axis"),
                        circleSeletor: CreateClassAndSelector("circleSelector")
                    }, this.DefaultDotPlotSettings = {
                        labelSettings: {
                            show: !0,
                            precision: 2,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                            displayUnits: 0,
                            labelColor: visuals.dataLabelUtils.defaultLabelColor
                        },
                        categorySettings: {
                            show: !0,
                            fontColor: visuals.LegendData.DefaultLegendLabelFillColor
                        },
                        defaultDataPointColor: DefaultDataPointColor
                    }, options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                    this.radius = options.radius || DefaultRadius, this.strokeWidth = options.strokeWidth || DefaultStrokeWidth);
                }
                return DotPlot.getTooltipData = function(value) {
                    return [ {
                        displayName: "Value",
                        value: value.toString()
                    } ];
                }, DotPlot.converter = function(dataView, scale, defaultMargin, defaultSetting, colors, viewport, radius) {
                    var settings, values = dataView.categorical.values, dataPointsGroup = [], displayName = dataView.categorical.categories[0].source.displayName, objects = this.getObjectsFromDataView(dataView), defaultColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), categories = dataView.categorical.categories[0].values.map(function(x, i) {
                        return {
                            value: x,
                            selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i])
                        };
                    });
                    settings = {
                        categorySettings: this.getCategorySettings(objects, defaultSetting),
                        defaultDataPointColor: defaultColor,
                        labelSettings: this.parseSettings(objects, defaultSetting)
                    };
                    for (var categoryColumn = dataView.categorical.categories[0], diameter = 2 * radius + 1, dotsTotalHeight = viewport.height - radius - MaxXAxisHeight, maxDots = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1, fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize), yScale = d3.scale.linear().domain([ 0, maxDots ]).range([ dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom ]), _i = 0, values_1 = values; _i < values_1.length; _i++) for (var value = values_1[_i], min = _.min(value.values), max = _.max(value.values), color = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), length_1 = value.values.length, minDots = min / (max / maxDots), dotsScale = d3.scale.log().domain([ min, max ]).range([ 0 === minDots ? 1 : minDots, maxDots ]).clamp(!0), k = 0; length_1 > k; k++) {
                        for (var y = dotsScale(value.values[k]), dataPoints = [], level = 0; y > level; level++) dataPoints.push({
                            x: scale(categories[k].value) + scale.rangeBand() / 2,
                            y: yScale(level),
                            tooltipInfo: DotPlot.getTooltipData(value.values[k])
                        });
                        var categorySelectionId = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId(), tooltipInfo = DotPlot.getTooltipData(value.values[k]);
                        dataPointsGroup.push({
                            selected: !1,
                            value: value.values[k],
                            label: value.values[k],
                            color: color,
                            identity: categorySelectionId,
                            tooltipInfo: tooltipInfo,
                            dataPoints: dataPoints,
                            labelFontSize: fontSizeInPx
                        });
                    }
                    return {
                        dataPoints: dataPointsGroup,
                        values: dataView.categorical.categories[0].values,
                        displayName: displayName,
                        categories: categories,
                        settings: settings
                    };
                }, DotPlot.prototype.init = function(options) {
                    var element = options.element;
                    this.behavior = new DotplotBehavior(), this.interactivityService = visuals.createInteractivityService(options.host), 
                    this.radius = DefaultRadius, this.strokeWidth = DefaultStrokeWidth, this.colors = options.style.colorPalette.dataColors, 
                    this.svg = d3.select(element.get(0)).append("svg").classed(this.dotPlotSelectors.svgPlotSelector["class"], !0).style("position", "absolute"), 
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                    var axisGraphicsContext = this.svg.append("g").classed(this.dotPlotSelectors.axisSelector["class"], !0);
                    this.dotPlot = this.svg.append("g").classed(this.dotPlotSelectors.plotSelector["class"], !0), 
                    this.xAxis = axisGraphicsContext.append("g").classed(this.dotPlotSelectors.xAxisSelector["class"], !0);
                }, DotPlot.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);
                        var dataView = this.dataView = options.dataViews[0], viewport = options.viewport;
                        if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1 || !dataView.categorical || !dataView.categorical.categories || !dataView.categorical.categories[0]) return void this.clearData();
                        var viewportIn = {
                            height: viewport.height - this.DefaultMargin.top,
                            width: viewport.width - this.DefaultMargin.left
                        };
                        this.svg.style({
                            height: PixelConverter.toString(viewport.height),
                            width: PixelConverter.toString(viewport.width)
                        });
                        var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, !1), data = DotPlot.converter(dataView, xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);
                        this.dotPlotDataView = data;
                        var dataPoints = data.dataPoints;
                        this.interactivityService && this.interactivityService.applySelectionStateToData(dataPoints), 
                        this.renderAxis(viewportIn.height - MaxXAxisHeight, xAxisProperties, data, this.durationAnimations), 
                        this.drawDotPlot(dataPoints, data.settings);
                        var dataLabelsSettings = data.settings.labelSettings;
                        if (dataLabelsSettings.show) {
                            var layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn);
                            visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);
                        } else visuals.dataLabelUtils.cleanDataLabels(this.svg);
                    }
                }, DotPlot.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "dataPoint":
                        this.enumerateDataPoints(enumeration, this.dataView);
                        break;

                      case "labels":
                        this.enumerateDataLabels(enumeration, this.dataView);
                        break;

                      case "categories":
                        this.enumerateCategories(enumeration, this.dataView);
                    }
                    return enumeration.complete();
                }, DotPlot.getObjectsFromDataView = function(dataView) {
                    return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                }, DotPlot.parseSettings = function(objects, defaultDotPlotSettings) {
                    var precision = this.getPrecision(objects, defaultDotPlotSettings);
                    return {
                        show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),
                        precision: precision,
                        fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),
                        displayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),
                        labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor)
                    };
                }, DotPlot.getCategorySettings = function(objects, defaultDotPlotSettings) {
                    return {
                        show: powerbi.DataViewObject.getValue(objects, samples.DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),
                        fontColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)
                    };
                }, DotPlot.getPrecision = function(objects, defaultDotPlotSettings) {
                    var precision = powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);
                    return MinPrecision >= precision ? MinPrecision : precision >= MaxPrecision ? MaxPrecision : precision;
                }, DotPlot.prototype.drawDotPlot = function(data, setting) {
                    var selection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data), hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    selection.enter().append("g").attr({
                        stroke: "black",
                        "stroke-width": this.strokeWidth
                    }).style("fill-opacity", function(item) {
                        return visuals.ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, !1);
                    }).classed(this.dotPlotSelectors.plotGroupSelector["class"], !0);
                    var circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function(d) {
                        return d.dataPoints;
                    });
                    circleSelection.enter().append("circle").classed(this.dotPlotSelectors.circleSeletor["class"], !0), 
                    circleSelection.attr({
                        cx: function(point) {
                            return point.x;
                        },
                        cy: function(point) {
                            return point.y;
                        },
                        r: this.radius,
                        fill: setting.defaultDataPointColor
                    }), this.renderTooltip(selection), circleSelection.exit().remove(), selection.exit().remove();
                    var interactivityService = this.interactivityService;
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(data);
                        var behaviorOptions = {
                            columns: selection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService
                        };
                        interactivityService.bind(data, this.behavior, behaviorOptions);
                    }
                }, DotPlot.prototype.getEnhanchedDotplotLayout = function(labelSettings, viewport) {
                    var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize), formatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, samples.DotPlotProperties.general.formatString),
                        precision: labelSettings.precision,
                        value: labelSettings.displayUnits
                    });
                    return {
                        labelText: function(d) {
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: formatter.format(d.label),
                                fontSize: labelSettings.fontSize,
                                maxWidth: viewport.width
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].x : 0;
                            },
                            y: function(d) {
                                return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].y - LabelMargin : 0;
                            }
                        },
                        filter: function(d) {
                            return null != d && null != d.label;
                        },
                        style: {
                            fill: labelSettings.categoryLabelColor,
                            "font-size": fontSizeInPx
                        }
                    };
                }, DotPlot.prototype.enumerateDataLabels = function(enumeration, dataView) {
                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0;
                    enumeration.pushInstance({
                        objectName: "labels",
                        displayName: "Labels",
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),
                            labelPrecision: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),
                            labelDisplayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)
                        }
                    });
                }, DotPlot.prototype.enumerateDataPoints = function(enumeration, dataView) {
                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0, dataPointColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        displayName: "Data Points",
                        selector: null,
                        properties: {
                            fill: {
                                solid: {
                                    color: dataPointColor
                                }
                            }
                        }
                    });
                }, DotPlot.prototype.enumerateCategories = function(enumeration, dataView) {
                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0, categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);
                    enumeration.pushInstance({
                        objectName: "categories",
                        displayName: "Categories",
                        selector: null,
                        properties: {
                            show: categoriesSettings.show,
                            fontSize: categoriesSettings.fontSize,
                            fontColor: categoriesSettings.fontColor
                        }
                    });
                }, DotPlot.prototype.clearData = function() {
                    this.dotPlot.selectAll("*").remove(), this.xAxis.selectAll("*").remove(), visuals.dataLabelUtils.cleanDataLabels(this.svg);
                }, DotPlot.prototype.renderTooltip = function(selection) {
                    visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                }, DotPlot.prototype.calculateAxes = function(viewportIn, textProperties, scrollbarVisible) {
                    var category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0 ? this.dataView.categorical.categories[0] : {
                        source: void 0,
                        values: [ visuals.valueFormatter.format(null) ],
                        identity: void 0
                    }, visualOptions = {
                        viewport: viewportIn,
                        margin: this.DefaultMargin,
                        forcedXDomain: this.dataView.categorical.categories[0].values,
                        forceMerge: !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        categoryAxisScaleType: this.scaleType,
                        valueAxisScaleType: null,
                        valueAxisDisplayUnits: 0,
                        categoryAxisDisplayUnits: 0,
                        trimOrdinalDataOnOverflow: !1
                    }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, visualOptions, category.source);
                    return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                    axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.DefaultMargin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                    axes;
                }, DotPlot.prototype.calculateAxesProperties = function(viewportIn, options, metaDataColumn) {
                    var xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: viewportIn.width,
                        dataDomain: options.forcedXDomain,
                        metaDataColumn: metaDataColumn,
                        formatString: visuals.valueFormatter.getFormatString(metaDataColumn, samples.DotPlotProperties.general.formatString),
                        outerPadding: 0,
                        isScalar: !1,
                        isVertical: !1,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !0,
                        getValueFn: function(index, type) {
                            return index;
                        },
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits
                    });
                    return xAxisProperties.axisLabel = "New Label", xAxisProperties;
                }, DotPlot.prototype.renderAxis = function(height, xAxisProperties, data, duration) {
                    this.xAxis.attr({
                        transform: visuals.SVGUtil.translate(0, height)
                    });
                    var xAxis = xAxisProperties.axis;
                    xAxis.orient("bottom"), this.xAxis.transition().duration(duration).call(xAxis);
                }, DotPlot.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Category"
                    }, {
                        name: "Values",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Values"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Values: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        "for": {
                                            "in": "Values"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: "Data colors",
                            properties: {
                                fill: {
                                    displayName: "Fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: "Data labels",
                            description: "Display data label options",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                showSeries: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: "Color",
                                    description: "Select color for data labels",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                labelDisplayUnits: {
                                    displayName: "Display units",
                                    description: "Select the units (millions, billions, etc.)",
                                    type: {
                                        formatting: {
                                            labelDisplayUnits: !0
                                        }
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelPrecision: {
                                    displayName: "Decimal places",
                                    description: "Select the number of decimal places to display",
                                    placeHolderText: "Auto",
                                    type: {
                                        numeric: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                showAll: {
                                    displayName: "Customize series",
                                    type: {
                                        bool: !0
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, DotPlot;
            }();
            samples.DotPlot = DotPlot;
            var DotplotBehavior = function() {
                function DotplotBehavior() {}
                return DotplotBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                    this.columns.on("click", function(d, i) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }), options.clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, DotplotBehavior.prototype.renderSelection = function(hasSelection) {
                    var hasHighlights = this.interactivityService.hasSelection();
                    this.columns.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                    });
                }, DotplotBehavior;
            }();
            samples.DotplotBehavior = DotplotBehavior;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var linkColorType, PixelConverter = jsCommon.PixelConverter;
            !function(linkColorType) {
                linkColorType.byWeight = "ByWeight", linkColorType.byLinkType = "ByLinkType", linkColorType.interactive = "Interactive", 
                linkColorType.type = powerbi.createEnumType([ {
                    value: linkColorType.byWeight,
                    displayName: "ByWeight"
                }, {
                    value: linkColorType.byLinkType,
                    displayName: "ByLinkType"
                }, {
                    value: linkColorType.interactive,
                    displayName: "Interactive"
                } ]);
            }(linkColorType || (linkColorType = {})), samples.forceProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    color: {
                        objectName: "labels",
                        propertyName: "color"
                    },
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    }
                },
                links: {
                    showArrow: {
                        objectName: "links",
                        propertyName: "showArrow"
                    },
                    showLabel: {
                        objectName: "links",
                        propertyName: "showLabel"
                    },
                    colorLink: {
                        objectName: "links",
                        propertyName: "colorLink"
                    },
                    thickenLink: {
                        objectName: "links",
                        propertyName: "thickenLink"
                    }
                },
                nodes: {
                    displayImage: {
                        objectName: "nodes",
                        propertyName: "displayImage"
                    },
                    defaultImage: {
                        objectName: "nodes",
                        propertyName: "defaultImage"
                    },
                    imageUrl: {
                        objectName: "nodes",
                        propertyName: "imageUrl"
                    },
                    imageExt: {
                        objectName: "nodes",
                        propertyName: "imageExt"
                    },
                    nameMaxLength: {
                        objectName: "nodes",
                        propertyName: "nameMaxLength"
                    },
                    highlightReachableLinks: {
                        objectName: "nodes",
                        propertyName: "highlightReachableLinks"
                    }
                },
                size: {
                    charge: {
                        objectName: "size",
                        propertyName: "charge"
                    }
                }
            };
            var ForceGraph = function() {
                function ForceGraph() {}
                return Object.defineProperty(ForceGraph.prototype, "margin", {
                    get: function() {
                        return this.marginValue || {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        };
                    },
                    set: function(value) {
                        this.marginValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(ForceGraph.prototype, "viewport", {
                    get: function() {
                        return this.viewportValue || {
                            width: 0,
                            height: 0
                        };
                    },
                    set: function(value) {
                        this.viewportValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(ForceGraph.prototype, "viewportIn", {
                    get: function() {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: !0,
                    configurable: !0
                }), ForceGraph.substractMargin = function(viewport, margin) {
                    return {
                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                    };
                }, ForceGraph.prototype.scale1to10 = function(d) {
                    var scale = d3.scale.linear().domain([ this.data.minFiles, this.data.maxFiles ]).rangeRound([ 1, 10 ]).clamp(!0);
                    return scale(d);
                }, ForceGraph.prototype.getLinkColor = function(d) {
                    switch (this.options.colorLink) {
                      case linkColorType.byWeight:
                        return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;

                      case linkColorType.byLinkType:
                        return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;
                    }
                    return this.options.defaultLinkColor;
                }, ForceGraph.prototype.getDefaultOptions = function() {
                    return {
                        showDataLabels: !0,
                        labelColor: visuals.dataLabelUtils.defaultLabelColor,
                        fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                        showArrow: !1,
                        showLabel: !1,
                        colorLink: linkColorType.interactive,
                        thickenLink: !0,
                        displayImage: !1,
                        defaultImage: "Home",
                        imageUrl: "",
                        imageExt: ".png",
                        nameMaxLength: 10,
                        highlightReachableLinks: !1,
                        charge: -15,
                        defaultLinkColor: "#bbb",
                        defaultLinkHighlightColor: "#f00",
                        defaultLinkThickness: "1.5px"
                    };
                }, ForceGraph.prototype.updateOptions = function(objects) {
                    this.options.showDataLabels = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.show, this.options.showDataLabels), 
                    this.options.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.forceProps.labels.color, this.options.labelColor), 
                    this.options.fontSize = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.fontSize, this.options.fontSize), 
                    this.options.showArrow = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showArrow, this.options.showArrow), 
                    this.options.showLabel = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showLabel, this.options.showLabel), 
                    this.options.colorLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.colorLink, this.options.colorLink), 
                    this.options.thickenLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.thickenLink, this.options.thickenLink), 
                    this.options.displayImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.displayImage, this.options.displayImage), 
                    this.options.defaultImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.defaultImage, this.options.defaultImage), 
                    this.options.imageUrl = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageUrl, this.options.imageUrl), 
                    this.options.imageExt = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageExt, this.options.imageExt), 
                    this.options.nameMaxLength = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.nameMaxLength, this.options.nameMaxLength), 
                    this.options.highlightReachableLinks = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks), 
                    this.options.charge = powerbi.DataViewObjects.getValue(objects, samples.forceProps.size.charge, this.options.charge), 
                    (this.options.charge >= 0 || this.options.charge < -100) && (this.options.charge = this.getDefaultOptions().charge);
                }, ForceGraph.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "labels":
                        this.enumerateLabels(enumeration);
                        break;

                      case "links":
                        this.enumerateLinks(enumeration);
                        break;

                      case "nodes":
                        this.enumerateNodes(enumeration);
                        break;

                      case "size":
                        this.enumerateSize(enumeration);
                    }
                    return enumeration.complete();
                }, ForceGraph.prototype.enumerateLabels = function(enumeration) {
                    var labels, options;
                    this.options && this.options && (options = this.options, labels = {
                        objectName: "labels",
                        displayName: "Labels",
                        selector: null,
                        properties: {
                            show: options.showDataLabels,
                            fontSize: options.fontSize,
                            color: options.labelColor
                        }
                    }, enumeration.pushInstance(labels));
                }, ForceGraph.prototype.enumerateLinks = function(enumeration) {
                    var links, options;
                    this.options && (options = this.options, links = {
                        objectName: "links",
                        displayName: "Links",
                        selector: null,
                        properties: {
                            showArrow: options.showArrow,
                            colorLink: options.colorLink,
                            showLabel: options.showLabel,
                            thickenLink: options.thickenLink
                        }
                    }, enumeration.pushInstance(links));
                }, ForceGraph.prototype.enumerateNodes = function(enumeration) {
                    var nodes, options;
                    this.options && (options = this.options, nodes = {
                        objectName: "nodes",
                        displayName: "Nodes",
                        selector: null,
                        properties: {
                            displayImage: options.displayImage,
                            defaultImage: options.defaultImage,
                            imageUrl: options.imageUrl,
                            imageExt: options.imageExt,
                            nameMaxLength: options.nameMaxLength,
                            highlightReachableLinks: options.highlightReachableLinks
                        }
                    }, enumeration.pushInstance(nodes));
                }, ForceGraph.prototype.enumerateSize = function(enumeration) {
                    var size, options;
                    this.options && (options = this.options, size = {
                        objectName: "size",
                        displayName: "Size",
                        selector: null,
                        properties: {
                            charge: options.charge
                        }
                    }, enumeration.pushInstance(size));
                }, ForceGraph.converter = function(dataView, colors) {
                    var rows, categorical = dataView.categorical, nodes = {}, minFiles = Number.MAX_VALUE, maxFiles = 0, linkedByName = {}, links = [], linkDataPoints = {}, linkTypeCount = 0, sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1, tooltipInfo = [], formatStringProp = samples.forceProps.general.formatString;
                    if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) for (var metadataColumns = dataView.metadata.columns, i = 0; i < metadataColumns.length; i++) {
                        var col = metadataColumns[i];
                        col.roles && (col.roles.Source ? sourceCol = i : col.roles.Target ? targetCol = i : col.roles.Weight ? weightCol = i : col.roles.LinkType ? linkTypeCol = i : col.roles.SourceType ? sourceTypeCol = i : col.roles.TargetType && (targetTypeCol = i));
                    }
                    if (dataView && dataView.table && (rows = dataView.table.rows), 0 > sourceCol || 0 > targetCol) return {
                        nodes: {},
                        links: [],
                        minFiles: 0,
                        maxFiles: 0,
                        linkedByName: {},
                        linkTypes: {}
                    };
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp), categoryTargetFormatString = visuals.valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp), weightFormatString = visuals.valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, !0);
                    return rows.forEach(function(item) {
                        linkedByName[item[sourceCol] + "," + item[targetCol]] = 1;
                        var source = nodes[item[sourceCol]] || (nodes[item[sourceCol]] = {
                            name: item[sourceCol],
                            image: sourceTypeCol > 0 ? item[sourceTypeCol] : "",
                            adj: {}
                        }), target = nodes[item[targetCol]] || (nodes[item[targetCol]] = {
                            name: item[targetCol],
                            image: targetTypeCol > 0 ? item[targetTypeCol] : "",
                            adj: {}
                        });
                        source.adj[target.name] = 1, target.adj[source.name] = 1, tooltipInfo = [ {
                            displayName: dataView.metadata.columns[0].displayName,
                            value: visuals.valueFormatter.format(source.name, categorySourceFormatString)
                        }, {
                            displayName: dataView.metadata.columns[1].displayName,
                            value: visuals.valueFormatter.format(target.name, categoryTargetFormatString)
                        } ], weightCol > 0 && tooltipInfo.push({
                            displayName: dataView.metadata.columns[2].displayName,
                            value: visuals.valueFormatter.format(item[weightCol], weightFormatString)
                        });
                        var link = {
                            source: source,
                            target: target,
                            filecount: weightCol > 0 ? item[weightCol] : 0,
                            type: linkTypeCol > 0 ? item[linkTypeCol] : "",
                            tooltipInfo: tooltipInfo
                        };
                        linkTypeCol > 0 && (linkDataPoints[item[linkTypeCol]] || (linkDataPoints[item[linkTypeCol]] = {
                            label: item[linkTypeCol],
                            color: colors.getColorByIndex(linkTypeCount++).value
                        })), link.filecount < minFiles && (minFiles = link.filecount), link.filecount > maxFiles && (maxFiles = link.filecount), 
                        links.push(link);
                    }), {
                        nodes: nodes,
                        links: links,
                        minFiles: minFiles,
                        maxFiles: maxFiles,
                        linkedByName: linkedByName,
                        linkTypes: linkDataPoints
                    };
                }, ForceGraph.prototype.init = function(options) {
                    this.root = d3.select(options.element.get(0)), this.forceLayout = d3.layout.force(), 
                    this.colors = options.style.colorPalette.dataColors, this.options = this.getDefaultOptions();
                }, ForceGraph.prototype.update = function(options) {
                    var _this = this;
                    if (options.dataViews && !(options.dataViews.length < 1) && (this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors), 
                    this.data)) {
                        options.dataViews[0].metadata && options.dataViews[0].metadata.objects && this.updateOptions(options.dataViews[0].metadata.objects), 
                        this.viewport = options.viewport;
                        var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
                        this.root.selectAll("svg").remove();
                        var svg = this.root.append("svg").attr("width", this.viewport.width).attr("height", this.viewport.height).classed(ForceGraph.VisualClassName, !0);
                        this.forceLayout.gravity(100 * k).links(this.data.links).size([ this.viewport.width, this.viewport.height ]).linkDistance(100).charge(this.options.charge / k).on("tick", this.tick()), 
                        this.updateNodes(), this.forceLayout.start(), this.paths = svg.selectAll(".link").data(this.forceLayout.links()).enter().append("path").attr("class", "link").attr("id", function(d, i) {
                            return "linkid_" + i;
                        }).attr("stroke-width", function(d) {
                            return _this.options.thickenLink ? _this.scale1to10(d.filecount) : _this.options.defaultLinkThickness;
                        }).style("stroke", function(d) {
                            return _this.getLinkColor(d);
                        }).style("fill", function(d) {
                            return _this.options.showArrow ? _this.getLinkColor(d) : void 0;
                        }).on("mouseover", this.fadePath(.3, this.options.defaultLinkHighlightColor)).on("mouseout", this.fadePath(1, this.options.defaultLinkColor)), 
                        visuals.TooltipManager.addTooltip(this.paths, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), this.options.showLabel && svg.selectAll(".linklabelholder").data(this.forceLayout.links()).enter().append("g").attr("class", "linklabelholder").append("text").attr("class", "linklabel").attr("y", "-12").attr("text-anchor", "middle").style("fill", "#000").append("textPath").attr("xlink:href", function(d, i) {
                            return "#linkid_" + i;
                        }).attr("startOffset", "25%").text(function(d) {
                            return _this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount;
                        }), this.nodes = svg.selectAll(".node").data(this.forceLayout.nodes()).enter().append("g").attr("class", "node").call(this.forceLayout.drag).on("mouseover", this.fadeNode(.3, this.options.defaultLinkHighlightColor)).on("mouseout", this.fadeNode(1, this.options.defaultLinkColor)).on("mousedown", function() {
                            return d3.event.stopPropagation();
                        }).attr("drag-resize-disabled", !0), this.options.displayImage ? this.nodes.append("image").attr("xlink:href", function(d) {
                            return d.image && "" !== d.image ? _this.options.imageUrl + d.image + _this.options.imageExt : _this.options.defaultImage && "" !== _this.options.defaultImage ? _this.options.imageUrl + _this.options.defaultImage + _this.options.imageExt : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=";
                        }).attr("x", "-12px").attr("y", "-12px").attr("width", "24px").attr("height", "24px") : this.nodes.append("circle").attr("r", function(d) {
                            return d.weight < 5 ? 5 : d.weight;
                        }), this.options.showDataLabels && this.nodes.append("text").attr({
                            x: 12,
                            dy: ".35em"
                        }).style({
                            fill: this.options.labelColor,
                            "font-size": PixelConverter.fromPoint(this.options.fontSize)
                        }).text(function(d) {
                            return d.name ? d.name.length > _this.options.nameMaxLength ? d.name.substr(0, _this.options.nameMaxLength) : d.name : "";
                        });
                    }
                }, ForceGraph.prototype.updateNodes = function() {
                    var oldNodes = this.forceLayout.nodes();
                    this.forceLayout.nodes(d3.values(this.data.nodes)), this.forceLayout.nodes().forEach(function(node, i) {
                        oldNodes[i] && (node.x = oldNodes[i].x, node.y = oldNodes[i].y, node.px = oldNodes[i].px, 
                        node.py = oldNodes[i].py, node.weight = oldNodes[i].weight);
                    });
                }, ForceGraph.prototype.tick = function() {
                    var _this = this, viewport = this.viewportIn, maxWidth = 20 * viewport.width, maxHeight = 20 * viewport.height, limitX = function(x) {
                        return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x));
                    }, limitY = function(y) {
                        return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y));
                    }, getPath = this.options.showArrow ? function(d) {
                        d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                        d.target.y = limitY(d.target.y);
                        var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
                        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
                    } : function(d) {
                        d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                        d.target.y = limitY(d.target.y);
                        var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                    };
                    return function() {
                        _this.paths.each(function() {
                            this.parentNode.insertBefore(this, this);
                        }), _this.paths.attr("d", getPath), _this.nodes.attr("transform", function(d) {
                            return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")";
                        });
                    };
                }, ForceGraph.prototype.fadePath = function(opacity, highlight) {
                    var _this = this;
                    if (this.options.colorLink === linkColorType.interactive) return function(d) {
                        _this.paths.style("stroke-opacity", function(o) {
                            return o.source === d.source && o.target === d.target ? 1 : opacity;
                        }), _this.paths.style("stroke", function(o) {
                            return o.source === d.source && o.target === d.target ? highlight : _this.options.defaultLinkColor;
                        });
                    };
                }, ForceGraph.prototype.isReachable = function(a, b) {
                    if (a.name === b.name) return !0;
                    if (this.data.linkedByName[a.name + "," + b.name]) return !0;
                    var visited = {};
                    for (var name_1 in this.data.nodes) visited[name_1] = !1;
                    visited[a.name] = !0;
                    var stack = [];
                    for (stack.push(a.name); stack.length > 0; ) {
                        var cur = stack.pop(), node = this.data.nodes[cur];
                        for (var nb in node.adj) {
                            if (nb === b.name) return !0;
                            visited[nb] || (visited[nb] = !0, stack.push(nb));
                        }
                    }
                    return !1;
                }, ForceGraph.prototype.fadeNode = function(opacity, highlight) {
                    var _this = this;
                    if (this.options.colorLink === linkColorType.interactive) {
                        var isConnected = function(a, b) {
                            return _this.data.linkedByName[a.name + "," + b.name] || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name;
                        };
                        return function(d) {
                            var that = _this;
                            _this.nodes.style("stroke-opacity", function(o) {
                                var thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;
                                return this.setAttribute("fill-opacity", thisOpacity), thisOpacity;
                            }), _this.paths.style("stroke-opacity", function(o) {
                                return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) : o.source === d || o.target === d) ? 1 : opacity;
                            }), _this.paths.style("stroke", function(o) {
                                return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) : o.source === d || o.target === d) ? highlight : _this.options.defaultLinkColor;
                            });
                        };
                    }
                }, ForceGraph.prototype.destroy = function() {
                    this.root = null;
                }, ForceGraph.VisualClassName = "forceGraph", ForceGraph.capabilities = {
                    dataRoles: [ {
                        name: "Source",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Source"
                    }, {
                        name: "Target",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Target"
                    }, {
                        name: "Weight",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Weight"
                    }, {
                        name: "LinkType",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "LinkType",
                        description: "Links can be colored by link types"
                    }, {
                        name: "SourceType",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "SourceType",
                        description: "Source type represents the image name for source entities"
                    }, {
                        name: "TargetType",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "TargetType",
                        description: "Target type represents the image name for target entities"
                    } ],
                    objects: {
                        general: {
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: "Data labels",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: {
                                    displayName: "Fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        links: {
                            displayName: "Links",
                            properties: {
                                showArrow: {
                                    type: {
                                        bool: !0
                                    },
                                    displayName: "Arrow"
                                },
                                showLabel: {
                                    type: {
                                        bool: !0
                                    },
                                    displayName: "Label",
                                    description: "Displays weight on links"
                                },
                                colorLink: {
                                    type: {
                                        enumeration: linkColorType.type
                                    },
                                    displayName: "Color"
                                },
                                thickenLink: {
                                    type: {
                                        bool: !0
                                    },
                                    displayName: "Thickness",
                                    description: "Thickenss of links represents weight"
                                }
                            }
                        },
                        nodes: {
                            displayName: "Nodes",
                            properties: {
                                displayImage: {
                                    type: {
                                        bool: !0
                                    },
                                    displayName: "Image",
                                    description: "Images are loaded from image url + source or target type + image extension"
                                },
                                defaultImage: {
                                    type: {
                                        text: !0
                                    },
                                    displayName: "Default image"
                                },
                                imageUrl: {
                                    type: {
                                        text: !0
                                    },
                                    displayName: "Image url"
                                },
                                imageExt: {
                                    type: {
                                        text: !0
                                    },
                                    displayName: "Image extension"
                                },
                                nameMaxLength: {
                                    type: {
                                        numeric: !0
                                    },
                                    displayName: "Max name length",
                                    description: "Max length of the name of entities displayed"
                                },
                                highlightReachableLinks: {
                                    type: {
                                        bool: !0
                                    },
                                    displayName: "Highlight all reachable links",
                                    description: "In interactive mode, whether a node's all reachable links will be highlighted"
                                }
                            }
                        },
                        size: {
                            displayName: "Size",
                            properties: {
                                charge: {
                                    type: {
                                        numeric: !0
                                    },
                                    displayName: "Charge",
                                    description: "The larger the negative charge the more apart the entities, must be negative but greater than -100"
                                }
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Source: {
                                max: 1
                            },
                            Target: {
                                max: 1
                            },
                            Weight: {
                                max: 1
                            },
                            LinkType: {
                                max: 1
                            },
                            SourceType: {
                                max: 1
                            },
                            TargetType: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Source"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Target"
                                    }
                                }, {
                                    bind: {
                                        to: "Weight"
                                    }
                                }, {
                                    bind: {
                                        to: "LinkType"
                                    }
                                }, {
                                    bind: {
                                        to: "SourceType"
                                    }
                                }, {
                                    bind: {
                                        to: "TargetType"
                                    }
                                } ]
                            },
                            rowCount: {
                                preferred: {
                                    min: 1
                                }
                            }
                        }
                    } ],
                    suppressDefaultTitle: !0
                }, ForceGraph;
            }();
            samples.ForceGraph = ForceGraph;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var SelectionManager = visuals.utility.SelectionManager, PixelConverter = jsCommon.PixelConverter, PercentFormat = "0.00 %;-0.00 %;0.00 %", MillisecondsInADay = 864e5, MillisecondsInWeek = 6048e5, MillisecondsInAMonth = 2629746e3, MillisecondsInAYear = 31556952e3;
            samples.DefaultDateType = "Week";
            var dateTypeSelector, ChartLineHeight = 40, PaddingTasks = 5;
            !function(dateTypeSelector) {
                dateTypeSelector.day = "Day", dateTypeSelector.week = "Week", dateTypeSelector.month = "Month", 
                dateTypeSelector.year = "Year", dateTypeSelector.type = powerbi.createEnumType([ {
                    value: dateTypeSelector.day,
                    displayName: "Day"
                }, {
                    value: dateTypeSelector.week,
                    displayName: "Week"
                }, {
                    value: dateTypeSelector.month,
                    displayName: "Month"
                }, {
                    value: dateTypeSelector.year,
                    displayName: "Year"
                } ]);
            }(dateTypeSelector = samples.dateTypeSelector || (samples.dateTypeSelector = {})), 
            samples.GanttChartProps = {
                legend: {
                    show: {
                        objectName: "legend",
                        propertyName: "show"
                    },
                    position: {
                        objectName: "legend",
                        propertyName: "position"
                    },
                    showTitle: {
                        objectName: "legend",
                        propertyName: "showTitle"
                    },
                    titleText: {
                        objectName: "legend",
                        propertyName: "titleText"
                    },
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    },
                    fontSize: {
                        objectName: "legend",
                        propertyName: "fontSize"
                    }
                },
                taskCompletion: {
                    fill: {
                        objectName: "taskCompletion",
                        propertyName: "fill"
                    }
                },
                dataPoint: {
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                taskLabels: {
                    show: {
                        objectName: "taskLabels",
                        propertyName: "show"
                    },
                    fill: {
                        objectName: "taskLabels",
                        propertyName: "fill"
                    },
                    fontSize: {
                        objectName: "taskLabels",
                        propertyName: "fontSize"
                    },
                    width: {
                        objectName: "taskLabels",
                        propertyName: "width"
                    }
                },
                taskResource: {
                    show: {
                        objectName: "taskResource",
                        propertyName: "show"
                    },
                    fill: {
                        objectName: "taskResource",
                        propertyName: "fill"
                    },
                    fontSize: {
                        objectName: "taskResource",
                        propertyName: "fontSize"
                    }
                },
                ganttDateType: {
                    type: {
                        objectName: "ganttDateType",
                        propertyName: "type"
                    }
                }
            };
            var Selectors;
            !function(Selectors) {
                var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.ClassName = CreateClassAndSelector("gantt"), Selectors.Chart = CreateClassAndSelector("chart"), 
                Selectors.ChartLine = CreateClassAndSelector("chart-line"), Selectors.Body = CreateClassAndSelector("gantt-body"), 
                Selectors.AxisGroup = CreateClassAndSelector("axis"), Selectors.Domain = CreateClassAndSelector("domain"), 
                Selectors.AxisTick = CreateClassAndSelector("tick"), Selectors.Tasks = CreateClassAndSelector("tasks"), 
                Selectors.SingleTask = CreateClassAndSelector("task"), Selectors.TaskRect = CreateClassAndSelector("task-rect"), 
                Selectors.TaskProgress = CreateClassAndSelector("task-progress"), Selectors.TaskResource = CreateClassAndSelector("task-resource"), 
                Selectors.SingleMilestone = CreateClassAndSelector("milestone"), Selectors.TaskLabels = CreateClassAndSelector("task-labels"), 
                Selectors.TaskLines = CreateClassAndSelector("task-lines"), Selectors.SingleTaskLine = CreateClassAndSelector("task-line"), 
                Selectors.Label = CreateClassAndSelector("label"), Selectors.LegendItems = CreateClassAndSelector("legendItem"), 
                Selectors.LegendTitle = CreateClassAndSelector("legendTitle");
            }(Selectors || (Selectors = {}));
            var Gantt = function() {
                function Gantt() {
                    this.textProperties = {
                        fontFamily: "wf_segoe-ui_normal",
                        fontSize: jsCommon.PixelConverter.toString(9)
                    }, this.margin = {
                        top: 50,
                        right: 40,
                        bottom: 40,
                        left: 10
                    };
                }
                return Gantt.getMaxTaskOpacity = function() {
                    return Gantt.DefaultValues.MaxTaskOpacity;
                }, Gantt.getMinTaskOpacity = function() {
                    return Gantt.DefaultValues.MinTaskOpacity;
                }, Gantt.prototype.init = function(options) {
                    var element = options.element;
                    this.style = options.style, this.body = d3.select(element.get(0)), this.hostServices = options.host, 
                    this.selectionManager = new SelectionManager({
                        hostServices: options.host
                    }), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                    this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                    this.createViewport(element), this.updateChartSize(options.viewport), this.behavior = new GanttChartBehavior(), 
                    this.colors = options.style.colorPalette.dataColors, this.data = {
                        legendData: null,
                        series: null,
                        showLegend: null
                    };
                }, Gantt.prototype.createViewport = function(element) {
                    this.ganttDiv = this.body.append("div").classed(Selectors.Body["class"], !0), this.ganttSvg = this.ganttDiv.append("svg").classed(Selectors.ClassName["class"], !0), 
                    this.clearCatcher = visuals.appendClearCatcher(this.ganttSvg), this.axisGroup = this.ganttSvg.append("g").classed(Selectors.AxisGroup["class"], !0), 
                    this.lineGroup = this.ganttSvg.append("g").classed(Selectors.TaskLines["class"], !0), 
                    this.chartGroup = this.ganttSvg.append("g").classed(Selectors.Chart["class"], !0), 
                    this.taskGroup = this.chartGroup.append("g").classed(Selectors.Tasks["class"], !0), 
                    this.legend = visuals.createLegend(element.children(Selectors.Body.selector), this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top);
                }, Gantt.prototype.clearViewport = function() {
                    this.body.selectAll(Selectors.LegendItems.selector).remove(), this.body.selectAll(Selectors.LegendTitle.selector).remove(), 
                    this.axisGroup.selectAll(Selectors.AxisTick.selector).remove(), this.axisGroup.selectAll(Selectors.Domain.selector).remove(), 
                    this.lineGroup.selectAll("*").remove(), this.chartGroup.selectAll(Selectors.ChartLine.selector).remove(), 
                    this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();
                }, Gantt.prototype.updateChartSize = function(viewport) {
                    this.ganttDiv.style({
                        height: PixelConverter.toString(viewport.height),
                        width: PixelConverter.toString(viewport.width)
                    });
                }, Gantt.prototype.createSeries = function(objects, tasks) {
                    var colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill), taskGroup = _.groupBy(tasks, function(t) {
                        return t.taskType;
                    }), taskTypes = Gantt.getAllTasksTypes(this.dataView), series = _.map(taskTypes.types, function(type) {
                        return {
                            tasks: taskGroup[type],
                            fill: colorHelper.getColorForMeasure(objects, type),
                            name: type,
                            identity: visuals.SelectionId.createWithMeasure(type),
                            selected: !1
                        };
                    });
                    return series;
                }, Gantt.converter = function(dataView, colorPalette) {
                    var taskLabelsShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.show, !0), taskLabelsColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor), taskLabelsFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize), taskLabelsWidth = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.width, taskLabelsShow ? Gantt.DefaultValues.TaskLabelWidth : 0), taskProgressColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor), taskResourceColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor), taskResourceFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize), taskResourceShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.show, !0), dateType = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType), taskTypes = Gantt.getAllTasksTypes(dataView), colorHelper = new visuals.ColorHelper(colorPalette, samples.GanttChartProps.dataPoint.fill), legendData = {
                        fontSize: Gantt.DefaultValues.LegendFontSize,
                        dataPoints: [],
                        title: taskTypes.typeName
                    };
                    legendData.dataPoints = _.map(taskTypes.types, function(type) {
                        return {
                            label: type,
                            color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),
                            icon: visuals.LegendIcon.Circle,
                            selected: !1,
                            identity: visuals.SelectionId.createWithMeasure(type)
                        };
                    });
                    var settings = {
                        taskLabelsShow: taskLabelsShow,
                        taskLabelsColor: taskLabelsColor,
                        taskLabelsFontSize: taskLabelsFontSize,
                        taskLabelsWidth: taskLabelsWidth,
                        taskProgressColor: taskProgressColor,
                        taskResourceShow: taskResourceShow,
                        taskResourceColor: taskResourceColor,
                        taskResourceFontSize: taskResourceFontSize,
                        legendData: legendData,
                        taskTypes: taskTypes,
                        dateType: dateType
                    };
                    return settings;
                }, Gantt.prototype.parseSettings = function(dataView) {
                    if (!dataView || !dataView.metadata || !dataView.metadata.columns) return null;
                    for (var dateFormat = "d", numberFormat = "#", _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                        var dvColumn = _a[_i];
                        if (dataView.categorical.categories) for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {
                            var dvCategory = _c[_b];
                            this.hasRole(dvCategory.source, "StartDate") && (dateFormat = dvColumn.format);
                        }
                    }
                    return {
                        startDateFormatter: visuals.valueFormatter.create({
                            format: dateFormat
                        }),
                        durationFormatter: visuals.valueFormatter.create({
                            format: numberFormat
                        }),
                        completionFormatter: visuals.valueFormatter.create({
                            format: PercentFormat,
                            value: 1,
                            allowFormatBeautification: !0
                        })
                    };
                }, Gantt.prototype.isValidDate = function(date) {
                    return "[object Date]" !== Object.prototype.toString.call(date) ? !1 : !isNaN(date.getTime());
                }, Gantt.prototype.convertToDecimal = function(number) {
                    return number >= 0 && 1 >= number ? number : number / 100;
                }, Gantt.prototype.createTasks = function(dataView, formatters) {
                    var _this = this, columnSource = dataView.table.columns, data = dataView.table.rows, categories = dataView.categorical.categories[0], colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill);
                    return data.map(function(child, index) {
                        var dateString = _this.getTaskProperty(columnSource, child, "StartDate");
                        dateString = _this.isValidDate(dateString) ? dateString : new Date(Date.now());
                        var duration = _this.getTaskProperty(columnSource, child, "Duration"), completionValue = _this.getTaskProperty(columnSource, child, "Completion"), completion = _this.convertToDecimal(completionValue);
                        completion = 1 >= completion ? completion : 1;
                        var taskType = _this.getTaskProperty(columnSource, child, "Legend"), tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType), task = {
                            id: index,
                            name: _this.getTaskProperty(columnSource, child, "Task"),
                            start: dateString ? dateString : new Date(Date.now()),
                            duration: duration > 0 ? duration : 1,
                            end: null,
                            completion: completion > 0 ? completion : 0,
                            resource: _this.getTaskProperty(columnSource, child, "Resource"),
                            taskType: taskType,
                            color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,
                            tooltipInfo: null,
                            description: "",
                            identity: visuals.SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),
                            selected: !1
                        };
                        return task.end = d3.time.day.offset(task.start, task.duration), task.tooltipInfo = _this.getTooltipInfo(task, formatters), 
                        task;
                    });
                }, Gantt.getAllTasksTypes = function(dataView) {
                    var taskTypes, types = [], groupName = "", data = dataView.table.rows, index = _.findIndex(dataView.table.columns, function(col) {
                        return col.roles.hasOwnProperty("Legend");
                    });
                    return -1 !== index && (groupName = dataView.table.columns[index].displayName, types = _.unique(data, function(d) {
                        return d[index];
                    }).map(function(d) {
                        return d[index];
                    })), taskTypes = {
                        typeName: groupName,
                        types: types
                    };
                }, Gantt.prototype.getTooltipInfo = function(task, formatters, timeInterval) {
                    void 0 === timeInterval && (timeInterval = "Days");
                    var tooltipDataArray = [];
                    return task.taskType && tooltipDataArray.push({
                        displayName: Gantt.capabilities.dataRoles[0].name,
                        value: task.taskType
                    }), tooltipDataArray.push({
                        displayName: Gantt.capabilities.dataRoles[1].name,
                        value: task.name
                    }), isNaN(task.start.getDate()) || tooltipDataArray.push({
                        displayName: Gantt.capabilities.dataRoles[2].name,
                        value: formatters.startDateFormatter.format(task.start.toLocaleDateString())
                    }), tooltipDataArray.push({
                        displayName: Gantt.capabilities.dataRoles[3].name,
                        value: formatters.durationFormatter.format(task.duration) + " " + timeInterval
                    }), tooltipDataArray.push({
                        displayName: Gantt.capabilities.dataRoles[4].name,
                        value: formatters.completionFormatter.format(task.completion)
                    }), task.resource && tooltipDataArray.push({
                        displayName: Gantt.capabilities.dataRoles[5].name,
                        value: task.resource
                    }), tooltipDataArray;
                }, Gantt.prototype.getTaskProperty = function(columnSource, child, propertyName) {
                    if (!(child && columnSource && columnSource.length > 0 && columnSource[0].roles)) return null;
                    var index = columnSource.indexOf(columnSource.filter(function(x) {
                        return x.roles[propertyName];
                    })[0]);
                    return -1 !== index ? child[index] : null;
                }, Gantt.prototype.hasRole = function(column, name) {
                    var roles = column.roles;
                    return roles && roles[name];
                }, Gantt.prototype.isChartHasTask = function(dataView) {
                    if (dataView.table && dataView.table.columns) for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {
                        var column = _a[_i];
                        if (this.hasRole(column, "Task")) return !0;
                    }
                    return !1;
                }, Gantt.prototype.renderLegend = function(legendData) {
                    if (legendData) {
                        if (this.legendObjectProperties) {
                            visuals.LegendData.update(legendData, this.legendObjectProperties);
                            var position;
                            position = this.legendObjectProperties[visuals.legendProps.position], position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                        var viewport = this.viewport;
                        this.legend.drawLegend(legendData, {
                            height: viewport.height,
                            width: viewport.width
                        }), visuals.Legend.positionChartArea(this.ganttSvg, this.legend);
                    }
                }, Gantt.prototype.parseLegendProperties = function(dataView) {
                    return dataView && dataView.metadata ? void (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})) : void (this.legendObjectProperties = {});
                }, Gantt.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        var dataView = options.dataViews[0];
                        if (!this.isChartHasTask(dataView) || 0 === options.dataViews[0].table.rows.length) return void this.clearViewport();
                        this.dataView = dataView;
                        var viewport = options.viewport;
                        this.viewport = viewport, this.updateChartSize(viewport);
                        var viewModel = Gantt.converter(dataView, this.colors), formatters = this.parseSettings(dataView), tasks = this.createTasks(dataView, formatters);
                        if (this.parseLegendProperties(dataView), this.renderLegend(viewModel.legendData), 
                        this.data.series = this.createSeries(dataView.metadata.objects, tasks), this.viewModel = viewModel, 
                        this.interactivityService && (this.interactivityService.applySelectionStateToData(tasks), 
                        this.interactivityService.applySelectionStateToData(this.data.series)), tasks.length > 0) {
                            var tasksSortedByStartDate = _.sortBy(tasks, function(t) {
                                return t.start;
                            }), tasksSortedByEndDate = _.sortBy(tasks, function(t) {
                                return t.end;
                            }), dateTypeMilliseconds = this.getDateType(), startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);
                            ticks = 0 === ticks || 1 === ticks ? 2 : ticks;
                            var axisLength = 50 * ticks;
                            this.ganttSvg.attr({
                                height: PixelConverter.toString(tasks.length * ChartLineHeight + this.margin.top),
                                width: PixelConverter.toString(this.margin.left + this.viewModel.taskLabelsWidth + axisLength + Gantt.DefaultValues.ResourceWidth)
                            });
                            var viewportIn = {
                                height: viewport.height,
                                width: axisLength
                            }, xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, !1);
                            if (this.timeScale = xAxisProperties.scale, this.renderAxis(xAxisProperties, 200), 
                            this.renderTasks(tasks), this.createMilestoneLine(tasks), this.updateTaskLabels(tasks, viewModel.taskLabelsWidth), 
                            this.updateElementsPositions(viewport, this.margin), this.interactivityService) {
                                var behaviorOptions = {
                                    clearCatcher: this.clearCatcher,
                                    taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),
                                    legendSelection: this.body.selectAll(Selectors.LegendItems.selector),
                                    interactivityService: this.interactivityService
                                };
                                this.interactivityService.bind(tasks, this.behavior, behaviorOptions);
                            }
                        }
                    }
                }, Gantt.prototype.getDateType = function() {
                    var milliSeconds = MillisecondsInWeek;
                    switch (this.viewModel.dateType) {
                      case "Day":
                        milliSeconds = MillisecondsInADay;
                        break;

                      case "Week":
                        milliSeconds = MillisecondsInWeek;
                        break;

                      case "Month":
                        milliSeconds = MillisecondsInAMonth;
                        break;

                      case "Year":
                        milliSeconds = MillisecondsInAYear;
                    }
                    return milliSeconds;
                }, Gantt.prototype.calculateAxes = function(viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {
                    var dataTypeDatetime = powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Date), category = {
                        displayName: "StartDate",
                        queryName: "StartDate",
                        type: dataTypeDatetime,
                        index: 0
                    }, visualOptions = {
                        viewport: viewportIn,
                        margin: this.margin,
                        forcedXDomain: [ startDate, endDate ],
                        forceMerge: !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        categoryAxisScaleType: powerbi.visuals.axisScale.linear,
                        valueAxisScaleType: null,
                        valueAxisDisplayUnits: 0,
                        categoryAxisDisplayUnits: 0,
                        trimOrdinalDataOnOverflow: !1,
                        forcedTickCount: ticksCount
                    }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);
                    return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                    axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                    axes;
                }, Gantt.prototype.calculateAxesProperties = function(viewportIn, options, axisLength, metaDataColumn) {
                    var xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: viewportIn.width,
                        dataDomain: options.forcedXDomain,
                        metaDataColumn: metaDataColumn,
                        formatString: Gantt.DefaultValues.ganttFormatString,
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !1,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !0,
                        getValueFn: function(index, type) {
                            return visuals.valueFormatter.format(new Date(index), Gantt.DefaultValues.ganttFormatString);
                        },
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits
                    });
                    return xAxisProperties.axisLabel = metaDataColumn.displayName, xAxisProperties;
                }, Gantt.prototype.renderAxis = function(xAxisProperties, duration) {
                    var xAxis = xAxisProperties.axis;
                    xAxis.orient("bottom"), this.axisGroup.transition().duration(duration).call(xAxis);
                }, Gantt.prototype.updateTaskLabels = function(tasks, width) {
                    var axisLabel, _this = this, taskLineCoordinateX = 15, taskLabelsShow = this.viewModel ? this.viewModel.taskLabelsShow : !0, taskLabelsColor = this.viewModel ? this.viewModel.taskLabelsColor : Gantt.DefaultValues.TaskLabelColor, taskLabelsFontSize = this.viewModel ? this.viewModel.taskLabelsFontSize : Gantt.DefaultValues.LabelFontSize;
                    taskLabelsShow ? (axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks), 
                    axisLabel.enter().append("text").classed(Selectors.Label["class"], !0), axisLabel.attr({
                        x: taskLineCoordinateX,
                        y: function(task, i) {
                            return _this.getTaskLabelCoordinateY(task.id);
                        },
                        fill: taskLabelsColor,
                        "stroke-width": 1
                    }).style("font-size", PixelConverter.fromPoint(taskLabelsFontSize)).text(function(task) {
                        return task.name;
                    }), axisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width - 20, powerbi.TextMeasurementService.svgEllipsis), 
                    axisLabel.append("title").text(function(task) {
                        return task.name;
                    }), axisLabel.exit().remove()) : this.lineGroup.selectAll(Selectors.Label.selector).remove();
                }, Gantt.prototype.renderTasks = function(tasks) {
                    var _this = this, taskSelection = this.taskGroup.selectAll(Selectors.SingleTask.selector).data(tasks), taskProgressColor = this.viewModel ? this.viewModel.taskProgressColor : Gantt.DefaultValues.ProgressColor, taskResourceShow = this.viewModel ? this.viewModel.taskResourceShow : !0, padding = 4, taskResourceColor = this.viewModel ? this.viewModel.taskResourceColor : Gantt.DefaultValues.TaskResourceColor, taskResourceFontSize = this.viewModel ? this.viewModel.taskResourceFontSize : Gantt.DefaultValues.ResourceFontSize;
                    taskSelection.enter().append("g").classed(Selectors.SingleTask["class"], !0);
                    var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function(d) {
                        return [ d ];
                    });
                    taskRect.enter().append("rect").classed(Selectors.TaskRect["class"], !0), taskRect.classed(Selectors.TaskRect["class"], !0).attr({
                        x: function(task) {
                            return _this.timeScale(task.start);
                        },
                        y: function(task) {
                            return _this.getBarYCoordinate(task.id);
                        },
                        width: function(task) {
                            return _this.taskDurationToWidth(task);
                        },
                        height: function() {
                            return _this.getBarHeight();
                        }
                    }).style("fill", function(task) {
                        return task.color;
                    }), taskRect.exit().remove();
                    var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function(d) {
                        return [ d ];
                    });
                    if (taskProgress.enter().append("rect").classed(Selectors.TaskProgress["class"], !0), 
                    taskProgress.attr({
                        x: function(task) {
                            return _this.timeScale(task.start);
                        },
                        y: function(task) {
                            return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2;
                        },
                        width: function(task) {
                            return _this.setTaskProgress(task);
                        },
                        height: Gantt.DefaultValues.ProgressBarHeight
                    }).style("fill", taskProgressColor), taskProgress.exit().remove(), taskResourceShow) {
                        var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function(d) {
                            return [ d ];
                        });
                        taskResource.enter().append("text").classed(Selectors.TaskResource["class"], !0), 
                        taskResource.attr({
                            x: function(task) {
                                return _this.timeScale(task.end) + padding;
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 + padding;
                            }
                        }).text(function(task) {
                            return task.resource;
                        }).style({
                            fill: taskResourceColor,
                            "font-size": PixelConverter.fromPoint(taskResourceFontSize)
                        }).call(visuals.AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, powerbi.TextMeasurementService.svgEllipsis), 
                        taskResource.exit().remove();
                    } else taskSelection.selectAll(Selectors.TaskResource.selector).remove();
                    visuals.TooltipManager.addTooltip(taskSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), taskSelection.exit().remove();
                }, Gantt.prototype.onClearSelection = function() {
                    this.selectionManager.clear();
                }, Gantt.prototype.getTaskLabelCoordinateY = function(taskIndex) {
                    var fontSize = +this.getTaskLabelFontSize();
                    return ChartLineHeight * taskIndex + (this.getBarHeight() + 5 - (40 - fontSize) / 4);
                }, Gantt.prototype.setTaskProgress = function(task) {
                    var fraction = task.completion / 1, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;
                    return progress;
                }, Gantt.prototype.getBarYCoordinate = function(lineNumber) {
                    return ChartLineHeight * lineNumber + PaddingTasks;
                }, Gantt.prototype.getBarHeight = function() {
                    return ChartLineHeight / 1.5;
                }, Gantt.prototype.taskDurationToWidth = function(task) {
                    return this.timeScale(task.end) - this.timeScale(task.start);
                }, Gantt.prototype.getTooltipForMilstoneLine = function(timestamp, milestoneTitle) {
                    var stringDate = new Date(timestamp).toDateString(), tooltip = [ {
                        displayName: milestoneTitle,
                        value: stringDate
                    } ];
                    return tooltip;
                }, Gantt.prototype.createMilestoneLine = function(tasks, milestoneTitle, timestamp) {
                    void 0 === milestoneTitle && (milestoneTitle = "Today"), void 0 === timestamp && (timestamp = Date.now());
                    var line = [ {
                        x1: this.timeScale(timestamp),
                        y1: 0,
                        x2: this.timeScale(timestamp),
                        y2: this.getMilestoneLineLength(tasks.length),
                        tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)
                    } ], chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);
                    chartLineSelection.enter().append("line").classed(Selectors.ChartLine["class"], !0), 
                    chartLineSelection.attr({
                        x1: function(line) {
                            return line.x1;
                        },
                        y1: function(line) {
                            return line.y1;
                        },
                        x2: function(line) {
                            return line.x2;
                        },
                        y2: function(line) {
                            return line.y2;
                        },
                        tooltipInfo: function(line) {
                            return line.tooltipInfo;
                        }
                    }), visuals.TooltipManager.addTooltip(chartLineSelection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), chartLineSelection.exit().remove();
                }, Gantt.prototype.updateElementsPositions = function(viewport, margin) {
                    var viewModel = this.viewModel;
                    this.axisGroup.attr("transform", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, 15)), 
                    this.chartGroup.attr("transform", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, margin.top)), 
                    this.lineGroup.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                }, Gantt.prototype.getMilestoneLineLength = function(numOfTasks) {
                    return numOfTasks * ChartLineHeight;
                }, Gantt.prototype.getTaskLabelFontSize = function() {
                    return powerbi.DataViewObjects.getValue(this.dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);
                }, Gantt.prototype.enumerateLegendOptions = function(enumeration, objects) {
                    enumeration.pushInstance({
                        displayName: samples.GanttChartProps.legend.show.objectName,
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.show, !0),
                            position: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.position, !0),
                            showTitle: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.showTitle, !0),
                            titleText: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.titleText, ""),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.legend.labelColor, Gantt.DefaultValues.LegendLabelColor),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.fontSize, Gantt.DefaultValues.LegendFontSize)
                        },
                        objectName: samples.GanttChartProps.legend.show.objectName
                    });
                }, Gantt.prototype.enumerateDataPoints = function(enumeration, objects) {
                    var taskSeries = this.data.series;
                    taskSeries.forEach(function(item) {
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: item.name,
                            selector: visuals.ColorHelper.normalizeSelector(item.identity.getSelector(), !1),
                            properties: {
                                fill: {
                                    solid: {
                                        color: item.fill
                                    }
                                }
                            }
                        });
                    });
                }, Gantt.prototype.enumerateTaskCompletion = function(enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor)
                        },
                        objectName: samples.GanttChartProps.taskCompletion.fill.objectName
                    });
                }, Gantt.prototype.enumerateTaskLabels = function(enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.show, !0),
                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize),
                            width: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.width, Gantt.DefaultValues.TaskLabelWidth)
                        },
                        objectName: samples.GanttChartProps.taskLabels.show.objectName
                    });
                }, Gantt.prototype.enumerateDataLabels = function(enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.show, !0),
                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize)
                        },
                        objectName: samples.GanttChartProps.taskResource.show.objectName
                    });
                }, Gantt.prototype.enumerateDateType = function(enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            type: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType)
                        },
                        objectName: samples.GanttChartProps.ganttDateType.type.objectName
                    });
                }, Gantt.prototype.enumerateObjectInstances = function(options) {
                    var dataView = this.dataView;
                    if (dataView) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "legend":
                            this.enumerateLegendOptions(enumeration, dataView.metadata.objects);
                            break;

                          case "dataPoint":
                            this.enumerateDataPoints(enumeration, dataView.metadata.objects);
                            break;

                          case "taskLabels":
                            this.enumerateTaskLabels(enumeration, dataView.metadata.objects);
                            break;

                          case "taskCompletion":
                            this.enumerateTaskCompletion(enumeration, dataView.metadata.objects);
                            break;

                          case "taskResource":
                            this.enumerateDataLabels(enumeration, dataView.metadata.objects);
                            break;

                          case "ganttDateType":
                            this.enumerateDateType(enumeration, dataView.metadata.objects);
                        }
                        return enumeration.complete();
                    }
                }, Gantt.DefaultValues = {
                    AxisTickSize: 6,
                    LabelFontSize: 9,
                    LegendFontSize: 8,
                    LegendLabelColor: "#000000",
                    MaxTaskOpacity: 1,
                    MinTaskOpacity: .4,
                    ProgressBarHeight: 4,
                    ProgressColor: "#000000",
                    ResourceFontSize: 9,
                    ResourceWidth: 100,
                    TaskColor: "#00B099",
                    TaskLabelColor: "#000000",
                    TaskLabelWidth: 110,
                    TaskLineWidth: 15,
                    TaskResourceColor: "#000000",
                    ganttFormatString: "MMM dd"
                }, Gantt.capabilities = {
                    dataRoles: [ {
                        name: "Legend",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Legend"
                    }, {
                        name: "Task",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Task"
                    }, {
                        name: "StartDate",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Start Date"
                    }, {
                        name: "Duration",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Duration",
                        requiredTypes: [ {
                            numeric: !0
                        }, {
                            integer: !0
                        } ]
                    }, {
                        name: "Completion",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "% Completion",
                        requiredTypes: [ {
                            numeric: !0
                        }, {
                            integer: !0
                        } ]
                    }, {
                        name: "Resource",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Resource"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Legend: {
                                min: 0,
                                max: 1
                            },
                            Task: {
                                min: 1,
                                max: 1
                            },
                            StartDate: {
                                min: 0,
                                max: 0
                            },
                            Duration: {
                                min: 0,
                                max: 0
                            },
                            Completion: {
                                min: 0,
                                max: 0
                            },
                            Resource: {
                                min: 0,
                                max: 0
                            }
                        }, {
                            Legend: {
                                min: 0,
                                max: 1
                            },
                            Task: {
                                min: 1,
                                max: 1
                            },
                            StartDate: {
                                min: 0,
                                max: 1
                            },
                            Duration: {
                                min: 0,
                                max: 0
                            },
                            Completion: {
                                min: 0,
                                max: 0
                            },
                            Resource: {
                                min: 0,
                                max: 0
                            }
                        }, {
                            Legend: {
                                min: 0,
                                max: 1
                            },
                            Task: {
                                min: 0,
                                max: 1
                            },
                            StartDate: {
                                min: 0,
                                max: 1
                            },
                            Duration: {
                                min: 0,
                                max: 1
                            },
                            Completion: {
                                min: 0,
                                max: 1
                            },
                            Resource: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        table: {
                            rows: {
                                select: [ {
                                    "for": {
                                        "in": "Legend"
                                    }
                                }, {
                                    "for": {
                                        "in": "Task"
                                    }
                                }, {
                                    "for": {
                                        "in": "StartDate"
                                    }
                                }, {
                                    "for": {
                                        "in": "Duration"
                                    }
                                }, {
                                    "for": {
                                        "in": "Completion"
                                    }
                                }, {
                                    "for": {
                                        "in": "Resource"
                                    }
                                } ]
                            }
                        }
                    } ],
                    sorting: {
                        "default": {}
                    },
                    objects: {
                        legend: {
                            displayName: "Legend",
                            description: "Display legend options",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: "Position",
                                    description: "Select the location for the legend",
                                    type: {
                                        enumeration: visuals.legendPosition.type
                                    }
                                },
                                showTitle: {
                                    displayName: "Title",
                                    description: "Display a title for legend symbols",
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: "Legend Name",
                                    description: "Title text",
                                    type: {
                                        text: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        taskLabels: {
                            displayName: "Category Labels",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: "Fill",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Font Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                },
                                width: {
                                    displayName: "Width",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        taskCompletion: {
                            displayName: "Task Completion",
                            properties: {
                                show: {
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: "Completion Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        taskResource: {
                            displayName: "Data Labels",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                fill: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Font Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        },
                        ganttDateType: {
                            displayName: "Gantt Date Type",
                            properties: {
                                type: {
                                    displayName: "Type",
                                    type: {
                                        enumeration: dateTypeSelector.type
                                    }
                                }
                            }
                        }
                    }
                }, Gantt;
            }();
            samples.Gantt = Gantt;
            var GanttChartBehavior = function() {
                function GanttChartBehavior() {}
                return GanttChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.options = options;
                    var clearCatcher = options.clearCatcher;
                    options.taskSelection.on("click", function(d) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                    }), clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, GanttChartBehavior.prototype.renderSelection = function(hasSelection) {
                    var options = this.options, ganttMaxOpacity = Gantt.getMaxTaskOpacity(), ganttMinOpacity = Gantt.getMinTaskOpacity();
                    options.taskSelection.style("opacity", function(d) {
                        return hasSelection && !d.selected ? ganttMinOpacity : ganttMaxOpacity;
                    });
                }, GanttChartBehavior;
            }();
            samples.GanttChartBehavior = GanttChartBehavior;
            var GanttChartWarning = function() {
                function GanttChartWarning() {}
                return Object.defineProperty(GanttChartWarning.prototype, "code", {
                    get: function() {
                        return "GanttChartWarning";
                    },
                    enumerable: !0,
                    configurable: !0
                }), GanttChartWarning.prototype.getMessages = function(resourceProvider) {
                    var visualMessage, message = "This visual requires task value", titleKey = "", detailKey = "";
                    return visualMessage = {
                        message: message,
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                }, GanttChartWarning;
            }();
            samples.GanttChartWarning = GanttChartWarning;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, SelectionManager = visuals.utility.SelectionManager, px = jsCommon.PixelConverter.toString, pt = jsCommon.PixelConverter.fromPoint, fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;
            samples.Months = powerbi.createEnumType([ {
                value: 1,
                displayName: "January"
            }, {
                value: 2,
                displayName: "February"
            }, {
                value: 3,
                displayName: "March"
            }, {
                value: 4,
                displayName: "April"
            }, {
                value: 5,
                displayName: "May"
            }, {
                value: 6,
                displayName: "June"
            }, {
                value: 7,
                displayName: "July"
            }, {
                value: 8,
                displayName: "August"
            }, {
                value: 9,
                displayName: "September"
            }, {
                value: 10,
                displayName: "October"
            }, {
                value: 11,
                displayName: "November"
            }, {
                value: 12,
                displayName: "December"
            } ]), samples.WeekDays = powerbi.createEnumType([ {
                value: 0,
                displayName: "Sunday"
            }, {
                value: 1,
                displayName: "Monday"
            }, {
                value: 2,
                displayName: "Tuesday"
            }, {
                value: 3,
                displayName: "Wednesday"
            }, {
                value: 4,
                displayName: "Thursday"
            }, {
                value: 5,
                displayName: "Friday"
            }, {
                value: 6,
                displayName: "Saturday"
            } ]), function(GranularityType) {
                GranularityType[GranularityType.year = 0] = "year", GranularityType[GranularityType.quarter = 1] = "quarter", 
                GranularityType[GranularityType.month = 2] = "month", GranularityType[GranularityType.week = 3] = "week", 
                GranularityType[GranularityType.day = 4] = "day";
            }(samples.GranularityType || (samples.GranularityType = {}));
            var GranularityType = samples.GranularityType, SelectedCellColorProp = {
                objectName: "cells",
                propertyName: "fillSelected"
            }, UnselectedCellColorProp = {
                objectName: "cells",
                propertyName: "fillUnselected"
            }, TimeRangeColorProp = {
                objectName: "rangeHeader",
                propertyName: "fontColor"
            }, TimeRangeSizeProp = {
                objectName: "rangeHeader",
                propertyName: "textSize"
            }, TimeRangeShowProp = {
                objectName: "rangeHeader",
                propertyName: "show"
            }, LabelsColorProp = {
                objectName: "labels",
                propertyName: "fontColor"
            }, LabelsSizeProp = {
                objectName: "labels",
                propertyName: "textSize"
            }, LabelsShowProp = {
                objectName: "labels",
                propertyName: "show"
            }, CalendarMonthProp = {
                objectName: "calendar",
                propertyName: "month"
            }, CalendarDayProp = {
                objectName: "calendar",
                propertyName: "day"
            }, WeekDayProp = {
                objectName: "weekDay",
                propertyName: "day"
            }, GranularityNames = [ {
                granularityType: GranularityType.year,
                name: "year"
            }, {
                granularityType: GranularityType.quarter,
                name: "quarter"
            }, {
                granularityType: GranularityType.month,
                name: "month"
            }, {
                granularityType: GranularityType.week,
                name: "week"
            }, {
                granularityType: GranularityType.day,
                name: "day"
            } ], TimelineGranularity = function() {
                function TimelineGranularity() {
                    this.datePeriods = [];
                }
                return TimelineGranularity.prototype.shortMonthName = function(date) {
                    return date.toString().split(" ")[1];
                }, TimelineGranularity.prototype.resetDatePeriods = function() {
                    this.datePeriods = [];
                }, TimelineGranularity.prototype.getDatePeriods = function() {
                    return this.datePeriods;
                }, TimelineGranularity.prototype.getExtendedLabel = function() {
                    return this.extendedLabel;
                }, TimelineGranularity.prototype.setExtendedLabel = function(extendedLabel) {
                    this.extendedLabel = extendedLabel;
                }, TimelineGranularity.prototype.createLabels = function(granularity) {
                    var lastDatePeriod, labels = [];
                    return _.map(this.datePeriods, function(x) {
                        !_.isEmpty(labels) && granularity.sameLabel(x, lastDatePeriod) || (lastDatePeriod = x, 
                        labels.push(granularity.generateLabel(x)));
                    }), labels;
                }, TimelineGranularity.prototype.addDate = function(date, identifierArray) {
                    var datePeriods = this.getDatePeriods(), lastDatePeriod = datePeriods[datePeriods.length - 1];
                    0 !== datePeriods.length && _.isEqual(lastDatePeriod.identifierArray, identifierArray) ? lastDatePeriod.endDate = date : (datePeriods.length > 0 && (lastDatePeriod.endDate = date), 
                    datePeriods.push({
                        identifierArray: identifierArray,
                        startDate: date,
                        endDate: date,
                        week: this.determineWeek(date),
                        year: this.determineYear(date),
                        fraction: 1,
                        index: datePeriods.length
                    }));
                }, TimelineGranularity.prototype.setNewEndDate = function(date) {
                    _.last(this.datePeriods).endDate = date;
                }, TimelineGranularity.prototype.splitPeriod = function(index, newFraction, newDate) {
                    var oldDatePeriod = this.datePeriods[index];
                    oldDatePeriod.fraction -= newFraction;
                    var newDateObject = {
                        identifierArray: oldDatePeriod.identifierArray,
                        startDate: newDate,
                        endDate: oldDatePeriod.endDate,
                        week: this.determineWeek(newDate),
                        year: this.determineYear(newDate),
                        fraction: newFraction,
                        index: oldDatePeriod.index + oldDatePeriod.fraction
                    };
                    oldDatePeriod.endDate = newDate, this.datePeriods.splice(index + 1, 0, newDateObject);
                }, TimelineGranularity.prototype.previousMonth = function(month) {
                    return month > 0 ? month - 1 : 11;
                }, TimelineGranularity.prototype.nextMonth = function(month) {
                    return 11 > month ? month + 1 : 0;
                }, TimelineGranularity.prototype.countWeeks = function(startDate, endDate) {
                    var totalDays;
                    if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate()) totalDays = endDate.getDate() - startDate.getDate(); else {
                        totalDays = endDate.getDate() - 1;
                        for (var lastMonth = this.nextMonth(startDate.getMonth()), month = endDate.getMonth(); month !== lastMonth; ) totalDays += new Date(endDate.getFullYear(), month, 0).getDate(), 
                        month = this.previousMonth(month);
                        totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();
                    }
                    return 1 + Math.floor(totalDays / 7);
                }, TimelineGranularity.prototype.determineWeek = function(date) {
                    var year = date.getFullYear();
                    this.inPreviousYear(date) && year--;
                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year), weeks = this.countWeeks(dateOfFirstWeek, date);
                    return [ weeks, year ];
                }, TimelineGranularity.prototype.inPreviousYear = function(date) {
                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());
                    return dateOfFirstWeek > date;
                }, TimelineGranularity.prototype.determineYear = function(date) {
                    var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());
                    return date.getFullYear() - (date >= firstDay ? 0 : 1);
                }, TimelineGranularity;
            }();
            samples.TimelineGranularity = TimelineGranularity;
            var DayGranularity = function(_super) {
                function DayGranularity() {
                    _super.apply(this, arguments);
                }
                return __extends(DayGranularity, _super), DayGranularity.prototype.getType = function() {
                    return GranularityType.day;
                }, DayGranularity.prototype.splitDate = function(date) {
                    return [ this.shortMonthName(date), date.getDate(), date.getFullYear() ];
                }, DayGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                    return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();
                }, DayGranularity.prototype.generateLabel = function(datePeriod) {
                    return {
                        title: this.shortMonthName(datePeriod.startDate) + " " + datePeriod.startDate.getDate() + " - " + datePeriod.year,
                        text: datePeriod.startDate.getDate().toString(),
                        id: datePeriod.index
                    };
                }, DayGranularity;
            }(TimelineGranularity);
            samples.DayGranularity = DayGranularity;
            var MonthGranularity = function(_super) {
                function MonthGranularity() {
                    _super.apply(this, arguments);
                }
                return __extends(MonthGranularity, _super), MonthGranularity.prototype.getType = function() {
                    return GranularityType.month;
                }, MonthGranularity.prototype.splitDate = function(date) {
                    return [ this.shortMonthName(date), date.getFullYear() ];
                }, MonthGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                    return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);
                }, MonthGranularity.prototype.generateLabel = function(datePeriod) {
                    var shortMonthName = this.shortMonthName(datePeriod.startDate);
                    return {
                        title: shortMonthName,
                        text: shortMonthName,
                        id: datePeriod.index
                    };
                }, MonthGranularity;
            }(TimelineGranularity);
            samples.MonthGranularity = MonthGranularity;
            var WeekGranularity = function(_super) {
                function WeekGranularity() {
                    _super.apply(this, arguments);
                }
                return __extends(WeekGranularity, _super), WeekGranularity.prototype.getType = function() {
                    return GranularityType.week;
                }, WeekGranularity.prototype.splitDate = function(date) {
                    return this.determineWeek(date);
                }, WeekGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                    return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);
                }, WeekGranularity.prototype.generateLabel = function(datePeriod) {
                    return {
                        title: "Week " + datePeriod.week[0] + " - " + datePeriod.week[1],
                        text: "W" + datePeriod.week[0],
                        id: datePeriod.index
                    };
                }, WeekGranularity;
            }(TimelineGranularity);
            samples.WeekGranularity = WeekGranularity;
            var QuarterGranularity = function(_super) {
                function QuarterGranularity() {
                    _super.apply(this, arguments);
                }
                return __extends(QuarterGranularity, _super), QuarterGranularity.prototype.quarterText = function(date) {
                    for (var quarter = 3, year = date.getFullYear(); date < Timeline.calendar.getQuarterStartDate(year, quarter); ) quarter > 0 ? quarter-- : (quarter = 3, 
                    year--);
                    return quarter++, "Q" + quarter;
                }, QuarterGranularity.prototype.getType = function() {
                    return GranularityType.quarter;
                }, QuarterGranularity.prototype.splitDate = function(date) {
                    return [ this.quarterText(date), date.getFullYear() ];
                }, QuarterGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                    return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate) && firstDatePeriod.year === secondDatePeriod.year;
                }, QuarterGranularity.prototype.generateLabel = function(datePeriod) {
                    var quarter = this.quarterText(datePeriod.startDate);
                    return {
                        title: quarter + " " + datePeriod.year,
                        text: quarter,
                        id: datePeriod.index
                    };
                }, QuarterGranularity;
            }(TimelineGranularity);
            samples.QuarterGranularity = QuarterGranularity;
            var YearGranularity = function(_super) {
                function YearGranularity() {
                    _super.apply(this, arguments);
                }
                return __extends(YearGranularity, _super), YearGranularity.prototype.getType = function() {
                    return GranularityType.year;
                }, YearGranularity.prototype.splitDate = function(date) {
                    return [ date.getFullYear() ];
                }, YearGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                    return firstDatePeriod.year === secondDatePeriod.year;
                }, YearGranularity.prototype.generateLabel = function(datePeriod) {
                    return {
                        title: "Year " + datePeriod.year,
                        text: datePeriod.year.toString(),
                        id: datePeriod.index
                    };
                }, YearGranularity;
            }(TimelineGranularity);
            samples.YearGranularity = YearGranularity;
            var TimelineGranularityData = function() {
                function TimelineGranularityData(startDate, endDate) {
                    this.granularities = [], this.setDatesRange(startDate, endDate);
                    var lastDate = this.dates[this.dates.length - 1];
                    this.endingDate = TimelineGranularityData.nextDay(lastDate);
                }
                return TimelineGranularityData.previousDay = function(date) {
                    var prevDay = new Date(date.getTime());
                    return prevDay.setDate(prevDay.getDate() - 1), prevDay;
                }, TimelineGranularityData.nextDay = function(date) {
                    var nextDay = new Date(date.getTime());
                    return nextDay.setDate(nextDay.getDate() + 1), nextDay;
                }, TimelineGranularityData.prototype.setDatesRange = function(startDate, endDate) {
                    this.dates = [];
                    for (var date = startDate; endDate >= date; ) this.dates.push(date), date = TimelineGranularityData.nextDay(date);
                }, TimelineGranularityData.prototype.addGranularity = function(granularity) {
                    granularity.resetDatePeriods();
                    for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {
                        var date = _a[_i], identifierArray = granularity.splitDate(date);
                        granularity.addDate(date, identifierArray);
                    }
                    granularity.setNewEndDate(this.endingDate), this.granularities.push(granularity);
                }, TimelineGranularityData.prototype.getGranularity = function(index) {
                    return this.granularities[index];
                }, TimelineGranularityData.prototype.createGranularities = function() {
                    this.granularities = [], this.addGranularity(new YearGranularity()), this.addGranularity(new QuarterGranularity()), 
                    this.addGranularity(new MonthGranularity()), this.addGranularity(new WeekGranularity()), 
                    this.addGranularity(new DayGranularity());
                }, TimelineGranularityData.prototype.createLabels = function() {
                    var _this = this;
                    this.granularities.forEach(function(x) {
                        x.setExtendedLabel({
                            dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],
                            weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],
                            monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],
                            quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],
                            yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : []
                        });
                    });
                }, TimelineGranularityData;
            }();
            samples.TimelineGranularityData = TimelineGranularityData;
            var Utils = function() {
                function Utils() {}
                return Utils.getStartSelectionDate = function(timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
                }, Utils.getEndSelectionDate = function(timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
                }, Utils.getEndSelectionPeriod = function(timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
                }, Utils.getCellColor = function(d, timelineData, cellFormat) {
                    var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
                    return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;
                }, Utils.getGranularityType = function(granularityName) {
                    var index = _.findIndex(GranularityNames, function(x) {
                        return x.name === granularityName;
                    });
                    return GranularityNames[index].granularityType;
                }, Utils.getGranularityName = function(granularity) {
                    var index = _.findIndex(GranularityNames, function(x) {
                        return x.granularityType === granularity;
                    });
                    return GranularityNames[index].name;
                }, Utils.separateSelection = function(timelineData, startDate, endDate) {
                    var datePeriods = timelineData.currentGranularity.getDatePeriods(), startDateIndex = _.findIndex(datePeriods, function(x) {
                        return startDate < x.endDate;
                    }), endDateIndex = _.findIndex(datePeriods, function(x) {
                        return endDate <= x.endDate;
                    });
                    timelineData.selectionStartIndex = startDateIndex, timelineData.selectionEndIndex = endDateIndex;
                    var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, !0), endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, !1);
                    if (endRatio > 0 && timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate), 
                    startRatio > 0) {
                        var startFration = datePeriods[startDateIndex].fraction - startRatio;
                        timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate), 
                        timelineData.selectionStartIndex++, timelineData.selectionEndIndex++;
                    }
                }, Utils.getDateRatio = function(datePeriod, date, fromStart) {
                    var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime(), periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
                    return 0 === periodDifference ? 0 : dateDifference / periodDifference;
                }, Utils.timeRangeText = function(timelineData) {
                    var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData)), endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
                    return startSelectionDateArray.join(" ") + " - " + endSelectionDateArray.join(" ");
                }, Utils.dateRangeText = function(datePeriod) {
                    return datePeriod.startDate.toDateString() + " - " + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();
                }, Utils.unseparateSelection = function(datePeriods) {
                    var separationIndex = _.findIndex(datePeriods, function(x) {
                        return x.fraction < 1;
                    });
                    return separationIndex >= 0 ? (datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate, 
                    datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction, 
                    datePeriods.splice(separationIndex + 1, 1), !0) : !1;
                }, Utils;
            }();
            samples.Utils = Utils;
            var Calendar = function() {
                function Calendar(calendarFormat) {
                    var _this = this;
                    this.firstDayOfWeek = calendarFormat.weekDayProperty, this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1, 
                    this.firstDayOfYear = calendarFormat.firstDayProperty, this.dateOfFirstWeek = {}, 
                    this.quarterFirstMonths = [ 0, 3, 6, 9 ].map(function(x) {
                        return x + _this.firstMonthOfYear;
                    });
                }
                return Calendar.prototype.getFirstDayOfWeek = function() {
                    return this.firstDayOfWeek;
                }, Calendar.prototype.getFirstMonthOfYear = function() {
                    return this.firstMonthOfYear;
                }, Calendar.prototype.getFirstDayOfYear = function() {
                    return this.firstDayOfYear;
                }, Calendar.prototype.getQuarterStartDate = function(year, quarterIndex) {
                    return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);
                }, Calendar.prototype.isChanged = function(calendarFormat) {
                    return this.firstMonthOfYear !== calendarFormat.firstMonthProperty - 1 || this.firstDayOfYear !== calendarFormat.firstDayProperty || this.firstDayOfWeek !== calendarFormat.weekDayProperty;
                }, Calendar.prototype.calculateDateOfFirstWeek = function(year) {
                    for (var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear); date.getDay() !== this.firstDayOfWeek; ) date = TimelineGranularityData.nextDay(date);
                    return date;
                }, Calendar.prototype.getDateOfFirstWeek = function(year) {
                    return this.dateOfFirstWeek[year] || (this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year)), 
                    this.dateOfFirstWeek[year];
                }, Calendar;
            }();
            samples.Calendar = Calendar;
            var Timeline = function() {
                function Timeline() {
                    var _this = this;
                    this.requiresNoUpdate = !1, this.foreignSelection = !1, this.selector = [ "Y", "Q", "M", "W", "D" ], 
                    this.timelineMargins = {
                        LeftMargin: 15,
                        RightMargin: 15,
                        TopMargin: 15,
                        BottomMargin: 10,
                        CellWidth: 40,
                        CellHeight: 25,
                        StartXpoint: 10,
                        StartYpoint: 20,
                        ElementWidth: 30,
                        MinCellWidth: 30,
                        MaxCellHeight: 60,
                        PeriodSlicerRectWidth: 15,
                        PeriodSlicerRectHeight: 23
                    }, this.defaultTimelineProperties = {
                        DefaultLabelsShow: !0,
                        TimelineDefaultTextSize: 9,
                        TimelineDefaultCellColor: "#ADD8E6",
                        TimelineDefaultCellColorOut: "#FFFFFF",
                        TimelineDefaultTimeRangeShow: !0,
                        DefaultTimeRangeColor: "#777777",
                        DefaultLabelColor: "#777777",
                        DefaultGranularity: GranularityType.month,
                        DefaultFirstMonth: 1,
                        DefaultFirstDay: 1,
                        DefaultFirstWeekDay: 0
                    }, this.timelineSelectors = {
                        TimelineVisual: createClassAndSelector("Timeline"),
                        SelectionRangeContainer: createClassAndSelector("selectionRangeContainer"),
                        textLabel: createClassAndSelector("label"),
                        LowerTextCell: createClassAndSelector("lowerTextCell"),
                        UpperTextCell: createClassAndSelector("upperTextCell"),
                        UpperTextArea: createClassAndSelector("upperTextArea"),
                        LowerTextArea: createClassAndSelector("lowerTextArea"),
                        RangeTextArea: createClassAndSelector("rangeTextArea"),
                        CellsArea: createClassAndSelector("cellsArea"),
                        CursorsArea: createClassAndSelector("cursorsArea"),
                        MainArea: createClassAndSelector("mainArea"),
                        SelectionCursor: createClassAndSelector("selectionCursor"),
                        Cell: createClassAndSelector("cell"),
                        CellRect: createClassAndSelector("cellRect"),
                        VertLine: createClassAndSelector("timelineVertLine"),
                        TimelineSlicer: createClassAndSelector("timelineSlicer"),
                        PeriodSlicerGranularities: createClassAndSelector("periodSlicerGranularities"),
                        PeriodSlicerSelection: createClassAndSelector("periodSlicerSelection"),
                        PeriodSlicerSelectionRect: createClassAndSelector("periodSlicerSelectionRect"),
                        PeriodSlicerRect: createClassAndSelector("periodSlicerRect")
                    }, this.drag = d3.behavior.drag().origin(function(d) {
                        return d.x = d.selectionIndex * _this.timelineProperties.cellWidth, d;
                    }).on("dragstart", function() {
                        _this.dragstarted();
                    }).on("drag", function(d) {
                        _this.dragged(d);
                    }).on("dragend", function() {
                        _this.dragended();
                    });
                }
                return Timeline.prototype.changeGranularity = function(granularity, startDate, endDate) {
                    Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()) && Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()), 
                    this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity), 
                    Utils.separateSelection(this.timelineData, startDate, endDate);
                }, Timeline.prototype.init = function(options) {
                    this.hostServices = options.host, this.initialized = !1;
                    var element = options.element;
                    this.selectionManager = new SelectionManager({
                        hostServices: options.host
                    }), this.timelineProperties = {
                        element: element,
                        textYPosition: 50,
                        cellsYPosition: 3 * this.timelineMargins.TopMargin + 65,
                        topMargin: this.timelineMargins.TopMargin,
                        bottomMargin: this.timelineMargins.BottomMargin,
                        leftMargin: this.timelineMargins.LeftMargin,
                        startXpoint: this.timelineMargins.StartXpoint,
                        startYpoint: this.timelineMargins.StartYpoint,
                        cellWidth: this.timelineMargins.CellWidth,
                        cellHeight: this.timelineMargins.CellHeight,
                        elementWidth: this.timelineMargins.ElementWidth,
                        rightMargin: this.timelineMargins.RightMargin
                    }, this.body = d3.select(element.get(0)), this.timelineDiv = this.body.append("div"), 
                    this.svg = this.timelineDiv.append("svg").attr("width", px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual["class"], !0), 
                    this.clearCatcher = visuals.appendClearCatcher(this.svg), this.clearCatcher.data([ this ]).on("click", function(timeline) {
                        return timeline.clear();
                    }).on("touchstart", function(timeline) {
                        return timeline.clear();
                    }), this.rangeText = this.svg.append("g").classed(this.timelineSelectors.RangeTextArea["class"], !0).append("text"), 
                    this.mainGroupElement = this.svg.append("g").classed(this.timelineSelectors.MainArea["class"], !0), 
                    this.yearLabelsElement = this.mainGroupElement.append("g"), this.quarterLabelsElement = this.mainGroupElement.append("g"), 
                    this.monthLabelsElement = this.mainGroupElement.append("g"), this.weekLabelsElement = this.mainGroupElement.append("g"), 
                    this.dayLabelsElement = this.mainGroupElement.append("g"), this.cellsElement = this.mainGroupElement.append("g").classed(this.timelineSelectors.CellsArea["class"], !0), 
                    this.cursorGroupElement = this.svg.append("g").classed(this.timelineSelectors.CursorsArea["class"], !0);
                }, Timeline.prototype.clear = function() {
                    this.selectionManager.clear(), this.timelineData && (this.timelineData.selectionStartIndex = 0, 
                    this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1, 
                    _.any(this.timelineData.timelineDatapoints, function(x) {
                        return x.index % 1 !== 0;
                    }) ? this.selectPeriod(this.timelineData.currentGranularity.getType()) : (Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth), 
                    this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                    this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat)), 
                    this.setSelection(this.timelineData));
                }, Timeline.prototype.drawGranular = function(timelineProperties) {
                    var _this = this, dragPeriodRectState = !1, startXpoint = timelineProperties.startXpoint, startYpoint = timelineProperties.startYpoint, elementWidth = timelineProperties.elementWidth;
                    this.selectorContainer = this.svg.append("g").classed(this.timelineSelectors.TimelineSlicer["class"], !0), 
                    this.selectorContainer.on("mouseleave", function(d) {
                        return dragPeriodRectState = !1;
                    });
                    var fillRect = this.selectorContainer.append("rect"), selectorPeriods = this.selector;
                    fillRect.attr({
                        height: px(1),
                        x: px(startXpoint),
                        y: px(startYpoint + 2),
                        width: px((selectorPeriods.length - 1) * elementWidth)
                    });
                    var fillVertLine = this.selectorContainer.selectAll("vertLines").data(selectorPeriods).enter().append("rect");
                    fillVertLine.classed(this.timelineSelectors.VertLine["class"], !0).attr({
                        x: function(d, index) {
                            return px(startXpoint + index * elementWidth);
                        },
                        y: px(startYpoint),
                        width: px(2),
                        height: px(3)
                    }).style({
                        cursor: "pointer"
                    });
                    var textLabels, text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector).data(selectorPeriods).enter().append("text").classed(this.timelineSelectors.PeriodSlicerGranularities["class"], !0);
                    textLabels = text.text(function(d) {
                        return d;
                    }).attr({
                        x: function(d, index) {
                            return px(startXpoint - 3 + index * elementWidth);
                        },
                        y: px(startYpoint - 3)
                    }), this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelectors.PeriodSlicerSelection["class"], !0), 
                    this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity)).attr({
                        x: px(startXpoint + 2 * elementWidth),
                        y: px(startYpoint + 17)
                    });
                    var selRects = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector).data(selectorPeriods).enter().append("rect").classed(this.timelineSelectors.PeriodSlicerSelectionRect["class"], !0), clickHandler = function(d, index) {
                        _this.selectPeriod(index), dragPeriodRectState = !0;
                    };
                    selRects.attr({
                        x: function(d, index) {
                            return px(startXpoint - elementWidth / 2 + index * elementWidth);
                        },
                        y: px(3),
                        width: px(elementWidth),
                        height: px(23)
                    }).style({
                        cursor: "pointer"
                    }).on("mousedown", clickHandler).on("touchstart", clickHandler).on("mouseup", function() {
                        return dragPeriodRectState = !1;
                    }).on("touchend", function() {
                        return dragPeriodRectState = !1;
                    }).on("mouseover", function(d, index) {
                        dragPeriodRectState && _this.selectPeriod(index);
                    });
                    var dragPeriodRect = d3.behavior.drag().on("dragstart", function(e, b) {
                        dragPeriodRectState = !0;
                    }).on("dragend", function(e, b) {
                        dragPeriodRectState = !1;
                    });
                    this.periodSlicerRect = this.selectorContainer.append("rect").classed(this.timelineSelectors.PeriodSlicerRect["class"], !0).attr({
                        x: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),
                        y: px(startYpoint - 16),
                        rx: px(4),
                        width: px(15),
                        height: px(23)
                    }).on("mouseup", function(d) {
                        return dragPeriodRectState = !1;
                    }), this.periodSlicerRect.call(dragPeriodRect);
                }, Timeline.prototype.redrawPeriod = function(granularity) {
                    var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;
                    this.periodSlicerRect.transition().attr("x", px(dx - 7)), this.selectedText.text(Utils.getGranularityName(granularity));
                    var startDate = Utils.getStartSelectionDate(this.timelineData), endDate = Utils.getEndSelectionDate(this.timelineData);
                    this.changeGranularity(granularity, startDate, endDate);
                }, Timeline.setMeasures = function(labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {
                    timelineProperties.cellsYPosition = timelineProperties.textYPosition;
                    var labelSize = fromPointToPixel(labelFormat.sizeProperty);
                    labelFormat.showProperty && (timelineProperties.cellsYPosition += 1.5 * labelSize * (granularityType + 1));
                    var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin), maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount, height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20)), width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);
                    timelineProperties.cellHeight = height, timelineProperties.cellWidth = width;
                }, Timeline.prototype.visualChangeOnly = function(options) {
                    if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata && this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {
                        var newObjects_1 = options.dataViews[0].metadata.objects, oldObjects_1 = this.options.dataViews[0].metadata.objects, properties = [ "rangeHeader", "cells", "labels" ], metadataChanged = !properties.every(function(x) {
                            return _.isEqual(newObjects_1 ? newObjects_1[x] : void 0, oldObjects_1 ? oldObjects_1[x] : void 0);
                        });
                        return options.suppressAnimations || metadataChanged;
                    }
                    return !1;
                }, Timeline.prototype.unavailableType = function(dataViewCategorical) {
                    return !(dataViewCategorical.categories && 1 === dataViewCategorical.categories.length && dataViewCategorical.categories[0].values && 0 !== dataViewCategorical.categories[0].values.length && dataViewCategorical.categories[0].source && dataViewCategorical.categories[0].source.type);
                }, Timeline.prototype.unavailableChildIdentityField = function(dataViewTree) {
                    return !dataViewTree.root || !dataViewTree.root.childIdentityFields || 0 === dataViewTree.root.childIdentityFields.length;
                }, Timeline.prototype.createTimelineOptions = function(dataView) {
                    if (this.dataView = dataView, !dataView.categorical || !dataView.metadata || this.unavailableType(dataView.categorical) || !dataView.tree || this.unavailableChildIdentityField(dataView.tree)) return !1;
                    var columnExp = dataView.tree.root.childIdentityFields[0];
                    return this.valueType = columnExp ? columnExp.ref : null, dataView.categorical.categories[0].source.type.dateTime || dataView.categorical.categories[0].source.type.numeric && ("Year" === this.valueType || "Date" === this.valueType) ? (this.values = this.prepareValues(this.dataView.categorical.categories[0].values), 
                    !0) : !1;
                }, Timeline.prototype.prepareValues = function(values) {
                    values = values.filter(Boolean);
                    for (var i in values) {
                        var item = values[i];
                        if ("String" == typeof item && "Invalid Date" !== String(new Date(item))) return values[i] = new Date(item);
                    }
                    return values;
                }, Timeline.prototype.createTimelineData = function() {
                    var startDate, endDate;
                    if ("Year" === this.valueType) {
                        var years = this.values;
                        startDate = new Date(_.min(years), 0), endDate = new Date(_.max(years), 11);
                    } else {
                        var dates = this.values;
                        startDate = _.min(dates), endDate = _.max(dates);
                    }
                    if (this.initialized || this.drawGranular(this.timelineProperties), this.initialized) {
                        var actualEndDate = TimelineGranularityData.nextDay(endDate), daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods(), prevStartDate = daysPeriods[0].startDate, prevEndDate = daysPeriods[daysPeriods.length - 1].endDate, changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();
                        this.newGranularity = this.timelineData.currentGranularity.getType(), changedSelection ? (this.foreignSelection = !0, 
                        this.changeGranularity(this.newGranularity, startDate, actualEndDate), this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties)) : (prevEndDate > actualEndDate && (endDate = daysPeriods[daysPeriods.length - 1].startDate), 
                        startDate > prevStartDate && (startDate = prevStartDate), this.initialized = !1);
                    }
                    this.initialized || (this.timelineGranularityData = new TimelineGranularityData(startDate, endDate), 
                    this.timelineData = {
                        elementsCount: 0,
                        timelineDatapoints: [],
                        cursorDataPoints: new Array()
                    });
                }, Timeline.prototype.update = function(options) {
                    var visualChange = this.visualChangeOnly(options);
                    if (this.requiresNoUpdate = this.requiresNoUpdate && !visualChange, this.requiresNoUpdate) return void (this.foreignSelection ? this.foreignSelection = !1 : this.requiresNoUpdate = !1);
                    if (this.options = options, options.dataViews && options.dataViews[0]) {
                        var validOptions = this.createTimelineOptions(options.dataViews[0]);
                        if (!validOptions) return void this.clearData();
                        this.newGranularity = this.defaultTimelineProperties.DefaultGranularity, visualChange || this.createTimelineData(), 
                        this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins), 
                        this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options), 
                        this.initialized = !0;
                    }
                }, Timeline.prototype.selectPeriod = function(periodNameIndex) {
                    this.redrawPeriod(periodNameIndex), this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins), 
                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);
                }, Timeline.isDataNotMatch = function(dataView) {
                    return dataView.categorical.categories.length <= 0 || void 0 === dataView.categorical.categories[0] || void 0 === dataView.categorical.categories[0].identityFields || dataView.categorical.categories[0].identityFields.length <= 0;
                }, Timeline.converter = function(timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {
                    var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
                    if (initialized || (timelineData.cursorDataPoints.push({
                        x: 0,
                        selectionIndex: 0,
                        cursorIndex: 0
                    }), timelineData.cursorDataPoints.push({
                        x: 0,
                        selectionIndex: 0,
                        cursorIndex: 1
                    })), initialized && !Timeline.calendar.isChanged(timelineFormat.calendarFormat) || (Timeline.calendar = new Calendar(timelineFormat.calendarFormat), 
                    timelineGranularityData.createGranularities(), timelineGranularityData.createLabels(), 
                    timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType), 
                    timelineData.selectionStartIndex = 0, timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1), 
                    timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName, 
                    timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0], 
                    dataView.categorical.categories[0].source.type.numeric && (timelineData.columnIdentity.ref = "Date"), 
                    !this.isDataNotMatch(dataView)) {
                        var timelineElements = timelineData.currentGranularity.getDatePeriods();
                        timelineData.elementsCount = timelineElements.length, timelineData.timelineDatapoints = [];
                        for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {
                            var currentTimePeriod = timelineElements_1[_i], datapoint = {
                                index: currentTimePeriod.index,
                                datePeriod: currentTimePeriod
                            };
                            timelineData.timelineDatapoints.push(datapoint);
                        }
                        var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function(x) {
                            return x.index % 1 === 0;
                        }).length;
                        return Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins), 
                        Timeline.updateCursors(timelineData, timelineProperties.cellWidth), timelineFormat;
                    }
                }, Timeline.prototype.render = function(timelineData, timelineFormat, timelineProperties, options) {
                    var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function(x) {
                        return x.index % 1 === 0;
                    }).length;
                    this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount, 
                    this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), this.timelineDiv.attr({
                        height: px(options.viewport.height),
                        width: px(options.viewport.width),
                        "drag-resize-disabled": !0
                    }).style({
                        "overflow-x": "auto",
                        "overflow-y": "auto"
                    }), this.svg.attr({
                        height: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),
                        width: px(Math.max(0, this.svgWidth))
                    });
                    var fixedTranslateString = visuals.SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin), translateString = visuals.SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);
                    this.mainGroupElement.attr("transform", translateString), this.selectorContainer.attr("transform", fixedTranslateString), 
                    this.cursorGroupElement.attr("transform", translateString);
                    var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel(), granularityType = this.timelineData.currentGranularity.getType(), yPos = 0, yDiff = 1.5;
                    this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, 0 === granularityType), 
                    yPos += yDiff, this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, 1 === granularityType), 
                    yPos += yDiff, this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, 2 === granularityType), 
                    yPos += yDiff, this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, 3 === granularityType), 
                    yPos += yDiff, this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, 4 === granularityType), 
                    this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations), 
                    this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
                }, Timeline.prototype.renderLabels = function(labels, labelsElement, index, isLast) {
                    var _this = this, labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);
                    if (!this.timelineFormat.labelFormat.showProperty) return void labelTextSelection.remove();
                    var labelsGroupSelection = labelTextSelection.data(labels);
                    labelsGroupSelection.enter().append("text").classed(this.timelineSelectors.textLabel["class"], !0), 
                    labelsGroupSelection.text(function(x, id) {
                        if (!isLast && 0 === id && labels.length > 1) {
                            var fontSize = pt(_this.timelineFormat.labelFormat.sizeProperty), textProperties = {
                                text: labels[0].text,
                                fontFamily: "arial",
                                fontSize: fontSize
                            }, halfFirstTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
                            textProperties = {
                                text: labels[1].text,
                                fontFamily: "arial",
                                fontSize: fontSize
                            };
                            var halfSecondTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2, diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);
                            if (halfFirstTextWidth + halfSecondTextWidth > diff) return "";
                        }
                        var labelFormattedTextOptions = {
                            label: x.text,
                            maxWidth: _this.timelineProperties.cellWidth * (isLast ? .9 : 3),
                            fontSize: _this.timelineFormat.labelFormat.sizeProperty
                        };
                        return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                    }).style("font-size", pt(this.timelineFormat.labelFormat.sizeProperty)).attr({
                        x: function(x) {
                            return (x.id + .5) * _this.timelineProperties.cellWidth;
                        },
                        y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),
                        fill: this.timelineFormat.labelFormat.colorProperty
                    }).append("title").text(function(x) {
                        return x.title;
                    }), labelsGroupSelection.exit().remove();
                }, Timeline.prototype.clearData = function() {
                    this.initialized = !1, this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove(), 
                    this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove(), 
                    this.rangeText.text(""), this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove(), 
                    this.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();
                }, Timeline.updateCursors = function(timelineData, cellWidth) {
                    var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;
                    timelineData.cursorDataPoints[0].selectionIndex = startDate.index;
                    var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
                    timelineData.cursorDataPoints[1].selectionIndex = endDate.index + endDate.fraction;
                }, Timeline.fillTimelineFormat = function(objects, timelineProperties) {
                    var timelineFormat = {
                        rangeTextFormat: {
                            showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),
                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
                            sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)
                        },
                        cellFormat: {
                            colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),
                            colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)
                        },
                        labelFormat: {
                            showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
                            sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)
                        },
                        calendarFormat: {
                            firstMonthProperty: powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1),
                            firstDayProperty: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),
                            weekDayProperty: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))
                        }
                    };
                    return timelineFormat;
                }, Timeline.prototype.fillCells = function(cellFormat) {
                    var _this = this, dataPoints = this.timelineData.timelineDatapoints, cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);
                    cellSelection.attr("fill", function(d) {
                        return Utils.getCellColor(d, _this.timelineData, cellFormat);
                    });
                }, Timeline.prototype.renderCells = function(timelineData, timelineFormat, timelineProperties, suppressAnimations) {
                    var _this = this, allDataPoints = timelineData.timelineDatapoints, totalX = 0, cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);
                    cellsSelection.enter().append("rect").classed(this.timelineSelectors.CellRect["class"], !0), 
                    cellsSelection.attr({
                        height: px(timelineProperties.cellHeight),
                        width: function(d) {
                            return px(d.datePeriod.fraction * timelineProperties.cellWidth);
                        },
                        x: function(d) {
                            var value = totalX;
                            return totalX += d.datePeriod.fraction * timelineProperties.cellWidth, px(value);
                        },
                        y: px(timelineProperties.cellsYPosition),
                        id: function(d) {
                            return d.index;
                        }
                    });
                    var clickHandler = function(d, index) {
                        d3.event.preventDefault();
                        var cursorDataPoints = _this.timelineData.cursorDataPoints, keyEvent = d3.event;
                        keyEvent.altKey || keyEvent.shiftKey ? _this.timelineData.selectionEndIndex < index ? (cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction, 
                        timelineData.selectionEndIndex = index) : (cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                        timelineData.selectionStartIndex = index) : (timelineData.selectionStartIndex = index, 
                        timelineData.selectionEndIndex = index, cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                        cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction), 
                        _this.fillCells(timelineFormat.cellFormat), _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition), 
                        _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), _this.setSelection(timelineData);
                    };
                    cellsSelection.on("click", clickHandler).on("touchstart", clickHandler), this.fillCells(timelineFormat.cellFormat), 
                    cellsSelection.exit().remove();
                }, Timeline.prototype.dragstarted = function() {
                    this.timelineData.dragging = !0;
                }, Timeline.prototype.dragged = function(currentCursor) {
                    if (this.timelineData.dragging === !0) {
                        var xScale = 1, container = d3.select(this.timelineSelectors.TimelineVisual.selector);
                        if (container) {
                            var transform = container.style("transform");
                            if (void 0 !== transform && "none" !== transform) {
                                var str = transform.split("(")[1];
                                xScale = Number(str.split(", ")[0]);
                            }
                        }
                        var cursorOverElement = this.findCursorOverElement(d3.event.x);
                        if (!cursorOverElement) return;
                        var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;
                        0 === currentCursor.cursorIndex && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex && (this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex, 
                        this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index), 
                        1 === currentCursor.cursorIndex && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex && (this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex, 
                        this.timelineData.cursorDataPoints[1].selectionIndex = currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction), 
                        this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
                    }
                }, Timeline.prototype.findCursorOverElement = function(x) {
                    var timelineDatapoints = this.timelineData.timelineDatapoints || [], length = timelineDatapoints.length, cellWidth = this.timelineProperties.cellWidth;
                    if (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) return {
                        index: 0,
                        datapoint: timelineDatapoints[0]
                    };
                    if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) return {
                        index: length - 1,
                        datapoint: timelineDatapoints[length - 1]
                    };
                    for (var i = 1; length > i; i++) {
                        var left = timelineDatapoints[i].index * cellWidth, right = timelineDatapoints[i + 1].index * cellWidth;
                        if (x >= left && right >= x) return {
                            index: i,
                            datapoint: timelineDatapoints[i]
                        };
                    }
                    return null;
                }, Timeline.prototype.dragended = function() {
                    this.setSelection(this.timelineData);
                }, Timeline.prototype.renderCursors = function(timelineData, timelineFormat, cellHeight, cellsYPosition) {
                    var _this = this, cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);
                    return cursorSelection.enter().append("path").classed(this.timelineSelectors.SelectionCursor["class"], !0), 
                    cursorSelection.attr("transform", function(d) {
                        return visuals.SVGUtil.translate(d.selectionIndex * _this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition);
                    }).attr({
                        d: d3.svg.arc().innerRadius(0).outerRadius(cellHeight / 2).startAngle(function(d) {
                            return d.cursorIndex * Math.PI + Math.PI;
                        }).endAngle(function(d) {
                            return d.cursorIndex * Math.PI + 2 * Math.PI;
                        })
                    }).call(this.drag), cursorSelection.exit().remove(), cursorSelection;
                }, Timeline.prototype.renderTimeRangeText = function(timelineData, timeRangeFormat) {
                    var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth, maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;
                    if (timeRangeFormat.showProperty && maxWidth > 0) {
                        var timeRangeText = Utils.timeRangeText(timelineData), labelFormattedTextOptions = {
                            label: timeRangeText,
                            maxWidth: maxWidth,
                            fontSize: timeRangeFormat.sizeProperty
                        }, actualText = visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                        this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer["class"], !0), 
                        this.rangeText.attr({
                            x: GranularityNames.length * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),
                            y: 40,
                            fill: timeRangeFormat.colorProperty
                        }).style({
                            "font-size": pt(timeRangeFormat.sizeProperty)
                        }).text(actualText).append("title").text(timeRangeText);
                    } else this.rangeText.text("");
                }, Timeline.prototype.setSelection = function(timelineData) {
                    this.requiresNoUpdate = !0;
                    var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData)), upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1)), filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper), filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr), objects = {
                        merge: [ {
                            objectName: "general",
                            selector: void 0,
                            properties: {
                                filter: filter
                            }
                        } ]
                    };
                    this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                        data: []
                    });
                }, Timeline.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "rangeHeader":
                        this.enumerateRangeHeader(enumeration, this.dataView);
                        break;

                      case "cells":
                        this.enumerateCells(enumeration, this.dataView);
                        break;

                      case "labels":
                        this.enumerateLabels(enumeration, this.dataView);
                        break;

                      case "calendar":
                        this.enumerateCalendar(enumeration, this.dataView);
                        break;

                      case "weekDay":
                        this.enumerateWeekDay(enumeration, this.dataView);
                    }
                    return enumeration.complete();
                }, Timeline.prototype.enumerateRangeHeader = function(enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                    enumeration.pushInstance({
                        objectName: "rangeHeader",
                        displayName: "Selection Color",
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
                            textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                        }
                    });
                }, Timeline.prototype.enumerateCells = function(enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                    enumeration.pushInstance({
                        objectName: "cells",
                        selector: null,
                        properties: {
                            fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),
                            fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)
                        }
                    });
                }, Timeline.prototype.enumerateLabels = function(enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                    enumeration.pushInstance({
                        objectName: "labels",
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
                            textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                        }
                    });
                }, Timeline.prototype.enumerateCalendar = function(enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                    enumeration.pushInstance({
                        objectName: "calendar",
                        selector: null,
                        properties: {
                            month: Math.max(1, Math.min(12, powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1))),
                            day: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, 1)))
                        }
                    });
                }, Timeline.prototype.enumerateWeekDay = function(enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                    enumeration.pushInstance({
                        objectName: "weekDay",
                        selector: null,
                        properties: {
                            day: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, 0)))
                        }
                    });
                }, Timeline.capabilities = {
                    dataRoles: [ {
                        name: "Time",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Time"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Time: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Time"
                                },
                                dataReductionAlgorithm: {
                                    sample: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Time"
                                    }
                                } ]
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                },
                                selected: {
                                    type: {
                                        bool: !0
                                    }
                                },
                                filter: {
                                    type: {
                                        filter: {}
                                    },
                                    rule: {
                                        output: {
                                            property: "selected",
                                            selector: [ "Time" ]
                                        }
                                    }
                                }
                            }
                        },
                        calendar: {
                            displayName: "Fiscal Year Start",
                            properties: {
                                month: {
                                    displayName: "Month",
                                    type: {
                                        enumeration: samples.Months
                                    }
                                },
                                day: {
                                    displayName: "Day",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        weekDay: {
                            displayName: "First Day of Week",
                            properties: {
                                day: {
                                    displayName: "Day",
                                    type: {
                                        enumeration: samples.WeekDays
                                    }
                                }
                            }
                        },
                        rangeHeader: {
                            displayName: "Range Header",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                fontColor: {
                                    displayName: "Font color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                textSize: {
                                    displayName: "Text Size",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        cells: {
                            displayName: "Cells",
                            properties: {
                                fillSelected: {
                                    displayName: "Selected cell color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fillUnselected: {
                                    displayName: "Unselected cell color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: "Labels",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                fontColor: {
                                    displayName: "Font color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                textSize: {
                                    displayName: "Text Size",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        }
                    }
                }, Timeline;
            }();
            samples.Timeline = Timeline;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter, SelectionManager = visuals.utility.SelectionManager, StreamGraphAxisGraphicsContextClassName = "axisGraphicsContext", StreamGraphXAxisClassName = "x axis", StreamGraphYAxisClassName = "y axis", StreamGraphDefaultAxisColor = "#777", StreamGraphDefaultFontSizeInPoints = 8, DefaultLegendFontSizeInPt = 8, DefaultLegendLabelFillColor = "#666666", StreamGraphDefaultFontFamily = "wf_segoe-ui_normal", StreamGraphDefaultFontWeight = "normal", StreamGraphDefaultSettings = {
                legendSettings: {
                    show: !0,
                    showTitle: !0,
                    labelColor: DefaultLegendLabelFillColor,
                    titleText: "",
                    fontSize: DefaultLegendFontSizeInPt
                },
                categoryAxisSettings: {
                    show: !0,
                    axisColor: StreamGraphDefaultAxisColor,
                    showAxisTitle: !1
                },
                valueAxisSettings: {
                    show: !0,
                    axisColor: StreamGraphDefaultAxisColor,
                    showAxisTitle: !1
                }
            }, StreamGraph = function() {
                function StreamGraph() {
                    this.margin = {
                        left: 45,
                        right: 20,
                        bottom: 20,
                        top: 20
                    };
                }
                return StreamGraph.prototype.converter = function(dataView, colors) {
                    if (!(dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.categories)) return null;
                    for (var valueFormatter, categoryFormatter, catDv = dataView.categorical, values = catDv.values, dataPoints = [], legendData = {
                        dataPoints: [],
                        title: values[0].source.displayName,
                        fontSize: StreamGraphDefaultFontSizeInPoints
                    }, value = 0, i = 0; i < values.length; i++) {
                        dataPoints.push([]), values[i].source.groupName && legendData.dataPoints.push({
                            label: values[i].source.groupName,
                            color: colors.getColorByIndex(i).value,
                            icon: visuals.LegendIcon.Box,
                            selected: !1,
                            identity: visuals.SelectionId.createWithId(values[i].identity)
                        });
                        for (var k = 0; k < values[i].values.length; k++) {
                            var id = visuals.SelectionIdBuilder.builder().withSeries(dataView.categorical.values, dataView.categorical.values[i]).createSelectionId(), y = values[i].values[k];
                            y > value && (value = y), dataPoints[i].push({
                                x: k,
                                y: y,
                                identity: id
                            });
                        }
                    }
                    var streamGraphSettings = this.parseSettings(dataView);
                    return valueFormatter = ValueFormatter.create({
                        format: "g",
                        value: value
                    }), categoryFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(catDv.categories[0].source, StreamGraph.Properties.general.formatString),
                        value: catDv.categories[0].values
                    }), {
                        dataPoints: dataPoints,
                        legendData: legendData,
                        valueFormatter: valueFormatter,
                        categoryFormatter: categoryFormatter,
                        streamGraphSettings: streamGraphSettings
                    };
                }, StreamGraph.prototype.parseSettings = function(dataView) {
                    if (!dataView || !dataView.metadata) return StreamGraphDefaultSettings;
                    var objects = dataView.metadata.objects, streamGraphSettings = _.clone(StreamGraphDefaultSettings), categoryAxisSettings = streamGraphSettings.categoryAxisSettings;
                    categoryAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show), 
                    categoryAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.axisColor, categoryAxisSettings.axisColor), 
                    categoryAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);
                    var valueAxisSettings = streamGraphSettings.valueAxisSettings;
                    return valueAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show), 
                    valueAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.axisColor, valueAxisSettings.axisColor), 
                    valueAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle), 
                    streamGraphSettings;
                }, StreamGraph.prototype.init = function(options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({
                        hostServices: options.host
                    }), this.svg = d3.select(element.get(0)).append("svg").classed(StreamGraph.VisualClassName, !0).style("position", "absolute"), 
                    this.axisGraphicsContext = this.svg.append("g").classed(StreamGraphAxisGraphicsContextClassName, !0), 
                    this.xAxis = this.axisGraphicsContext.append("g").classed(StreamGraphXAxisClassName, !0), 
                    this.yAxis = this.axisGraphicsContext.append("g").classed(StreamGraphYAxisClassName, !0), 
                    this.colors = options.style.colorPalette.dataColors, this.legend = visuals.createLegend(element, !1, null, !0);
                }, StreamGraph.prototype.update = function(options) {
                    var _this = this;
                    if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) return void this.clearData();
                    this.viewport = {
                        width: Math.max(0, options.viewport.width),
                        height: Math.max(0, options.viewport.height)
                    };
                    var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors);
                    if (!data || !data.dataPoints || !data.dataPoints.length) return void this.clearData();
                    var dataPoints = data.dataPoints;
                    this.renderLegend(data), this.updateViewPort(), this.renderXAxisLabels(), this.renderYAxisLabels();
                    var height = Math.max(0, this.viewport.height - this.margin.top);
                    this.svg.attr({
                        width: this.viewport.width,
                        height: height
                    });
                    var stack = d3.layout.stack();
                    this.getWiggle(dataView) && stack.offset("wiggle");
                    var layers = stack(dataPoints), xScale = d3.scale.linear().domain([ 0, dataPoints[0].length - 1 ]).range([ this.margin.left, this.viewport.width - this.margin.right ]), yScale = d3.scale.linear().domain([ 0, d3.max(layers, function(layer) {
                        return d3.max(layer, function(d) {
                            return d.y0 + d.y;
                        });
                    }) ]).range([ height - this.margin.bottom, this.margin.top ]), area = d3.svg.area().interpolate("basis").x(function(d) {
                        return xScale(d.x);
                    }).y0(function(d) {
                        return yScale(d.y0);
                    }).y1(function(d) {
                        return yScale(d.y0 + d.y);
                    }), selectionManager = this.selectionManager, selection = this.svg.selectAll(StreamGraph.Layer.selector).data(layers);
                    selection.enter().append("path").classed(StreamGraph.Layer["class"], !0), selection.style("fill", function(d, i) {
                        return _this.colors.getColorByIndex(i).value;
                    }).on("click", function(d) {
                        var _this = this;
                        selectionManager.select(d[0].identity).then(function(ids) {
                            ids.length > 0 ? (selection.style("opacity", .5), d3.select(_this).style("opacity", 1)) : selection.style("opacity", 1);
                        });
                    }).transition().duration(duration).attr("d", area), selection.exit().remove(), this.drawAxis(data, xScale, yScale);
                }, StreamGraph.prototype.drawAxis = function(data, xScale, yScale) {
                    var _this = this, shiftY = this.viewport.height - this.margin.bottom - this.margin.top, shiftX = this.viewport.width - this.margin.left - this.margin.right, xAxis = d3.svg.axis();
                    xAxis.scale(xScale).orient("bottom").tickFormat(function(item, index) {
                        return data.categoryFormatter && (item = data.categoryFormatter.format(item)), null == index || !xAxis.tickValues() || 0 !== index && index !== xAxis.tickValues().length - 1 || (item = powerbi.TextMeasurementService.getTailoredTextOrDefault(StreamGraph.getTextPropertiesFunction(item), 2 * (index ? _this.margin.right : _this.margin.left))), 
                        item;
                    }.bind(xAxis));
                    var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(function(item) {
                        return data.valueFormatter ? data.valueFormatter.format(item) : item;
                    });
                    this.setMaxTicks(xAxis, shiftX, StreamGraph.MaxNumberOfAxisXValues), this.setMaxTicks(yAxis, shiftY);
                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                    if (valueAxisSettings.show) {
                        var axisColor = valueAxisSettings.axisColor;
                        this.yAxis.attr("transform", visuals.SVGUtil.translate(this.margin.left, 0)).call(yAxis), 
                        this.yAxis.selectAll("text").style("fill", axisColor);
                    } else this.yAxis.selectAll("*").remove();
                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                    if (categoryAxisSettings.show) {
                        var axisColor = categoryAxisSettings.axisColor;
                        this.xAxis.attr("transform", visuals.SVGUtil.translate(0, shiftY)).call(xAxis), 
                        this.xAxis.selectAll("text").style("fill", axisColor);
                    } else this.xAxis.selectAll("*").remove();
                }, StreamGraph.prototype.renderYAxisLabels = function() {
                    this.yAxis.selectAll(StreamGraph.YAxisLabel.selector).remove();
                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                    if (valueAxisSettings.show) {
                        if (this.margin.left = 45, valueAxisSettings.showAxisTitle) if (this.dataView.categorical.values.source) {
                            var marginLeft_1 = this.margin.left = 65, categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings, isXAxisOn = categoryAxisSettings.show === !0, isXTitleOn = categoryAxisSettings.showAxisTitle === !0, height_1 = isXAxisOn ? isXTitleOn ? this.viewport.height - this.margin.bottom : this.viewport.height - this.margin.top : this.viewport.height, yAxisText = this.dataView.categorical.values.source.displayName, yAxisClass_1 = StreamGraph.YAxisLabel["class"], yAxisLabel = this.yAxis.append("text").style("text-anchor", "middle").text(yAxisText).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": yAxisClass_1,
                                        transform: "rotate(-90)",
                                        y: -marginLeft_1 + 5,
                                        x: -(height_1 / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height_1, powerbi.TextMeasurementService.svgEllipsis);
                        } else valueAxisSettings.showAxisTitle = !1;
                    } else this.margin.left = 20;
                }, StreamGraph.prototype.renderXAxisLabels = function() {
                    this.xAxis.selectAll(StreamGraph.XAxisLabel.selector).remove();
                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                    if (categoryAxisSettings.show) {
                        if (this.margin.bottom = 20, categoryAxisSettings.showAxisTitle) if (this.dataView.categorical.categories[0].source) {
                            var marginBottom_1 = this.margin.bottom = 40, valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings, isYAxisOn = valueAxisSettings.show === !0, isYTitleOn = valueAxisSettings.showAxisTitle === !0, width_1 = isYAxisOn ? isYTitleOn ? this.viewport.width + this.margin.left : this.viewport.width + this.margin.right : this.viewport.width, xAxisText = this.dataView.categorical.categories[0].source.displayName, xAxisClass_1 = StreamGraph.XAxisLabel["class"], xAxisLabel = this.xAxis.append("text").style("text-anchor", "middle").text(xAxisText).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": xAxisClass_1,
                                        transform: visuals.SVGUtil.translate(width_1 / 2, marginBottom_1 - 5)
                                    });
                                });
                            });
                            xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width_1, powerbi.TextMeasurementService.svgEllipsis);
                        } else categoryAxisSettings.showAxisTitle = !1;
                    } else this.margin.bottom = 10;
                }, StreamGraph.prototype.renderLegend = function(streamGraphData) {
                    var legendData = streamGraphData.legendData;
                    if (legendData && this.dataView && this.dataView.metadata) {
                        if (this.legendObjectProperties = powerbi.DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {}), 
                        this.legendObjectProperties) {
                            visuals.LegendData.update(legendData, this.legendObjectProperties);
                            var position = this.legendObjectProperties[visuals.legendProps.position];
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                        this.legend.drawLegend(legendData, _.clone(this.viewport)), visuals.Legend.positionChartArea(this.svg, this.legend);
                    }
                }, StreamGraph.prototype.updateViewPort = function() {
                    var legendMargins = this.legend.getMargins(), legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                      case visuals.LegendPosition.Top:
                      case visuals.LegendPosition.TopCenter:
                      case visuals.LegendPosition.Bottom:
                      case visuals.LegendPosition.BottomCenter:
                        this.viewport.height -= legendMargins.height;
                        break;

                      case visuals.LegendPosition.Left:
                      case visuals.LegendPosition.LeftCenter:
                      case visuals.LegendPosition.Right:
                      case visuals.LegendPosition.RightCenter:
                        this.viewport.width -= legendMargins.width;
                    }
                }, StreamGraph.prototype.setMaxTicks = function(axis, maxSize, maxValue) {
                    var maxTicks = void 0 === maxValue ? this.getTicksByAxis(axis).length : Math.min(maxValue, this.getTicksByAxis(axis).length);
                    axis.scale().domain.toString() === d3.scale.linear().domain.toString() ? axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks)) : axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
                }, StreamGraph.prototype.getFittedTickLength = function(axis, maxSize, maxTicks) {
                    for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([ maxTicks ]).length > maxTicks); maxTicks--, 
                    ticks = this.getTicksByAxis(axis)) axis.ticks(maxTicks);
                    return maxTicks;
                }, StreamGraph.prototype.getFittedTickValues = function(axis, maxSize, maxTicks) {
                    for (var maxWidthOf2Ticks, ticks = this.getTicksByAxis(axis), tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks), currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, 
                    indexes = []) {
                        switch (currentMaxTicks) {
                          case 0:
                            return [];

                          case 1:
                            indexes = [ 0 ];
                            break;

                          case 2:
                            indexes = [ 0, ticks.length - 1 ];
                            break;

                          default:
                            for (var takeEvery = ticks.length / (currentMaxTicks - 1), i = 0; currentMaxTicks - 1 > i; i++) indexes.push(Math.round(takeEvery * i));
                            indexes.push(ticks.length - 1);
                        }
                        var ticksIndexes = indexes.map(function(x) {
                            return [ ticks[x], x ];
                        });
                        if (maxWidthOf2Ticks = maxSize / ticks.length * 2, ticksIndexes.reduce(function(a, b) {
                            return tickPairsWidths.push([ measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks ]), 
                            b;
                        }), !tickPairsWidths.some(function(x) {
                            return x[0] > x[1];
                        })) return ticksIndexes.map(function(x) {
                            return x[0];
                        });
                    }
                    return [];
                }, StreamGraph.prototype.measureTicks = function(ticks, measureTickFunction) {
                    return ticks.map(function(x) {
                        return measureTickFunction(x);
                    }).reduce(function(a, b) {
                        return a + b;
                    });
                }, StreamGraph.prototype.getTicksByAxis = function(axis) {
                    var scale = axis.scale(), result = null === axis.tickValues() ? scale.ticks ? scale.ticks.apply(scale, axis.ticks()) : scale.domain() : axis.tickValues();
                    return void 0 === result.length ? [ result ] : result;
                }, StreamGraph.prototype.getMeasureTickFunction = function(axis, ticks) {
                    var measureFunction = "top" === axis.orient() || "bottom" === axis.orient() ? powerbi.TextMeasurementService.measureSvgTextWidth : powerbi.TextMeasurementService.measureSvgTextHeight, cache = {};
                    return function(x) {
                        return cache[x] ? cache[x] : cache[x] = measureFunction(StreamGraph.getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
                    };
                }, StreamGraph.getTextPropertiesFunction = function(text) {
                    var fontFamily = StreamGraphDefaultFontFamily, fontSize = jsCommon.PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;
                    return {
                        text: text,
                        fontFamily: fontFamily,
                        fontSize: fontSize,
                        fontWeight: fontWeight
                    };
                }, StreamGraph.prototype.getWiggle = function(dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = powerbi.DataViewObjects.getObject(objects, "general", void 0);
                            if (general) return general.wiggle;
                        }
                    }
                    return !0;
                }, StreamGraph.prototype.enumerateValueAxisValues = function(enumeration) {
                    var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;
                    enumeration.pushInstance({
                        selector: null,
                        objectName: "valueAxis",
                        displayName: "Y-Axis",
                        properties: {
                            show: valueAxisSettings.show,
                            showAxisTitle: valueAxisSettings.showAxisTitle,
                            axisColor: valueAxisSettings.axisColor
                        }
                    });
                }, StreamGraph.prototype.enumerateCategoryAxisValues = function(enumeration) {
                    var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;
                    enumeration.pushInstance({
                        selector: null,
                        objectName: "categoryAxis",
                        displayName: "X-Axis",
                        properties: {
                            show: categoryAxisSettings.show,
                            showAxisTitle: categoryAxisSettings.showAxisTitle,
                            axisColor: categoryAxisSettings.axisColor
                        }
                    });
                }, StreamGraph.prototype.enumerateLegend = function(enumeration) {
                    var legendSettings = this.legendObjectProperties ? this.legendObjectProperties : {};
                    enumeration.pushInstance({
                        selector: null,
                        objectName: "legend",
                        displayName: "Legend",
                        properties: {
                            show: this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings.show : !0,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.showTitle, !0),
                            titleText: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.titleText, ""),
                            labelColor: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.labelColor, DefaultLegendLabelFillColor),
                            fontSize: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.fontSize, DefaultLegendFontSizeInPt)
                        }
                    });
                }, StreamGraph.prototype.clearData = function() {
                    this.svg.selectAll(StreamGraph.Layer.selector).remove(), this.legend.drawLegend({
                        dataPoints: []
                    }, this.viewport), this.yAxis.selectAll("*").remove(), this.xAxis.selectAll("*").remove();
                }, StreamGraph.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), dataView = this.dataView;
                    switch (options.objectName) {
                      case "legend":
                        dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.source && this.enumerateLegend(enumeration);
                        break;

                      case "categoryAxis":
                        this.enumerateCategoryAxisValues(enumeration);
                        break;

                      case "valueAxis":
                        this.enumerateValueAxisValues(enumeration);
                        break;

                      case "general":
                        var general = {
                            objectName: "general",
                            displayName: "General",
                            selector: null,
                            properties: {
                                wiggle: this.getWiggle(dataView)
                            }
                        };
                        enumeration.pushInstance(general);
                    }
                    return enumeration.complete();
                }, StreamGraph.VisualClassName = "streamGraph", StreamGraph.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        }
                    },
                    categoryAxis: {
                        show: {
                            objectName: "categoryAxis",
                            propertyName: "show"
                        },
                        axisColor: {
                            objectName: "categoryAxis",
                            propertyName: "axisColor"
                        },
                        showAxisTitle: {
                            objectName: "categoryAxis",
                            propertyName: "showAxisTitle"
                        }
                    },
                    valueAxis: {
                        show: {
                            objectName: "valueAxis",
                            propertyName: "show"
                        },
                        axisColor: {
                            objectName: "valueAxis",
                            propertyName: "axisColor"
                        },
                        showAxisTitle: {
                            objectName: "valueAxis",
                            propertyName: "showAxisTitle"
                        }
                    }
                }, StreamGraph.Layer = {
                    "class": "layer",
                    selector: ".layer"
                }, StreamGraph.XAxisLabel = {
                    "class": "xAxisLabel",
                    selector: ".xAxisLabel"
                }, StreamGraph.YAxisLabel = {
                    "class": "yAxisLabel",
                    selector: ".yAxisLabel"
                }, StreamGraph.MaxNumberOfAxisXValues = 5, StreamGraph.capabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Category"
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Series"
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                min: 1,
                                max: 1
                            },
                            Y: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    bottom: {}
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        "for": {
                                            "in": "Y"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        bottom: {}
                                    }
                                }
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                },
                                wiggle: {
                                    type: {
                                        bool: !0
                                    },
                                    displayName: "Wiggle"
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: "X-Axis",
                            properties: {
                                show: {
                                    displayName: "show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                showAxisTitle: {
                                    displayName: "Title",
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        valueAxis: {
                            displayName: "Y-Axis",
                            properties: {
                                show: {
                                    displayName: "show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                showAxisTitle: {
                                    displayName: "Title",
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        legend: {
                            displayName: "Legend",
                            properties: {
                                show: {
                                    displayName: "show",
                                    type: {
                                        bool: !0
                                    }
                                },
                                position: {
                                    displayName: "Position",
                                    type: {
                                        enumeration: visuals.legendPosition.type
                                    }
                                },
                                showTitle: {
                                    displayName: "Title",
                                    type: {
                                        bool: !0
                                    }
                                },
                                titleText: {
                                    displayName: "Legend Name",
                                    type: {
                                        text: !0
                                    },
                                    suppressFormatPainterCopy: !0
                                },
                                labelColor: {
                                    displayName: "Color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: {
                                        formatting: {
                                            fontSize: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, StreamGraph;
            }();
            samples.StreamGraph = StreamGraph;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            samples.sunburstRoleNames = {
                nodes: "Nodes",
                values: "Values"
            };
            var Sunburst = function() {
                function Sunburst() {
                    this.total = 0;
                }
                return Sunburst.prototype.init = function(options) {
                    var _this = this;
                    this.arc = d3.svg.arc().startAngle(function(d) {
                        return d.x;
                    }).endAngle(function(d) {
                        return d.x + d.dx;
                    }).innerRadius(function(d) {
                        return Math.sqrt(d.y);
                    }).outerRadius(function(d) {
                        return Math.sqrt(d.y + d.dy);
                    }), this.colors = options.style.colorPalette.dataColors, this.selectionManager = new SelectionManager({
                        hostServices: options.host
                    }), this.svg = d3.select(options.element.get(0)).append("svg"), this.svg.classed("mainDrawArea", !0), 
                    this.g = this.svg.append("g"), this.g.classed("container", !0), this.svg.append("text").classed("sunBurstPercentageFixed", !0), 
                    this.svg.on("mousedown", function(d) {
                        _this.svg.selectAll("path").style("opacity", 1), _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0), 
                        _this.selectionManager.clear();
                    });
                }, Sunburst.setAllUnhide = function(selection) {
                    selection.attr("setUnHide", "true");
                }, Sunburst.prototype.update = function(options) {
                    if (options.dataViews.length > 0) {
                        var data = this.converter(options.dataViews[0], this.colors);
                        this.viewport = options.viewport, this.updateInternal(data);
                    }
                }, Sunburst.prototype.updateInternal = function(dataRootNode) {
                    var _this = this;
                    this.svg.attr({
                        height: this.viewport.height,
                        width: this.viewport.width
                    }), this.g.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                    var radius = Math.min(this.viewport.width, this.viewport.height) / 2, partition = d3.layout.partition().size([ 2 * Math.PI, radius * radius ]).value(function(d) {
                        return d.value;
                    }), path = this.g.datum(dataRootNode).selectAll("path").data(partition.nodes);
                    path.enter().append("path"), path.attr("display", function(d) {
                        return d.depth ? null : "none";
                    }).attr("d", this.arc).style("stroke", "#fff").style("fill", function(d) {
                        return d.color;
                    }).style("fill-rule", "evenodd").on("mousedown", function(d) {
                        d.selector && _this.selectionManager.select(d.selector), d3.selectAll("path").call(Sunburst.setAllUnhide).attr("setUnHide", null), 
                        _this.highlightPath(d, _this, !0);
                        var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed"), percentage = 0 === _this.total ? 0 : (100 * d.total / _this.total).toPrecision(3);
                        percentageFixedText.text(d ? percentage + "%" : ""), percentageFixedText.style("fill", d.color), 
                        _this.onResize(), event.stopPropagation();
                    }), this.renderTooltip(path), path.exit().remove(), this.onResize();
                }, Sunburst.getTreePath = function(node) {
                    for (var path = [], current = node; current.parent; ) path.unshift(current), current = current.parent;
                    return path;
                }, Sunburst.prototype.onResize = function() {
                    var width = this.viewport.width, height = this.viewport.height, percentageFixedText = this.svg.select(".sunBurstPercentageFixed"), textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
                    percentageFixedText.style("opacity", 1), percentageFixedText.attr("y", height / 2 + 4), 
                    percentageFixedText.attr("x", width / 2 - textWidth / 2);
                }, Sunburst.prototype.highlightPath = function(d, sunBurst, setUnhide) {
                    var parentsArray = d ? Sunburst.getTreePath(d) : [];
                    sunBurst.svg.selectAll("path").each(function() {
                        "true" !== d3.select(this).attr("setUnHide") && d3.select(this).style("opacity", Sunburst.minOpacity);
                    }), sunBurst.svg.selectAll("path").filter(function(node) {
                        return parentsArray.indexOf(node) >= 0;
                    }).each(function() {
                        d3.select(this).style("opacity", 1), setUnhide === !0 && d3.select(this).attr("setUnHide", "true");
                    });
                }, Sunburst.prototype.renderTooltip = function(selection) {
                    visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                }, Sunburst.getTooltipData = function(displayName, value) {
                    return [ {
                        displayName: displayName,
                        value: 0 > value ? "" : value.toString()
                    } ];
                }, Sunburst.prototype.covertTreeNodeToSunBurstNode = function(originParentNode, sunburstParentNode, colors, pathIdentity, color) {
                    var selector;
                    originParentNode.identity && (pathIdentity = pathIdentity.concat([ originParentNode.identity ]), 
                    selector = {
                        data: pathIdentity
                    });
                    var selectionId = 0 === pathIdentity.length ? null : new visuals.SelectionId(selector, !1), valueToSet = originParentNode.values ? originParentNode.values[0].value : 0, newSunNode = {
                        name: originParentNode.name,
                        value: Math.max(valueToSet, 0),
                        selector: selectionId,
                        total: valueToSet
                    };
                    if (originParentNode.value && (newSunNode.color = color ? color : colors.getColor(originParentNode.value).value), 
                    this.total += newSunNode.value, originParentNode.children && originParentNode.children.length > 0) {
                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1), newSunNode.children = [];
                        for (var i = 0; i < originParentNode.children.length; i++) {
                            var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
                            newSunNode.children.push(newChild), newSunNode.total += newChild.total;
                        }
                    } else newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
                    return sunburstParentNode && (newSunNode.parent = sunburstParentNode), newSunNode;
                }, Sunburst.prototype.converter = function(dataView, colors) {
                    var colorScale = colors.getNewColorScale();
                    this.total = 0;
                    var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], void 0);
                    return root;
                }, Sunburst.minOpacity = .2, Sunburst.roleNames = {
                    nodes: "Nodes",
                    values: "Values"
                }, Sunburst.capabilities = {
                    dataRoles: [ {
                        name: Sunburst.roleNames.nodes,
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Groups"
                    }, {
                        name: Sunburst.roleNames.values,
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Values"
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Groups: {
                                min: 0
                            },
                            Values: {
                                max: 1
                            }
                        } ],
                        matrix: {
                            rows: {
                                "for": {
                                    "in": Sunburst.roleNames.nodes
                                }
                            },
                            values: {
                                "for": {
                                    "in": Sunburst.roleNames.values
                                }
                            }
                        }
                    } ]
                }, Sunburst;
            }();
            samples.Sunburst = Sunburst;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var samples;
        !function(samples) {
            var SelectionManager = visuals.utility.SelectionManager, LineDotChart = function() {
                function LineDotChart() {
                    this.margin = {
                        top: 10,
                        right: 30,
                        bottom: 10,
                        left: 10
                    }, this.LegendSize = 50, this.AxisSize = 30;
                }
                return LineDotChart.prototype.init = function(options) {
                    var _this = this;
                    this.hostServices = options.host, this.selectionManager = new SelectionManager({
                        hostServices: this.hostServices
                    }), this.root = d3.select(options.element.get(0)).append("svg").classed(LineDotChart.Identity["class"], !0), 
                    this.root.on("click", function(d) {
                        _this.clearSelection();
                    }), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(LineDotChart.Axes["class"], !0), 
                    this.axisX = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), this.axisY = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), 
                    this.axisY2 = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), this.legends = this.main.append("g").classed(LineDotChart.Legends["class"], !0), 
                    this.line = this.main.append("g").classed(LineDotChart.Values["class"], !0), this.colors = options.style && options.style.colorPalette ? options.style.colorPalette.dataColors : new visuals.DataColorPalette();
                }, LineDotChart.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        var viewport = options.viewport, model = this.model = this.converter(options.dataViews[0], viewport);
                        this.clearSelection(), this.resize(viewport), this.draw(model);
                    }
                }, LineDotChart.prototype.destroy = function() {
                    this.root = null;
                }, LineDotChart.prototype.setIsStopped = function(isstopped) {
                    var objects = {
                        merge: [ {
                            objectName: "misc",
                            selector: void 0,
                            properties: {
                                isstopped: isstopped
                            }
                        } ]
                    };
                    this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                        data: []
                    });
                }, LineDotChart.prototype.enumerateObjectInstances = function(options) {
                    var instances = [];
                    if (!this.model || !this.model.settings) return instances;
                    var settings = this.model.settings;
                    switch (options.objectName) {
                      case "lineoptions":
                        var lineoptions = {
                            objectName: "lineoptions",
                            displayName: "lineoptions",
                            selector: null,
                            properties: {
                                fill: settings.lineFill,
                                lineThickness: settings.lineThickness
                            }
                        };
                        instances.push(lineoptions);
                        break;

                      case "dotoptions":
                        var dotoptions = {
                            objectName: "dotoptions",
                            displayName: "dotoptions",
                            selector: null,
                            properties: {
                                color: settings.dotFill,
                                dotSizeMin: settings.dotSizeMin,
                                dotSizeMax: settings.dotSizeMax
                            }
                        };
                        instances.push(dotoptions);
                        break;

                      case "counteroptions":
                        var counteroptions = {
                            objectName: "counteroptions",
                            displayName: "counteroptions",
                            selector: null,
                            properties: {
                                counterTitle: settings.counterTitle
                            }
                        };
                        instances.push(counteroptions);
                        break;

                      case "misc":
                        var misc = {
                            objectName: "misc",
                            displayName: "misc",
                            selector: null,
                            properties: {
                                isanimated: settings.isanimated,
                                isstopped: settings.isstopped,
                                duration: settings.duration
                            }
                        };
                        instances.push(misc);
                    }
                    return instances;
                }, LineDotChart.prototype.selectDot = function(dotelement, selector) {
                    var dot = d3.select(dotelement);
                    dot.classed("point_selected") ? this.clearSelection() : (selector && this.selectionManager.select(selector), 
                    this.root.classed("filtered", !0), this.line.selectAll("circle.point").classed("point_selected", !1), 
                    d3.select(dotelement).classed("point_selected", !0)), d3.event.stopPropagation();
                }, LineDotChart.prototype.clearSelection = function() {
                    this.root.classed("filtered", !1), this.root.selectAll("circle.point").classed("point_selected", !1), 
                    this.selectionManager.clear();
                }, LineDotChart.prototype.converter = function(dataView, viewport) {
                    if (!(dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0 && dataView.categorical && dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && dataView.categorical.values[0].values.length > 0)) return null;
                    var metadataColumn, extent, min, max, values = [], that = this, categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, !0);
                    this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                    var formatter, isScalar = !0, settings = this.parseSettings(dataView), effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize), effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize), format = "";
                    values = dataView.categorical.categories[0].values, metadataColumn = dataView.categorical.categories[0].source, 
                    extent = d3.extent(values), this.isDateTime ? (min = extent[0].getTime(), max = extent[1].getTime(), 
                    min = new Date(min), max = new Date(max + .05 * (max - min)), format = "MMM dd yyyy", 
                    formatter = visuals.valueFormatter.create({
                        format: format
                    })) : (min = extent[0], max = extent[1], max += .05 * (max - min), formatter = visuals.valueFormatter.create({
                        value: 0
                    }));
                    var xAxis = visuals.AxisHelper.createAxis({
                        pixelSpan: effectiveWidth,
                        dataDomain: [ min, max ],
                        metaDataColumn: metadataColumn,
                        formatString: null,
                        outerPadding: 0,
                        isCategoryAxis: !0,
                        isScalar: isScalar,
                        isVertical: !1,
                        forcedTickCount: void 0,
                        useTickIntervalForDisplayUnits: !0,
                        getValueFn: function(index, type) {
                            return that.isDateTime ? formatter.format(new Date(index)) : index;
                        }
                    });
                    xAxis.formatter = formatter, metadataColumn = dataView.categorical.values[0].source, 
                    values = dataView.categorical.values[0].values, extent = d3.extent(values), min = extent[0], 
                    max = extent[1];
                    for (var selector, result = [], value_sum = 0, value = 0, time = 0, i = 0; i < dataView.categorical.categories[0].values.length; i++) value = dataView.categorical.values[0].values[i], 
                    time = dataView.categorical.categories[0].values[i], value_sum += value, selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]), 
                    result.push({
                        dot: (value - min) / (max - min),
                        value: value,
                        sum: value_sum,
                        time: time,
                        selector: selector
                    });
                    value_sum += .1 * (value_sum - min);
                    var yAxis = visuals.AxisHelper.createAxis({
                        pixelSpan: effectiveHeight,
                        dataDomain: [ min, value_sum ],
                        metaDataColumn: metadataColumn,
                        formatString: null,
                        outerPadding: 0,
                        isCategoryAxis: !1,
                        isScalar: !0,
                        isVertical: !0,
                        useTickIntervalForDisplayUnits: !0
                    }), yAxis2 = visuals.AxisHelper.createAxis({
                        pixelSpan: effectiveHeight,
                        dataDomain: [ min, value_sum ],
                        metaDataColumn: metadataColumn,
                        formatString: null,
                        outerPadding: 0,
                        isCategoryAxis: !1,
                        isScalar: !0,
                        isVertical: !0,
                        useTickIntervalForDisplayUnits: !0
                    });
                    return yAxis2.axis.orient("right"), {
                        points: result,
                        settings: settings,
                        xAxis: xAxis,
                        yAxis: yAxis,
                        yAxis2: yAxis2,
                        legends: this.generateAxisLabels(viewport, settings)
                    };
                }, LineDotChart.prototype.parseSettings = function(dataView) {
                    if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                    var objects = dataView.metadata.objects, lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill), dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill), xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle, yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;
                    dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.categories[0].source.displayName && dataView.categorical.values[0] && dataView.categorical.values[0].source && dataView.categorical.values[0].source.displayName && (xAxisTitle = dataView.categorical.categories[0].source.displayName, 
                    yAxisTitle = dataView.categorical.values[0].source.displayName);
                    var lineThickness = LineDotChart.DefaultSettings.lineThickness, dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin, dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax, counterTitle = LineDotChart.DefaultSettings.counterTitle, isanimated = LineDotChart.DefaultSettings.isanimated, isstopped = LineDotChart.DefaultSettings.isstopped, duration = LineDotChart.DefaultSettings.duration;
                    return objects && (lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness), 
                    dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin), 
                    dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax), 
                    counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle), 
                    isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated), 
                    isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped), 
                    duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration)), 
                    {
                        xAxisTitle: xAxisTitle,
                        yAxisTitle: yAxisTitle,
                        lineFill: lineFillColorHelper.getColorForMeasure(objects, ""),
                        lineThickness: lineThickness,
                        dotFill: dotFillColorHelper.getColorForMeasure(objects, ""),
                        dotSizeMin: dotSizeMin,
                        dotSizeMax: dotSizeMax,
                        counterTitle: counterTitle,
                        isstopped: isstopped,
                        isanimated: isanimated,
                        duration: duration
                    };
                }, LineDotChart.prototype.generateAxisLabels = function(viewport, settings) {
                    return [ {
                        transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, viewport.height - this.margin.top - this.margin.bottom),
                        text: settings.xAxisTitle,
                        dx: "1em",
                        dy: "-1em"
                    }, {
                        transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),
                        text: settings.yAxisTitle,
                        dx: "3em"
                    } ];
                }, LineDotChart.prototype.resize = function(viewport) {
                    this.root.attr({
                        height: Math.max(0, viewport.height),
                        width: Math.max(0, viewport.width)
                    }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                    this.legends.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                    this.line.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                    this.axes.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                    this.axisX.attr("transform", visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize)), 
                    this.axisY2.attr("transform", visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));
                }, LineDotChart.prototype.draw = function(model) {
                    var _this = this, that = this;
                    if (this.line.selectAll("*").remove(), this.legends.selectAll("*").remove(), this.axisX.selectAll("*").remove(), 
                    this.axisY.selectAll("*").remove(), this.axisY2.selectAll("*").remove(), model && (this.renderLegends(model), 
                    model && model.points && model.points.length)) {
                        if (this.axisX.call(model.xAxis.axis), this.axisY.call(model.yAxis.axis), this.axisY2.call(model.yAxis2.axis), 
                        model.settings.isanimated) {
                            var playBtn = this.line.append("g").classed("lineDotChart__playBtn", !0).attr("transform", "translate(40, 20)");
                            if (playBtn.append("circle").attr("r", 17), model.settings.isstopped) return playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform", "translate(-4,-8)"), 
                            void playBtn.on("click.lineDotChart__playBt", function() {
                                that.setIsStopped(!1);
                            });
                            playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform-origin", "center").attr("transform", "translate(6, 8) rotate(180)"), 
                            playBtn.append("rect").attr("width", "2").attr("height", "12").attr("transform", "translate(-7,-6)"), 
                            playBtn.on("click.lineDotChart__playBt", function() {
                                that.setIsStopped(!0);
                            });
                        }
                        var clip = this.line.append("clipPath").attr("id", "lineClip").append("rect").attr("x", 0).attr("y", 0).attr("width", 1).attr("height", 1e4), line = d3.svg.line().x(function(d) {
                            return model.xAxis.scale(d.time);
                        }).y(function(d) {
                            return model.yAxis.scale(d.sum);
                        }), lineSelection = this.line.selectAll("path.plot").data([ model.points ]);
                        lineSelection.enter().append("path"), lineSelection.classed("plot", !0).attr("stroke", function(d, i) {
                            return model.settings.lineFill;
                        }).attr("stroke-width", model.settings.lineThickness).attr("d", line);
                        var totalLength = lineSelection.node().getTotalLength(), line_left = lineSelection.node().getPointAtLength(0).x, line_right = lineSelection.node().getPointAtLength(totalLength).x;
                        lineSelection.attr("clip-path", "url(" + location.href + "#lineClip)"), model.settings.isanimated ? clip.attr("x", line_left).interrupt().transition().ease("linear").duration(1e3 * model.settings.duration).attr("width", line_right - line_left) : clip.interrupt().attr("x", line_left).attr("width", line_right - line_left), 
                        lineSelection.exit().remove();
                        var point_time = 300, counter_time = 0, lineTipSelection = this.line.selectAll("circle.point").data(model.points), that = this;
                        lineTipSelection.enter().append("circle").attr("fill", model.settings.dotFill).attr("opacity", .77).attr("r", function(d) {
                            return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin);
                        }).classed("point", !0).on("mouseover.point", this.showDataPoint).on("mouseout.point", this.hideDataPoint).on("click.point", function(d) {
                            that.selectDot(this, d.selector);
                        }), model.settings.isanimated ? lineTipSelection.interrupt().attr("transform", function(d) {
                            return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(0.005)";
                        }).transition().duration(point_time).delay(function(d, i) {
                            return _this.pointDelay(model.points, i, model.settings.duration);
                        }).ease("linear").attr("transform", function(d) {
                            return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(3.4)";
                        }).transition().duration(point_time).delay(function(d, i) {
                            return _this.pointDelay(model.points, i, model.settings.duration) + point_time;
                        }).ease("elastic").attr("transform", function(d) {
                            return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                        }) : lineTipSelection.interrupt().attr("transform", function(d) {
                            return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                        }), lineTipSelection.exit().remove();
                        for (var i = 0; i < lineTipSelection[0].length; i++) this.addTooltip(model, lineTipSelection[0][i]);
                        var lineTextSelection = this.line.selectAll("text").data(model.points);
                        lineTextSelection.enter().append("text").classed("text", !0).text(function(d, i) {
                            return model.settings.counterTitle + " " + (i + 1);
                        }).attr("x", line_right - 260).attr("y", 30), model.settings.isanimated ? lineTextSelection.attr("opacity", 0).interrupt().transition().duration(counter_time).delay(function(d, i) {
                            return _this.pointDelay(model.points, i, model.settings.duration);
                        }).attr("transform", "translate(0 0)").attr("opacity", 1).transition().duration(counter_time).delay(function(d, i) {
                            return model.points[i + 1] ? _this.pointDelay(model.points, i + 1, model.settings.duration) : Number.POSITIVE_INFINITY;
                        }).attr("opacity", 0) : lineTextSelection.interrupt().attr("transform", "translate(0 0)").attr("opacity", function(d, i) {
                            return Number(i === model.points.length - 1);
                        }), lineTextSelection.exit().remove();
                    }
                }, LineDotChart.prototype.pointDelay = function(points, num, animation_duration) {
                    if (!points.length || !points[num] || 0 === num) return 0;
                    if (this.isDateTime) var time = points[num].time, min = points[0].time.getTime(), max = points[points.length - 1].time.getTime(), val = time.getTime(); else var time = points[num].time, min = points[0].time, max = points[points.length - 1].time, val = time;
                    return 1e3 * animation_duration * (val - min) / (max - min);
                }, LineDotChart.prototype.showDataPoint = function(data, index) {
                    d3.select(this).classed("show", !0);
                }, LineDotChart.prototype.hideDataPoint = function(data, index) {
                    d3.select(this).classed("show", !1);
                }, LineDotChart.prototype.addTooltip = function(model, element) {
                    var selection = d3.select(element), data = selection.datum();
                    visuals.TooltipManager.addTooltip(selection, function(event) {
                        return [ {
                            displayName: model.settings.xAxisTitle,
                            value: model.xAxis.formatter.format(data.time)
                        }, {
                            displayName: model.settings.yAxisTitle,
                            value: data.value.toString()
                        } ];
                    });
                }, LineDotChart.prototype.renderLegends = function(model) {
                    var legendSelection = this.legends.selectAll(LineDotChart.Legend.selector).data(model.legends);
                    legendSelection.enter().append("svg:text"), legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                        return item.dx;
                    }).attr("dy", function(item) {
                        return item.dy;
                    }).attr("transform", function(item) {
                        return item.transform;
                    }).text(function(item) {
                        return item.text;
                    }).classed(LineDotChart.Legend["class"], !0), legendSelection.exit().remove();
                }, LineDotChart.DefaultSettings = {
                    lineFill: "rgb(102, 212, 204)",
                    lineThickness: 3,
                    dotFill: "#005c55",
                    dotSizeMin: 4,
                    dotSizeMax: 38,
                    counterTitle: "Total features",
                    xAxisTitle: "",
                    yAxisTitle: "",
                    duration: 20,
                    isanimated: !0,
                    isstopped: !0
                }, LineDotChart.capabilities = {
                    dataRoles: [ {
                        name: "Date",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: "Date"
                    }, {
                        name: "Values",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: "Values"
                    } ],
                    dataViewMappings: [ {
                        conditions: [ {
                            Date: {
                                min: 0,
                                max: 1
                            },
                            Values: {
                                min: 0,
                                max: 1
                            },
                            Labels: {
                                min: 0,
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Date"
                                },
                                dataReductionAlgorithm: {
                                    sample: {}
                                }
                            },
                            values: {
                                "for": {
                                    "in": "Values"
                                }
                            }
                        }
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: !0
                                        }
                                    }
                                }
                            }
                        },
                        lineoptions: {
                            displayName: "Line",
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                lineThickness: {
                                    displayName: "Thickness",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        dotoptions: {
                            displayName: "Dot",
                            properties: {
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                dotSizeMin: {
                                    displayName: "Min size",
                                    type: {
                                        numeric: !0
                                    }
                                },
                                dotSizeMax: {
                                    displayName: "Min size",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        counteroptions: {
                            displayName: "Counter",
                            properties: {
                                counterTitle: {
                                    displayName: "Title",
                                    type: {
                                        text: !0
                                    }
                                }
                            }
                        },
                        misc: {
                            displayName: "Animation",
                            properties: {
                                isanimated: {
                                    displayName: "Animated",
                                    type: {
                                        bool: !0
                                    }
                                },
                                isstopped: {
                                    displayName: "Stop on load",
                                    type: {
                                        bool: !0
                                    }
                                },
                                duration: {
                                    displayName: "Time",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        }
                    }
                }, LineDotChart.Identity = {
                    "class": "lineDotChart",
                    selector: ".lineDotChart"
                }, LineDotChart.Axes = {
                    "class": "axes",
                    selector: ".axes"
                }, LineDotChart.Axis = {
                    "class": "axis",
                    selector: ".axis"
                }, LineDotChart.Legends = {
                    "class": "legends",
                    selector: ".legends"
                }, LineDotChart.Legend = {
                    "class": "legend",
                    selector: ".legend"
                }, LineDotChart.Values = {
                    "class": "line",
                    selector: ".line"
                }, LineDotChart.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    lineoptions: {
                        fill: {
                            objectName: "lineoptions",
                            propertyName: "fill"
                        },
                        lineThickness: {
                            objectName: "lineoptions",
                            propertyName: "lineThickness"
                        }
                    },
                    dotoptions: {
                        color: {
                            objectName: "dotoptions",
                            propertyName: "color"
                        },
                        dotSizeMin: {
                            objectName: "dotoptions",
                            propertyName: "dotSizeMin"
                        },
                        dotSizeMax: {
                            objectName: "dotoptions",
                            propertyName: "dotSizeMax"
                        }
                    },
                    counteroptions: {
                        counterTitle: {
                            objectName: "counteroptions",
                            propertyName: "counterTitle"
                        }
                    },
                    misc: {
                        isanimated: {
                            objectName: "misc",
                            propertyName: "isanimated"
                        },
                        isstopped: {
                            objectName: "misc",
                            propertyName: "isstopped"
                        },
                        duration: {
                            objectName: "misc",
                            propertyName: "duration"
                        }
                    }
                }, LineDotChart;
            }();
            samples.LineDotChart = LineDotChart;
        }(samples = visuals.samples || (visuals.samples = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var plugins;
        !function(plugins) {
            plugins.sunburstCustom = {
                name: "sunburstCustom",
                watermarkKey: "defaultWatermark",
                capabilities: visuals.samples.Sunburst.capabilities,
                create: function() {
                    return new visuals.samples.Sunburst();
                }
            }, plugins.asterPlot = {
                name: "asterPlot",
                capabilities: visuals.samples.AsterPlot.capabilities,
                create: function() {
                    return new visuals.samples.AsterPlot();
                }
            }, plugins.tornadoChart = {
                name: "tornadoChart",
                capabilities: visuals.samples.TornadoChart.capabilities,
                create: function() {
                    return new visuals.samples.TornadoChart();
                }
            }, plugins.sankeyDiagram = {
                name: "sankeyDiagram",
                capabilities: visuals.samples.SankeyDiagram.capabilities,
                create: function() {
                    return new visuals.samples.SankeyDiagram();
                }
            }, plugins.mekkoChart = {
                name: "mekkoChart",
                watermarkKey: "mekko",
                capabilities: visuals.samples.MekkoChart.capabilities,
                create: function() {
                    return new visuals.samples.MekkoChart({
                        chartType: 0
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            }, plugins.bulletChart = {
                name: "bulletChart",
                capabilities: visuals.samples.BulletChart.capabilities,
                create: function() {
                    return new visuals.samples.BulletChart();
                }
            }, plugins.wordCloud = {
                name: "wordCloud",
                capabilities: visuals.samples.WordCloud.capabilities,
                create: function() {
                    return new visuals.samples.WordCloud();
                }
            }, plugins.chicletSlicer = {
                name: "chicletSlicer",
                capabilities: visuals.samples.ChicletSlicer.capabilities,
                create: function() {
                    return new visuals.samples.ChicletSlicer();
                }
            }, plugins.chordChart = {
                name: "chordChart",
                capabilities: visuals.samples.ChordChart.capabilities,
                create: function() {
                    return new visuals.samples.ChordChart();
                }
            }, plugins.enhancedScatterChart = {
                name: "enhancedScatterChart",
                capabilities: visuals.samples.EnhancedScatterChart.capabilities,
                create: function() {
                    return new visuals.samples.EnhancedScatterChart();
                }
            }, plugins.radarChart = {
                name: "radarChart",
                capabilities: visuals.samples.RadarChart.capabilities,
                create: function() {
                    return new visuals.samples.RadarChart();
                }
            }, plugins.dotPlot = {
                name: "dotPlot",
                capabilities: visuals.samples.DotPlot.capabilities,
                create: function() {
                    return new visuals.samples.DotPlot();
                }
            }, plugins.histogram = {
                name: "histogram",
                capabilities: visuals.samples.Histogram.capabilities,
                create: function() {
                    return new visuals.samples.Histogram();
                }
            }, plugins.timeline = {
                name: "timeline",
                capabilities: visuals.samples.Timeline.capabilities,
                create: function() {
                    return new visuals.samples.Timeline();
                }
            }, plugins.forceGraph = {
                name: "forceGraph",
                capabilities: visuals.samples.ForceGraph.capabilities,
                create: function() {
                    return new visuals.samples.ForceGraph();
                }
            }, plugins.gantt = {
                name: "gantt",
                capabilities: visuals.samples.Gantt.capabilities,
                create: function() {
                    return new visuals.samples.Gantt();
                }
            }, plugins.streamGraph = {
                name: "streamGraph",
                capabilities: visuals.samples.StreamGraph.capabilities,
                create: function() {
                    return new visuals.samples.StreamGraph();
                }
            }, plugins.lineDotChart = {
                name: "lineDotChart",
                capabilities: visuals.samples.LineDotChart.capabilities,
                create: function() {
                    return new visuals.samples.LineDotChart();
                }
            };
        }(plugins = visuals.plugins || (visuals.plugins = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var visualPluginFactory;
        !function(visualPluginFactory) {
            function createCustomVisualPluginService() {
                return new CustomVisualPluginService();
            }
            var CustomVisualPluginService = function(_super) {
                function CustomVisualPluginService() {
                    _super.call(this, {}), this.initCustomVisualPlugins();
                }
                return __extends(CustomVisualPluginService, _super), CustomVisualPluginService.prototype.getVisuals = function() {
                    var registry = this.customVisualPlugins, names = Object.keys(registry);
                    return names.map(function(name) {
                        return registry[name];
                    });
                }, CustomVisualPluginService.prototype.getPlugin = function(type) {
                    if (!type) return null;
                    var plugin = this.customVisualPlugins[type];
                    return plugin ? plugin : null;
                }, CustomVisualPluginService.prototype.capabilities = function(type) {
                    var plugin = this.getPlugin(type);
                    return plugin ? plugin.capabilities : {};
                }, CustomVisualPluginService.prototype.initCustomVisualPlugins = function() {
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.asterPlot, function() {
                        return new visuals.samples.AsterPlot();
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, function() {
                        return new visuals.samples.TornadoChart({
                            animator: new visuals.BaseAnimator()
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, function() {
                        return new visuals.samples.SankeyDiagram();
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, function() {
                        return new visuals.samples.MekkoChart({
                            chartType: 0,
                            isScrollable: !0,
                            animator: new visuals.WebColumnChartAnimator(),
                            behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ])
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, function() {
                        return new visuals.samples.BulletChart();
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, function() {
                        return new visuals.samples.WordCloud({
                            animator: new visuals.BaseAnimator()
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, function() {
                        return new visuals.samples.ChicletSlicer({
                            behavior: new visuals.samples.ChicletSlicerWebBehavior()
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, function() {
                        return new visuals.samples.EnhancedScatterChart();
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, function() {
                        return new visuals.samples.RadarChart({
                            animator: new visuals.BaseAnimator()
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, function() {
                        return new visuals.samples.DotPlot({
                            animator: new visuals.BaseAnimator()
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, function() {
                        return new visuals.samples.Histogram({
                            animator: new visuals.BaseAnimator()
                        });
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, function() {
                        return new visuals.samples.ForceGraph();
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.gantt, function() {
                        return new visuals.samples.Gantt();
                    }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.streamGraph, function() {
                        return new visuals.samples.StreamGraph();
                    });
                }, CustomVisualPluginService;
            }(visualPluginFactory.VisualPluginService);
            visualPluginFactory.CustomVisualPluginService = CustomVisualPluginService, visualPluginFactory.createCustomVisualPluginService = createCustomVisualPluginService;
        }(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));