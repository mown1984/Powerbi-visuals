/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var AxisScale = powerbi.visuals.axisScale;
            var DataRoleHelper = powerbi.data.DataRoleHelper;
            var AreaRangeChart = (function () {
                function AreaRangeChart(options) {
                    this.scaleType = AxisScale.linear;
                    if (options) {
                        this.animator = options.animator;
                    }
                    this.margin = AreaRangeChart.DefaultMargin;
                }
                AreaRangeChart.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.colors = options.style.colorPalette.dataColors;
                    this.legend = visuals.createLegend(element, false, null);
                    this.svg = d3.select(element.get(0))
                        .append('svg')
                        .classed(AreaRangeChart.VisualClassName, true);
                    this.chart = this.svg
                        .append('g')
                        .classed(AreaRangeChart.Chart.class, true);
                    this.axis = this.svg
                        .append('g')
                        .classed(AreaRangeChart.Axis.class, true);
                    this.axisX = this.axis
                        .append('g')
                        .classed(AreaRangeChart.Axis.class, true);
                    this.axisY = this.axis
                        .append('g')
                        .classed(AreaRangeChart.Axis.class, true);
                };
                AreaRangeChart.prototype.isSizeAvailable = function (viewport) {
                    if ((viewport.height < AreaRangeChart.DefaultViewport.height) ||
                        (viewport.width < AreaRangeChart.DefaultViewport.width)) {
                        return false;
                    }
                    return true;
                };
                AreaRangeChart.prototype.updateInternal = function (options) {
                    if (!options.dataViews || !options.dataViews[0]) {
                        return;
                    }
                    var dataView = options.dataViews[0];
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.values ||
                        !dataView.categorical.values[0] ||
                        !dataView.categorical.values[0].values) {
                        this.clearChart();
                        return;
                    }
                    if (!this.isSizeAvailable(options.viewport)) {
                        this.clearChart();
                        return;
                    }
                    this.setSize(options.viewport);
                    this.setData(options.dataViews);
                    if (typeof (this.data) === 'undefined') {
                        this.clearChart();
                        return;
                    }
                    this.calculateAxesProperties(null);
                    this.render(options.suppressAnimations);
                };
                AreaRangeChart.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0]) {
                        return;
                    }
                    this.updateInternal(options);
                };
                AreaRangeChart.getColor = function (colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                    var objects;
                    if (hasDynamicSeries) {
                        if (grouped && grouped[seriesIndex])
                            objects = grouped[seriesIndex].objects;
                    }
                    else if (values[seriesIndex]) {
                        objects = values[seriesIndex].source.objects;
                    }
                    return hasDynamicSeries && groupedIdentity
                        ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name)
                        : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
                };
                AreaRangeChart.prototype.setData = function (dataViews) {
                    this.data = {
                        series: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                        axesLabels: { x: null, y: null },
                        hasDynamicSeries: false,
                        categories: [],
                        categoryMetadata: undefined,
                        lowerMeasureIndex: undefined,
                        upperMeasureIndex: undefined,
                    };
                    if (dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView) {
                            if (dataView.categorical) {
                                var dataViewCat = this.dataViewCat = dataView.categorical;
                                var dvCategories = dataViewCat.categories;
                                var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                                if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                                    categoryType = dvCategories[0].source.type;
                                //var axisType = lineChartProps.categoryAxis.axisType
                                var axisType = AreaRangeChart.properties.general.formatString;
                                var convertedData = AreaRangeChart.converter(dataView, visuals.valueFormatter.format(null), this.colors, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, axisType, categoryType), null);
                                this.data = convertedData;
                            }
                        }
                    }
                };
                AreaRangeChart.converter = function (dataView, blankCategoryValue, colors, isScalar, interactivityService) {
                    var categorical = dataView.categorical;
                    var category = categorical.categories && categorical.categories.length > 0
                        ? categorical.categories[0]
                        : {
                            source: undefined,
                            values: [blankCategoryValue],
                            identity: undefined,
                        };
                    var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                    categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                    var formatStringProp = AreaRangeChart.properties.general.formatString;
                    var categoryType = visuals.AxisHelper.getCategoryValueType(category.source, isScalar);
                    var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                    var categoryValues = category.values;
                    var series = [];
                    var seriesLen = categorical.values ? categorical.values.length : 0;
                    var hasDynamicSeries = !!(categorical.values && categorical.values.source);
                    var values = categorical.values;
                    var labelFormatString = values && values[0] ? visuals.valueFormatter.getFormatString(values[0].source, formatStringProp) : undefined;
                    var defaultLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings();
                    var defaultSeriesColor;
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        defaultSeriesColor = powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.dataPoint.defaultColor);
                    }
                    var settings = AreaRangeChart.parseSettings(dataView);
                    if (!settings) {
                        return;
                    }
                    var colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultSeriesColor);
                    var grouped;
                    if (dataView.categorical.values) {
                        grouped = dataView.categorical.values.grouped();
                    }
                    var lowerMeasureIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, AreaRangeChart.RoleNames.Lower);
                    var upperMeasureIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, AreaRangeChart.RoleNames.Upper);
                    if (lowerMeasureIndex < 0 || upperMeasureIndex < 0) {
                        return;
                    }
                    seriesLen = grouped.length;
                    for (var seriesIndex = 0; seriesIndex < seriesLen; seriesIndex++) {
                        var column = categorical.values[seriesIndex];
                        var valuesMetadata = column.source;
                        var dataPoints = [];
                        var groupedIdentity = grouped[seriesIndex];
                        var identity = hasDynamicSeries && groupedIdentity ?
                            visuals.SelectionId.createWithIdAndMeasure(groupedIdentity.identity, column.source.queryName) :
                            visuals.SelectionId.createWithMeasure(column.source.queryName);
                        var key = identity.getKey();
                        var color = AreaRangeChart.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity);
                        var seriesLabelSettings;
                        if (!hasDynamicSeries) {
                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                            var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                            if (labelObjects) {
                            }
                        }
                        var dataPointLabelSettings = (seriesLabelSettings) ? seriesLabelSettings : defaultLabelSettings;
                        for (var categoryIndex = 0, len = column.values.length; categoryIndex < len; categoryIndex++) {
                            var categoryValue = categoryValues[categoryIndex];
                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(column.values[categoryIndex]);
                            // When Scalar, skip null categories and null values so we draw connected lines and never draw isolated dots.
                            if (isScalar && (categoryValue === null || value === null)) {
                                continue;
                            }
                            var categorical = dataView.categorical;
                            var y0_group = groupedIdentity.values[lowerMeasureIndex];
                            var y1_group = groupedIdentity.values[upperMeasureIndex];
                            var y0 = y0_group.values[categoryIndex];
                            var y1 = y1_group.values[categoryIndex];
                            var formatterLarge = visuals.valueFormatter.create({ format: "0", value: 1e6 });
                            var formatted_y0 = (y0 != null ? (String(y0).length >= 6 ? formatterLarge.format(y0) : y0) : y0);
                            var formatted_y1 = (y1 != null ? (String(y1).length >= 6 ? formatterLarge.format(y1) : y1) : y1);
                            var seriesData = [
                                {
                                    value: formatted_y0,
                                    metadata: y0_group
                                },
                                {
                                    value: formatted_y1,
                                    metadata: y1_group
                                }];
                            if (typeof (categorical.categories) === 'undefined') {
                                return;
                            }
                            var categoryColumns = [
                                categorical.categories[0]
                            ];
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null /*categorical*/, categoryValue, null, categoryColumns, seriesData, null);
                            var dataPoint = {
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: value,
                                categoryIndex: categoryIndex,
                                seriesIndex: seriesIndex,
                                tooltipInfo: tooltipInfo,
                                selected: false,
                                identity: identity,
                                key: JSON.stringify({ ser: key, catIdx: categoryIndex }),
                                labelFill: dataPointLabelSettings.labelColor,
                                labelFormatString: labelFormatString || valuesMetadata.format,
                                labelSettings: dataPointLabelSettings,
                                y0: y0,
                                y1: y1,
                                pointColor: color,
                            };
                            dataPoints.push(dataPoint);
                        }
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(dataPoints);
                        }
                        if (dataPoints.length > 0) {
                            series.push({
                                displayName: grouped[seriesIndex].name,
                                key: key,
                                lineIndex: seriesIndex,
                                color: color,
                                xCol: category.source,
                                yCol: column.source,
                                data: dataPoints,
                                identity: identity,
                                selected: false,
                                labelSettings: seriesLabelSettings,
                            });
                        }
                    }
                    xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                    var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                    // Convert to DataViewMetadataColumn
                    var valuesMetadataArray = [];
                    if (values) {
                        for (var i = 0; i < values.length; i++) {
                            if (values[i] && values[i].source && values[i].source.displayName) {
                                valuesMetadataArray.push({ displayName: values[i].source.displayName });
                            }
                        }
                    }
                    var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(series);
                    }
                    return {
                        series: series,
                        isScalar: isScalar,
                        dataLabelsSettings: defaultLabelSettings,
                        axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                        hasDynamicSeries: hasDynamicSeries,
                        categoryMetadata: category.source,
                        categories: categoryValues,
                        lowerMeasureIndex: lowerMeasureIndex,
                        upperMeasureIndex: upperMeasureIndex,
                        settings: settings
                    };
                };
                AreaRangeChart.prototype.clearChart = function () {
                    this.chart.selectAll('*').remove();
                    this.axisY.selectAll('*').remove();
                    this.axisX.selectAll('*').remove();
                };
                AreaRangeChart.prototype.render = function (suppressAnimations) {
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    var result;
                    var data = this.data;
                    if (!data) {
                        this.clearChart();
                        return;
                    }
                    this.renderAxis(data, duration);
                    this.renderChart(data, duration);
                    //calculateLegend
                    var legendData = this.createLegendDataPoints(0);
                    if (data.settings && data.settings.legend) {
                        visuals.LegendData.update(legendData, data.settings.legend);
                        this.legend.changeOrientation(data.settings.legend.position);
                    }
                    var isDrawLegend = false;
                    if (isDrawLegend) {
                        this.legend.drawLegend(legendData, this.viewport);
                    }
                    return result;
                };
                AreaRangeChart.prototype.setSize = function (viewport) {
                    var height, width;
                    height = viewport.height - this.margin.top - this.margin.bottom;
                    width = viewport.width - this.margin.left - this.margin.right;
                    height = Math.max(height, AreaRangeChart.DefaultViewport.height);
                    width = Math.max(width, AreaRangeChart.DefaultViewport.width);
                    this.viewport = {
                        height: height,
                        width: width
                    };
                    this.updateElements(viewport.height, viewport.width);
                };
                AreaRangeChart.prototype.updateElements = function (height, width) {
                    this.svg.attr({
                        'height': height,
                        'width': width
                    });
                    this.chart.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.axisY.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.axisX.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top + this.viewport.height));
                };
                AreaRangeChart.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                AreaRangeChart.getPrecision = function (objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, AreaRangeChart.properties.labels.labelPrecision, AreaRangeChart.DefaultSettings.precision);
                    return precision;
                };
                AreaRangeChart.getLegendSettings = function (objects) {
                    var legend = objects["legend"];
                    legend.show = powerbi.DataViewObjects.getValue(objects, AreaRangeChart.properties.legend.show, AreaRangeChart.DefaultSettings.legend.show);
                    legend.position = powerbi.DataViewObjects.getValue(objects, AreaRangeChart.properties.legend.position, AreaRangeChart.DefaultSettings.legend.position);
                    legend.showTitle = powerbi.DataViewObjects.getValue(objects, AreaRangeChart.properties.legend.showTitle, AreaRangeChart.DefaultSettings.legend.showTitle);
                    legend.titleText = powerbi.DataViewObjects.getValue(objects, AreaRangeChart.properties.legend.titleText, AreaRangeChart.DefaultSettings.legend.titleText);
                    return legend;
                };
                AreaRangeChart.getDataColorsSettings = function (objects) {
                    var legend = objects["dataPoints"];
                    return legend;
                };
                AreaRangeChart.parseSettings = function (dataView) {
                    var settings = {}, objects;
                    settings.displayName = AreaRangeChart.DefaultSettings.displayName;
                    settings.fillColor = AreaRangeChart.DefaultSettings.fillColor;
                    objects = AreaRangeChart.getObjectsFromDataView(dataView);
                    if (objects) {
                        settings.precision = AreaRangeChart.getPrecision(objects);
                        settings.legend = AreaRangeChart.getLegendSettings(objects);
                        settings.colors = AreaRangeChart.getDataColorsSettings(objects);
                    }
                    return settings;
                };
                AreaRangeChart.prototype.calculateAxesProperties = function (options) {
                    this.data.xAxisProperties = this.getXAxisProperties();
                    this.data.yAxisProperties = this.getYAxisProperties();
                    return [this.data.xAxisProperties, this.data.yAxisProperties];
                };
                AreaRangeChart.prototype.lookupXValue = function (index, type) {
                    var isDateTime = visuals.AxisHelper.isDateTime(type);
                    if (isDateTime && this.data.isScalar) {
                        return new Date(index);
                    }
                    if (this.data && this.data.series && this.data.series.length > 0) {
                        var firstSeries = this.data.series[0];
                        if (firstSeries) {
                            var data = firstSeries.data;
                            if (data) {
                                var dataAtIndex = data[index];
                                if (dataAtIndex) {
                                    if (isDateTime) {
                                        return new Date(dataAtIndex.categoryValue);
                                    }
                                    return dataAtIndex.categoryValue;
                                }
                            }
                        }
                    }
                    return index;
                };
                AreaRangeChart.prototype.getXAxisProperties = function () {
                    var _this = this;
                    var data = this.data;
                    var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0;
                    var categoryThickness = visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.viewport.width, xDomain, data.isScalar, false);
                    var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata);
                    var xDomain = visuals.AxisHelper.createDomain(data.series, categoryDataType, data.isScalar, null);
                    var xMetaDataColumn = data.categoryMetadata;
                    var xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewport.width,
                        dataDomain: xDomain,
                        metaDataColumn: xMetaDataColumn,
                        //formatStringProp: lineChartProps.general.formatString,
                        formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, AreaRangeChart.properties.general.formatString),
                        outerPadding: 0,
                        isScalar: this.data.isScalar,
                        isVertical: false,
                        forcedTickCount: undefined,
                        useTickIntervalForDisplayUnits: true,
                        getValueFn: function (index, type) { return _this.lookupXValue(index, type); },
                        categoryThickness: categoryThickness,
                        isCategoryAxis: true,
                        scaleType: this.scaleType,
                        axisDisplayUnits: undefined,
                        axisPrecision: undefined
                    });
                    return xAxisProperties;
                };
                /**
                 * Creates a [min,max] from your Cartiesian data values.
                 *
                 * @param data The series array of CartesianDataPoints.
                 * @param includeZero Columns and bars includeZero, line and scatter do not.
                 */
                AreaRangeChart.createValueDomain = function (data, includeZero) {
                    if (data.length === 0) {
                        return null;
                    }
                    var minY0 = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.y0; }); });
                    var minY1 = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.y1; }); });
                    var maxY0 = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.y0; }); });
                    var maxY1 = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.y1; }); });
                    var minY = Math.min(minY0, minY1);
                    var maxY = Math.max(maxY0, maxY1);
                    if (includeZero) {
                        return [Math.min(minY, 0), Math.max(maxY, 0)];
                    }
                    return [minY, maxY];
                };
                AreaRangeChart.prototype.getYAxisProperties = function () {
                    var yDomain = AreaRangeChart.createValueDomain(this.data.series, false);
                    var lowerMeasureIndex = this.data.series.length === 1 ? 0 : this.data.lowerMeasureIndex;
                    var yMetaDataColumn = this.data.series.length ? this.data.series[lowerMeasureIndex].yCol : undefined;
                    var yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewport.height,
                        dataDomain: yDomain,
                        metaDataColumn: yMetaDataColumn,
                        //formatStringProp: AreaRangeChart.properties.general.formatString,
                        formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, AreaRangeChart.properties.general.formatString),
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: true,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: false,
                        scaleType: this.scaleType,
                    });
                    return yAxisProperties;
                };
                AreaRangeChart.prototype.renderAxis = function (data, duration) {
                    var xAxis = data.xAxisProperties.axis;
                    var yAxis = data.yAxisProperties.axis;
                    xAxis.orient('bottom');
                    yAxis.orient('left');
                    this.axisX
                        .transition()
                        .duration(duration)
                        .call(xAxis);
                    this.axisY
                        .transition()
                        .duration(duration)
                        .call(yAxis);
                };
                AreaRangeChart.prototype.renderChart = function (data, duration) {
                    var series = data.series, isScalar = data.isScalar, xScale = data.xAxisProperties.scale, yScale = data.yAxisProperties.scale, sm = this.selectionManager;
                    var area = d3.svg.area()
                        .x(function (d) {
                        return xScale(isScalar ? d.categoryValue : d.categoryIndex);
                    })
                        .y0(function (d) { return yScale(d.y0); })
                        .y1(function (d) { return yScale(d.y1); });
                    var selection = this.chart.selectAll(AreaRangeChart.Area.selector).data(series);
                    selection
                        .enter()
                        .append('svg:path')
                        .classed(AreaRangeChart.Area.class, true);
                    selection
                        .attr('fill', function (d) { return d.color; })
                        .attr('stroke', function (d) { return d.color; })
                        .attr('d', function (d) {
                        return area(d.data);
                    })
                        .style('fill-opacity', AreaRangeChart.DimmedFillOpacity)
                        .on('click', function (d) {
                        var _this = this;
                        sm.select(d.identity).then(function (ids) {
                            if (ids.length > 0) {
                                selection.style('fill-opacity', AreaRangeChart.DimmedFillOpacity);
                                d3.select(_this).transition()
                                    .duration(duration)
                                    .style('fill-opacity', AreaRangeChart.FillOpacity);
                            }
                            else {
                                selection.style('fill-opacity', AreaRangeChart.DimmedFillOpacity);
                            }
                        });
                        d3.event.stopPropagation();
                    });
                    selection.exit().remove();
                    this.renderTooltip(selection, xScale, data.isScalar);
                };
                AreaRangeChart.findClosestXAxisIndex = function (currentX, xAxisValues, isScalar) {
                    var closestValueIndex = -1;
                    var minDistance = Number.MAX_VALUE;
                    for (var i in xAxisValues) {
                        var element = xAxisValues[i];
                        var value = isScalar ? element.categoryValue : element.categoryIndex;
                        var distance = Math.abs(currentX - value);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestValueIndex = i;
                        }
                    }
                    return closestValueIndex;
                };
                AreaRangeChart.getTooltipInfoByPointX = function (pointData, xScale, isScalar, pointX) {
                    var index = 0;
                    var currentX = powerbi.visuals.AxisHelper.invertScale(xScale, pointX);
                    index = AreaRangeChart.findClosestXAxisIndex(currentX, pointData.data, isScalar);
                    return pointData.data[index].tooltipInfo;
                };
                AreaRangeChart.prototype.renderTooltip = function (selection, xScale, isScalar) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        var pointX = tooltipEvent.elementCoordinates[0];
                        return AreaRangeChart.getTooltipInfoByPointX(tooltipEvent.data, xScale, isScalar, pointX);
                    }, true);
                };
                AreaRangeChart.prototype.createLegendDataPoints = function (columnIndex) {
                    var data = this.data;
                    if (!data) {
                        return null;
                    }
                    var legendDataPoints = [];
                    var category;
                    // Category will be the same for all series. This is an optimization.
                    if (data.series.length > 0) {
                        var lineDatePointFirstSeries = data.series[0].data[columnIndex];
                        var isDateTime = visuals.AxisHelper.isDateTime(this.data.xAxisProperties.axisType);
                        var value = (isDateTime && this.data.isScalar && lineDatePointFirstSeries) ? lineDatePointFirstSeries.categoryValue : columnIndex;
                        category = lineDatePointFirstSeries && this.lookupXValue(value, this.data.xAxisProperties.axisType);
                    }
                    var formatStringProp = visuals.lineChartProps.general.formatString;
                    var seriesYCol = null;
                    // iterating over the line data (i is for a line)
                    for (var i = 0, len = data.series.length; i < len; i++) {
                        var series = data.series[i];
                        var lineData = series.data;
                        var lineDataPoint = lineData[columnIndex];
                        var measure = lineDataPoint && lineDataPoint.value;
                        var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                        seriesYCol = series.yCol;
                        legendDataPoints.push({
                            color: series.color,
                            icon: visuals.LegendIcon.Line,
                            label: label,
                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                            identity: series.identity,
                            selected: false
                        });
                    }
                    var dvValues = this.dataViewCat ? this.dataViewCat.values : null;
                    var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                    return {
                        title: title,
                        dataPoints: legendDataPoints
                    };
                };
                AreaRangeChart.prototype.enumerateLegend = function (enumeration) {
                    var data = this.data;
                    if (typeof (data) === 'undefined') {
                        return;
                    }
                    var legendObjectProperties = { legend: data.settings.legend };
                    var show = powerbi.DataViewObjects.getValue(legendObjectProperties, AreaRangeChart.properties.legend.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, AreaRangeChart.properties.legend.showTitle, true);
                    var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, AreaRangeChart.properties.legend.titleText, null);
                    enumeration.pushInstance({
                        selector: null,
                        objectName: 'legend',
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText
                        }
                    });
                };
                AreaRangeChart.prototype.enumerateDataPoints = function (enumeration) {
                    var data = this.data;
                    if (!data) {
                        return;
                    }
                    var series = data.series;
                    for (var i = 0; i < series.length; i++) {
                        var item = series[i];
                        var color = item.color;
                        var selector = item.identity.getSelector();
                        var isSingleSeries = !!selector.data;
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: item.displayName,
                            selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                            properties: {
                                fill: { solid: { color: color } }
                            },
                        });
                    }
                };
                AreaRangeChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'legend':
                            this.enumerateLegend(enumeration);
                            break;
                        case 'dataPoint':
                            this.enumerateDataPoints(enumeration);
                            break;
                    }
                    return enumeration.complete();
                };
                AreaRangeChart.properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    legend: {
                        show: { objectName: 'legend', propertyName: 'show' },
                        position: { objectName: 'legend', propertyName: 'position' },
                        showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                        titleText: { objectName: 'legend', propertyName: 'titleText' },
                    },
                    dataPoint: {
                        defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                        fill: { objectName: 'dataPoint', propertyName: 'fill' },
                        showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
                    },
                    labels: {
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        }
                    }
                };
                AreaRangeChart.RoleNames = {
                    Category: "Category",
                    Series: "Series",
                    Lower: "Lower",
                    Upper: "Upper",
                };
                AreaRangeChart.capabilities = {
                    dataRoles: [
                        {
                            name: AreaRangeChart.RoleNames.Category,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                            description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription")
                        },
                        {
                            name: AreaRangeChart.RoleNames.Series,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                            description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                        },
                        {
                            name: AreaRangeChart.RoleNames.Lower,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y1'
                        },
                        {
                            name: AreaRangeChart.RoleNames.Upper,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y2")
                        },
                    ],
                    dataViewMappings: [
                        {
                            conditions: [
                                {
                                    "Category": { max: 1 },
                                    "Series": { max: 1 },
                                    "Lower": { max: 1 },
                                    "Upper": { max: 1 }
                                },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: AreaRangeChart.RoleNames.Category },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: AreaRangeChart.RoleNames.Series,
                                        select: [
                                            { bind: { to: AreaRangeChart.RoleNames.Lower } },
                                            { bind: { to: AreaRangeChart.RoleNames.Upper } }
                                        ]
                                    },
                                },
                            }
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    type: { formatting: { legendPosition: true } }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                                    type: { text: true }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        label: {
                            displayName: powerbi.data.createDisplayNameGetter("Label"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Fill"),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    }
                };
                AreaRangeChart.VisualClassName = 'areaRangeChart';
                AreaRangeChart.Chart = createClassAndSelector('chart');
                AreaRangeChart.Area = createClassAndSelector('area');
                AreaRangeChart.Axis = createClassAndSelector('axis');
                AreaRangeChart.DimmedFillOpacity = 0.5;
                AreaRangeChart.FillOpacity = 0.9;
                AreaRangeChart.DefaultSettings = {
                    displayName: "Area Range Chart",
                    precision: 2,
                    legend: {
                        show: true,
                        position: visuals.LegendPosition.Top,
                        showTitle: true,
                    }
                };
                AreaRangeChart.DefaultMargin = {
                    top: 20,
                    bottom: 50,
                    right: 20,
                    left: 40,
                };
                AreaRangeChart.DefaultViewport = {
                    width: 50,
                    height: 50
                };
                return AreaRangeChart;
            })();
            samples.AreaRangeChart = AreaRangeChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var AsterPlotVisualClassName = 'asterPlot';
            var AsterDefaultOuterLineThickness = 1;
            var AsterDefaultLabelFill = { solid: { color: '#333' } };
            var AsterDefaultLegendFontSize = 8;
            var AsterDefaultLegendShow = true;
            var AsterLabelFillProp = { objectName: 'label', propertyName: 'fill' };
            var AsterLegendShowProp = { objectName: "legend", propertyName: "show" };
            var AsterOuterLineShowProp = { objectName: 'outerLine', propertyName: 'show' };
            var AsterOuterLineThicknessProp = { objectName: 'outerLine', propertyName: 'thickness' };
            var AsterGeneralFormatStringProp = { objectName: 'general', propertyName: 'formatString' };
            //more than one implementation of interface which contains "IVisual" in its name currently is not supported in devtools
            var AsterPlotWarning /* implements IVisualWarning*/ = (function () {
                function AsterPlotWarning /* implements IVisualWarning*/(message) {
                    this.message = message;
                }
                Object.defineProperty(AsterPlotWarning /* implements IVisualWarning*/.prototype, "code", {
                    get: function () {
                        return "AsterPlotWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                AsterPlotWarning /* implements IVisualWarning*/.prototype.getMessages = function (resourceProvider) {
                    return {
                        message: this.message,
                        title: resourceProvider.get(""),
                        detail: resourceProvider.get("")
                    };
                };
                return AsterPlotWarning /* implements IVisualWarning*/;
            })();
            samples.AsterPlotWarning /* implements IVisualWarning*/ = AsterPlotWarning /* implements IVisualWarning*/;
            var AsterPlot = (function () {
                function AsterPlot() {
                }
                AsterPlot.GetCenterTextProperties = function (fontSize, text) {
                    return {
                        fontFamily: 'Segoe UI, wf_segoe-ui_normal, helvetica, arial, sans-serif',
                        fontWeight: 'bold',
                        fontSize: jsCommon.PixelConverter.toString(fontSize),
                        text: text
                    };
                };
                AsterPlot.getDefaultAsterData = function () {
                    return {
                        dataPoints: null,
                        legendData: null,
                        settings: { showLegend: AsterDefaultLegendShow },
                        valueFormatter: null
                    };
                };
                AsterPlot.converter = function (dataView, colors) {
                    var asterDataResult = this.getDefaultAsterData();
                    if (!dataView.categorical
                        || !dataView.categorical.categories
                        || dataView.categorical.categories.length !== 1)
                        return asterDataResult;
                    var catDv = dataView.categorical;
                    var cat = catDv.categories[0];
                    var catValues = cat.values;
                    var values = catDv.values;
                    asterDataResult.dataPoints = [];
                    if (!catValues || catValues.length < 1 || !values || values.length < 1)
                        return asterDataResult;
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(cat.source, AsterGeneralFormatStringProp);
                    var minValue = Math.min(0, d3.min(values[0].values));
                    for (var i = 0, length_1 = Math.min(colors.getAllColors().length, catValues.length); i < length_1; i++) {
                        var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString);
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(AsterGeneralFormatStringProp, catDv, formattedCategoryValue, values[0].values[i], null, null, 0);
                        if (values.length > 1) {
                            var toolTip = visuals.TooltipBuilder.createTooltipInfo(AsterGeneralFormatStringProp, catDv, formattedCategoryValue, values[1].values[i], null, null, 1)[1];
                            if (toolTip) {
                                tooltipInfo.push(toolTip);
                            }
                        }
                        asterDataResult.dataPoints.push({
                            sliceHeight: values[0].values[i] - minValue,
                            sliceWidth: Math.max(0, values.length > 1 ? values[1].values[i] : 1),
                            label: catValues[i],
                            color: colors.getColorByIndex(i).value,
                            selector: visuals.SelectionId.createWithId(cat.identity[i]),
                            tooltipInfo: tooltipInfo
                        });
                    }
                    asterDataResult.legendData = AsterPlot.getLegendData(dataView, asterDataResult.dataPoints);
                    asterDataResult.settings = AsterPlot.parseLegendSettings(dataView);
                    return asterDataResult;
                };
                AsterPlot.getLegendData = function (dataView, asterDataPoints) {
                    var legendData = {
                        fontSize: AsterDefaultLegendFontSize,
                        dataPoints: [],
                        title: dataView.categorical.categories[0].source.displayName
                    };
                    for (var i = 0; i < asterDataPoints.length; ++i) {
                        legendData.dataPoints.push({
                            label: asterDataPoints[i].label,
                            color: asterDataPoints[i].color,
                            icon: visuals.LegendIcon.Box,
                            selected: false,
                            identity: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i], false)
                        });
                    }
                    return legendData;
                };
                AsterPlot.parseLegendSettings = function (dataView) {
                    var objects;
                    if (!dataView)
                        objects = null;
                    else
                        objects = dataView.metadata.objects;
                    return { showLegend: powerbi.DataViewObjects.getValue(objects, AsterLegendShowProp, AsterDefaultLegendShow) };
                };
                AsterPlot.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    var svg = this.svg = d3.select(element.get(0))
                        .append('svg')
                        .classed(AsterPlotVisualClassName, true)
                        .style('position', 'absolute');
                    this.hostService = options.host;
                    this.colors = options.style.colorPalette.dataColors;
                    this.mainGroupElement = svg.append('g');
                    this.centerText = this.mainGroupElement.append('text');
                    this.legend = visuals.createLegend(element, false, null, true);
                };
                AsterPlot.prototype.update = function (options) {
                    var _this = this;
                    if (!options.dataViews || !options.dataViews[0])
                        return; // or clear the view, display an error, etc.
                    var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                    this.currentViewport = {
                        height: Math.max(0, options.viewport.height),
                        width: Math.max(0, options.viewport.width)
                    };
                    var dataView = this.dataView = options.dataViews[0];
                    var convertedData = this.data = AsterPlot.converter(dataView, this.colors);
                    if (!convertedData || !convertedData.dataPoints) {
                        this.clearData();
                        return;
                    }
                    this.renderLegend(this.data);
                    this.updateViewPortAccordingToLegend();
                    this.svg
                        .attr({
                        height: Math.max(0, this.currentViewport.height),
                        width: Math.max(0, this.currentViewport.width)
                    })
                        .on('click', function () { return _this.selectionManager.clear().then(function () { return selection.style('opacity', 1); }); });
                    var width = this.currentViewport.width - 20;
                    var height = this.currentViewport.height - 20;
                    var radius = Math.min(width, height) / 2;
                    var innerRadius = 0.3 * radius;
                    var mainGroup = this.mainGroupElement;
                    mainGroup.attr('transform', visuals.SVGUtil.translate((width + 10) / 2, (height + 10) / 2));
                    var dataPoints = this.validateData(dataView, convertedData.dataPoints);
                    if (!dataPoints)
                        return;
                    var maxScore = d3.max(dataPoints, function (d) { return d.sliceHeight; });
                    var totalWeight = d3.sum(dataPoints, function (d) { return d.sliceWidth; });
                    var pie = d3.layout.pie()
                        .sort(null)
                        .value(function (d) { return (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight; });
                    var arc = d3.svg.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(function (d) { return (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore + innerRadius + 1; });
                    var selectionManager = this.selectionManager;
                    var selection = mainGroup.selectAll(AsterPlot.AsterSlice.selector)
                        .data(pie(dataPoints), function (d, idx) { return dataPoints[idx] ? dataPoints[idx].selector.getKey() : idx; });
                    selection.enter()
                        .append('path')
                        .attr('stroke', '#333')
                        .classed(AsterPlot.AsterSlice.class, true);
                    selection
                        .on('click', function (d) {
                        var _this = this;
                        selectionManager.select(d.data.selector).then(function (ids) {
                            if (ids.length > 0) {
                                selection.style('opacity', 0.5);
                                d3.select(_this).style('opacity', 1);
                            }
                            else {
                                selection.style('opacity', 1);
                            }
                        });
                        d3.event.stopPropagation();
                    })
                        .attr('fill', function (d) { return d.data.color; })
                        .transition().duration(duration)
                        .attrTween('d', function (data) {
                        if (!this.oldData) {
                            this.oldData = data;
                            return function () { return arc(data); };
                        }
                        var interpolation = d3.interpolate(this.oldData, data);
                        this.oldData = interpolation(0);
                        return function (x) { return arc(interpolation(x)); };
                    });
                    selection.exit().remove();
                    this.drawCenterText(innerRadius);
                    this.drawOuterLine(innerRadius, radius, pie(dataPoints));
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                };
                AsterPlot.prototype.renderLegend = function (asterPlotData) {
                    if (!asterPlotData || !asterPlotData.legendData)
                        return;
                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {});
                    var legendData = asterPlotData.legendData;
                    if (this.legendObjectProperties) {
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        var position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    this.legend.drawLegend(legendData, _.clone(this.currentViewport));
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                };
                AsterPlot.prototype.updateViewPortAccordingToLegend = function () {
                    var legendMargins = this.legend.getMargins(), legendPosition;
                    if (!this.legendObjectProperties)
                        return;
                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter: {
                            this.currentViewport.height -= legendMargins.height;
                            break;
                        }
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter: {
                            this.currentViewport.width -= legendMargins.width;
                            break;
                        }
                        default:
                            break;
                    }
                };
                AsterPlot.prototype.validateData = function (dataView, dataPoints) {
                    var maxCategories = this.colors.getAllColors().length;
                    if (dataPoints && dataView.categorical.categories[0].values.length > maxCategories) {
                        this.hostService.setWarnings([new AsterPlotWarning(powerbi.localization.defaultLocalizedStrings.DsrLimitWarning_TooMuchDataMessage)]);
                        var minSliceWidth = dataPoints.sort(function (a, b) { return b.sliceWidth - a.sliceWidth; })[maxCategories - 1].sliceWidth;
                        return dataPoints.filter(function (x) { return x.sliceWidth >= minSliceWidth; }).slice(0, maxCategories);
                    }
                    return dataPoints;
                };
                AsterPlot.prototype.drawOuterLine = function (innerRadius, radius, data) {
                    var mainGroup = this.mainGroupElement;
                    var outlineArc = d3.svg.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(radius);
                    if (this.getShowOuterline(this.dataView)) {
                        var outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
                        outerLine.enter().append('path');
                        outerLine.attr("fill", "none")
                            .attr({
                            'stroke': '#333',
                            'stroke-width': this.getOuterThickness(this.dataView) + 'px',
                            'd': outlineArc
                        })
                            .style('opacity', 1)
                            .classed(AsterPlot.OuterLine.class, true);
                    }
                    else {
                        mainGroup.selectAll(AsterPlot.OuterLine.selector).style('opacity', 0);
                    }
                };
                AsterPlot.prototype.getCenterText = function (dataView) {
                    var columns = dataView.metadata.columns;
                    for (var _i = 0; _i < columns.length; _i++) {
                        var column = columns[_i];
                        if (!column.isMeasure) {
                            return column.displayName;
                        }
                    }
                    return '';
                };
                AsterPlot.prototype.drawCenterText = function (innerRadius) {
                    var centerTextProperties = AsterPlot.GetCenterTextProperties(innerRadius * AsterPlot.CenterTextFontHeightCoefficient, this.getCenterText(this.dataView));
                    this.centerText
                        .style({
                        'line-height': 1,
                        'font-weight': centerTextProperties.fontWeight,
                        'font-size': centerTextProperties.fontSize,
                        'fill': this.getLabelFill(this.dataView).solid.color
                    })
                        .attr({
                        'dy': '0.35em',
                        'text-anchor': 'middle'
                    })
                        .text(powerbi.TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
                };
                AsterPlot.prototype.getShowOuterline = function (dataView) {
                    return dataView.metadata && powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterOuterLineShowProp, false);
                };
                AsterPlot.prototype.getOuterThickness = function (dataView) {
                    if (dataView && dataView.metadata && dataView.metadata.objects)
                        return powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterOuterLineThicknessProp, AsterDefaultOuterLineThickness);
                    return AsterDefaultOuterLineThickness;
                };
                // This extracts fill color of the label from the DataView
                AsterPlot.prototype.getLabelFill = function (dataView) {
                    if (dataView && dataView.metadata && dataView.metadata.objects)
                        return powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterLabelFillProp, AsterDefaultLabelFill);
                    return AsterDefaultLabelFill;
                };
                AsterPlot.prototype.getLegendInstance = function () {
                    return {
                        selector: null,
                        objectName: 'legend',
                        displayName: 'Legend',
                        properties: {
                            show: this.data.settings.showLegend,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true),
                            titleText: this.data.legendData ? this.data.legendData.title : '',
                            labelColor: powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, null),
                            fontSize: powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, AsterDefaultLegendFontSize)
                        }
                    };
                };
                AsterPlot.prototype.clearData = function () {
                    this.mainGroupElement.selectAll("path").remove();
                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
                };
                // This function retruns the values to be displayed in the property pane for each object.
                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
                // validation and return other values/defaults
                AsterPlot.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    switch (options.objectName) {
                        case 'legend':
                            var legend = this.getLegendInstance();
                            instances.push(legend);
                            break;
                        case 'label':
                            var label = {
                                objectName: 'label',
                                displayName: 'Label',
                                selector: null,
                                properties: {
                                    fill: this.getLabelFill(this.dataView)
                                }
                            };
                            instances.push(label);
                            break;
                        case 'outerLine':
                            var outerLine = {
                                objectName: 'outerLine',
                                displayName: 'Outer Line',
                                selector: null,
                                properties: {
                                    show: this.getShowOuterline(this.dataView),
                                    thickness: this.getOuterThickness(this.dataView)
                                }
                            };
                            instances.push(outerLine);
                            break;
                    }
                    return instances;
                };
                AsterPlot.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                        },
                        {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Y': { max: 2 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [{ bind: { to: 'Y' } }]
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: 'Legend',
                            description: 'Display legend options',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: 'Position',
                                    description: 'Select the location for the legend',
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: 'Title',
                                    description: 'Display a title for legend symbols',
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Legend Name',
                                    description: 'Title text',
                                    type: { text: true },
                                    suppressFormatPainterCopy: true
                                },
                                labelColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        label: {
                            displayName: 'Label',
                            properties: {
                                fill: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        outerLine: {
                            displayName: 'Outer line',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                thickness: {
                                    displayName: 'Thickness',
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                AsterPlot.AsterSlice = createClassAndSelector('asterSlice');
                AsterPlot.OuterLine = createClassAndSelector('outerLine');
                AsterPlot.CenterTextFontHeightCoefficient = 0.4;
                AsterPlot.CenterTextFontWidthCoefficient = 1.9;
                return AsterPlot;
            })();
            samples.AsterPlot = AsterPlot;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var PixelConverter = jsCommon.PixelConverter;
            samples.bulletChartProps = {
                values: {
                    targetValue: { objectName: 'values', propertyName: 'targetValue' },
                    minimumPercent: { objectName: 'values', propertyName: 'minimumPercent' },
                    needsImprovementPercent: { objectName: 'values', propertyName: 'needsImprovementPercent' },
                    satisfactoryPercent: { objectName: 'values', propertyName: 'satisfactoryPercent' },
                    goodPercent: { objectName: 'values', propertyName: 'goodPercent' },
                    veryGoodPercent: { objectName: 'values', propertyName: 'veryGoodPercent' },
                    maximumPercent: { objectName: 'values', propertyName: 'maximumPercent' },
                    targetValue2: { objectName: 'values', propertyName: 'targetValue2' },
                },
                orientation: {
                    orientation: { objectName: 'orientation', propertyName: 'orientation' },
                },
                colors: {
                    badColor: { objectName: 'colors', propertyName: 'badColor' },
                    needsImprovementColor: { objectName: 'colors', propertyName: 'needsImprovementColor' },
                    satisfactoryColor: { objectName: 'colors', propertyName: 'satisfactoryColor' },
                    goodColor: { objectName: 'colors', propertyName: 'goodColor' },
                    veryGoodColor: { objectName: 'colors', propertyName: 'veryGoodColor' },
                    bulletColor: { objectName: 'colors', propertyName: 'bulletColor' },
                },
                axis: {
                    axis: { objectName: 'axis', propertyName: 'axis' },
                    axisColor: { objectName: 'axis', propertyName: 'axisColor' },
                    measureUnits: { objectName: 'axis', propertyName: 'measureUnits' },
                    unitsColor: { objectName: 'axis', propertyName: 'unitsColor' },
                },
                formatString: { objectName: 'general', propertyName: 'formatString' },
                labels: {
                    fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                    show: { objectName: 'labels', propertyName: 'show' },
                    labelColor: { objectName: 'labels', propertyName: 'labelColor' }
                }
            };
            samples.bulletChartRoleNames = {
                value: 'Value',
                targetValue: 'TargetValue',
                minValue: 'Minimum',
                needsImprovementValue: 'NeedsImprovement',
                satisfactoryValue: 'Satisfactory',
                goodValue: 'Good',
                veryGoodValue: 'VeryGood',
                maxValue: 'Maximum',
                targetValue2: 'TargetValue2',
            };
            var Orientation;
            (function (Orientation) {
                Orientation.HORIZONTALLEFT = 'Horizontal Left';
                Orientation.HORIZONTALRIGHT = 'Horizontal Right';
                Orientation.VERTICALTOP = 'Vertical Top';
                Orientation.VERTICALBOTTOM = 'Vertical Bottom';
                Orientation.type = powerbi.createEnumType([
                    { value: Orientation.HORIZONTALLEFT, displayName: Orientation.HORIZONTALLEFT },
                    { value: Orientation.HORIZONTALRIGHT, displayName: Orientation.HORIZONTALRIGHT },
                    { value: Orientation.VERTICALTOP, displayName: Orientation.VERTICALTOP },
                    { value: Orientation.VERTICALBOTTOM, displayName: Orientation.VERTICALBOTTOM }
                ]);
            })(Orientation || (Orientation = {}));
            var BulletChart = (function () {
                function BulletChart() {
                    this.baselineDelta = 0;
                }
                Object.defineProperty(BulletChart.prototype, "reverse", {
                    get: function () {
                        return this.model.bulletChartSettings.orientation.reverse;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BulletChart.prototype, "vertical", {
                    get: function () {
                        return this.model.bulletChartSettings.orientation.vertical;
                    },
                    enumerable: true,
                    configurable: true
                });
                BulletChart.DefaultStyleProperties = function () {
                    return {
                        values: {
                            targetValue: 0,
                            targetValue2: 0,
                            minimumPercent: 0,
                            needsImprovementPercent: 25,
                            satisfactoryPercent: 50,
                            goodPercent: 100,
                            veryGoodPercent: 125,
                            maximumPercent: 200,
                        },
                        orientation: {
                            orientation: Orientation.HORIZONTALLEFT,
                            reverse: false,
                            vertical: false
                        },
                        colors: {
                            badColor: 'Darkred',
                            needsImprovementColor: 'Red',
                            satisfactoryColor: 'Yellow',
                            goodColor: 'Green',
                            veryGoodColor: 'Darkgreen',
                            bulletColor: 'Black'
                        },
                        axis: {
                            axis: true,
                            axisColor: 'Grey',
                            measureUnits: '',
                            unitsColor: 'Grey',
                        },
                        labelSettings: {
                            fontSize: 11,
                            show: true,
                            labelColor: 'Black',
                        },
                    };
                };
                Object.defineProperty(BulletChart.prototype, "viewportIn", {
                    get: function () {
                        return {
                            width: this.viewport.width,
                            height: this.viewport.height
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BulletChart.prototype, "viewportScroll", {
                    get: function () {
                        var viewportIn = this.viewportIn;
                        return {
                            width: viewportIn.width - BulletChart.ScrollBarSize,
                            height: viewportIn.height - BulletChart.ScrollBarSize
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                BulletChart.getTextProperties = function (text, fontSize) {
                    return {
                        fontFamily: BulletChart.FontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize),
                        text: text,
                    };
                };
                // Convert a DataView into a view model
                BulletChart.converter = function (dataView, options) {
                    var defaultSettings = BulletChart.DefaultStyleProperties();
                    var bulletModel = {
                        bulletValueFormatString: null,
                        bulletChartSettings: defaultSettings,
                        bars: [],
                        barRects: [],
                        valueRects: [],
                        targetValues: [],
                    };
                    if (!dataView || !dataView.categorical || !dataView.categorical.categories || !dataView.categorical.values || dataView.categorical.values.length === 0
                        || !dataView.metadata || !dataView.metadata.columns || dataView.metadata.columns.length === 0) {
                        return bulletModel;
                    }
                    var objects = dataView.metadata.objects;
                    var settings = bulletModel.bulletChartSettings;
                    if (objects) {
                        settings.values.targetValue = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue, defaultSettings.values.targetValue);
                        settings.values.targetValue2 = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2);
                        settings.values.minimumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent);
                        settings.values.needsImprovementPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent);
                        settings.values.satisfactoryPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent);
                        settings.values.goodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent);
                        settings.values.veryGoodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent);
                        settings.values.maximumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent);
                        settings.orientation.orientation = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation);
                        settings.colors.badColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.badColor, defaultSettings.colors.badColor);
                        settings.colors.needsImprovementColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor);
                        settings.colors.satisfactoryColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor);
                        settings.colors.goodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor);
                        settings.colors.veryGoodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor);
                        settings.colors.bulletColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor);
                        settings.axis.axis = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.axis, defaultSettings.axis.axis);
                        settings.axis.axisColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor);
                        settings.axis.measureUnits = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth);
                        settings.axis.unitsColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor);
                        settings.labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize);
                        settings.labelSettings.show = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.show, defaultSettings.labelSettings.show);
                        settings.labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor);
                    }
                    if (settings.orientation.orientation === Orientation.HORIZONTALRIGHT || settings.orientation.orientation === Orientation.VERTICALBOTTOM)
                        settings.orientation.reverse = true;
                    if (settings.orientation.orientation === Orientation.VERTICALTOP || settings.orientation.orientation === Orientation.VERTICALBOTTOM)
                        settings.orientation.vertical = true;
                    var categories, categoryValues, categoryValuesLen = 1, categoryFormatString;
                    if (dataView.categorical.categories) {
                        categories = dataView.categorical.categories[0];
                        categoryValues = categories.values;
                        categoryValuesLen = categoryValues.length;
                        categoryFormatString = visuals.valueFormatter.getFormatString(categories.source, samples.bulletChartProps.formatString);
                    }
                    bulletModel.bulletValueFormatString = visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps.formatString);
                    for (var idx = 0; idx < categoryValuesLen; idx++) {
                        var toolTipItems = [];
                        var category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0;
                        var highlight = false, categoryIdentity = void 0;
                        if (categoryValues) {
                            var categoryValue = categoryValues[idx];
                            category = visuals.valueFormatter.format(categoryValue, categoryFormatString);
                            categoryIdentity = categories.identity ? categories.identity[idx] : null;
                            var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);
                            category = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);
                            var labelWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                            var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                            BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth);
                            BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);
                        }
                        var values = dataView.categorical.values;
                        targetValue = settings.values.targetValue;
                        targetValue2 = settings.values.targetValue2;
                        for (var i = 0; i < values.length; i++) {
                            var col = values[i].source;
                            var currentVal = values[i].values[idx] || 0;
                            if (col && col.roles) {
                                if (col.roles[samples.bulletChartRoleNames.value]) {
                                    if (values[i].highlights)
                                        highlight = values[i].highlights[idx] !== null;
                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
                                    value = currentVal;
                                }
                                else if (col.roles[samples.bulletChartRoleNames.targetValue]) {
                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
                                    targetValue = currentVal;
                                }
                                else if (col.roles[samples.bulletChartRoleNames.targetValue2]) {
                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
                                    targetValue2 = currentVal;
                                }
                                else if (col.roles[samples.bulletChartRoleNames.minValue])
                                    minimum = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.needsImprovementValue])
                                    needsImprovement = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.satisfactoryValue])
                                    satisfactory = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.goodValue])
                                    good = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.veryGoodValue])
                                    veryGood = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.maxValue])
                                    maximum = currentVal;
                            }
                        }
                        if (!minimum)
                            minimum = settings.values.minimumPercent * targetValue / 100;
                        if (!needsImprovement)
                            needsImprovement = settings.values.needsImprovementPercent * targetValue / 100;
                        if (!satisfactory)
                            satisfactory = settings.values.satisfactoryPercent * targetValue / 100;
                        if (!good)
                            good = settings.values.goodPercent * targetValue / 100;
                        if (!veryGood)
                            veryGood = settings.values.veryGoodPercent * targetValue / 100;
                        if (!maximum)
                            maximum = settings.values.maximumPercent * targetValue / 100;
                        var viewportLength = (settings.orientation.vertical ? (options.viewport.height - BulletChart.MaxLabelHeight) : (options.viewport.width - BulletChart.MaxLabelWidth)) -
                            BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize;
                        var sortedRanges = [minimum, needsImprovement, satisfactory, good, veryGood, maximum].sort(d3.descending);
                        var scale = (d3.scale.linear()
                            .clamp(true)
                            .domain([minimum, Math.max(sortedRanges[0], targetValue, value)])
                            .range(settings.orientation.vertical ? [viewportLength, 0] : [0, viewportLength]));
                        // Scalles without
                        var firstScale = scale(minimum);
                        var secondScale = scale(needsImprovement);
                        var thirdScale = scale(satisfactory);
                        var fourthScale = scale(good);
                        var fifthScale = scale(veryGood);
                        var lastScale = scale(maximum);
                        var valueScale = scale(value);
                        var firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity);
                        // markerValue
                        bulletModel.targetValues.push({
                            barIndex: idx,
                            value: scale(targetValue),
                            fill: settings.colors.bulletColor,
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),
                            value2: scale(targetValue2),
                        });
                        var xAxis = null;
                        if (settings.axis.axis) {
                            xAxis = d3.svg.axis();
                            xAxis.orient(settings.orientation.vertical ? "left" : "bottom");
                            var minTickSize = Math.round(Math.max(3, viewportLength / 100));
                            var axisValues = [value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood]
                                .filter(function (x) { return !isNaN(x); });
                            xAxis.tickFormat(visuals.valueFormatter.create({
                                format: bulletModel.bulletValueFormatString,
                                value: axisValues.length ? Math.max.apply(null, axisValues) : 0
                            }).format);
                            xAxis.ticks(minTickSize);
                            xAxis.scale(scale);
                        }
                        var bar = {
                            scale: scale,
                            barIndex: idx,
                            categoryLabel: category,
                            x: (settings.orientation.vertical) ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,
                            y: (settings.orientation.vertical) ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,
                            axis: xAxis,
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey(),
                        };
                        bulletModel.bars.push(bar);
                    }
                    return bulletModel;
                };
                BulletChart.addItemToBarArray = function (collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity) {
                    collection.push({
                        barIndex: barIndex,
                        start: start,
                        end: end,
                        fill: fill,
                        tooltipInfo: visuals.TooltipBuilder.createTooltipInfo(samples.bulletChartProps.formatString, null, null, null, null, tooltipInfo),
                        selected: false,
                        identity: visuals.SelectionId.createWithId(categoryIdentity),
                        key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, start + " " + end).getKey(),
                    });
                };
                /* One time setup*/
                BulletChart.prototype.init = function (options) {
                    var body = d3.select(options.element.get(0));
                    this.hostService = options.host;
                    this.bulletBody = body
                        .append('div')
                        .classed('bulletChart', true);
                    this.scrollContainer = this.bulletBody.append('svg')
                        .classed('bullet-scroll-region', true);
                    this.clearCatcher = visuals.appendClearCatcher(this.scrollContainer);
                    this.labelGraphicsContext = this.scrollContainer.append('g');
                    this.bulletGraphicsContext = this.scrollContainer.append('g');
                    this.behavior = new BulletWebBehavior();
                    this.interactivityService = visuals.createInteractivityService(options.host);
                };
                /* Called for data, size, formatting changes*/
                BulletChart.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;
                    var dataView = options.dataViews[0];
                    this.viewport = options.viewport;
                    this.model = BulletChart.converter(dataView, options);
                    //TODO: Calculating the baseline delta of the text. needs to be removed once the TExtMeasurementService.estimateSVGTextBaselineDelta is available.
                    this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.model.bulletChartSettings.labelSettings.fontSize));
                    this.ClearViewport();
                    if (!this.model) {
                        return;
                    }
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(this.model.barRects);
                    }
                    this.bulletBody.style({
                        'height': this.viewportIn.height + 'px',
                        'width': this.viewportIn.width + 'px',
                    });
                    if (this.vertical) {
                        this.scrollContainer.attr({
                            width: (this.model.bars.length * BulletChart.SpaceRequiredForBarVertically) + 'px',
                            height: this.viewportScroll.height + 'px'
                        });
                    }
                    else {
                        this.scrollContainer.attr({
                            height: (this.model.bars.length * BulletChart.SpaceRequiredForBar) + 'px',
                            width: this.viewportScroll.width + 'px'
                        });
                    }
                    if (this.vertical)
                        this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse);
                    else
                        this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse);
                };
                BulletChart.prototype.ClearViewport = function () {
                    this.labelGraphicsContext.selectAll("text").remove();
                    this.bulletGraphicsContext.selectAll("rect").remove();
                    this.bulletGraphicsContext.selectAll('axis').remove();
                    this.bulletGraphicsContext.selectAll('path').remove();
                    this.bulletGraphicsContext.selectAll('line').remove();
                    this.bulletGraphicsContext.selectAll('tick').remove();
                    this.bulletGraphicsContext.selectAll('g').remove();
                };
                BulletChart.prototype.calculateLabelWidth = function (barData, bar, reversed) {
                    if (reversed)
                        return BulletChart.StartMarginHorizontal + ((bar) ? bar.start : 0);
                    var textSize = powerbi.TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                    if (textSize > BulletChart.BiggestLabelWidth)
                        return barData.x + BulletChart.MaxLabelWidth + ((bar) ? bar.start : 0);
                    return barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + ((bar) ? bar.start : 0);
                };
                BulletChart.prototype.calculateLabelHeight = function (barData, bar, reversed) {
                    if (reversed)
                        return BulletChart.StartMarginVertical + ((bar) ? bar.end : 0);
                    var textSize = powerbi.TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                    if (textSize > BulletChart.BiggestLabelHeight)
                        return barData.y + BulletChart.MaxLabelHeight + ((bar) ? bar.end : 0);
                    return barData.y + textSize + BulletChart.BarMargin + ((bar) ? bar.end : 0);
                };
                BulletChart.prototype.setUpBulletsHorizontally = function (bulletBody, model, reveresed) {
                    var _this = this;
                    var bars = model.bars;
                    var rects = model.barRects;
                    var valueRects = model.valueRects;
                    var targetValues = model.targetValues;
                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });
                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });
                    // Draw bullets
                    var bullets = rectSelection.enter().append('rect').attr({
                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),
                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 2; }),
                        'width': (function (d) { return d.end - d.start; }),
                        'height': BulletChart.BulletSize,
                    }).classed('range', true).style({
                        'fill': (function (d) { return d.fill; })
                    });
                    rectSelection.exit();
                    // Draw value rects
                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });
                    valueSelection.enter().append('rect').attr({
                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),
                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 8; }),
                        'width': (function (d) { return d.end - d.start; }),
                        'height': BulletChart.BulletSize * 1 / 4,
                    }).classed('value', true).style({
                        'fill': (function (d) { return d.fill; }),
                    });
                    valueSelection.exit();
                    // Draw markers
                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) { return d.key; });
                    markerSelection.enter().append('line').attr({
                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),
                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),
                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                    });
                    markerSelection.enter().append('line').attr({
                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(45deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.enter().append('line').attr({
                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(315deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.exit();
                    // Draw axes
                    if (model.bulletChartSettings.axis.axis) {
                        // Using var instead of let since you can't pass let parameters to functions inside loops.
                        // needs to be changed to let when typescript 1.8 comes out.
                        for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                'transform': function () {
                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed);
                                    var yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return 'translate(' + xLocation + ',' + yLocation + ')';
                                },
                            }).classed("axis", true).call(bar.axis.scale(bar.scale)).style({
                                'fill': model.bulletChartSettings.axis.axisColor,
                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll('line').style({
                                'stroke': model.bulletChartSettings.axis.axisColor,
                            });
                        }
                    }
                    // Draw Labels
                    if (model.bulletChartSettings.labelSettings.show) {
                        barSelection.enter().append('text').classed("title", true).attr({
                            'x': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().width + BulletChart.StartMarginHorizontal;
                                return d.x;
                            }),
                            'y': (function (d) { return d.y + _this.baselineDelta; }),
                            'fill': model.bulletChartSettings.labelSettings.labelColor,
                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),
                        }).text(function (d) { return d.categoryLabel; });
                    }
                    // Draw measure label
                    if (model.bulletChartSettings.axis.measureUnits) {
                        barSelection.enter().append('text').attr({
                            'x': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin;
                                return d.x - BulletChart.SubtitleMargin;
                            }),
                            'y': (function (d) { return d.y + BulletChart.BulletSize; }),
                            'fill': model.bulletChartSettings.axis.unitsColor,
                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(model.bulletChartSettings.axis.measureUnits);
                    }
                    if (this.interactivityService) {
                        var behaviorOptions = {
                            rects: bullets,
                            valueRects: valueSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                            bulletChartSettings: this.model.bulletChartSettings,
                            hasHighlights: false,
                        };
                        var targetCollection = this.model.barRects.concat(this.model.valueRects);
                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                    }
                    barSelection.exit();
                    visuals.TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    visuals.TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                };
                BulletChart.prototype.setUpBulletsVertically = function (bulletBody, model, reveresed) {
                    var _this = this;
                    var bars = model.bars;
                    var rects = model.barRects;
                    var valueRects = model.valueRects;
                    var targetValues = model.targetValues;
                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });
                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });
                    // Draw bullets
                    var bullets = rectSelection.enter().append('rect').attr({
                        'x': (function (d) { return bars[d.barIndex].x; }),
                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),
                        'height': (function (d) { return d.start - d.end; }),
                        'width': BulletChart.BulletSize,
                    }).classed('range', true).style({
                        'fill': (function (d) { return d.fill; })
                    });
                    rectSelection.exit();
                    // Draw value rects
                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });
                    valueSelection.enter().append('rect').attr({
                        'x': (function (d) { return bars[d.barIndex].x + BulletChart.BulletSize / 3; }),
                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),
                        'height': (function (d) { return d.start - d.end; }),
                        'width': BulletChart.BulletSize * 1 / 4,
                    }).classed('value', true).style({
                        'fill': (function (d) { return d.fill; }),
                    });
                    valueSelection.exit();
                    // Draw markers
                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) { return d.key; });
                    markerSelection.enter().append('line').attr({
                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),
                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                    });
                    markerSelection.enter().append('line').attr({
                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(45deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.enter().append('line').attr({
                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(315deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.exit();
                    // // Draw axes
                    if (model.bulletChartSettings.axis.axis) {
                        // Using var instead of let since you can't pass let parameters to functions inside loops.
                        // needs to be changed to let when typescript 1.8 comes out.
                        for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                'transform': function () {
                                    var xLocation = bar.x;
                                    var yLocation = _this.calculateLabelHeight(bar, null, reveresed);
                                    // let yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return 'translate(' + xLocation + ',' + yLocation + ')';
                                },
                            }).classed("axis", true).call(bar.axis.scale(bar.scale)).style({
                                'fill': model.bulletChartSettings.axis.axisColor,
                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt),
                            }).selectAll('line').style({
                                'stroke': model.bulletChartSettings.axis.axisColor,
                            });
                        }
                    }
                    // Draw Labels
                    if (model.bulletChartSettings.labelSettings.show) {
                        barSelection.enter().append('text').classed("title", true).attr({
                            'x': (function (d) { return d.x; }),
                            'y': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize;
                                return d.y + powerbi.TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel, model.bulletChartSettings.labelSettings.fontSize)) / 2;
                            }),
                            'fill': model.bulletChartSettings.labelSettings.labelColor,
                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),
                        }).text(function (d) { return d.categoryLabel; });
                    }
                    // Draw measure label
                    if (model.bulletChartSettings.axis.measureUnits) {
                        barSelection.enter().append('text').attr({
                            'x': (function (d) { return d.x + BulletChart.BulletSize; }),
                            'y': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;
                                return d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;
                            }),
                            'fill': model.bulletChartSettings.axis.unitsColor,
                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(model.bulletChartSettings.axis.measureUnits);
                    }
                    if (this.interactivityService) {
                        var behaviorOptions = {
                            rects: bullets,
                            valueRects: valueSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                            bulletChartSettings: this.model.bulletChartSettings,
                            hasHighlights: false,
                        };
                        var targetCollection = this.model.barRects.concat(this.model.valueRects);
                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                    }
                    barSelection.exit();
                    visuals.TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    visuals.TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                };
                /*About to remove your visual, do clean up here */
                BulletChart.prototype.destroy = function () { };
                BulletChart.prototype.enumerateObjectInstances = function (options) {
                    var data = this.model;
                    if (!data) {
                        return;
                    }
                    var objectName = options.objectName;
                    switch (objectName) {
                        case 'labels':
                            return this.enumerateLabels(data);
                        case 'values':
                            return this.enumerateValues(data);
                        case 'orientation':
                            return this.enumerateOrientation(data);
                        case 'axis':
                            return this.enumerateAxis(data);
                        case 'colors':
                            return this.enumerateColors(data);
                    }
                };
                BulletChart.prototype.enumerateLabels = function (data) {
                    return [{
                            selector: null,
                            objectName: 'labels',
                            properties: {
                                show: this.model.bulletChartSettings.labelSettings.show,
                                labelColor: this.model.bulletChartSettings.labelSettings.labelColor,
                                fontSize: this.model.bulletChartSettings.labelSettings.fontSize,
                            }
                        }];
                };
                BulletChart.prototype.enumerateValues = function (data) {
                    return [{
                            selector: null,
                            objectName: 'values',
                            properties: {
                                targetValue: this.model.bulletChartSettings.values.targetValue,
                                targetValue2: this.model.bulletChartSettings.values.targetValue2,
                                minimumPercent: this.model.bulletChartSettings.values.minimumPercent,
                                needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,
                                satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,
                                goodPercent: this.model.bulletChartSettings.values.goodPercent,
                                veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,
                                maximumPercent: this.model.bulletChartSettings.values.maximumPercent,
                            }
                        }];
                };
                BulletChart.prototype.enumerateOrientation = function (data) {
                    return [{
                            selector: null,
                            objectName: 'orientation',
                            properties: {
                                orientation: this.model.bulletChartSettings.orientation.orientation
                            }
                        }];
                };
                BulletChart.prototype.enumerateAxis = function (data) {
                    return [{
                            selector: null,
                            objectName: 'axis',
                            properties: {
                                axis: this.model.bulletChartSettings.axis.axis,
                                axisColor: this.model.bulletChartSettings.axis.axisColor,
                                measureUnits: this.model.bulletChartSettings.axis.measureUnits,
                                unitsColor: this.model.bulletChartSettings.axis.unitsColor,
                            }
                        }];
                };
                BulletChart.prototype.enumerateColors = function (data) {
                    return [{
                            selector: null,
                            objectName: 'colors',
                            properties: {
                                badColor: this.model.bulletChartSettings.colors.badColor,
                                needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,
                                satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,
                                goodColor: this.model.bulletChartSettings.colors.goodColor,
                                veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,
                                bulletColor: this.model.bulletChartSettings.colors.bulletColor,
                            }
                        }];
                };
                BulletChart.ScrollBarSize = 13;
                BulletChart.SpaceRequiredForBar = 60;
                BulletChart.SpaceRequiredForBarVertically = 100;
                BulletChart.StartMarginHorizontal = 30;
                BulletChart.StartMarginVertical = 50;
                BulletChart.BulletSize = 25;
                BulletChart.DefaultSubtitleFontSizeInPt = 9;
                BulletChart.BarMargin = 10;
                BulletChart.MaxLabelWidth = 80;
                BulletChart.MaxLabelHeight = 60;
                BulletChart.SubtitleMargin = 10;
                BulletChart.AxisFontSizeInPt = 8;
                BulletChart.BiggestLabelWidth = 0;
                BulletChart.BiggestLabelHeight = 0;
                BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3;
                BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4;
                BulletChart.FontFamily = "Segoe UI";
                BulletChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category',
                        }, {
                            name: 'Value',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Value',
                        }, {
                            name: 'TargetValue',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Target Value',
                        }, {
                            name: 'Minimum',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Minimum',
                        }, {
                            name: 'NeedsImprovement',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Needs Improvement',
                        }, {
                            name: 'Satisfactory',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Satisfactory',
                        }, {
                            name: 'Good',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Good',
                        }, {
                            name: 'VeryGood',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Very Good',
                        }, {
                            name: 'Maximum',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Maximum',
                        }, {
                            name: 'TargetValue2',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Target Value 2'
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        values: {
                            displayName: 'Data values',
                            properties: {
                                targetValue: {
                                    displayName: 'Target Value',
                                    type: { numeric: true }
                                },
                                targetValue2: {
                                    displayName: 'Target Value 2',
                                    type: { numeric: true },
                                },
                                minimumPercent: {
                                    displayName: 'Minimum %',
                                    type: { numeric: true }
                                },
                                needsImprovementPercent: {
                                    displayName: 'Needs Improvement %',
                                    type: { numeric: true },
                                },
                                satisfactoryPercent: {
                                    displayName: 'Satisfactory %',
                                    type: { numeric: true }
                                },
                                goodPercent: {
                                    displayName: 'Good %',
                                    type: { numeric: true }
                                },
                                veryGoodPercent: {
                                    displayName: 'Very Good %',
                                    type: { numeric: true },
                                },
                                maximumPercent: {
                                    displayName: 'Maximum %',
                                    type: { numeric: true }
                                },
                            }
                        },
                        labels: {
                            displayName: 'Category labels',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true },
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } },
                                },
                            },
                        },
                        orientation: {
                            displayName: 'Orientation',
                            properties: {
                                orientation: {
                                    displayName: 'Orientation',
                                    type: { enumeration: Orientation.type }
                                }
                            }
                        },
                        colors: {
                            displayName: 'Colors',
                            properties: {
                                badColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Bad Color'
                                },
                                needsImprovementColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Needs Improvement Color',
                                },
                                satisfactoryColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Satisfactory Color'
                                },
                                goodColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Good Color'
                                },
                                veryGoodColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Very Good Color',
                                },
                                bulletColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Bullet Color'
                                }
                            },
                        },
                        axis: {
                            displayName: 'Axis',
                            properties: {
                                axis: {
                                    displayName: 'Axis',
                                    type: { bool: true }
                                },
                                axisColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Axis Color'
                                },
                                measureUnits: {
                                    type: { text: true },
                                    displayName: 'Measure Units '
                                },
                                unitsColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Units Color'
                                },
                            }
                        }
                    },
                    dataViewMappings: [{
                            conditions: [
                                {
                                    'Category': { max: 1 }, 'Value': { max: 1 }, 'TargetValue': { max: 1 }, 'Minimum': { max: 1 }, 'NeedsImprovement': { max: 1 },
                                    'Satisfactory': { max: 1 }, 'Good': { max: 1 }, 'VeryGood': { max: 1 }, 'Maximum': { max: 1 }, 'TargetValue2': { max: 1 },
                                },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: 'Value' } },
                                        { bind: { to: 'TargetValue' } },
                                        { bind: { to: 'TargetValue2' } },
                                        { bind: { to: 'Minimum' } },
                                        { bind: { to: 'NeedsImprovement' } },
                                        { bind: { to: 'Satisfactory' } },
                                        { bind: { to: 'Good' } },
                                        { bind: { to: 'VeryGood' } },
                                        { bind: { to: 'Maximum' } },
                                    ]
                                },
                            },
                        }],
                    supportsHighlight: true,
                    sorting: {
                        default: {},
                    },
                    drilldown: {
                        roles: ['Category']
                    }
                };
                return BulletChart;
            })();
            samples.BulletChart = BulletChart;
            //TODO: This module should be removed once TextMeasruementService exports the "estimateSvgTextBaselineDelta" function.
            var TextMeasurementHelper;
            (function (TextMeasurementHelper) {
                var spanElement;
                var svgTextElement;
                var canvasCtx;
                function estimateSvgTextBaselineDelta(textProperties) {
                    var rect = estimateSvgTextRect(textProperties);
                    return rect.y + rect.height;
                }
                TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                function ensureDOM() {
                    if (spanElement)
                        return;
                    spanElement = $('<span/>');
                    $('body').append(spanElement);
                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
                    svgTextElement = d3.select($('body').get(0))
                        .append('svg')
                        .style({
                        'height': '0px',
                        'width': '0px',
                        'position': 'absolute'
                    })
                        .append('text');
                    canvasCtx = $('<canvas/>').get(0).getContext("2d");
                }
                function measureSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    ensureDOM();
                    svgTextElement.style(null);
                    svgTextElement
                        .text(textProperties.text)
                        .attr({
                        'visibility': 'hidden',
                        'font-family': textProperties.fontFamily,
                        'font-size': textProperties.fontSize,
                        'font-weight': textProperties.fontWeight,
                        'font-style': textProperties.fontStyle,
                        'white-space': textProperties.whiteSpace || 'nowrap'
                    });
                    // We're expecting the browser to give a synchronous measurement here
                    // We're using SVGTextElement because it works across all browsers 
                    return svgTextElement.node().getBBox();
                }
                function estimateSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    var estimatedTextProperties = {
                        fontFamily: textProperties.fontFamily,
                        fontSize: textProperties.fontSize,
                        text: "M",
                    };
                    var rect = measureSvgTextRect(estimatedTextProperties);
                    return rect;
                }
            })(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
            var BulletWebBehavior = (function () {
                function BulletWebBehavior() {
                }
                BulletWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    this.options = options;
                    var clearCatcher = options.clearCatcher;
                    options.valueRects.on('click', function (d, i) {
                        d3.event.stopPropagation();
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    });
                    options.rects.on('click', function (d, i) {
                        d3.event.stopPropagation();
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    });
                    clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                BulletWebBehavior.prototype.renderSelection = function (hasSelection) {
                    var options = this.options;
                    options.valueRects.style("opacity", function (d) {
                        return hasSelection ? (d.selected ? '1' : '0.4') : '1';
                    });
                    options.rects.style("opacity", function (d) {
                        return hasSelection ? (d.selected ? '1' : '0.4') : '1';
                    });
                };
                return BulletWebBehavior;
            })();
            samples.BulletWebBehavior = BulletWebBehavior;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var PixelConverter = jsCommon.PixelConverter;
            var TableViewFactory;
            (function (TableViewFactory) {
                function createTableView(options) {
                    return new TableView(options);
                }
                TableViewFactory.createTableView = createTableView;
            })(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
            /**
             * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
             * It can create lists containing either HTML or SVG elements.
             */
            var TableView = (function () {
                function TableView(options) {
                    // make a copy of options so that it is not modified later by caller
                    this.options = $.extend(true, {}, options);
                    this.options.baseContainer
                        .style('overflow-y', 'auto')
                        .attr('drag-resize-disabled', true);
                    this.scrollContainer = options.baseContainer
                        .append('div')
                        .attr('class', 'scrollRegion');
                    this.visibleGroupContainer = this.scrollContainer
                        .append('div')
                        .attr('class', 'visibleGroup');
                    TableView.SetDefaultOptions(options);
                }
                TableView.SetDefaultOptions = function (options) {
                    options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
                };
                TableView.prototype.rowHeight = function (rowHeight) {
                    this.options.rowHeight = Math.ceil(rowHeight);
                    return this;
                };
                TableView.prototype.columnWidth = function (columnWidth) {
                    this.options.columnWidth = Math.ceil(columnWidth);
                    return this;
                };
                TableView.prototype.orientation = function (orientation) {
                    this.options.orientation = orientation;
                    return this;
                };
                TableView.prototype.rows = function (rows) {
                    this.options.rows = Math.ceil(rows);
                    return this;
                };
                TableView.prototype.columns = function (columns) {
                    this.options.columns = Math.ceil(columns);
                    return this;
                };
                TableView.prototype.data = function (data, getDatumIndex, dataReset) {
                    if (dataReset === void 0) { dataReset = false; }
                    this._data = data;
                    this.getDatumIndex = getDatumIndex;
                    this.setTotalRows();
                    if (dataReset) {
                        $(this.options.baseContainer.node()).scrollTop(0);
                    }
                    return this;
                };
                TableView.prototype.viewport = function (viewport) {
                    this.options.viewport = viewport;
                    return this;
                };
                TableView.prototype.empty = function () {
                    this._data = [];
                    this.render();
                };
                TableView.prototype.setTotalRows = function () {
                    var count = this._data.length;
                    var rows = Math.min(this.options.rows, count);
                    var columns = Math.min(this.options.columns, count);
                    if ((columns > 0) && (rows > 0)) {
                        this._totalColumns = columns;
                        this._totalRows = rows;
                    }
                    else if (rows > 0) {
                        this._totalRows = rows;
                        this._totalColumns = Math.ceil(count / rows);
                    }
                    else if (columns > 0) {
                        this._totalColumns = columns;
                        this._totalRows = Math.ceil(count / columns);
                    }
                    else {
                        this._totalColumns = TableView.defaultColumns;
                        this._totalRows = Math.ceil(count / TableView.defaultColumns);
                    }
                    if (this.options.orientation === Orientation.HORIZONTAL) {
                        this._totalRows = 1;
                        this._totalColumns = count;
                    }
                };
                TableView.prototype.render = function () {
                    var options = this.options;
                    var visibleGroupContainer = this.visibleGroupContainer;
                    var rowHeight = options.rowHeight || TableView.defaultRowHeight;
                    var groupedData = [];
                    for (var i = 0; i < this._totalRows; i++) {
                        var k = i * this._totalColumns;
                        groupedData.push(this._data.slice(k, k + this._totalColumns));
                    }
                    visibleGroupContainer.selectAll(".row").remove();
                    var cellSelection = visibleGroupContainer.selectAll(".row")
                        .data(groupedData)
                        .enter()
                        .append("div")
                        .classed('row', true)
                        .selectAll(".cell")
                        .data(function (d) { return d; });
                    cellSelection
                        .enter()
                        .append('div')
                        .classed('cell', true)
                        .call(function (d) { return options.enter(d); });
                    cellSelection.order();
                    var cellUpdateSelection = visibleGroupContainer.selectAll('.cell:not(.transitioning)');
                    cellUpdateSelection.call(function (d) { return options.update(d); });
                    cellUpdateSelection.style({ 'height': (rowHeight > 0) ? rowHeight + 'px' : 'auto' });
                    cellUpdateSelection.style({
                        'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / this._totalColumns) + '%'
                    });
                    cellSelection
                        .exit()
                        .call(function (d) { return options.exit(d); })
                        .remove();
                };
                TableView.defaultRowHeight = 0;
                TableView.defaultColumns = 1;
                return TableView;
            })();
            // TODO: Generate these from above, defining twice just introduces potential for error
            samples.chicletSlicerProps = {
                general: {
                    orientation: { objectName: 'general', propertyName: 'orientation' },
                    columns: { objectName: 'general', propertyName: 'columns' },
                    rows: { objectName: 'general', propertyName: 'rows' },
                    showDisabled: { objectName: 'general', propertyName: 'showDisabled' },
                    multiselect: { objectName: 'general', propertyName: 'multiselect' },
                },
                header: {
                    show: { objectName: 'header', propertyName: 'show' },
                    title: { objectName: 'header', propertyName: 'title' },
                    fontColor: { objectName: 'header', propertyName: 'fontColor' },
                    background: { objectName: 'header', propertyName: 'background' },
                    outline: { objectName: 'header', propertyName: 'outline' },
                    textSize: { objectName: 'header', propertyName: 'textSize' },
                    outlineColor: { objectName: 'header', propertyName: 'outlineColor' },
                    outlineWeight: { objectName: 'header', propertyName: 'outlineWeight' }
                },
                rows: {
                    fontColor: { objectName: 'rows', propertyName: 'fontColor' },
                    textSize: { objectName: 'rows', propertyName: 'textSize' },
                    height: { objectName: 'rows', propertyName: 'height' },
                    width: { objectName: 'rows', propertyName: 'width' },
                    background: { objectName: 'rows', propertyName: 'background' },
                    transparency: { objectName: 'rows', propertyName: 'transparency' },
                    selectedColor: { objectName: 'rows', propertyName: 'selectedColor' },
                    unselectedColor: { objectName: 'rows', propertyName: 'unselectedColor' },
                    disabledColor: { objectName: 'rows', propertyName: 'disabledColor' },
                    outline: { objectName: 'rows', propertyName: 'outline' },
                    outlineColor: { objectName: 'rows', propertyName: 'outlineColor' },
                    outlineWeight: { objectName: 'rows', propertyName: 'outlineWeight' },
                    borderStyle: { objectName: 'rows', propertyName: 'borderStyle' },
                },
                images: {
                    imageSplit: { objectName: 'images', propertyName: 'imageSplit' },
                    stretchImage: { objectName: 'images', propertyName: 'stretchImage' },
                    bottomImage: { objectName: 'images', propertyName: 'bottomImage' },
                },
                selectedPropertyIdentifier: { objectName: 'general', propertyName: 'selected' },
                filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
                formatString: { objectName: 'general', propertyName: 'formatString' },
            };
            var ChicletBorderStyle;
            (function (ChicletBorderStyle) {
                ChicletBorderStyle.ROUNDED = 'Rounded';
                ChicletBorderStyle.CUT = 'Cut';
                ChicletBorderStyle.SQUARE = 'Square';
                ChicletBorderStyle.type = powerbi.createEnumType([
                    { value: ChicletBorderStyle.ROUNDED, displayName: ChicletBorderStyle.ROUNDED },
                    { value: ChicletBorderStyle.CUT, displayName: ChicletBorderStyle.CUT },
                    { value: ChicletBorderStyle.SQUARE, displayName: ChicletBorderStyle.SQUARE },
                ]);
            })(ChicletBorderStyle || (ChicletBorderStyle = {}));
            var ChicletSlicerShowDisabled;
            (function (ChicletSlicerShowDisabled) {
                ChicletSlicerShowDisabled.INPLACE = 'Inplace';
                ChicletSlicerShowDisabled.BOTTOM = 'Bottom';
                ChicletSlicerShowDisabled.HIDE = 'Hide';
                ChicletSlicerShowDisabled.type = powerbi.createEnumType([
                    { value: ChicletSlicerShowDisabled.INPLACE, displayName: ChicletSlicerShowDisabled.INPLACE },
                    { value: ChicletSlicerShowDisabled.BOTTOM, displayName: ChicletSlicerShowDisabled.BOTTOM },
                    { value: ChicletSlicerShowDisabled.HIDE, displayName: ChicletSlicerShowDisabled.HIDE },
                ]);
            })(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
            var Orientation;
            (function (Orientation) {
                Orientation.HORIZONTAL = 'Horizontal';
                Orientation.VERTICAL = 'Vertical';
                Orientation.type = powerbi.createEnumType([
                    { value: Orientation.HORIZONTAL, displayName: Orientation.HORIZONTAL },
                    { value: Orientation.VERTICAL, displayName: Orientation.VERTICAL }
                ]);
            })(Orientation || (Orientation = {}));
            var ChicletSlicer = (function () {
                function ChicletSlicer(options) {
                    if (options) {
                        if (options.behavior) {
                            this.behavior = options.behavior;
                        }
                    }
                    if (!this.behavior) {
                        this.behavior = new ChicletSlicerWebBehavior();
                    }
                }
                ChicletSlicer.DefaultStyleProperties = function () {
                    return {
                        general: {
                            orientation: Orientation.VERTICAL,
                            columns: 3,
                            rows: 0,
                            multiselect: true,
                            showDisabled: ChicletSlicerShowDisabled.INPLACE
                        },
                        margin: {
                            top: 50,
                            bottom: 50,
                            right: 50,
                            left: 50
                        },
                        header: {
                            borderBottomWidth: 1,
                            show: true,
                            outline: 'BottomOnly',
                            fontColor: '#a6a6a6',
                            background: '#ffffff',
                            textSize: 10,
                            outlineColor: '#a6a6a6',
                            outlineWeight: 1,
                            title: '',
                        },
                        headerText: {
                            marginLeft: 8,
                            marginTop: 0
                        },
                        slicerText: {
                            textSize: 10,
                            height: 0,
                            width: 0,
                            fontColor: '#666666',
                            hoverColor: '#212121',
                            selectedColor: '#BDD7EE',
                            unselectedColor: '#ffffff',
                            disabledColor: 'grey',
                            marginLeft: 8,
                            outline: 'Frame',
                            background: '#ffffff',
                            transparency: 0,
                            outlineColor: '#000000',
                            outlineWeight: 1,
                            borderStyle: 'Cut',
                        },
                        slicerItemContainer: {
                            // The margin is assigned in the less file. This is needed for the height calculations.
                            marginTop: 5,
                            marginLeft: 0,
                        },
                        images: {
                            imageSplit: 50,
                            stretchImage: false,
                            bottomImage: false
                        }
                    };
                };
                ChicletSlicer.converter = function (dataView, localizedSelectAllText, interactivityService) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !(dataView.categorical.categories[0].values.length > 0)) {
                        return;
                    }
                    var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
                    converter.convert();
                    var slicerData;
                    var defaultSettings = this.DefaultStyleProperties();
                    var objects = dataView.metadata.objects;
                    if (objects) {
                        defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation);
                        defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns);
                        defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows);
                        defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect);
                        defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled);
                        defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show);
                        defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title);
                        defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor);
                        defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background);
                        defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize);
                        defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline);
                        defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor);
                        defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight);
                        defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize);
                        defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height);
                        defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width);
                        defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor);
                        defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor);
                        defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor);
                        defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background);
                        defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency);
                        defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor);
                        defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline);
                        defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor);
                        defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight);
                        defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle);
                        defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit);
                        defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage);
                        defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage);
                    }
                    var categories = dataView.categorical.categories[0];
                    slicerData = {
                        categorySourceName: categories.source.displayName,
                        formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
                        slicerSettings: defaultSettings,
                        slicerDataPoints: converter.dataPoints,
                    };
                    // Override hasSelection if a objects contained more scopeIds than selections we found in the data
                    slicerData.hasSelectionOverride = converter.hasSelectionOverride;
                    return slicerData;
                };
                ChicletSlicer.prototype.init = function (options) {
                    this.element = options.element;
                    this.currentViewport = options.viewport;
                    if (this.behavior) {
                        this.interactivityService = visuals.createInteractivityService(options.host);
                    }
                    this.hostServices = options.host;
                    this.settings = ChicletSlicer.DefaultStyleProperties();
                    this.initContainer();
                };
                ChicletSlicer.prototype.update = function (options) {
                    if (!options ||
                        !options.dataViews ||
                        !options.dataViews[0] ||
                        !options.viewport) {
                        return;
                    }
                    var existingDataView = this.dataView;
                    this.dataView = options.dataViews[0];
                    var resetScrollbarPosition = true;
                    if (existingDataView) {
                        resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                    }
                    if (options.viewport.height === this.currentViewport.height
                        && options.viewport.width === this.currentViewport.width) {
                        this.waitingForData = false;
                    }
                    else {
                        this.currentViewport = options.viewport;
                    }
                    this.updateInternal(resetScrollbarPosition);
                };
                ChicletSlicer.prototype.onResizing = function (finalViewport) {
                    this.currentViewport = finalViewport;
                    this.updateInternal(false /* resetScrollbarPosition */);
                };
                ChicletSlicer.prototype.enumerateObjectInstances = function (options) {
                    var data = this.slicerData;
                    if (!data) {
                        return;
                    }
                    var objectName = options.objectName;
                    switch (objectName) {
                        case 'rows':
                            return this.enumerateRows(data);
                        case 'header':
                            return this.enumerateHeader(data);
                        case 'general':
                            return this.enumerateGeneral(data);
                        case 'images':
                            return this.enumerateImages(data);
                    }
                };
                ChicletSlicer.prototype.enumerateHeader = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'header',
                            properties: {
                                show: slicerSettings.header.show,
                                title: slicerSettings.header.title,
                                fontColor: slicerSettings.header.fontColor,
                                background: slicerSettings.header.background,
                                textSize: slicerSettings.header.textSize,
                                outline: slicerSettings.header.outline,
                                outlineColor: slicerSettings.header.outlineColor,
                                outlineWeight: slicerSettings.header.outlineWeight
                            }
                        }];
                };
                ChicletSlicer.prototype.enumerateRows = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'rows',
                            properties: {
                                textSize: slicerSettings.slicerText.textSize,
                                height: slicerSettings.slicerText.height,
                                width: slicerSettings.slicerText.width,
                                background: slicerSettings.slicerText.background,
                                transparency: slicerSettings.slicerText.transparency,
                                selectedColor: slicerSettings.slicerText.selectedColor,
                                unselectedColor: slicerSettings.slicerText.unselectedColor,
                                disabledColor: slicerSettings.slicerText.disabledColor,
                                outline: slicerSettings.slicerText.outline,
                                outlineColor: slicerSettings.slicerText.outlineColor,
                                outlineWeight: slicerSettings.slicerText.outlineWeight,
                                fontColor: slicerSettings.slicerText.fontColor,
                                borderStyle: slicerSettings.slicerText.borderStyle,
                            }
                        }];
                };
                ChicletSlicer.prototype.enumerateGeneral = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'general',
                            properties: {
                                orientation: slicerSettings.general.orientation,
                                columns: slicerSettings.general.columns,
                                rows: slicerSettings.general.rows,
                                showDisabled: slicerSettings.general.showDisabled,
                                multiselect: slicerSettings.general.multiselect,
                            }
                        }];
                };
                ChicletSlicer.prototype.enumerateImages = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'images',
                            properties: {
                                imageSplit: slicerSettings.images.imageSplit,
                                stretchImage: slicerSettings.images.stretchImage,
                                bottomImage: slicerSettings.images.bottomImage,
                            }
                        }];
                };
                ChicletSlicer.prototype.updateInternal = function (resetScrollbarPosition) {
                    this.updateSlicerBodyDimensions();
                    var localizedSelectAllText = 'Select All';
                    var data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);
                    if (!data) {
                        this.tableView.empty();
                        return;
                    }
                    data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight;
                    this.slicerData = data;
                    this.settings = this.slicerData.slicerSettings;
                    if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM) {
                        data.slicerDataPoints.sort(function (a, b) {
                            if (a.selectable === b.selectable) {
                                return 0;
                            }
                            else if (a.selectable && !b.selectable) {
                                return -1;
                            }
                            else {
                                return 1;
                            }
                        });
                    }
                    else if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE) {
                        data.slicerDataPoints = data.slicerDataPoints.filter(function (x) { return x.selectable; });
                    }
                    var textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
                    var height = this.settings.slicerText.height > 0 ? this.settings.slicerText.height :
                        (data.slicerDataPoints.length === 0 || data.slicerDataPoints[0].imageURL !== '' ? 100 :
                            powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta(textProperties));
                    this.tableView
                        .rowHeight(height)
                        .columnWidth(this.settings.slicerText.width)
                        .orientation(this.settings.general.orientation)
                        .rows(this.settings.general.rows)
                        .columns(this.settings.general.columns)
                        .data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }, resetScrollbarPosition)
                        .viewport(this.getSlicerBodyViewport(this.currentViewport))
                        .render();
                };
                ChicletSlicer.prototype.initContainer = function () {
                    var _this = this;
                    var settings = this.settings;
                    var slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport);
                    var slicerContainer = d3.select(this.element.get(0))
                        .append('div')
                        .classed(ChicletSlicer.Container.class, true);
                    this.slicerHeader = slicerContainer
                        .append('div')
                        .classed(ChicletSlicer.Header.class, true);
                    this.slicerHeader
                        .append('span')
                        .classed(ChicletSlicer.Clear.class, true)
                        .attr('title', 'Clear');
                    this.slicerHeader
                        .append('div')
                        .classed(ChicletSlicer.HeaderText.class, true)
                        .style({
                        'margin-left': PixelConverter.toString(settings.headerText.marginLeft),
                        'margin-top': PixelConverter.toString(settings.headerText.marginTop),
                        'border-style': this.getBorderStyle(settings.header.outline),
                        'border-color': settings.header.outlineColor,
                        'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                        'font-size': PixelConverter.fromPoint(settings.header.textSize),
                    });
                    this.slicerBody = slicerContainer
                        .append('div').classed(ChicletSlicer.Body.class, true)
                        .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)
                        .style({
                        'height': PixelConverter.toString(slicerBodyViewport.height),
                        'width': '100%',
                    });
                    var rowEnter = function (rowSelection) {
                        var settings = _this.settings;
                        var listItemElement = rowSelection.append('li')
                            .classed(ChicletSlicer.ItemContainer.class, true)
                            .style({
                            'margin-left': PixelConverter.toString(settings.slicerItemContainer.marginLeft),
                        });
                        listItemElement.append('div')
                            .classed('slicer-img-wrapper', true);
                        listItemElement.append('div')
                            .classed('slicer-text-wrapper', true)
                            .append('span')
                            .classed(ChicletSlicer.LabelText.class, true)
                            .style({
                            'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
                        });
                    };
                    var rowUpdate = function (rowSelection) {
                        var settings = _this.settings;
                        var data = _this.slicerData;
                        if (data && settings) {
                            _this.slicerHeader.classed('hidden', !settings.header.show);
                            _this.slicerHeader.select(ChicletSlicer.HeaderText.selector)
                                .text(settings.header.title.trim() !== "" ? settings.header.title.trim() : _this.slicerData.categorySourceName)
                                .style({
                                'border-style': _this.getBorderStyle(settings.header.outline),
                                'border-color': settings.header.outlineColor,
                                'border-width': _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                                'color': settings.header.fontColor,
                                'background-color': settings.header.background,
                                'font-size': PixelConverter.fromPoint(settings.header.textSize),
                            });
                            _this.slicerBody
                                .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL);
                            var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector);
                            var textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize);
                            var formatString = data.formatString;
                            slicerText.text(function (d) {
                                var text = visuals.valueFormatter.format(d.category, formatString);
                                textProperties.text = text;
                                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.currentViewport.width / _this.settings.general.columns);
                            });
                            var slicerImg = rowSelection.selectAll('.slicer-img-wrapper');
                            slicerImg
                                .style('height', settings.images.imageSplit + '%')
                                .classed('hidden', function (d) {
                                if (!(d.imageURL)) {
                                    return true;
                                }
                                if (settings.images.imageSplit < 10) {
                                    return true;
                                }
                            })
                                .style('display', function (d) { return (d.imageURL) ? 'flex' : 'none'; })
                                .classed('stretchImage', settings.images.stretchImage)
                                .classed('bottomImage', settings.images.bottomImage)
                                .style('background-image', function (d) {
                                return d.imageURL ? "url(" + d.imageURL + ")" : '';
                            });
                            rowSelection.selectAll('.slicer-text-wrapper')
                                .style('height', function (d) {
                                return d.imageURL ? (100 - settings.images.imageSplit) + '%' : '100%';
                            })
                                .classed('hidden', function (d) {
                                if (settings.images.imageSplit > 90) {
                                    return true;
                                }
                            });
                            rowSelection.selectAll('.slicerItemContainer').style({
                                'color': settings.slicerText.fontColor,
                                'border-style': _this.getBorderStyle(settings.slicerText.outline),
                                'border-color': settings.slicerText.outlineColor,
                                'border-width': _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
                                'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
                                'border-radius': _this.getBorderRadius(settings.slicerText.borderStyle),
                            });
                            _this.slicerBody.style('background-color', explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100));
                            if (_this.interactivityService && _this.slicerBody) {
                                var slicerBody = _this.slicerBody.attr('width', _this.currentViewport.width);
                                var slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector);
                                var slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector);
                                var slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector);
                                var slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector);
                                var behaviorOptions = {
                                    dataPoints: data.slicerDataPoints,
                                    slicerItemContainers: slicerItemContainers,
                                    slicerItemLabels: slicerItemLabels,
                                    slicerItemInputs: slicerItemInputs,
                                    slicerClear: slicerClear,
                                    interactivityService: _this.interactivityService,
                                    slicerSettings: data.slicerSettings,
                                };
                                _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {
                                    overrideSelectionFromData: true,
                                    hasSelectionOverride: data.hasSelectionOverride
                                });
                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());
                            }
                            else {
                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), false);
                            }
                        }
                    };
                    var rowExit = function (rowSelection) {
                        rowSelection.remove();
                    };
                    var tableViewOptions = {
                        rowHeight: this.getRowHeight(),
                        columnWidth: this.settings.slicerText.width,
                        orientation: this.settings.general.orientation,
                        rows: this.settings.general.rows,
                        columns: this.settings.general.columns,
                        enter: rowEnter,
                        exit: rowExit,
                        update: rowUpdate,
                        loadMoreData: function () { return _this.onLoadMoreData(); },
                        scrollEnabled: true,
                        viewport: this.getSlicerBodyViewport(this.currentViewport),
                        baseContainer: this.slicerBody,
                    };
                    this.tableView = TableViewFactory.createTableView(tableViewOptions);
                };
                ChicletSlicer.prototype.onLoadMoreData = function () {
                    if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                        this.hostServices.loadMoreData();
                        this.waitingForData = true;
                    }
                };
                ChicletSlicer.prototype.getSlicerBodyViewport = function (currentViewport) {
                    var settings = this.settings;
                    var headerHeight = (settings.header.show) ? this.getHeaderHeight() : 0;
                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                    return {
                        height: slicerBodyHeight,
                        width: currentViewport.width
                    };
                };
                ChicletSlicer.prototype.updateSlicerBodyDimensions = function () {
                    var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                    this.slicerBody
                        .style({
                        'height': PixelConverter.toString(slicerViewport.height),
                        'width': '100%',
                    });
                };
                ChicletSlicer.getChicletTextProperties = function (textSize) {
                    return {
                        fontFamily: ChicletSlicer.DefaultFontFamily,
                        fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt),
                    };
                };
                ChicletSlicer.prototype.getHeaderHeight = function () {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
                };
                ChicletSlicer.prototype.getRowHeight = function () {
                    var textSettings = this.settings.slicerText;
                    return textSettings.height !== 0
                        ? textSettings.height
                        : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
                };
                ChicletSlicer.prototype.getBorderStyle = function (outlineElement) {
                    return outlineElement === '0px' ? 'none' : 'solid';
                };
                ChicletSlicer.prototype.getBorderWidth = function (outlineElement, outlineWeight) {
                    switch (outlineElement) {
                        case 'None':
                            return '0px';
                        case 'BottomOnly':
                            return '0px 0px ' + outlineWeight + 'px 0px';
                        case 'TopOnly':
                            return outlineWeight + 'px 0px 0px 0px';
                        case 'TopBottom':
                            return outlineWeight + 'px 0px ' + outlineWeight + 'px 0px';
                        case 'LeftRight':
                            return '0px ' + outlineWeight + 'px 0px ' + outlineWeight + 'px';
                        case 'Frame':
                            return outlineWeight + 'px';
                        default:
                            return outlineElement.replace("1", outlineWeight.toString());
                    }
                };
                ChicletSlicer.prototype.getBorderRadius = function (borderType) {
                    switch (borderType) {
                        case ChicletBorderStyle.ROUNDED:
                            return "10px";
                        case ChicletBorderStyle.SQUARE:
                            return "0px";
                        default:
                            return "5px";
                    }
                };
                ChicletSlicer.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),
                        },
                        {
                            name: 'Values',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                        },
                        {
                            name: 'Image',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Image',
                        },
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                orientation: {
                                    displayName: 'Orientation',
                                    type: { enumeration: Orientation.type }
                                },
                                columns: {
                                    displayName: 'Columns',
                                    type: { numeric: true }
                                },
                                rows: {
                                    displayName: 'Rows',
                                    type: { numeric: true }
                                },
                                showDisabled: {
                                    displayName: 'Show Disabled',
                                    type: { enumeration: ChicletSlicerShowDisabled.type }
                                },
                                multiselect: {
                                    displayName: 'Multiple selection',
                                    type: { bool: true }
                                },
                                selected: {
                                    type: { bool: true }
                                },
                                filter: {
                                    type: { filter: {} },
                                    rule: {
                                        output: {
                                            property: 'selected',
                                            selector: ['Category'],
                                        }
                                    }
                                },
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        header: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                title: {
                                    displayName: 'Title',
                                    type: { text: true }
                                },
                                fontColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                background: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                outline: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                                    type: { formatting: { outline: true } }
                                },
                                textSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { numeric: true }
                                },
                                outlineColor: {
                                    displayName: 'Outline Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                outlineWeight: {
                                    displayName: 'Outline Weight',
                                    type: { numeric: true }
                                }
                            }
                        },
                        rows: {
                            displayName: 'Chiclets',
                            properties: {
                                fontColor: {
                                    displayName: 'Text color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                textSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { numeric: true }
                                },
                                height: {
                                    displayName: 'Height',
                                    type: { numeric: true }
                                },
                                width: {
                                    displayName: 'Width',
                                    type: { numeric: true }
                                },
                                selectedColor: {
                                    displayName: 'Selected Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                unselectedColor: {
                                    displayName: 'Unselected Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                disabledColor: {
                                    displayName: 'Disabled Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                background: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                transparency: {
                                    displayName: "Transparency",
                                    description: "Set transparency for background color",
                                    type: { numeric: true }
                                },
                                outline: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                                    type: { formatting: { outline: true } }
                                },
                                outlineColor: {
                                    displayName: 'Outline Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                outlineWeight: {
                                    displayName: 'Outline Weight',
                                    type: { numeric: true }
                                },
                                borderStyle: {
                                    displayName: 'Outline Style',
                                    type: { enumeration: ChicletBorderStyle.type }
                                },
                            }
                        },
                        images: {
                            displayName: 'Images',
                            properties: {
                                imageSplit: {
                                    displayName: 'Image Split',
                                    type: { numeric: true }
                                },
                                stretchImage: {
                                    displayName: 'Stretch image',
                                    type: { bool: true }
                                },
                                bottomImage: {
                                    displayName: 'Bottom image',
                                    type: { bool: true }
                                },
                            }
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Image': { min: 0, max: 1 }, 'Values': { min: 0, max: 1 } }],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Image',
                                        select: [{ bind: { to: 'Values' } },
                                        ],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                includeEmptyGroups: true
                            }
                        }],
                    supportsHighlight: true,
                    sorting: {
                        default: {},
                    },
                    suppressDefaultTitle: true,
                };
                ChicletSlicer.DefaultFontFamily = 'Segoe UI, Tahoma, Verdana, Geneva, sans-serif';
                ChicletSlicer.DefaultFontSizeInPt = 11;
                ChicletSlicer.ItemContainer = createClassAndSelector('slicerItemContainer');
                ChicletSlicer.HeaderText = createClassAndSelector('headerText');
                ChicletSlicer.Container = createClassAndSelector('chicletSlicer');
                ChicletSlicer.LabelText = createClassAndSelector('slicerText');
                ChicletSlicer.Header = createClassAndSelector('slicerHeader');
                ChicletSlicer.Input = createClassAndSelector('slicerCheckbox');
                ChicletSlicer.Clear = createClassAndSelector('clear');
                ChicletSlicer.Body = createClassAndSelector('slicerBody');
                return ChicletSlicer;
            })();
            samples.ChicletSlicer = ChicletSlicer;
            var ChicletSlicerChartConversion;
            (function (ChicletSlicerChartConversion) {
                var ChicletSlicerConverter = (function () {
                    function ChicletSlicerConverter(dataView, interactivityService) {
                        var dataViewCategorical = dataView.categorical;
                        this.dataViewCategorical = dataViewCategorical;
                        this.dataViewMetadata = dataView.metadata;
                        if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                            this.category = dataViewCategorical.categories[0];
                            this.categoryIdentities = this.category.identity;
                            this.categoryValues = this.category.values;
                            this.categoryColumnRef = this.category.identityFields;
                            this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString);
                        }
                        this.dataPoints = [];
                        this.interactivityService = interactivityService;
                        this.hasSelectionOverride = false;
                    }
                    ChicletSlicerConverter.prototype.convert = function () {
                        this.dataPoints = [];
                        this.numberOfCategoriesSelectedInData = 0;
                        // If category exists, we render labels using category values. If not, we render labels
                        // using measure labels.
                        if (this.categoryValues) {
                            var objects = this.dataViewMetadata ? this.dataViewMetadata.objects : undefined;
                            var isInvertedSelectionMode = undefined;
                            var numberOfScopeIds;
                            if (objects && objects.general && objects.general.filter) {
                                if (!this.categoryColumnRef)
                                    return;
                                var filter = objects.general.filter;
                                var scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
                                if (scopeIds) {
                                    isInvertedSelectionMode = scopeIds.isNot;
                                    numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0;
                                }
                                else {
                                    isInvertedSelectionMode = false;
                                }
                            }
                            if (this.interactivityService) {
                                if (isInvertedSelectionMode === undefined) {
                                    // The selection state is read from the Interactivity service in case of SelectAll or Clear when query doesn't update the visual
                                    isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted();
                                }
                                else {
                                    this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                                }
                            }
                            var hasSelection = undefined;
                            for (var idx = 0; idx < this.categoryValues.length; idx++) {
                                var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
                                if (selected != null) {
                                    hasSelection = selected;
                                    break;
                                }
                            }
                            var dataViewCategorical = this.dataViewCategorical;
                            var formatStringProp = samples.chicletSlicerProps.formatString;
                            var value = -Infinity;
                            var imageURL = '';
                            for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                                var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null;
                                var categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex);
                                var selectable = true;
                                if (hasSelection != null) {
                                    if (isInvertedSelectionMode) {
                                        if (this.category.objects == null)
                                            categoryIsSelected = undefined;
                                        if (categoryIsSelected != null) {
                                            categoryIsSelected = hasSelection;
                                        }
                                        else if (categoryIsSelected == null)
                                            categoryIsSelected = !hasSelection;
                                    }
                                    else {
                                        if (categoryIsSelected == null) {
                                            categoryIsSelected = !hasSelection;
                                        }
                                    }
                                }
                                if (categoryIsSelected) {
                                    this.numberOfCategoriesSelectedInData++;
                                }
                                var categoryValue = this.categoryValues[categoryIndex];
                                var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                                if (this.dataViewCategorical.values) {
                                    // Series are either measures in the multi-measure case, or the single series otherwise
                                    for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
                                        var seriesData = dataViewCategorical.values[seriesIndex];
                                        if (seriesData.values[categoryIndex] != null) {
                                            value = seriesData.values[categoryIndex];
                                            if (seriesData.highlights) {
                                                selectable = !(seriesData.highlights[categoryIndex] === null);
                                            }
                                            if (seriesData.source.groupName && seriesData.source.groupName !== '') {
                                                imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                                                if (!/^(ftp|http|https):\/\/[^ "]+$/.test(imageURL)) {
                                                    imageURL = undefined;
                                                }
                                            }
                                        }
                                    }
                                }
                                this.dataPoints.push({
                                    identity: visuals.SelectionId.createWithId(categoryIdentity),
                                    category: categoryLabel,
                                    imageURL: imageURL,
                                    value: value,
                                    selected: categoryIsSelected,
                                    selectable: selectable
                                });
                            }
                            if (numberOfScopeIds != null && numberOfScopeIds > this.numberOfCategoriesSelectedInData) {
                                this.hasSelectionOverride = true;
                            }
                        }
                    };
                    return ChicletSlicerConverter;
                })();
                ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
            })(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
            //TODO: This module should be removed once TextMeasruementService exports the "estimateSvgTextBaselineDelta" function.
            var ChicletSlicerTextMeasurementHelper;
            (function (ChicletSlicerTextMeasurementHelper) {
                var spanElement;
                var svgTextElement;
                var canvasCtx;
                function estimateSvgTextBaselineDelta(textProperties) {
                    var rect = estimateSvgTextRect(textProperties);
                    return rect.y + rect.height;
                }
                ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                function ensureDOM() {
                    if (spanElement)
                        return;
                    spanElement = $('<span/>');
                    $('body').append(spanElement);
                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
                    svgTextElement = d3.select($('body').get(0))
                        .append('svg')
                        .style({
                        'height': '0px',
                        'width': '0px',
                        'position': 'absolute'
                    })
                        .append('text');
                    canvasCtx = $('<canvas/>').get(0).getContext("2d");
                }
                function measureSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    ensureDOM();
                    svgTextElement.style(null);
                    svgTextElement
                        .text(textProperties.text)
                        .attr({
                        'visibility': 'hidden',
                        'font-family': textProperties.fontFamily,
                        'font-size': textProperties.fontSize,
                        'font-weight': textProperties.fontWeight,
                        'font-style': textProperties.fontStyle,
                        'white-space': textProperties.whiteSpace || 'nowrap'
                    });
                    // We're expecting the browser to give a synchronous measurement here
                    // We're using SVGTextElement because it works across all browsers 
                    return svgTextElement.node().getBBox();
                }
                function estimateSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    var estimatedTextProperties = {
                        fontFamily: textProperties.fontFamily,
                        fontSize: textProperties.fontSize,
                        text: "M",
                    };
                    var rect = measureSvgTextRect(estimatedTextProperties);
                    return rect;
                }
            })(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
            var ChicletSlicerWebBehavior = (function () {
                function ChicletSlicerWebBehavior() {
                }
                ChicletSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    var _this = this;
                    var filterPropertyId = samples.chicletSlicerProps.filterPropertyIdentifier;
                    var slicers = this.slicers = options.slicerItemContainers;
                    this.slicerItemLabels = options.slicerItemLabels;
                    this.slicerItemInputs = options.slicerItemInputs;
                    var slicerClear = options.slicerClear;
                    this.dataPoints = options.dataPoints;
                    this.interactivityService = options.interactivityService;
                    this.slicerSettings = options.slicerSettings;
                    slicers.on("mouseover", function (d) {
                        if (d.selectable) {
                            d.mouseOver = true;
                            d.mouseOut = false;
                            _this.renderMouseover();
                        }
                    });
                    slicers.on("mouseout", function (d) {
                        if (d.selectable) {
                            d.mouseOver = false;
                            d.mouseOut = true;
                            _this.renderMouseover();
                        }
                    });
                    slicers.on("click", function (d, index) {
                        if (!d.selectable) {
                            return;
                        }
                        var settings = _this.slicerSettings;
                        d3.event.preventDefault();
                        if (d3.event.altKey && settings.general.multiselect) {
                            var selectedIndexes = jQuery.map(_this.dataPoints, function (d, index) { if (d.selected)
                                return index; });
                            var selIndex = selectedIndexes.length > 0 ? (selectedIndexes[selectedIndexes.length - 1]) : 0;
                            if (selIndex > index) {
                                var temp = index;
                                index = selIndex;
                                selIndex = temp;
                            }
                            selectionHandler.handleClearSelection();
                            for (var i = selIndex; i <= index; i++) {
                                selectionHandler.handleSelection(_this.dataPoints[i], true /* isMultiSelect */);
                            }
                        }
                        else if (d3.event.ctrlKey && settings.general.multiselect) {
                            selectionHandler.handleSelection(d, true /* isMultiSelect */);
                        }
                        else {
                            selectionHandler.handleSelection(d, false /* isMultiSelect */);
                        }
                        selectionHandler.persistSelectionFilter(filterPropertyId);
                    });
                    slicerClear.on("click", function (d) {
                        selectionHandler.handleClearSelection();
                        selectionHandler.persistSelectionFilter(filterPropertyId);
                    });
                };
                ChicletSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                    if (!hasSelection && !this.interactivityService.isSelectionModeInverted()) {
                        this.slicers.style('background', this.slicerSettings.slicerText.unselectedColor);
                    }
                    else {
                        this.styleSlicerInputs(this.slicers, hasSelection);
                    }
                };
                ChicletSlicerWebBehavior.prototype.renderMouseover = function () {
                    var _this = this;
                    this.slicerItemLabels.style({
                        'color': function (d) {
                            if (d.mouseOver)
                                return _this.slicerSettings.slicerText.hoverColor;
                            if (d.mouseOut) {
                                if (d.selected)
                                    return _this.slicerSettings.slicerText.fontColor;
                                else
                                    return _this.slicerSettings.slicerText.fontColor;
                            }
                        }
                    });
                };
                ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function (slicers, hasSelection) {
                    var settings = this.slicerSettings;
                    slicers.each(function (d) {
                        d3.select(this).style({
                            'background': d.selectable ? (d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor)
                                : settings.slicerText.disabledColor
                        });
                        d3.select(this).classed('slicerItem-disabled', !d.selectable);
                    });
                };
                return ChicletSlicerWebBehavior;
            })();
            samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
            var explore;
            (function (explore) {
                var util;
                (function (util) {
                    function hexToRGBString(hex, transparency) {
                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                            return r + r + g + g + b + b;
                        });
                        // Hex format which return the format r-g-b
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        var rgb = result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                        // Wrong input
                        if (rgb === null) {
                            return '';
                        }
                        if (!transparency && transparency !== 0) {
                            return "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        }
                        else {
                            return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")";
                        }
                    }
                    util.hexToRGBString = hexToRGBString;
                })(util = explore.util || (explore.util = {}));
            })(explore || (explore = {}));
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ChordChart = (function () {
                function ChordChart() {
                }
                /* Convert a DataView into a view model */
                ChordChart.converter = function (dataView, colors, prevAxisVisible) {
                    var catDv = dataView.categorical;
                    var defaultDataPointColor = ChordChart.getDefaultDataPointColor(dataView).solid.color;
                    var labelColor = ChordChart.getLabelsColor(dataView);
                    var labelFontSize = ChordChart.getLabelsFontSize(dataView);
                    if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {
                        var cat = catDv.categories[0];
                        var catValues = cat.values;
                        var values = catDv.values;
                        var dataMatrix = [];
                        var legendData = {
                            dataPoints: [],
                            title: values[0] && values[0].source ? values[0].source.displayName : "",
                        };
                        var toolTipData = [];
                        var sliceTooltipData = [];
                        var max = 1000;
                        var seriesName = []; /* series name array */
                        var seriesIndex = []; /* series index array */
                        var catIndex = []; /* index array for category names */
                        var isDiffFromTo = false; /* boolean variable indicates that From and To are different */
                        var labelData = []; /* label data: !important */
                        var colorHelper = new visuals.ColorHelper(colors, ChordChart.chordChartProps.dataPoint.fill, defaultDataPointColor);
                        for (var i = 0, iLen = catValues.length; i < iLen; i++) {
                            catIndex[catValues[i]] = i;
                        }
                        for (var i = 0, iLen = values.length; i < iLen; i++) {
                            var seriesNameStr = visuals.converterHelper.getSeriesName(values[i].source);
                            seriesName.push(seriesNameStr);
                            seriesIndex[seriesNameStr] = i;
                        }
                        var totalFields = this.union_arrays(catValues, seriesName);
                        if (ChordChart.getValidArrayLength(totalFields) ===
                            ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName)) {
                            isDiffFromTo = true;
                        }
                        var formatStringProp = ChordChart.chordChartProps.general.formatString;
                        var categorySourceFormatString = visuals.valueFormatter.getFormatString(cat.source, formatStringProp);
                        for (var i = 0, iLen = totalFields.length; i < iLen; i++) {
                            var id = null;
                            var color = '';
                            var isCategory = false;
                            if (catIndex[totalFields[i]] !== undefined) {
                                var index = catIndex[totalFields[i]];
                                id = visuals.SelectionIdBuilder
                                    .builder()
                                    .withCategory(cat, catIndex[totalFields[i]])
                                    .createSelectionId();
                                isCategory = true;
                                var thisCategoryObjects = cat.objects ? cat.objects[index] : undefined;
                                color = colorHelper.getColorForSeriesValue(thisCategoryObjects, /* cat.identityFields */ undefined, catValues[index]);
                            }
                            else if (seriesIndex[totalFields[i]] !== undefined) {
                                var index = seriesIndex[totalFields[i]];
                                var seriesData = values[index];
                                var seriesObjects = seriesData && seriesData.objects && seriesData.objects[0];
                                var seriesNameStr = visuals.converterHelper.getSeriesName(seriesData.source);
                                id = visuals.SelectionId.createWithId(seriesData.identity);
                                isCategory = false;
                                color = colorHelper.getColorForSeriesValue(seriesObjects, /* values.identityFields */ undefined, seriesNameStr);
                            }
                            labelData.push({
                                label: totalFields[i],
                                labelColor: labelColor,
                                barColor: color,
                                isCategory: isCategory,
                                identity: id,
                                selected: false
                            });
                            dataMatrix.push([]);
                            toolTipData.push([]);
                            var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString);
                            for (var j = 0, jLen = totalFields.length; j < jLen; j++) {
                                var elementValue = 0;
                                var tooltipInfo = [];
                                if (catIndex[totalFields[i]] !== undefined &&
                                    seriesIndex[totalFields[j]] !== undefined) {
                                    var row = catIndex[totalFields[i]];
                                    var col = seriesIndex[totalFields[j]];
                                    if (values[col].values[row] !== null) {
                                        elementValue = values[col].values[row];
                                        if (elementValue > max)
                                            max = elementValue;
                                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, elementValue, null, null, col, row);
                                    }
                                }
                                else if (isDiffFromTo && catIndex[totalFields[j]] !== undefined &&
                                    seriesIndex[totalFields[i]] !== undefined) {
                                    var row = catIndex[totalFields[j]];
                                    var col = seriesIndex[totalFields[i]];
                                    if (values[col].values[row] !== null) {
                                        elementValue = values[col].values[row];
                                    }
                                }
                                dataMatrix[i].push(elementValue);
                                toolTipData[i].push({
                                    tooltipInfo: tooltipInfo
                                });
                            }
                            var totalSum = d3.sum(dataMatrix[i]);
                            sliceTooltipData.push({
                                tooltipInfo: [{
                                        displayName: totalFields[i],
                                        value: (ChordChart.isInt(totalSum)) ? totalSum.toFixed(0) : totalSum.toFixed(2)
                                    }]
                            });
                        }
                        var chordLayout = d3.layout.chord()
                            .padding(0.1)
                            .matrix(dataMatrix);
                        var unitLength = Math.round(max / 5).toString().length - 1;
                        return {
                            dataMatrix: dataMatrix,
                            labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),
                            legendData: legendData,
                            tooltipData: toolTipData,
                            sliceTooltipData: sliceTooltipData,
                            tickUnit: Math.pow(10, unitLength),
                            differentFromTo: isDiffFromTo,
                            defaultDataPointColor: defaultDataPointColor,
                            prevAxisVisible: prevAxisVisible,
                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                            showLabels: ChordChart.getLabelsShow(dataView),
                            showAxis: ChordChart.getAxisShow(dataView),
                            labelFontSize: labelFontSize,
                        };
                    }
                    else {
                        return {
                            dataMatrix: [],
                            labelDataPoints: [],
                            legendData: null,
                            tooltipData: [],
                            sliceTooltipData: [],
                            tickUnit: 1000,
                            differentFromTo: false,
                            defaultDataPointColor: defaultDataPointColor,
                            prevAxisVisible: prevAxisVisible,
                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                            showLabels: ChordChart.getLabelsShow(dataView),
                            showAxis: ChordChart.getAxisShow(dataView),
                            labelFontSize: labelFontSize,
                        };
                    }
                };
                /* Check every element of the array and returns the count of elements which are valid(not undefined) */
                ChordChart.getValidArrayLength = function (array) {
                    var len = 0;
                    for (var i = 0, iLen = array.length; i < iLen; i++) {
                        if (array[i] !== undefined) {
                            len++;
                        }
                    }
                    return len;
                };
                /* Convert ChordLayout to ChordArcDescriptor */
                ChordChart.convertToChordArcDescriptor = function (groups, datum) {
                    var labelDataPoints = [];
                    for (var i = 0, iLen = groups.length; i < iLen; i++) {
                        var labelDataPoint = groups[i];
                        labelDataPoint.data = datum[i];
                        labelDataPoints.push(labelDataPoint);
                    }
                    return labelDataPoints;
                };
                /* Calculate radius */
                ChordChart.prototype.calculateRadius = function (viewport) {
                    if (this.data && this.data.showLabels) {
                        // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.
                        // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.
                        var hw = viewport.height / viewport.width;
                        var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                        return Math.min(viewport.height, viewport.width) / denom;
                    }
                    // no labels
                    return Math.min(viewport.height, viewport.width) / 2;
                };
                /* Draw category labels */
                ChordChart.drawDefaultCategoryLabels = function (graphicsContext, chordData, radius, viewport) {
                    /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the chord/pie. */
                    var arc = d3.svg.arc()
                        .innerRadius(0)
                        .outerRadius(radius * ChordChart.InnerArcRadiusRatio);
                    var outerArc = d3.svg.arc()
                        .innerRadius(radius * ChordChart.OuterArcRadiusRatio)
                        .outerRadius(radius * ChordChart.OuterArcRadiusRatio);
                    if (chordData.showLabels) {
                        var labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);
                        ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints, graphicsContext, labelLayout, viewport, radius, arc, outerArc);
                    }
                    else
                        visuals.dataLabelUtils.cleanDataLabels(graphicsContext, true);
                };
                /* One time setup*/
                ChordChart.prototype.init = function (options) {
                    var element = this.element = options.element;
                    this.selectionManager = new visuals.utility.SelectionManager({ hostServices: options.host });
                    this.svg = d3.select(element.get(0))
                        .append('svg')
                        .style('position', 'absolute')
                        .classed(ChordChart.VisualClassName, true);
                    this.mainGraphicsContext = this.svg
                        .append('g');
                    this.mainGraphicsContext
                        .append('g')
                        .classed('slices', true);
                    this.mainGraphicsContext
                        .append('g')
                        .classed('ticks', true);
                    this.mainGraphicsContext
                        .append('g')
                        .classed('chords', true);
                    this.colors = options.style.colorPalette.dataColors;
                };
                /* Called for data, size, formatting changes*/
                ChordChart.prototype.update = function (options) {
                    var _this = this;
                    // assert dataView           
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    // get animation duration
                    var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                    var dataView = this.dataView = options.dataViews[0];
                    var prevAxisShow = (this.data) ? this.data.showAxis : !ChordChart.getAxisShow(dataView);
                    var data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow);
                    var viewport = options.viewport;
                    var chordLayout = this.chordLayout = d3.layout.chord()
                        .padding(0.1)
                        .matrix(data.dataMatrix);
                    var width = viewport.width;
                    var height = viewport.height;
                    var radius = this.calculateRadius(viewport);
                    var sm = this.selectionManager;
                    var innerRadius = radius;
                    var outerRadius = radius * ChordChart.InnerArcRadiusRatio;
                    var arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);
                    this.svg
                        .attr({
                        'width': width,
                        'height': height
                    });
                    var mainGraphicsContext = this.mainGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(width / 2, height / 2));
                    var sliceShapes = this.svg.select('.slices')
                        .selectAll('path' + ChordChart.sliceClass.selector)
                        .data(chordLayout.groups);
                    sliceShapes.enter()
                        .insert("path")
                        .classed(ChordChart.sliceClass.class, true);
                    sliceShapes.style('fill', function (d, i) { return data.labelDataPoints[i].data.barColor; })
                        .style("stroke", function (d, i) { return data.labelDataPoints[i].data.barColor; })
                        .on('click', function (d, i) {
                        var _this = this;
                        sm.select(data.labelDataPoints[i].data.identity).then(function (ids) {
                            if (ids.length > 0) {
                                mainGraphicsContext.selectAll(".chords path.chord")
                                    .style("opacity", 1);
                                mainGraphicsContext.selectAll(".slices path.slice")
                                    .style('opacity', 0.3);
                                mainGraphicsContext.selectAll(".chords path.chord")
                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })
                                    .style("opacity", 0.3);
                                d3.select(_this).style('opacity', 1);
                            }
                            else {
                                sliceShapes.style('opacity', 1);
                                mainGraphicsContext.selectAll(".chords path.chord")
                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })
                                    .style("opacity", 1);
                            }
                        });
                        d3.event.stopPropagation();
                    })
                        .transition()
                        .duration(duration)
                        .attr("d", arc);
                    sliceShapes.exit()
                        .remove();
                    visuals.TooltipManager.addTooltip(sliceShapes, function (tooltipEvent) {
                        return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
                    });
                    var chordShapes = this.svg.select('.chords')
                        .selectAll('path' + ChordChart.chordClass.selector)
                        .data(chordLayout.chords);
                    chordShapes
                        .enter().insert("path")
                        .classed(ChordChart.chordClass.class, true);
                    chordShapes.style("fill", function (d, i) { return data.labelDataPoints[d.target.index].data.barColor; })
                        .style("opacity", 1)
                        .transition()
                        .duration(duration)
                        .attr("d", d3.svg.chord().radius(innerRadius));
                    chordShapes.exit()
                        .remove();
                    this.svg
                        .on('click', function () { return _this.selectionManager.clear().then(function () {
                        sliceShapes.style('opacity', 1);
                        chordShapes.style('opacity', 1);
                    }); });
                    ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport);
                    ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport);
                    visuals.TooltipManager.addTooltip(chordShapes, function (tooltipEvent) {
                        var tooltipInfo = [];
                        if (data.differentFromTo) {
                            tooltipInfo = data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex]
                                .tooltipInfo;
                        }
                        else {
                            tooltipInfo.push({
                                displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label
                                    + '->' + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
                                value: data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
                            });
                            tooltipInfo.push({
                                displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label
                                    + '->' + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
                                value: data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
                            });
                        }
                        return tooltipInfo;
                    });
                };
                /*About to remove your visual, do clean up here */
                ChordChart.prototype.destroy = function () {
                };
                /* Clean ticks */
                ChordChart.cleanTicks = function (context) {
                    var empty = [];
                    var tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);
                    tickLines.exit().remove();
                    var tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);
                    tickTexts.exit().remove();
                    context.selectAll(ChordChart.tickPairClass.selector).remove();
                    context.selectAll(ChordChart.sliceTicksClass.selector).remove();
                };
                /* Draw axis(ticks) around the arc */
                ChordChart.drawTicks = function (graphicsContext, chordData, chordLayout, outerRadius, duration, viewport) {
                    if (chordData.showAxis) {
                        var tickShapes = graphicsContext.select('.ticks')
                            .selectAll('g' + ChordChart.sliceTicksClass.selector)
                            .data(chordLayout.groups);
                        var animDuration = (chordData.prevAxisVisible === chordData.showAxis) ? duration : 0;
                        tickShapes.enter().insert('g')
                            .classed(ChordChart.sliceTicksClass.class, true);
                        var tickPairs = tickShapes.selectAll('g' + ChordChart.tickPairClass.selector)
                            .data(function (d) {
                            var k = (d.endAngle - d.startAngle) / d.value;
                            var range = d3.range(0, d.value, d.value - 1 < 0.15 ? 0.15 : d.value - 1);
                            var retval = range.map(function (v, i) {
                                var divider = 1000;
                                var unitStr = 'k';
                                if (chordData.tickUnit >= 1000 * 1000) {
                                    divider = 1000 * 1000;
                                    unitStr = 'm';
                                }
                                else if (chordData.tickUnit >= 1000) {
                                    divider = 1000;
                                    unitStr = 'k';
                                }
                                else {
                                    divider = 1;
                                    unitStr = '';
                                }
                                var retv = {
                                    angle: v * k + d.startAngle,
                                    label: Math.floor(v / divider) + unitStr
                                };
                                return retv;
                            });
                            return retval;
                        });
                        tickPairs.enter().insert('g')
                            .classed(ChordChart.tickPairClass.class, true);
                        tickPairs.transition()
                            .duration(animDuration)
                            .attr('transform', function (d) {
                            return 'rotate(' + (d.angle * 180 / Math.PI - 90) + ')'
                                + 'translate(' + outerRadius + ',0)';
                        });
                        tickPairs.selectAll('line' + ChordChart.tickLineClass.selector)
                            .data(function (d) { return [d]; })
                            .enter().insert('line')
                            .classed(ChordChart.tickLineClass.class, true)
                            .style("stroke", "#000")
                            .attr("x1", 1)
                            .attr("y1", 0)
                            .attr("x2", 5)
                            .attr("y2", 0);
                        tickPairs.selectAll('text' + ChordChart.tickTextClass.selector)
                            .data(function (d) { return [d]; })
                            .enter().insert('text')
                            .classed(ChordChart.tickTextClass.class, true)
                            .style("text-anchor", function (d) { return d.angle > Math.PI ? "end" : null; })
                            .text(function (d) { return d.label; })
                            .attr("transform", function (d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
                            .attr("x", 8)
                            .attr("dy", ".35em");
                        tickPairs.exit()
                            .remove();
                        tickShapes.exit()
                            .remove();
                    }
                    else {
                        ChordChart.cleanTicks(graphicsContext);
                    }
                };
                /* Get format parameter axis whether it determines show ticks or not. Default value is true */
                ChordChart.getAxisShow = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var axis = objects['axis'];
                            if (axis && axis.hasOwnProperty('show')) {
                                return axis['show'];
                            }
                        }
                    }
                    return true;
                };
                /* Get format parameter labels whether it determines show labels or not. Default value is true */
                ChordChart.getLabelsShow = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects['labels'];
                            if (labels && labels.hasOwnProperty('show')) {
                                return labels['show'];
                            }
                        }
                    }
                    return true;
                };
                /* Get format parameter labels whether it determines show labels or not. Default value is true */
                ChordChart.getLabelsColor = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects['labels'];
                            if (labels && labels.hasOwnProperty('color'))
                                return labels['color'].solid.color;
                        }
                    }
                    return ChordChart.DefaultLabelColor;
                };
                ChordChart.getLabelsFontSize = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects['labels'];
                            if (labels && labels.hasOwnProperty('fontSize'))
                                return labels['fontSize'];
                        }
                    }
                    return ChordChart.DefaultLabelsFontSize;
                };
                /* Select labels */
                ChordChart.selectLabels = function (filteredData, context, isDonut, forAnimation) {
                    if (isDonut === void 0) { isDonut = false; }
                    if (forAnimation === void 0) { forAnimation = false; }
                    // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'
                    if (filteredData.length === 0) {
                        visuals.dataLabelUtils.cleanDataLabels(context, true);
                        return null;
                    }
                    if (context.select(ChordChart.labelGraphicsContextClass.selector).empty())
                        context.append('g').classed(ChordChart.labelGraphicsContextClass.class, true);
                    // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity
                    var hasKey = filteredData[0].key !== null;
                    var hasDataPointIdentity = filteredData[0].identity !== null;
                    var getIdentifier = hasKey ?
                        function (d) { return d.key; }
                        : hasDataPointIdentity ?
                            function (d) { return d.identity.getKey(); }
                            : undefined;
                    var labels = isDonut ?
                        context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, function (d) { return d.data.identity.getKey(); })
                        : getIdentifier !== null ?
                            context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier)
                            : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData);
                    var newLabels = labels.enter()
                        .append('text')
                        .classed(ChordChart.labelsClass.class, true);
                    if (forAnimation)
                        newLabels.style('opacity', 0);
                    return labels;
                };
                /* Draw labels */
                ChordChart.drawDefaultLabelsForChordChart = function (data, context, layout, viewport, radius, arc, outerArc) {
                    // Hide and reposition labels that overlap
                    var dataLabelManager = new powerbi.DataLabelManager();
                    var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, /* addTransform */ true);
                    var labels = ChordChart.selectLabels(filteredData, context, true);
                    if (!labels) {
                        return;
                    }
                    labels
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; }, dy: '.35em' })
                        .text(function (d) { return d.labeltext; })
                        .style(layout.style);
                    labels
                        .exit()
                        .remove();
                    if (context.select(ChordChart.linesGraphicsContextClass.selector).empty()) {
                        context
                            .append('g')
                            .classed(ChordChart.linesGraphicsContextClass.class, true);
                    }
                    var lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll('polyline')
                        .data(filteredData, function (d) { return d.data.identity.getKey(); });
                    var innerLinePointMultiplier = 2.05;
                    var midAngle = function (d) {
                        return d.startAngle + (d.endAngle - d.startAngle) / 2;
                    };
                    lines.enter()
                        .append('polyline')
                        .classed(ChordChart.lineClass.class, true);
                    lines
                        .attr('points', function (d) {
                        var textPoint = outerArc.centroid(d);
                        textPoint[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
                        var midPoint = outerArc.centroid(d);
                        var chartPoint = arc.centroid(d);
                        chartPoint[0] *= innerLinePointMultiplier;
                        chartPoint[1] *= innerLinePointMultiplier;
                        return [chartPoint, midPoint, textPoint];
                    }).
                        style({
                        'opacity': function (d) { return ChordChart.PolylineOpacity; },
                        'stroke': function (d) { return d.data.labelColor; },
                    });
                    lines
                        .exit()
                        .remove();
                };
                /* Get label layout */
                ChordChart.getChordChartLabelLayout = function (radius, outerArc, viewport, labelFontSize) {
                    var midAngle = function (d) {
                        return d.startAngle + (d.endAngle - d.startAngle) / 2;
                    };
                    var spaceAvaliableForLabels = viewport.width / 2 - radius;
                    var minAvailableSpace = Math.min(spaceAvaliableForLabels, visuals.dataLabelUtils.maxLabelWidth);
                    var PixelConverter = jsCommon.PixelConverter;
                    return {
                        labelText: function (d) {
                            // show only category label
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: d.data.label,
                                maxWidth: minAvailableSpace,
                                fontSize: labelFontSize,
                            });
                        },
                        labelLayout: {
                            x: function (d) {
                                return radius * (midAngle(d) < Math.PI ? 1 : -1);
                            },
                            y: function (d) {
                                var pos = outerArc.centroid(d);
                                return pos[1];
                            },
                        },
                        filter: function (d) { return (d !== null && d.data !== null && d.data.label !== null); },
                        style: {
                            'fill': function (d) { return d.data.labelColor; },
                            'text-anchor': function (d) { return midAngle(d) < Math.PI ? 'start' : 'end'; },
                            'font-size': function (d) { return PixelConverter.fromPointToPixel(labelFontSize); },
                        },
                    };
                };
                /* Get Default Datapoint color */
                ChordChart.getDefaultDataPointColor = function (dataView, defaultValue) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var dataPoint = objects['dataPoint'];
                            if (dataPoint && dataPoint.hasOwnProperty('defaultColor')) {
                                var defaultColor = dataPoint['defaultColor'];
                                if (defaultColor) {
                                    return defaultColor;
                                }
                            }
                        }
                    }
                    return { solid: { color: defaultValue } };
                };
                /* Get format paramter value (showAllDataPoints)  */
                ChordChart.getShowAllDataPoints = function (dataView) {
                    if (!dataView || !dataView.metadata || !dataView.metadata.objects)
                        return false;
                    var objects = dataView.metadata.objects;
                    var dataPoint = objects['dataPoint'];
                    if (dataPoint && dataPoint.hasOwnProperty('showAllDataPoints')) {
                        return dataPoint['showAllDataPoints'];
                    }
                    return false;
                };
                /* Enumerate format values */
                ChordChart.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    var axis;
                    switch (options.objectName) {
                        case 'axis':
                            axis = {
                                objectName: 'axis',
                                displayName: 'Axis',
                                selector: null,
                                properties: {
                                    show: ChordChart.getAxisShow(this.dataView)
                                }
                            };
                            instances.push(axis);
                            break;
                        case 'labels':
                            axis = {
                                objectName: 'labels',
                                displayName: 'Labels',
                                selector: null,
                                properties: {
                                    show: ChordChart.getLabelsShow(this.dataView),
                                    color: ChordChart.getLabelsColor(this.dataView),
                                    fontSize: ChordChart.getLabelsFontSize(this.dataView),
                                }
                            };
                            instances.push(axis);
                            break;
                        case 'dataPoint':
                            var defaultColor = {
                                objectName: 'dataPoint',
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: { color: (this.data && this.data.defaultDataPointColor) ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value }
                                    }
                                }
                            };
                            instances.push(defaultColor);
                            var showAllDataPoints = {
                                objectName: 'dataPoint',
                                selector: null,
                                properties: {
                                    showAllDataPoints: this.data ? !!this.data.showAllDataPoints : false,
                                }
                            };
                            instances.push(showAllDataPoints);
                            if (this.data && this.data.labelDataPoints) {
                                for (var i = 0, iLen = this.data.labelDataPoints.length; i < iLen; i++) {
                                    var labelDataPoint = this.data.labelDataPoints[i].data;
                                    if (labelDataPoint.isCategory) {
                                        var colorInstance = {
                                            objectName: 'dataPoint',
                                            displayName: labelDataPoint.label,
                                            selector: visuals.ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
                                            properties: {
                                                fill: { solid: { color: labelDataPoint.barColor } }
                                            }
                                        };
                                        instances.push(colorInstance);
                                    }
                                }
                            }
                            break;
                    }
                    return instances;
                };
                /* Utility function for checking if it is integer or float */
                ChordChart.isInt = function (n) {
                    return n % 1 === 0;
                };
                /* Utility function for union two arrays without duplicates */
                ChordChart.union_arrays = function (x, y) {
                    var obj = {};
                    for (var i = 0; i < x.length; i++) {
                        obj[x[i]] = x[i];
                    }
                    for (var i = 0; i < y.length; i++) {
                        obj[y[i]] = y[i];
                    }
                    var res = [];
                    for (var k in obj) {
                        if (obj.hasOwnProperty(k)) {
                            res.push(obj[k]);
                        }
                    }
                    return res;
                };
                ChordChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'From',
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'To',
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                        }
                    ],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Series': { max: 0 } },
                                { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                                { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [{ bind: { to: 'Y' } }],
                                        dataReductionAlgorithm: { top: {} }
                                    },
                                },
                                rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
                            },
                        }],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                            },
                        },
                        axis: {
                            displayName: 'Axis',
                            properties: {
                                show: {
                                    type: { bool: true }
                                },
                            },
                        },
                        labels: {
                            displayName: 'Labels',
                            properties: {
                                show: {
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } },
                                },
                            },
                        }
                    }
                };
                ChordChart.chordChartProps = {
                    general: {
                        formatString: { objectName: 'general', propertyName: 'formatString' },
                    },
                    dataPoint: {
                        defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                        fill: { objectName: 'dataPoint', propertyName: 'fill' },
                        showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
                    },
                    axis: {
                        show: { objectName: 'axis', propertyName: 'show' },
                    },
                    labels: {
                        show: { objectName: 'labels', propertyName: 'show' },
                        color: { objectName: 'labels', propertyName: 'color' },
                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                    },
                };
                ChordChart.PolylineOpacity = 0.5;
                ChordChart.OuterArcRadiusRatio = 0.9;
                ChordChart.InnerArcRadiusRatio = 0.8;
                ChordChart.DefaultLabelColor = "#777777";
                ChordChart.DefaultLabelsFontSize = 12;
                ChordChart.VisualClassName = 'chordChart';
                ChordChart.sliceClass = {
                    class: 'slice',
                    selector: '.slice',
                };
                ChordChart.chordClass = {
                    class: 'chord',
                    selector: '.chord',
                };
                ChordChart.sliceTicksClass = {
                    class: 'slice-ticks',
                    selector: '.slice-ticks'
                };
                ChordChart.tickPairClass = {
                    class: 'tick-pair',
                    selector: '.tick-pair'
                };
                ChordChart.tickLineClass = {
                    class: 'tick-line',
                    selector: '.tick-line'
                };
                ChordChart.tickTextClass = {
                    class: 'tick-text',
                    selector: '.tick-text'
                };
                ChordChart.labelGraphicsContextClass = {
                    class: 'labels',
                    selector: '.labels',
                };
                ChordChart.labelsClass = {
                    class: 'data-labels',
                    selector: '.data-labels',
                };
                ChordChart.linesGraphicsContextClass = {
                    class: 'lines',
                    selector: '.lines',
                };
                ChordChart.lineClass = {
                    class: 'line-label',
                    selector: '.line-label',
                };
                return ChordChart;
            })();
            samples.ChordChart = ChordChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ConsoleWriter = (function () {
                function ConsoleWriter() {
                }
                ConsoleWriter.converter = function (dataView) {
                    window.console.log('converter');
                    window.console.log(dataView);
                    return {};
                };
                ConsoleWriter.prototype.init = function (options) {
                    var div = d3.select(options.element.get(0)).append("div");
                    div.append("h1").text("ConsoleWriter");
                    div.append("p").text("This IVisual writes messages passed to it to the javscript console output. Check your console for the actual messages passed. For more information, click below");
                    var anchor = div.append('a');
                    anchor.attr('href', "http://microsoft.github.io/PowerBI-visuals/modules/powerbi.html")
                        .text("Online help");
                    window.console.log('init');
                    window.console.log(options);
                };
                ConsoleWriter.prototype.onResizing = function (viewport) { };
                ConsoleWriter.prototype.update = function (options) {
                    window.console.log('update');
                    window.console.log(options);
                };
                return ConsoleWriter;
            })();
            samples.ConsoleWriter = ConsoleWriter;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            var VisualLayout = (function () {
                function VisualLayout(defaultViewport, defaultMargin) {
                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
                }
                Object.defineProperty(VisualLayout.prototype, "margin", {
                    get: function () {
                        return this.marginValue || (this.margin = this.defaultMargin);
                    },
                    set: function (value) {
                        this.marginValue = VisualLayout.restrictToMinMax(value);
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewport", {
                    get: function () {
                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
                    },
                    set: function (value) {
                        this.viewportValue = VisualLayout.restrictToMinMax(value);
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                    get: function () {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                    get: function () {
                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                VisualLayout.prototype.update = function () {
                    this.viewportInValue = VisualLayout.restrictToMinMax({
                        width: this.viewport.width - (this.margin.left + this.margin.right),
                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
                    });
                };
                VisualLayout.restrictToMinMax = function (value) {
                    var result = $.extend({}, value);
                    d3.keys(value).forEach(function (x) { return result[x] = Math.max(0, value[x]); });
                    return result;
                };
                return VisualLayout;
            })();
            var DotPlot = (function () {
                function DotPlot(options) {
                    this.durationAnimations = 200;
                    this.MinOpacity = 0.3;
                    this.MaxOpacity = 1;
                    this.itemsWidth = 0;
                    this.itemsLength = 0;
                    if (options) {
                        if (options.svg) {
                            this.svg = options.svg;
                        }
                        if (options.animator) {
                            this.animator = options.animator;
                        }
                        this.layout = new VisualLayout(null, options.margin || DotPlot.DefaultMargin);
                        this.radius = options.radius || DotPlot.DefaultRadius;
                        this.strokeWidth = options.strokeWidth || DotPlot.DefaultStrokeWidth;
                    }
                }
                DotPlot.round10 = function (value, digits) {
                    if (digits === void 0) { digits = 2; }
                    var scale = Math.pow(10, digits);
                    return (Math.round(scale * value) / scale);
                };
                DotPlot.getTooltipData = function (value) {
                    return [{
                            displayName: DotPlot.FrequencyText,
                            value: value.toString()
                        }];
                };
                DotPlot.converter = function (dataView, maxDots, colors, host) {
                    var dataPoints = [];
                    var legendData = {
                        dataPoints: [],
                    };
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.values ||
                        dataView.categorical.values.length < 1 ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0]) {
                        return {
                            dataPoints: dataPoints,
                            legendData: legendData,
                        };
                    }
                    var catDv = dataView.categorical;
                    var series = catDv.values;
                    var categoryColumn = catDv.categories[0];
                    var category = catDv.categories[0].values;
                    if (!series[0].source.type.integer) {
                        var visualMessage = {
                            message: 'This visual expects integer Values. Try adding a text field to create a "Count of" value.',
                            title: 'Integer Value Expected',
                            detail: '',
                        };
                        var warning = {
                            code: 'UnexpectedValueType',
                            getMessages: function () { return visualMessage; },
                        };
                        host.setWarnings([warning]);
                        return {
                            dataPoints: dataPoints,
                            legendData: legendData,
                        };
                    }
                    for (var i = 0, iLen = series.length; i < iLen; i++) {
                        var counts = {};
                        var values = series[i].values;
                        for (var j = 0, jLen = values.length; j < jLen; j++) {
                            var idx = category[j];
                            var value = values[j];
                            if (!counts[idx])
                                counts[idx] = 0;
                            counts[idx] += value;
                        }
                        var legendText = series[i].source.displayName;
                        var color = colors.getColorByIndex(i).value;
                        var data = d3.entries(counts);
                        var min = d3.min(data, function (d) { return d.value; });
                        var max = d3.max(data, function (d) { return d.value; });
                        var dotsScale = d3.scale.linear().domain([min, max]);
                        if (max > maxDots) {
                            dotsScale.rangeRound([0, maxDots]);
                            var scale = DotPlot.round10(max / maxDots);
                            legendText += " (1 dot = x" + scale + ")";
                        }
                        else {
                            dotsScale.rangeRound([min, max]);
                        }
                        for (var k = 0, kLen = data.length; k < kLen; k++) {
                            var y = dotsScale(data[k].value);
                            var categorySelectionId = visuals.SelectionIdBuilder.builder()
                                .withCategory(categoryColumn, k)
                                .createSelectionId();
                            for (var level = 0; level < y; level++) {
                                dataPoints.push({
                                    x: data[k].key,
                                    y: level,
                                    color: color,
                                    identity: categorySelectionId,
                                    tooltipInfo: DotPlot.getTooltipData(data[k].value)
                                });
                            }
                        }
                        legendData.dataPoints.push({
                            label: legendText,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            selected: false,
                            identity: null
                        });
                    }
                    return {
                        dataPoints: dataPoints,
                        legendData: legendData
                    };
                };
                DotPlot.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.hostService = options.host;
                    if (!this.svg) {
                        this.svg = d3.select(element.get(0)).append('svg');
                    }
                    if (!this.layout) {
                        this.layout = new VisualLayout(null, DotPlot.DefaultMargin);
                    }
                    if (!this.radius) {
                        this.radius = DotPlot.DefaultRadius;
                    }
                    if (!this.strokeWidth) {
                        this.strokeWidth = DotPlot.DefaultStrokeWidth;
                    }
                    this.svg.classed(DotPlot.VisualClassName, true);
                    this.colors = options.style.colorPalette.dataColors;
                    this.legend = visuals.createLegend(element, false, null);
                    this.dotPlot = this.svg
                        .append('g')
                        .classed(DotPlot.DotPlot.class, true);
                    this.axis = this.svg
                        .append('g')
                        .classed(DotPlot.Axis.class, true);
                };
                DotPlot.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);
                    var dataView = this.dataView = options.dataViews[0];
                    this.layout.viewport = options.viewport;
                    this.svg.style({
                        "height": this.layout.viewportIn.height,
                        "width": this.layout.viewportIn.width,
                        "left": this.layout.margin.left,
                        "right": this.layout.margin.right,
                        "position": "relative"
                    });
                    if (this.layout.viewportInIsZero) {
                        return;
                    }
                    var diameter = 2 * this.radius + 1; // "1" is to look better, because stroke width is not included in radius.
                    var dotsTotalHeight = this.layout.viewportIn.height - this.radius - DotPlot.MaxXAxisHeight;
                    var maxDots = Math.floor(dotsTotalHeight / diameter);
                    var data = DotPlot.converter(dataView, maxDots, this.colors, this.hostService);
                    var dataPoints = data.dataPoints;
                    var values = dataView.categorical
                        && dataView.categorical.categories
                        && dataView.categorical.categories.length > 0
                        ? dataView.categorical.categories[0].values
                        : [];
                    var xValues = d3.set(values).values();
                    var xScale = d3.scale.ordinal()
                        .domain(xValues)
                        .rangeBands([DotPlot.XAxisHorizontalMargin, this.layout.viewportIn.width - DotPlot.XAxisHorizontalMargin]);
                    var yScale = d3.scale.linear()
                        .domain([0, maxDots])
                        .range([dotsTotalHeight, dotsTotalHeight - maxDots * diameter]);
                    // temporary disabled as this raises the following error on PBI Portal
                    // Uncaught TypeError: Cannot read property 'registerDirectivesForEndPoint' of undefined
                    //if(data.legendData.dataPoints.length > 0) {
                    //    this.legend.drawLegend(data.legendData, viewport);
                    //}
                    this.drawAxis(xValues, xScale, this.layout.viewportIn.height - DotPlot.MaxXAxisHeight);
                    this.drawDotPlot(dataPoints, xScale, yScale);
                };
                DotPlot.prototype.drawDotPlot = function (data, xScale, yScale) {
                    var selection = this.dotPlot.selectAll(DotPlot.Dot.selector).data(data);
                    selection
                        .enter()
                        .append('circle')
                        .classed(DotPlot.Dot.class, true);
                    selection
                        .attr("cx", function (point) { return xScale(point.x) + xScale.rangeBand() / 2; })
                        .attr("cy", function (point) { return yScale(point.y); })
                        .attr("fill", function (d) { return d.color; })
                        .attr("stroke", "black")
                        .attr("stroke-width", this.strokeWidth)
                        .attr("r", this.radius);
                    this.renderTooltip(selection);
                    this.setSelectHandler(selection);
                    selection.exit().remove();
                };
                DotPlot.prototype.setSelectHandler = function (dotSelection) {
                    var _this = this;
                    this.setSelection(dotSelection);
                    dotSelection.on("click", function (data) {
                        _this.selectionManager
                            .select(data.identity, d3.event.ctrlKey)
                            .then(function (selectionIds) { return _this.setSelection(dotSelection, selectionIds); });
                        d3.event.stopPropagation();
                    });
                    this.svg.on("click", function () {
                        _this.selectionManager.clear();
                        _this.setSelection(dotSelection);
                    });
                };
                DotPlot.prototype.setSelection = function (selection, selectionIds) {
                    selection.transition()
                        .duration(this.durationAnimations)
                        .style("fill-opacity", this.MaxOpacity);
                    if (!selectionIds || !selectionIds.length) {
                        return;
                    }
                    selection
                        .filter(function (dotSelectionData) {
                        return !selectionIds.some(function (selectionId) { return dotSelectionData.identity === selectionId; });
                    })
                        .transition()
                        .duration(this.durationAnimations)
                        .style("fill-opacity", this.MinOpacity);
                };
                DotPlot.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                };
                DotPlot.prototype.drawAxis = function (values, xScale, translateY) {
                    var xAxis = d3.svg.axis()
                        .scale(xScale)
                        .orient("bottom")
                        .tickValues(values);
                    this.axis.attr("class", "x axis")
                        .attr('transform', visuals.SVGUtil.translate(0, translateY));
                    this.axis.call(xAxis);
                    this.relaxTicks(values);
                };
                DotPlot.prototype.relaxTicks = function (values) {
                    var xAxisWidth = this.axis.node().getBoundingClientRect().width;
                    if (values.length !== this.itemsLength) {
                        var self = this;
                        this.itemsWidth = 0;
                        this.itemsLength = values.length;
                        this.axis.selectAll("text").each(function (d, i) {
                            self.itemsWidth += d3.select(this).node().getBoundingClientRect().width + 15;
                        });
                    }
                    this.toggleRotateTicks(xAxisWidth < this.itemsWidth ? true : false);
                    this.toggleHideTicks(xAxisWidth < values.length * 15 ? true : false);
                };
                DotPlot.prototype.toggleRotateTicks = function (state) {
                    if (state) {
                        this.axis.selectAll("text")
                            .attr("dx", ".8em")
                            .attr("dy", ".15em")
                            .attr("transform", "rotate(65)")
                            .style("text-anchor", "start")
                            .text(function (d) { return (d.length > 5 ? d.substring(0, 5) + '...' : d); });
                    }
                    else {
                        this.axis.selectAll("text")
                            .attr("dx", "0em")
                            .attr("transform", "rotate(0)")
                            .style("text-anchor", "middle");
                    }
                };
                DotPlot.prototype.toggleHideTicks = function (state) {
                    if (state) {
                        this.axis.selectAll("text").each(function (d, i) {
                            if (i % 2) {
                                d3.select(this).attr('fill', 'transparent');
                            }
                        });
                        return;
                    }
                    this.axis.selectAll("text").attr('fill', null);
                };
                DotPlot.capabilities = {
                    dataRoles: [{
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Category")
                        },
                        {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value")
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Y': { max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [{ bind: { to: 'Y' } }]
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        label: {
                            displayName: 'Label',
                            properties: {
                                fill: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    }
                };
                DotPlot.VisualClassName = 'dotPlot';
                DotPlot.DotPlot = {
                    class: 'dotPlot',
                    selector: '.dotPlot'
                };
                DotPlot.Axis = {
                    class: 'axis',
                    selector: '.axis'
                };
                DotPlot.Dot = {
                    class: 'dot',
                    selector: '.dot'
                };
                DotPlot.DefaultMargin = {
                    top: 40,
                    bottom: 5,
                    right: 5,
                    left: 5
                };
                DotPlot.MaxXAxisHeight = 50;
                DotPlot.XAxisHorizontalMargin = 40;
                DotPlot.DefaultRadius = 5;
                DotPlot.DefaultStrokeWidth = 1;
                DotPlot.FrequencyText = "Frequency";
                return DotPlot;
            })();
            samples.DotPlot = DotPlot;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var DataRoleHelper = powerbi.data.DataRoleHelper;
            var EnhancedScatterChart = (function () {
                function EnhancedScatterChart() {
                    this.AxisGraphicsContextClassName = 'axisGraphicsContext';
                    this.ScrollBarWidth = 10;
                    this.textProperties = {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: jsCommon.PixelConverter.toString(EnhancedScatterChart.AxisFontSize),
                    };
                }
                Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
                    get: function () {
                        return this._margin || { left: 0, right: 0, top: 0, bottom: 0 };
                    },
                    set: function (value) {
                        this._margin = $.extend({}, value);
                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
                    get: function () {
                        return this._viewport || { width: 0, height: 0 };
                    },
                    set: function (value) {
                        this._viewport = $.extend({}, value);
                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
                    get: function () {
                        return this._viewportIn || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
                    get: function () {
                        return this.legend.getMargins();
                    },
                    enumerable: true,
                    configurable: true
                });
                EnhancedScatterChart.substractMargin = function (viewport, margin) {
                    return {
                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                    };
                };
                EnhancedScatterChart.getCustomSymbolType = function (shape) {
                    var customSymbolTypes = d3.map({
                        "circle": function (size) {
                            var r = Math.sqrt(size / Math.PI);
                            return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
                        },
                        "cross": function (size) {
                            var r = Math.sqrt(size / 5) / 2;
                            return "M" + -3 * r + "," + -r
                                + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                        },
                        "diamond": function (size) {
                            var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
                            return "M0," + -ry
                                + "L" + rx + ",0"
                                + " 0," + ry
                                + " " + -rx + ",0"
                                + "Z";
                        },
                        "square": function (size) {
                            var r = Math.sqrt(size) / 2;
                            return "M" + -r + "," + -r
                                + "L" + r + "," + -r
                                + " " + r + "," + r
                                + " " + -r + "," + r
                                + "Z";
                        },
                        "triangle-up": function (size) {
                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                            return "M0," + -ry
                                + "L" + rx + "," + ry
                                + " " + -rx + "," + ry
                                + "Z";
                        },
                        "triangle-down": function (size) {
                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                            return "M0," + ry
                                + "L" + rx + "," + -ry
                                + " " + -rx + "," + -ry
                                + "Z";
                        },
                        'star': function (size) {
                            var outerRadius = Math.sqrt(size / 2);
                            var innerRadius = Math.sqrt(size / 10);
                            var results = "";
                            var angle = Math.PI / 5;
                            for (var i = 0; i < 10; i++) {
                                // Use outer or inner radius depending on what iteration we are in.
                                var r = (i & 1) === 0 ? outerRadius : innerRadius;
                                var currX = Math.cos(i * angle) * r;
                                var currY = Math.sin(i * angle) * r;
                                // Our first time we simply append the coordinates, subsequet times
                                // we append a ", " to distinguish each coordinate pair.
                                if (i === 0) {
                                    results = "M" + currX + "," + currY + "L";
                                }
                                else {
                                    results += " " + currX + "," + currY;
                                }
                            }
                            return results + "Z";
                        },
                        'hexagon': function (size) {
                            var r = Math.sqrt(size / (6 * Math.sqrt(3)));
                            var r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
                            return "M0," + (2 * r) + "L" + (-r2) + "," + r + " " + (-r2) + "," + (-r) + " 0," + (-2 * r) + " " + r2 + "," + (-r) + " " + r2 + "," + r + "Z";
                        },
                        'x': function (size) {
                            var r = Math.sqrt(size / 10);
                            return "M0," + r + "L" + (-r) + "," + 2 * r + " " + (-2 * r) + "," + r + " " + (-r) + ",0 " + (-2 * r) + "," + (-r) + " " + (-r) + "," + (-2 * r) + " 0," + (-r) + " " + r + "," + (-2 * r) + " " + (2 * r) + "," + (-r) + " " + r + ",0 " + (2 * r) + "," + r + " " + r + "," + (2 * r) + "Z";
                        },
                        'uparrow': function (size) {
                            var r = Math.sqrt(size / 12);
                            return "M" + r + "," + (3 * r) + "L" + (-r) + "," + (3 * r) + " " + (-r) + "," + (-r) + " " + (-2 * r) + "," + (-r) + " 0," + (-3 * r) + " " + (2 * r) + "," + (-r) + " " + r + "," + (-r) + "Z";
                        },
                        'downarrow': function (size) {
                            var r = Math.sqrt(size / 12);
                            return "M0," + (3 * r) + "L" + (-2 * r) + "," + r + " " + (-r) + "," + r + " " + (-r) + "," + (-3 * r) + " " + r + "," + (-3 * r) + " " + r + "," + r + " " + (2 * r) + "," + r + "Z";
                        }
                    });
                    var defaultValue = customSymbolTypes.entries()[0].value;
                    if (!shape) {
                        return defaultValue;
                    }
                    else if (isNaN(shape)) {
                        return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
                    }
                    else {
                        var result = customSymbolTypes.entries()[Math.floor(shape)];
                        return result ? result.value : defaultValue;
                    }
                };
                EnhancedScatterChart.prototype.init = function (options) {
                    this.options = options;
                    this.animator = new visuals.BaseAnimator();
                    this.behavior = new visuals.CartesianChartBehavior([new visuals.ScatterChartWebBehavior()]);
                    var element = this.element = options.element;
                    this.viewport = _.clone(options.viewport);
                    this.style = options.style;
                    this.hostServices = options.host;
                    this.colors = this.style.colorPalette.dataColors;
                    this.interactivity = options.interactivity;
                    this.margin = {
                        top: 1,
                        right: 1,
                        bottom: 1,
                        left: 1
                    };
                    element.addClass(EnhancedScatterChart.ClassName);
                    this.yAxisOrientation = visuals.yAxisPosition.left;
                    this.adjustMargins();
                    var showLinesOnX = this.scrollY = true;
                    var showLinesOnY = this.scrollX = true;
                    var svg = this.svg = d3.select(element.get(0)).append('svg');
                    svg.style('position', 'absolute');
                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                        .classed(this.AxisGraphicsContextClassName, true);
                    this.svgScrollable = svg.append('svg')
                        .classed('svgScrollable', true)
                        .style('overflow', 'hidden');
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                        .classed(this.AxisGraphicsContextClassName, true);
                    this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                    this.backgroundGraphicsContext = axisGraphicsContext.append('svg:image');
                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                    this.legend = visuals.createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, true);
                    this.mainGraphicsG = this.axisGraphicsContextScrollable.append('g')
                        .classed(EnhancedScatterChart.MainGraphicsContextClassName, true);
                    this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                    this.svgDefaultImage = "http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg";
                    this.keyArray = [];
                };
                EnhancedScatterChart.prototype.adjustMargins = function () {
                    // Adjust margins if ticks are not going to be shown on either axis
                    var xAxis = this.element.find('.x.axis');
                    if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) === 0
                        && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) === 0) {
                        this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        };
                        xAxis.hide();
                    }
                    else {
                        xAxis.show();
                    }
                };
                EnhancedScatterChart.prototype.getValueAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata)
                        return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var valueAxisObject = objects['valueAxis'];
                        if (valueAxisObject) {
                            toReturn = {
                                show: valueAxisObject['show'],
                                position: valueAxisObject['position'],
                                axisScale: valueAxisObject['axisScale'],
                                start: valueAxisObject['start'],
                                end: valueAxisObject['end'],
                                showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
                                axisStyle: valueAxisObject['axisStyle'],
                                axisColor: valueAxisObject['axisColor'],
                                secShow: valueAxisObject['secShow'],
                                secPosition: valueAxisObject['secPosition'],
                                secAxisScale: valueAxisObject['secAxisScale'],
                                secStart: valueAxisObject['secStart'],
                                secEnd: valueAxisObject['secEnd'],
                                secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
                                secAxisStyle: valueAxisObject['secAxisStyle'],
                                labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
                            };
                        }
                    }
                    return toReturn;
                };
                EnhancedScatterChart.prototype.getCategoryAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata)
                        return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var categoryAxisObject = objects['categoryAxis'];
                        if (categoryAxisObject) {
                            toReturn = {
                                show: categoryAxisObject['show'],
                                axisType: categoryAxisObject['axisType'],
                                axisScale: categoryAxisObject['axisScale'],
                                axisColor: categoryAxisObject['axisColor'],
                                start: categoryAxisObject['start'],
                                end: categoryAxisObject['end'],
                                showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
                                axisStyle: categoryAxisObject['axisStyle'],
                                labelDisplayUnits: categoryAxisObject['labelDisplayUnits']
                            };
                        }
                    }
                    return toReturn;
                };
                EnhancedScatterChart.converter = function (dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                    var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName;
                    var dataViewCategorical = dataView.categorical;
                    var dataViewMetadata = dataView.metadata;
                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        categoryValues = dataViewCategorical.categories[0].values;
                        categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });
                        categoryIdentities = dataViewCategorical.categories[0].identity;
                        categoryObjects = dataViewCategorical.categories[0].objects;
                        categoryQueryName = dataViewCategorical.categories[0].source.queryName;
                    }
                    else {
                        categoryValues = [null];
                        // creating default formatter for null value (to get the right string of empty value from the locale)
                        categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);
                    }
                    var categories = dataViewCategorical.categories;
                    var dataValues = dataViewCategorical.values;
                    var hasDynamicSeries = !!dataValues.source;
                    var grouped = dataValues.grouped();
                    var useShape = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image') >= 0)) ? false : true;
                    var useCustomColor = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill') >= 0)) ? true : false;
                    var dvSource = dataValues.source;
                    var scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource);
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                    var fillPoint = false;
                    var backdrop = { show: false, url: "" };
                    var crosshair = false;
                    var outline = false;
                    var defaultDataPointColor = "";
                    var showAllDataPoints = true;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                        /*if(objects['dataPoint']){
                            let shapeObj = objects['dataPoint'];
                            if(shapeObj['useShape']){
                                shape = <boolean>shapeObj['useShape'];
                            }
                        }*/
                        var labelsObj = objects['categoryLabels'];
                        if (labelsObj) {
                            dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? labelsObj['show'] : dataLabelsSettings.show;
                            dataLabelsSettings.fontSize = (labelsObj['fontSize'] !== undefined) ? labelsObj['fontSize'] : dataLabelsSettings.fontSize;
                            if (labelsObj['color'] !== undefined) {
                                dataLabelsSettings.labelColor = labelsObj['color'].solid.color;
                            }
                        }
                        fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, fillPoint);
                        var backdropObject = objects['backdrop'];
                        if (backdropObject !== undefined) {
                            backdrop.show = backdropObject['show'];
                            if (backdrop.show) {
                                backdrop.url = backdropObject['url'];
                            }
                        }
                        var crosshairObject = objects['crosshair'];
                        if (crosshairObject !== undefined) {
                            crosshair = crosshairObject['show'];
                        }
                        var outlineObject = objects['outline'];
                        if (outlineObject !== undefined) {
                            outline = outlineObject['show'];
                        }
                    }
                    var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(dataPoints);
                    }
                    var legendItems = hasDynamicSeries
                        ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor)
                        : [];
                    var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                    if (!legendTitle) {
                        legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : "";
                    }
                    var legendData = { title: legendTitle, dataPoints: legendItems };
                    var sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                    if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
                        scatterMetadata.axesLabels.x = null;
                    }
                    if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
                        scatterMetadata.axesLabels.y = null;
                    }
                    if (dataPoints && dataPoints[0]) {
                        var point = dataPoints[0];
                        if (point.backdrop != null) {
                            backdrop.show = true;
                            backdrop.url = point.backdrop;
                        }
                        if (point.xStart != null) {
                            categoryAxisProperties['start'] = point.xStart;
                        }
                        if (point.xEnd != null) {
                            categoryAxisProperties['end'] = point.xEnd;
                        }
                        if (point.yStart != null) {
                            valueAxisProperties['start'] = point.yStart;
                        }
                        if (point.yEnd != null) {
                            valueAxisProperties['end'] = point.yEnd;
                        }
                    }
                    return {
                        xCol: scatterMetadata.cols.x,
                        yCol: scatterMetadata.cols.y,
                        dataPoints: dataPoints,
                        legendData: legendData,
                        axesLabels: scatterMetadata.axesLabels,
                        selectedIds: [],
                        size: scatterMetadata.cols.size,
                        sizeRange: sizeRange,
                        dataLabelsSettings: dataLabelsSettings,
                        defaultDataPointColor: defaultDataPointColor,
                        hasDynamicSeries: hasDynamicSeries,
                        showAllDataPoints: showAllDataPoints,
                        fillPoint: fillPoint,
                        useShape: useShape,
                        useCustomColor: useCustomColor,
                        backdrop: backdrop,
                        crosshair: crosshair,
                        outline: outline
                    };
                };
                EnhancedScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                    var grouped = dataValues.grouped();
                    var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                    var legendItems = [];
                    for (var i = 0, len = grouped.length; i < len; i++) {
                        var grouping = grouped[i];
                        var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        legendItems.push({
                            color: color,
                            icon: visuals.LegendIcon.Circle,
                            label: visuals.valueFormatter.format(grouping.name, formatString),
                            identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                            selected: false,
                        });
                    }
                    return legendItems;
                };
                EnhancedScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
                    var result = {};
                    if (dataViewValueGroups) {
                        dataViewValueGroups.forEach(function (group) {
                            var sizeColumn = visuals.ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
                            var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                            if (result.min == null || result.min > currentRange.min) {
                                result.min = currentRange.min;
                            }
                            if (result.max == null || result.max < currentRange.max) {
                                result.max = currentRange.max;
                            }
                        });
                    }
                    return result;
                };
                EnhancedScatterChart.getMetadata = function (grouped, source) {
                    var xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');
                    var yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');
                    var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');
                    var gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
                    var colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill');
                    var shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Shape');
                    var imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image');
                    var rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Rotation');
                    var backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Backdrop');
                    var xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X Start');
                    var xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X End');
                    var yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y Start');
                    var yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y End');
                    var xCol;
                    var yCol;
                    var sizeCol;
                    var colorFillCol;
                    var shapeCol;
                    var imageCol;
                    var rotationCol;
                    var backdropCol;
                    var xStartCol;
                    var xEndCol;
                    var yStartCol;
                    var yEndCol;
                    var xAxisLabel = "";
                    var yAxisLabel = "";
                    if (grouped && grouped.length) {
                        var firstGroup = grouped[0], measureCount = firstGroup.values.length;
                        if (!(xIndex >= 0))
                            xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(yIndex >= 0))
                            yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(sizeIndex >= 0))
                            sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(colorFillIndex >= 0))
                            colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(shapeIndex >= 0))
                            shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(imageIndex >= 0)) {
                            imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        }
                        if (!(rotationIndex >= 0))
                            rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(backdropIndex >= 0))
                            backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(xStartIndex >= 0))
                            xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(xEndIndex >= 0))
                            xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex]);
                        if (!(yStartIndex >= 0))
                            yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex]);
                        if (!(yEndIndex >= 0))
                            yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex]);
                        if (xIndex >= 0) {
                            xCol = firstGroup.values[xIndex].source;
                            xAxisLabel = firstGroup.values[xIndex].source.displayName;
                        }
                        if (yIndex >= 0) {
                            yCol = firstGroup.values[yIndex].source;
                            yAxisLabel = firstGroup.values[yIndex].source.displayName;
                        }
                        if (sizeIndex >= 0) {
                            sizeCol = firstGroup.values[sizeIndex].source;
                        }
                        if (colorFillIndex >= 0) {
                            colorFillCol = firstGroup.values[colorFillIndex].source;
                        }
                        if (shapeIndex >= 0) {
                            shapeCol = firstGroup.values[shapeIndex].source;
                        }
                        if (imageIndex >= 0) {
                            imageCol = firstGroup.values[imageIndex].source;
                        }
                        if (rotationIndex >= 0) {
                            rotationCol = firstGroup.values[rotationIndex].source;
                        }
                        if (backdropIndex >= 0) {
                            backdropCol = firstGroup.values[backdropIndex].source;
                        }
                        if (xStartIndex >= 0) {
                            xStartCol = firstGroup.values[xStartIndex].source;
                        }
                        if (xEndIndex >= 0) {
                            xEndCol = firstGroup.values[xEndIndex].source;
                        }
                        if (yStartIndex >= 0) {
                            yStartCol = firstGroup.values[yStartIndex].source;
                        }
                        if (yEndIndex >= 0) {
                            yEndCol = firstGroup.values[yEndIndex].source;
                        }
                    }
                    return {
                        idx: {
                            x: xIndex,
                            y: yIndex,
                            size: sizeIndex,
                            colorFill: colorFillIndex,
                            shape: shapeIndex,
                            image: imageIndex,
                            rotation: rotationIndex,
                            backdrop: backdropIndex,
                            xStart: xStartIndex,
                            xEnd: xEndIndex,
                            yStart: yStartIndex,
                            yEnd: yEndIndex,
                        },
                        cols: {
                            x: xCol,
                            y: yCol,
                            size: sizeCol,
                            colorFill: colorFillCol,
                            shape: shapeCol,
                            image: imageCol,
                            rotation: rotationCol,
                            backdrop: backdropCol,
                            xStart: xStartCol,
                            xEnd: xEndCol,
                            yStart: yStartCol,
                            yEnd: yEndCol,
                        },
                        axesLabels: {
                            x: xAxisLabel,
                            y: yAxisLabel
                        }
                    };
                };
                EnhancedScatterChart.getDefaultMeasureIndex = function (count, usedIndexes) {
                    for (var i = 0; i < count; i++) {
                        var found = true;
                        for (var j = 0; j < usedIndexes.length; j++) {
                            if (i === usedIndexes[j]) {
                                found = false;
                                break;
                            }
                        }
                        if (found === true) {
                            return i;
                        }
                    }
                    return -1;
                };
                EnhancedScatterChart.createDataPoints = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
                    var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                    var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                    for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
                        var categoryValue = categoryValues[categoryIdx];
                        for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                            var grouping = grouped[seriesIdx];
                            var seriesValues = grouping.values;
                            var measureX = visuals.ScatterChart.getMeasureValue(indicies.x, seriesValues);
                            var measureY = visuals.ScatterChart.getMeasureValue(indicies.y, seriesValues);
                            var measureSize = visuals.ScatterChart.getMeasureValue(indicies.size, seriesValues);
                            var measureColorFill = visuals.ScatterChart.getMeasureValue(indicies.colorFill, seriesValues);
                            var measureShape = visuals.ScatterChart.getMeasureValue(indicies.shape, seriesValues);
                            var measureImage = visuals.ScatterChart.getMeasureValue(indicies.image, seriesValues);
                            var measureRotation = visuals.ScatterChart.getMeasureValue(indicies.rotation, seriesValues);
                            var measureBackdrop = visuals.ScatterChart.getMeasureValue(indicies.backdrop, seriesValues);
                            var measureXStart = visuals.ScatterChart.getMeasureValue(indicies.xStart, seriesValues);
                            var measureXEnd = visuals.ScatterChart.getMeasureValue(indicies.xEnd, seriesValues);
                            var measureYStart = visuals.ScatterChart.getMeasureValue(indicies.yStart, seriesValues);
                            var measureYEnd = visuals.ScatterChart.getMeasureValue(indicies.yEnd, seriesValues);
                            var xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null;
                            var yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0;
                            var size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;
                            var colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null;
                            var shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]);
                            var image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null;
                            var rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0;
                            var backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null;
                            var xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null;
                            var xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null;
                            var yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null;
                            var yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null;
                            var hasNullValue = (xVal == null) || (yVal == null);
                            if (hasNullValue)
                                continue;
                            var color = void 0;
                            if (hasDynamicSeries) {
                                color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                            }
                            else {
                                // If we have no Size measure then use a blank query name
                                var measureSource = (measureSize != null)
                                    ? measureSize.source.queryName
                                    : '';
                                color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                            }
                            var category = categories && categories.length > 0 ? categories[0] : null;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(category, categoryIdx)
                                .withSeries(dataValues, grouping)
                                .createSelectionId();
                            var seriesData = [];
                            if (dataValueSource) {
                                // Dynamic series
                                seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });
                            }
                            if (measureX) {
                                seriesData.push({ value: xVal, metadata: measureX });
                            }
                            if (measureY) {
                                seriesData.push({ value: yVal, metadata: measureY });
                            }
                            if (measureSize && measureSize.values && measureSize.values.length > 0) {
                                seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });
                            }
                            if (measureColorFill && measureColorFill.values && measureColorFill.values.length > 0) {
                                seriesData.push({ value: measureColorFill.values[categoryIdx], metadata: measureColorFill });
                            }
                            if (measureShape && measureShape.values && measureShape.values.length > 0) {
                                seriesData.push({ value: measureShape.values[categoryIdx], metadata: measureShape });
                            }
                            if (measureImage && measureImage.values && measureImage.values.length > 0) {
                                seriesData.push({ value: measureImage.values[categoryIdx], metadata: measureImage });
                            }
                            if (measureRotation && measureRotation.values && measureRotation.values.length > 0) {
                                seriesData.push({ value: measureRotation.values[categoryIdx], metadata: measureRotation });
                            }
                            if (measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0) {
                                seriesData.push({ value: measureBackdrop.values[categoryIdx], metadata: measureBackdrop });
                            }
                            if (measureXStart && measureXStart.values && measureXStart.values.length > 0) {
                                seriesData.push({ value: measureXStart.values[categoryIdx], metadata: measureXStart });
                            }
                            if (measureXEnd && measureXEnd.values && measureXEnd.values.length > 0) {
                                seriesData.push({ value: measureXEnd.values[categoryIdx], metadata: measureXEnd });
                            }
                            if (measureYStart && measureYStart.values && measureYStart.values.length > 0) {
                                seriesData.push({ value: measureYStart.values[categoryIdx], metadata: measureYStart });
                            }
                            if (measureYEnd && measureYEnd.values && measureYEnd.values.length > 0) {
                                seriesData.push({ value: measureYEnd.values[categoryIdx], metadata: measureYEnd });
                            }
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);
                            var dataPoint = {
                                x: xVal,
                                y: yVal,
                                size: size,
                                radius: { sizeMeasure: measureSize, index: categoryIdx },
                                fill: color,
                                category: categoryFormatter.format(categoryValue),
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                labelFill: labelSettings.labelColor,
                                labelFontSize: labelSettings.fontSize,
                                colorFill: colorFill,
                                shapeSymbolType: shapeSymbolType,
                                svgurl: image,
                                rotation: rotation,
                                backdrop: backdrop,
                                xStart: xStart,
                                xEnd: xEnd,
                                yStart: yStart,
                                yEnd: yEnd
                            };
                            dataPoints.push(dataPoint);
                        }
                    }
                    return dataPoints;
                };
                EnhancedScatterChart.prototype.setData = function (dataViews) {
                    this.data = {
                        xCol: undefined,
                        yCol: undefined,
                        dataPoints: [],
                        legendData: { dataPoints: [] },
                        axesLabels: { x: '', y: '' },
                        selectedIds: [],
                        sizeRange: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                        defaultDataPointColor: null,
                        hasDynamicSeries: false,
                        useShape: true,
                        useCustomColor: false,
                    };
                    if (dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView) {
                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, true);
                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, true);
                            this.dataView = dataView;
                            if (dataView.categorical && dataView.categorical.values) {
                                this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);
                            }
                        }
                    }
                };
                EnhancedScatterChart.prototype.update = function (options) {
                    debug.assertValue(options, 'options');
                    var dataViews = this.dataViews = options.dataViews;
                    this.viewport = _.clone(options.viewport);
                    if (!dataViews)
                        return;
                    if (dataViews && dataViews.length > 0) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                        if (warnings && warnings.length > 0)
                            this.hostServices.setWarnings(warnings);
                        this.populateObjectProperties(dataViews);
                    }
                    this.setData(dataViews);
                    // Note: interactive legend shouldn't be rendered explicitly here
                    // The interactive legend is being rendered in the render method of ICartesianVisual
                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) {
                        this.renderLegend();
                    }
                    this.render(options.suppressAnimations);
                };
                EnhancedScatterChart.prototype.populateObjectProperties = function (dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata) {
                            this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                        }
                        else {
                            this.legendObjectProperties = {};
                        }
                        this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata);
                        this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
                        var axisPosition = this.valueAxisProperties['position'];
                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                    }
                };
                EnhancedScatterChart.prototype.renderLegend = function () {
                    var legendData = { title: "", dataPoints: [] };
                    var legend = this.legend;
                    this.layerLegendData = this.data.legendData;
                    if (this.layerLegendData) {
                        legendData.title = this.layerLegendData.title || "";
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault;
                        if (this.layerLegendData.grouped) {
                            legendData.grouped = true;
                        }
                    }
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        if (position)
                            legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    else {
                        legend.changeOrientation(visuals.LegendPosition.Top);
                    }
                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                        legendData.dataPoints = [];
                    }
                    var viewport = this.viewport;
                    legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
                    visuals.Legend.positionChartArea(this.svg, legend);
                };
                EnhancedScatterChart.prototype.hideLegends = function () {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                            return true;
                        }
                    }
                    return false;
                };
                EnhancedScatterChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {
                    if (propertyName === void 0) { propertyName = "show"; }
                    if (!axisProperties) {
                        return false;
                    }
                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    return false;
                };
                EnhancedScatterChart.prototype.getMaxMarginFactor = function () {
                    return this.options.style.maxMarginFactor || 0.25;
                };
                EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function () {
                    var img = new Image();
                    var that = this;
                    img.src = this.data.backdrop.url;
                    img.onload = function () {
                        if (that.oldBackdrop !== this.src) {
                            that.render(true);
                            that.oldBackdrop = this.src;
                        }
                    };
                    if (img.width > 0 && img.height > 0) {
                        if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
                            this.viewport = { width: this.viewport.width - deltaWidth, height: this.viewport.height };
                        }
                        else {
                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
                            this.viewport = { width: this.viewport.width, height: this.viewport.height - deltaHeight };
                        }
                    }
                };
                EnhancedScatterChart.prototype.render = function (suppressAnimations) {
                    this.viewport.height -= this.legendViewport.height;
                    this.viewport.width -= this.legendViewport.width;
                    if (this.viewportIn.width === 0 || this.viewportIn.height === 0) {
                        return;
                    }
                    var maxMarginFactor = this.getMaxMarginFactor();
                    this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
                    var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
                    // reset defaults
                    this.margin.top = 8;
                    this.margin.bottom = bottomMarginLimit;
                    this.margin.right = 0;
                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                    this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis;
                    this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
                    var renderXAxis = this.shouldRenderAxis(this.xAxisProperties);
                    var renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
                    var mainAxisScale;
                    this.isXScrollBarVisible = false;
                    this.isYScrollBarVisible = false;
                    var tickLabelMargins;
                    var axisLabels;
                    var chartHasAxisLabels;
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;
                    while (!doneWithMargins && numIterations < maxIterations) {
                        numIterations++;
                        tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);
                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                        maxMainYaxisSide += 10;
                        maxSecondYaxisSide += 10;
                        xMax += 12;
                        if (showY1OnRight && renderY1Axis) {
                            maxSecondYaxisSide += 20;
                        }
                        if (!showY1OnRight && renderY1Axis) {
                            maxMainYaxisSide += 20;
                        }
                        if (this.hideAxisLabels()) {
                            this.xAxisProperties.axisLabel = null;
                            this.yAxisProperties.axisLabel = null;
                        }
                        this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);
                        axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };
                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                        if (axisLabels.x != null)
                            xMax += 18;
                        if (axisLabels.y != null)
                            maxMainYaxisSide += 20;
                        if (axisLabels.y2 != null)
                            maxSecondYaxisSide += 20;
                        this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                        this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                        this.margin.bottom = xMax;
                        // re-calculate the axes with the new margins
                        var previousTickCountY1 = this.yAxisProperties.values.length;
                        this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
                        if (this.yAxisProperties.values.length === previousTickCountY1)
                            doneWithMargins = true;
                    }
                    // we have to do the above process again since changes are made to viewport.
                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {
                        this.adjustViewportbyBackdrop();
                        doneWithMargins = false;
                        maxIterations = 2;
                        numIterations = 0;
                        while (!doneWithMargins && numIterations < maxIterations) {
                            numIterations++;
                            tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);
                            // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                            maxMainYaxisSide += 10;
                            if (showY1OnRight && renderY1Axis)
                                maxSecondYaxisSide += 15;
                            xMax += 12;
                            if (this.hideAxisLabels()) {
                                this.xAxisProperties.axisLabel = null;
                                this.yAxisProperties.axisLabel = null;
                            }
                            this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);
                            axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };
                            chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                            if (axisLabels.x != null)
                                xMax += 18;
                            if (axisLabels.y != null)
                                maxMainYaxisSide += 20;
                            if (axisLabels.y2 != null)
                                maxSecondYaxisSide += 20;
                            this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                            this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                            this.margin.bottom = xMax;
                            // re-calculate the axes with the new margins
                            var previousTickCountY1 = this.yAxisProperties.values.length;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                            // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
                            // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
                            if (this.yAxisProperties.values.length === previousTickCountY1)
                                doneWithMargins = true;
                        }
                    }
                    this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations);
                    this.updateAxis();
                    if (!this.data)
                        return;
                    var data = this.data;
                    var dataPoints = this.data.dataPoints;
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    this.mainGraphicsContext.attr('width', this.viewportIn.width)
                        .attr('height', this.viewportIn.height);
                    var sortedData = dataPoints.sort(function (a, b) {
                        return b.radius.sizeMeasure ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]) : 0;
                    });
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    var scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);
                    var dataLabelsSettings = this.data.dataLabelsSettings;
                    if (dataLabelsSettings.show) {
                        var layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange);
                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.mainGraphicsG, layout, this.viewportIn);
                        var offset = dataLabelsSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;
                        this.mainGraphicsG.select('.labels').attr('transform', visuals.SVGUtil.translate(offset, 0));
                    }
                    else {
                        visuals.dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
                    }
                    var behaviorOptions = undefined;
                    if (this.interactivityService) {
                        behaviorOptions = {
                            dataPointsSelection: scatterMarkers,
                            data: this.data,
                            plotContext: this.mainGraphicsContext,
                        };
                    }
                    visuals.TooltipManager.addTooltip(scatterMarkers, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                    if (this.behavior) {
                        var layerBehaviorOptions = [];
                        layerBehaviorOptions.push(behaviorOptions);
                        if (this.interactivityService) {
                            var cbehaviorOptions = {
                                layerOptions: layerBehaviorOptions,
                                clearCatcher: this.clearCatcher,
                            };
                            this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
                        }
                    }
                };
                EnhancedScatterChart.prototype.darkenZeroLine = function (g) {
                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
                    if (zeroTick) {
                        d3.select(zeroTick).select('line').classed('zero-line', true);
                    }
                };
                EnhancedScatterChart.prototype.getCategoryAxisFill = function () {
                    if (this.dataView && this.dataView.metadata.objects) {
                        var label = this.dataView.metadata.objects['categoryAxis'];
                        if (label) {
                            return label['axisColor'];
                        }
                    }
                    return { solid: { color: '#333' } };
                };
                EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function (labelSettings, viewport, sizeRange) {
                    var xScale = this.xAxisProperties.scale;
                    var yScale = this.yAxisProperties.scale;
                    var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);
                    var offset = labelSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;
                    return {
                        labelText: function (d) {
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: d.category,
                                fontSize: labelSettings.fontSize,
                                maxWidth: viewport.width,
                            });
                        },
                        labelLayout: {
                            x: function (d) { return xScale(d.x) - offset; },
                            y: function (d) {
                                var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + visuals.dataLabelUtils.labelMargin;
                                return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
                            },
                        },
                        filter: function (d) {
                            return (d != null && d.category != null);
                        },
                        style: {
                            'fill': function (d) { return d.labelFill; },
                            'font-size': fontSizeInPx,
                        },
                    };
                };
                EnhancedScatterChart.prototype.getValueAxisFill = function () {
                    if (this.dataView && this.dataView.metadata.objects) {
                        var label = this.dataView.metadata.objects['valueAxis'];
                        if (label)
                            return label['axisColor'];
                    }
                    return { solid: { color: '#333' } };
                };
                EnhancedScatterChart.prototype.renderCrossHair = function () {
                    var _this = this;
                    var xScale = this.xAxisProperties.scale;
                    var yScale = this.yAxisProperties.scale;
                    var mainGraphicsContext = this.mainGraphicsContext;
                    mainGraphicsContext.selectAll(".crosshairCanvas").remove();
                    if (this.data.crosshair) {
                        var canvas = mainGraphicsContext.append("g").attr("class", "crosshairCanvas").attr("id", "crosshairCanvas");
                        var crossHair = canvas.append("g").attr("class", "crosshair");
                        var hLine = crossHair.append("line").attr("id", "h_crosshair") // horizontal cross hair
                            .attr("x1", 0)
                            .attr("y1", 0)
                            .attr("x2", 0)
                            .attr("y2", 0)
                            .style("stroke", "gray")
                            .style("stroke-width", "1px")
                            .style("stroke-dasharray", "5,5")
                            .style("display", "none");
                        var vLine = crossHair.append("line").attr("id", "v_crosshair") // vertical cross hair
                            .attr("x1", 0)
                            .attr("y1", 0)
                            .attr("x2", 0)
                            .attr("y2", 0)
                            .style("stroke", "grey")
                            .style("stroke-width", "1px")
                            .style("stroke-dasharray", "5,5")
                            .style("display", "none");
                        var text = crossHair.append("text").attr("id", "crosshair_text") // text label for cross hair
                            .style("font-size", "10px")
                            .style("stroke", "black")
                            .style("stroke-width", "0.5px");
                        var textRect = crossHair.append("rect").attr("id", "crosshair_rect"); // text label for cross hair
                        var addCrossHair = function (xCoord, yCoord) {
                            // Update horizontal cross hair
                            hLine.attr("x1", 0)
                                .attr("y1", yCoord)
                                .attr("x2", _this.viewportIn.width)
                                .attr("y2", yCoord)
                                .style("display", "block");
                            // Update vertical cross hair
                            vLine.attr("x1", xCoord)
                                .attr("y1", 0)
                                .attr("x2", xCoord)
                                .attr("y2", _this.viewportIn.height)
                                .style("display", "block");
                            // Update text label
                            text.attr("transform", "translate(" + (xCoord + 5) + "," + (yCoord - 5) + ")")
                                .text("(" + Math.round(xScale.invert(xCoord) * 100) / 100 + " , " + Math.round(yScale.invert(yCoord) * 100) / 100 + ")");
                            var bbox = text.node().getBBox();
                            textRect.attr("x", (xCoord + 5) + bbox.x)
                                .attr("y", (yCoord - 5) + bbox.y)
                                .attr("width", bbox.width)
                                .attr("height", bbox.height)
                                .style({ 'fill': 'white', 'fill-opacity': 0.5 });
                        };
                        this.axisGraphicsContextScrollable.on("mousemove", function () {
                            var coordinates = d3.mouse(this);
                            var svgNode = this.viewportElement;
                            var scaledRect = svgNode.getBoundingClientRect();
                            var domRect = svgNode.getBBox();
                            var ratioX = scaledRect.width / domRect.width;
                            var ratioY = scaledRect.height / domRect.height;
                            if (domRect.width > 0 && !powerbi.Double.equalWithPrecision(ratioX, 1.0, 0.00001)) {
                                coordinates[0] = coordinates[0] / ratioX;
                            }
                            if (domRect.height > 0 && !powerbi.Double.equalWithPrecision(ratioY, 1.0, 0.00001)) {
                                coordinates[1] = coordinates[1] / ratioY;
                            }
                            addCrossHair(coordinates[0], coordinates[1]);
                        })
                            .on("mouseover", function () {
                            d3.selectAll(".crosshair").style("display", "block");
                        })
                            .on("mouseout", function () {
                            d3.selectAll(".crosshair").style("display", "none");
                        });
                    }
                };
                EnhancedScatterChart.prototype.renderBackground = function () {
                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {
                        this.backgroundGraphicsContext
                            .attr("xlink:href", this.data.backdrop.url)
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', this.viewportIn.width)
                            .attr('height', this.viewportIn.height);
                    }
                    else {
                        this.backgroundGraphicsContext
                            .attr('width', 0)
                            .attr('height', 0);
                    }
                };
                EnhancedScatterChart.prototype.renderChart = function (mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
                    var bottomMarginLimit = this.bottomMarginLimit;
                    var leftRightMarginLimit = this.leftRightMarginLimit;
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    this.renderBackground();
                    //hide show x-axis here
                    if (this.shouldRenderAxis(xAxis)) {
                        xAxis.axis.orient("bottom");
                        if (!xAxis.willLabelsFit)
                            xAxis.axis.tickPadding(5);
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        if (duration) {
                            xAxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(xAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        else {
                            xAxisGraphicsElement
                                .call(xAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        var xZeroTick = xAxisGraphicsElement.selectAll('g.tick').filter(function (data) { return data === 0; });
                        if (xZeroTick) {
                            var xZeroColor = this.getValueAxisFill();
                            if (xZeroColor)
                                xZeroTick.selectAll('line').style({ 'stroke': xZeroColor.solid.color });
                        }
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                        if (xAxis.willLabelsWordBreak) {
                            xAxisTextNodes
                                .call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit);
                        }
                        else {
                            xAxisTextNodes
                                .call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.svgEllipsis, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                        }
                    }
                    else {
                        this.xAxisGraphicsContext.selectAll('*').remove();
                    }
                    if (this.shouldRenderAxis(yAxis)) {
                        var yAxisOrientation = this.yAxisOrientation;
                        yAxis.axis
                            .tickSize(-this.viewportIn.width)
                            .tickPadding(10)
                            .orient(yAxisOrientation.toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        if (duration) {
                            y1AxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(yAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        else {
                            y1AxisGraphicsElement
                                .call(yAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        var yZeroTick = y1AxisGraphicsElement.selectAll('g.tick').filter(function (data) { return data === 0; });
                        if (yZeroTick) {
                            var yZeroColor = this.getCategoryAxisFill();
                            if (yZeroColor) {
                                yZeroTick.selectAll('line').style({ 'stroke': yZeroColor.solid.color });
                            }
                        }
                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
                            y1AxisGraphicsElement.selectAll('text')
                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                            leftRightMarginLimit - 10, powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }
                    else {
                        this.y1AxisGraphicsContext.selectAll('*').remove();
                    }
                    // Axis labels
                    //TODO: Add label for second Y axis for combo chart
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle");
                        var hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle");
                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
                        this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                    }
                    else {
                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    }
                    this.renderCrossHair();
                };
                EnhancedScatterChart.prototype.renderAxesLabels = function (axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    var margin = this.margin;
                    var width = this.viewportIn.width;
                    var height = this.viewport.height;
                    var fontSize = EnhancedScatterChart.AxisFontSize;
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    if (!hideXAxisTitle) {
                        var xAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(axisLabels.x)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    "transform": visuals.SVGUtil.translate(width / 2, height - fontSize - 2)
                                });
                            });
                        });
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!hideYAxisTitle) {
                        var yAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(axisLabels.y)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showY1OnRight ? width + margin.right - fontSize : -margin.left,
                                    "x": -((height - margin.top - legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!hideY2AxisTitle && axisLabels.y2) {
                        var y2AxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(axisLabels.y2)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showY1OnRight ? -margin.left : width + margin.right - fontSize,
                                    "x": -((height - margin.top - legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                };
                EnhancedScatterChart.prototype.updateAxis = function () {
                    this.adjustMargins();
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    this.xAxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(0, this.viewportIn.height));
                    this.y1AxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0));
                    this.svg.attr({
                        'width': this.viewport.width,
                        'height': this.viewport.height
                    });
                    this.svgScrollable.attr({
                        'width': this.viewport.width,
                        'height': this.viewport.height
                    });
                    this.svgScrollable.attr({
                        'x': 0
                    });
                    this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    if (this.isXScrollBarVisible) {
                        this.svgScrollable.attr({
                            'x': this.margin.left
                        });
                        this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, this.margin.top));
                        this.svgScrollable.attr('width', this.viewportIn.width);
                        this.svg.attr('width', this.viewport.width)
                            .attr('height', this.viewport.height + this.ScrollBarWidth);
                    }
                    else if (this.isYScrollBarVisible) {
                        this.svgScrollable.attr('height', this.viewportIn.height + this.margin.top);
                        this.svg.attr('width', this.viewport.width + this.ScrollBarWidth)
                            .attr('height', this.viewport.height);
                    }
                };
                EnhancedScatterChart.prototype.getUnitType = function (xAxis) {
                    if (xAxis.formatter &&
                        xAxis.formatter.displayUnit &&
                        xAxis.formatter.displayUnit.value > 1)
                        return xAxis.formatter.displayUnit.title;
                    return null;
                };
                EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function (xAxis, yAxis) {
                    var unitType = this.getUnitType(xAxis);
                    if (xAxis.isCategoryAxis) {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    if (xAxis.axisLabel && unitType) {
                        if (xAxis.isCategoryAxis) {
                            xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType);
                        }
                        else {
                            xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType);
                        }
                    }
                    unitType = this.getUnitType(yAxis);
                    if (!yAxis.isCategoryAxis) {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    if (yAxis.axisLabel && unitType) {
                        if (!yAxis.isCategoryAxis) {
                            yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType);
                        }
                        else {
                            yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType);
                        }
                    }
                };
                EnhancedScatterChart.prototype.hideAxisLabels = function () {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort
                            && ((this.viewport.height + this.legendViewport.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible)
                            && !this.options.interactivity.isInteractiveLegend) {
                            return true;
                        }
                    }
                    return false;
                };
                EnhancedScatterChart.prototype.drawScatterMarkers = function (scatterData, hasSelection, sizeRange, duration) {
                    var _this = this;
                    var xScale = this.xAxisProperties.scale;
                    var yScale = this.yAxisProperties.scale;
                    var shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint;
                    var markers;
                    var useCustomColor = this.data.useCustomColor;
                    if (this.data.useShape) {
                        this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove();
                        markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });
                        markers.enter()
                            .append('path')
                            .classed(EnhancedScatterChart.DotClasses.class, true).attr('id', 'markershape');
                        markers
                            .style({
                            'stroke-opacity': function (d) { return visuals.ScatterChart.getBubbleOpacity(d, hasSelection); },
                            'stroke-width': '1px',
                            'stroke': function (d) {
                                var color = useCustomColor ? d.colorFill : d.fill;
                                if (_this.data.outline) {
                                    return d3.rgb(color).darker();
                                }
                                else {
                                    return d3.rgb(color);
                                }
                            },
                            'fill': function (d) { return d3.rgb(useCustomColor ? d.colorFill : d.fill); },
                            'fill-opacity': function (d) { return (d.size != null || shouldEnableFill) ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0; },
                        })
                            .attr("d", function (d) {
                            var r = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            var area = 4 * r * r;
                            return d.shapeSymbolType(area);
                        })
                            .transition()
                            .duration(function (d) {
                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {
                                return duration;
                            }
                            else {
                                return 0;
                            }
                        })
                            .attr("transform", function (d) { return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")"; });
                    }
                    else {
                        this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove();
                        markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });
                        markers.enter().append("svg:image")
                            .classed(EnhancedScatterChart.ImageClasses.class, true).attr('id', 'markerimage');
                        markers
                            .attr("xlink:href", function (d) {
                            if (d.svgurl !== undefined && d.svgurl != null && d.svgurl !== "") {
                                return d.svgurl;
                            }
                            else {
                                return _this.svgDefaultImage;
                            }
                        })
                            .attr("width", function (d) {
                            return visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;
                        })
                            .attr("height", function (d) {
                            return visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;
                        })
                            .transition()
                            .duration(function (d) {
                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {
                                return duration;
                            }
                            else {
                                return 0;
                            }
                        })
                            .attr("transform", function (d) {
                            var radius = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
                        });
                    }
                    markers.exit().remove();
                    this.keyArray = [];
                    for (var i = 0; i < scatterData.length; i++) {
                        this.keyArray.push(scatterData[i].identity.getKey());
                    }
                    return markers;
                };
                EnhancedScatterChart.prototype.calculateAxes = function (categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
                    var visualOptions = {
                        viewport: this.viewport,
                        margin: this.margin,
                        forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                        forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
                        showCategoryAxisLabel: false,
                        showValueAxisLabel: false,
                        categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : null,
                        valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : null,
                        valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,
                        categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,
                        trimOrdinalDataOnOverflow: false
                    };
                    if (valueAxisProperties) {
                        visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
                    }
                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);
                    visualOptions.showValueAxisLabel = true;
                    var width = this.viewport.width - (this.margin.left + this.margin.right);
                    var axes = this.calculateAxesProperties(visualOptions);
                    axes[0].willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    // If labels do not fit and we are not scrolling, try word breaking
                    axes[0].willLabelsWordBreak = (!axes[0].willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                    return axes;
                };
                EnhancedScatterChart.prototype.calculateAxesProperties = function (options) {
                    var data = this.data;
                    var dataPoints = data.dataPoints;
                    this.margin = options.margin;
                    this.viewport = options.viewport;
                    var minY = 0, maxY = 10, minX = 0, maxX = 10;
                    if (dataPoints.length > 0) {
                        minY = d3.min(dataPoints, function (d) { return d.y; });
                        maxY = d3.max(dataPoints, function (d) { return d.y; });
                        minX = d3.min(dataPoints, function (d) { return d.x; });
                        maxX = d3.max(dataPoints, function (d) { return d.x; });
                    }
                    var xDomain = [minX, maxX];
                    var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);
                    this.xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewportIn.width,
                        dataDomain: combinedXDomain,
                        metaDataColumn: data.xCol,
                        formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: false,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: true,
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits
                    });
                    this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0);
                    this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                    var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [minY, maxY]);
                    this.yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewportIn.height,
                        dataDomain: combinedDomain,
                        metaDataColumn: data.yCol,
                        formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: true,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: false,
                        scaleType: options.valueAxisScaleType,
                        axisDisplayUnits: options.valueAxisDisplayUnits
                    });
                    this.yAxisProperties.axisLabel = this.data.axesLabels.y;
                    return [this.xAxisProperties, this.yAxisProperties];
                };
                EnhancedScatterChart.prototype.enumerateDataPoints = function (enumeration) {
                    var data = this.data;
                    if (!data)
                        return;
                    var seriesCount = data.dataPoints.length;
                    if (!data.hasDynamicSeries) {
                        // Add default color and show all slices
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                            }
                        }).pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                showAllDataPoints: !!data.showAllDataPoints
                            }
                        });
                        for (var i = 0; i < seriesCount; i++) {
                            var seriesDataPoints = data.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: seriesDataPoints.category,
                                selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                                properties: {
                                    fill: { solid: { color: seriesDataPoints.fill } }
                                },
                            });
                        }
                    }
                    else {
                        var legendDataPointLength = data.legendData.dataPoints.length;
                        for (var i = 0; i < legendDataPointLength; i++) {
                            var series = data.legendData.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: series.label,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: { solid: { color: series.color } }
                                },
                            });
                        }
                    }
                };
                EnhancedScatterChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'dataPoint':
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))
                                this.enumerateDataPoints(enumeration);
                            break;
                        case 'categoryAxis':
                            this.getCategoryAxisValues(enumeration);
                            break;
                        case 'valueAxis':
                            this.getValueAxisValues(enumeration);
                            break;
                        case 'categoryLabels':
                            if (this.data)
                                visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);
                            else
                                visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);
                            break;
                        case 'fillPoint':
                            var sizeRange = this.data.sizeRange;
                            // Check if the card should be shown or not
                            if (sizeRange && sizeRange.min)
                                break;
                            enumeration.pushInstance({
                                objectName: 'fillPoint',
                                selector: null,
                                properties: {
                                    show: this.data.fillPoint,
                                },
                            });
                            break;
                        case 'backdrop':
                            enumeration.pushInstance({
                                objectName: 'backdrop',
                                displayName: 'Backdrop',
                                selector: null,
                                properties: {
                                    show: this.data.backdrop ? this.data.backdrop.show : false,
                                    url: this.data.backdrop ? this.data.backdrop.url : null
                                },
                            });
                            break;
                        case 'crosshair':
                            enumeration.pushInstance({
                                objectName: 'crosshair',
                                selector: null,
                                properties: {
                                    show: this.data.crosshair
                                },
                            });
                            break;
                        case 'outline':
                            enumeration.pushInstance({
                                objectName: 'outline',
                                selector: null,
                                properties: {
                                    show: this.data.outline
                                },
                            });
                            break;
                        case 'legend':
                            this.getLegendValue(enumeration);
                            break;
                    }
                    return enumeration.complete();
                };
                EnhancedScatterChart.prototype.hasLegend = function () {
                    return this.data && this.data.hasDynamicSeries;
                };
                EnhancedScatterChart.prototype.getLegendValue = function (enumeration) {
                    if (!this.hasLegend())
                        return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');
                    var legendLabelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    this.legendLabelFontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: legendLabelColor,
                            fontSize: this.legendLabelFontSize,
                        },
                        objectName: 'legend'
                    });
                };
                EnhancedScatterChart.prototype.getCategoryAxisValues = function (enumeration) {
                    var supportedType = visuals.axisType.both;
                    var isScalar = true;
                    var logPossible = false;
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    if (!isScalar) {
                        if (this.categoryAxisProperties) {
                            this.categoryAxisProperties['start'] = null;
                            this.categoryAxisProperties['end'] = null;
                        }
                    }
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'categoryAxis',
                        validValues: {
                            axisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                    if (this.yAxisIsCategorical)
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    if (supportedType === visuals.axisType.both) {
                        instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
                    }
                    if (isScalar) {
                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : visuals.axisScale.linear;
                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;
                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;
                        instance.properties['labelDisplayUnits'] = this.categoryAxisProperties && this.categoryAxisProperties['labelDisplayUnits'] != null ? this.categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;
                    }
                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : true;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null
                        },
                        objectName: 'categoryAxis',
                        validValues: {
                            axisStyle: this.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        }
                    });
                };
                //todo: wrap all these object getters and other related stuff into an interface
                EnhancedScatterChart.prototype.getValueAxisValues = function (enumeration) {
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    var logPossible = false;
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis',
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                    if (!this.yAxisIsCategorical) {
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    }
                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : visuals.axisScale.linear;
                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;
                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;
                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : true;
                    instance.properties['labelDisplayUnits'] = this.valueAxisProperties && this.valueAxisProperties['labelDisplayUnits'] != null ? this.valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null
                        },
                        objectName: 'valueAxis',
                        validValues: {
                            axisStyle: this.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        },
                    });
                };
                EnhancedScatterChart.prototype.onClearSelection = function () {
                    if (this.interactivityService)
                        this.interactivityService.clearSelection();
                };
                EnhancedScatterChart.DefaultBubbleOpacity = 0.85;
                EnhancedScatterChart.DimmedBubbleOpacity = 0.4;
                EnhancedScatterChart.DataLabelsOffset = 5;
                EnhancedScatterChart.ClassName = 'enhancedScatterChart';
                EnhancedScatterChart.MainGraphicsContextClassName = 'mainGraphicsContext';
                EnhancedScatterChart.LegendLabelFontSizeDefault = 9;
                EnhancedScatterChart.LabelDisplayUnitsDefault = 0;
                EnhancedScatterChart.AxisFontSize = 11;
                EnhancedScatterChart.DotClasses = {
                    class: 'dot',
                    selector: '.dot'
                };
                EnhancedScatterChart.ImageClasses = {
                    class: 'img',
                    selector: '.img'
                };
                EnhancedScatterChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                        }, {
                            name: 'X',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                        }, {
                            name: 'Size',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
                        }, {
                            name: 'Gradient',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                        }, {
                            name: 'ColorFill',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Customized Color',
                        }, {
                            name: 'Shape',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Shape',
                        }, {
                            name: 'Image',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Image',
                        }, {
                            name: 'Rotation',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Rotation',
                        }, {
                            name: 'Backdrop',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Backdrop',
                        }, {
                            name: 'X Start',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'X Start',
                        }, {
                            name: 'X End',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'X End',
                        }, {
                            name: 'Y Start',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y Start',
                        }, {
                            name: 'Y End',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y End',
                        }
                    ],
                    dataViewMappings: [{
                            conditions: [{
                                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },
                                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }, {
                                    'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },
                                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }, {
                                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },
                                    'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }, {
                                    'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },
                                    'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { sample: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [
                                            { bind: { to: 'X' } },
                                            { bind: { to: 'Y' } },
                                            { bind: { to: 'Size' } },
                                            { bind: { to: 'Gradient' } },
                                            { bind: { to: 'ColorFill' } },
                                            { bind: { to: 'Shape' } },
                                            { bind: { to: 'Image' } },
                                            { bind: { to: 'Rotation' } },
                                            { bind: { to: 'Backdrop' } },
                                            { bind: { to: 'X Start' } },
                                            { bind: { to: 'X End' } },
                                            { bind: { to: 'Y Start' } },
                                            { bind: { to: 'Y End' } },
                                        ],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                rowCount: { preferred: { min: 2 } }
                            },
                        }],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                useShape: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_UseImage'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                    type: { fillRule: {} },
                                    rule: {
                                        inputRole: 'Gradient',
                                        output: {
                                            property: 'fill',
                                            selector: ['Category'],
                                        },
                                    }
                                }
                            }
                        },
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        categoryAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                start: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                axisColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display Units',
                                    type: { formatting: { labelDisplayUnits: true } },
                                },
                            }
                        },
                        valueAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                    type: { formatting: { yAxisPosition: true } }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                start: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                axisColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display Units',
                                    type: { formatting: { labelDisplayUnits: true } },
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                    type: { enumeration: visuals.legendPosition.type },
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Legend Name',
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                    type: { text: true }
                                },
                                labelColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        categoryLabels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                },
                            },
                        },
                        fillPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_FillPoint'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { bool: true }
                                },
                            },
                        },
                        backdrop: {
                            displayName: 'Backdrop',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                url: {
                                    displayName: 'Image URL',
                                    type: { text: true }
                                },
                            },
                        },
                        crosshair: {
                            displayName: 'Crosshair',
                            properties: {
                                show: {
                                    displayName: 'Crosshair',
                                    type: { bool: true }
                                },
                            },
                        },
                        outline: {
                            displayName: 'Outline',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                                    type: { bool: true }
                                }
                            }
                        }
                    }
                };
                return EnhancedScatterChart;
            })();
            samples.EnhancedScatterChart = EnhancedScatterChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  This file is based on or incorporates material from the projects listed below (Third Party IP).
 *  The original copyright notice and the license under which Microsoft received such Third Party IP,
 *  are set forth below. Such licenses and notices are provided for informational purposes only.
 *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.
 *  Microsoft reserves all other rights not expressly granted under this agreement, whether by
 *  implication, estoppel or otherwise.
 *
 *  d3 Force Layout
 *  Copyright (c) 2010-2015, Michael Bostock
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * The name Michael Bostock may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var PixelConverter = jsCommon.PixelConverter;
            var linkColorType;
            (function (linkColorType) {
                linkColorType.byWeight = 'ByWeight';
                linkColorType.byLinkType = 'ByLinkType';
                linkColorType.interactive = 'Interactive';
                linkColorType.type = powerbi.createEnumType([
                    { value: linkColorType.byWeight, displayName: 'ByWeight' },
                    { value: linkColorType.byLinkType, displayName: 'ByLinkType' },
                    { value: linkColorType.interactive, displayName: 'Interactive' },
                ]);
            })(linkColorType || (linkColorType = {}));
            samples.forceProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    color: {
                        objectName: "labels",
                        propertyName: "color"
                    },
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    }
                },
                links: {
                    showArrow: { objectName: 'links', propertyName: 'showArrow' },
                    showLabel: { objectName: 'links', propertyName: 'showLabel' },
                    colorLink: { objectName: 'links', propertyName: 'colorLink' },
                    thickenLink: { objectName: 'links', propertyName: 'thickenLink' },
                },
                nodes: {
                    displayImage: { objectName: 'nodes', propertyName: 'displayImage' },
                    defaultImage: { objectName: 'nodes', propertyName: 'defaultImage' },
                    imageUrl: { objectName: 'nodes', propertyName: 'imageUrl' },
                    imageExt: { objectName: 'nodes', propertyName: 'imageExt' },
                    nameMaxLength: { objectName: 'nodes', propertyName: 'nameMaxLength' },
                    highlightReachableLinks: { objectName: 'nodes', propertyName: 'highlightReachableLinks' },
                },
                size: {
                    charge: { objectName: 'size', propertyName: 'charge' },
                }
            };
            var ForceGraph = (function () {
                function ForceGraph() {
                }
                Object.defineProperty(ForceGraph.prototype, "margin", {
                    get: function () {
                        return this.marginValue || { left: 0, right: 0, top: 0, bottom: 0 };
                    },
                    set: function (value) {
                        this.marginValue = $.extend({}, value);
                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForceGraph.prototype, "viewport", {
                    get: function () {
                        return this.viewportValue || { width: 0, height: 0 };
                    },
                    set: function (value) {
                        this.viewportValue = $.extend({}, value);
                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForceGraph.prototype, "viewportIn", {
                    get: function () {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                ForceGraph.substractMargin = function (viewport, margin) {
                    return {
                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                    };
                };
                ForceGraph.prototype.scale1to10 = function (d) {
                    var scale = d3.scale.linear().domain([this.data.minFiles, this.data.maxFiles]).rangeRound([1, 10]).clamp(true);
                    return scale(d);
                };
                ForceGraph.prototype.getLinkColor = function (d) {
                    switch (this.options.colorLink) {
                        case linkColorType.byWeight:
                            return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;
                        case linkColorType.byLinkType:
                            return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;
                    }
                    ;
                    return this.options.defaultLinkColor;
                };
                ForceGraph.prototype.getDefaultOptions = function () {
                    return {
                        showDataLabels: true,
                        labelColor: visuals.dataLabelUtils.defaultLabelColor,
                        fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                        showArrow: false,
                        showLabel: false,
                        colorLink: linkColorType.interactive,
                        thickenLink: true,
                        displayImage: false,
                        defaultImage: "Home",
                        imageUrl: "",
                        imageExt: ".png",
                        nameMaxLength: 10,
                        highlightReachableLinks: false,
                        charge: -15,
                        defaultLinkColor: "#bbb",
                        defaultLinkHighlightColor: "#f00",
                        defaultLinkThickness: "1.5px",
                    };
                };
                ForceGraph.prototype.updateOptions = function (objects) {
                    this.options.showDataLabels = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.show, this.options.showDataLabels);
                    this.options.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.forceProps.labels.color, this.options.labelColor);
                    this.options.fontSize = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.fontSize, this.options.fontSize);
                    this.options.showArrow = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showArrow, this.options.showArrow);
                    this.options.showLabel = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showLabel, this.options.showLabel);
                    this.options.colorLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.colorLink, this.options.colorLink);
                    this.options.thickenLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.thickenLink, this.options.thickenLink);
                    this.options.displayImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.displayImage, this.options.displayImage);
                    this.options.defaultImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.defaultImage, this.options.defaultImage);
                    this.options.imageUrl = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageUrl, this.options.imageUrl);
                    this.options.imageExt = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageExt, this.options.imageExt);
                    this.options.nameMaxLength = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.nameMaxLength, this.options.nameMaxLength);
                    this.options.highlightReachableLinks = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks);
                    this.options.charge = powerbi.DataViewObjects.getValue(objects, samples.forceProps.size.charge, this.options.charge);
                    if (this.options.charge >= 0 || this.options.charge < -100)
                        this.options.charge = this.getDefaultOptions().charge;
                };
                ForceGraph.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'labels':
                            this.enumerateLabels(enumeration);
                            break;
                        case 'links':
                            this.enumerateLinks(enumeration);
                            break;
                        case 'nodes':
                            this.enumerateNodes(enumeration);
                            break;
                        case 'size':
                            this.enumerateSize(enumeration);
                            break;
                        default:
                            break;
                    }
                    return enumeration.complete();
                };
                ForceGraph.prototype.enumerateLabels = function (enumeration) {
                    var labels, options;
                    if (!this.options || !this.options)
                        return;
                    options = this.options;
                    labels = {
                        objectName: 'labels',
                        displayName: 'Labels',
                        selector: null,
                        properties: {
                            show: options.showDataLabels,
                            fontSize: options.fontSize,
                            color: options.labelColor
                        }
                    };
                    enumeration.pushInstance(labels);
                };
                ForceGraph.prototype.enumerateLinks = function (enumeration) {
                    var links, options;
                    if (!this.options)
                        return;
                    options = this.options;
                    links = {
                        objectName: 'links',
                        displayName: 'Links',
                        selector: null,
                        properties: {
                            showArrow: options.showArrow,
                            colorLink: options.colorLink,
                            showLabel: options.showLabel,
                            thickenLink: options.thickenLink,
                        }
                    };
                    enumeration.pushInstance(links);
                };
                ForceGraph.prototype.enumerateNodes = function (enumeration) {
                    var nodes, options;
                    if (!this.options)
                        return;
                    options = this.options;
                    nodes = {
                        objectName: 'nodes',
                        displayName: 'Nodes',
                        selector: null,
                        properties: {
                            displayImage: options.displayImage,
                            defaultImage: options.defaultImage,
                            imageUrl: options.imageUrl,
                            imageExt: options.imageExt,
                            nameMaxLength: options.nameMaxLength,
                            highlightReachableLinks: options.highlightReachableLinks,
                        }
                    };
                    enumeration.pushInstance(nodes);
                };
                ForceGraph.prototype.enumerateSize = function (enumeration) {
                    var size, options;
                    if (!this.options)
                        return;
                    options = this.options;
                    size = {
                        objectName: 'size',
                        displayName: 'Size',
                        selector: null,
                        properties: {
                            charge: options.charge,
                        }
                    };
                    enumeration.pushInstance(size);
                };
                ForceGraph.converter = function (dataView, colors) {
                    var categorical = dataView.categorical;
                    var nodes = {};
                    var minFiles = Number.MAX_VALUE;
                    var maxFiles = 0;
                    var linkedByName = {};
                    var links = [];
                    var linkDataPoints = {};
                    var linkTypeCount = 0;
                    var sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1;
                    var rows;
                    var tooltipInfo = [];
                    var formatStringProp = samples.forceProps.general.formatString;
                    if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) {
                        var metadataColumns = dataView.metadata.columns;
                        for (var i = 0; i < metadataColumns.length; i++) {
                            var col = metadataColumns[i];
                            if (col.roles) {
                                if (col.roles['Source'])
                                    sourceCol = i;
                                else if (col.roles['Target'])
                                    targetCol = i;
                                else if (col.roles['Weight'])
                                    weightCol = i;
                                else if (col.roles['LinkType'])
                                    linkTypeCol = i;
                                else if (col.roles['SourceType'])
                                    sourceTypeCol = i;
                                else if (col.roles['TargetType'])
                                    targetTypeCol = i;
                            }
                        }
                    }
                    if (dataView && dataView.table) {
                        rows = dataView.table.rows;
                    }
                    if (sourceCol < 0 || targetCol < 0)
                        return {
                            nodes: {},
                            links: [],
                            minFiles: 0,
                            maxFiles: 0,
                            linkedByName: {},
                            linkTypes: {},
                        };
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp);
                    var categoryTargetFormatString = visuals.valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp);
                    var weightFormatString = visuals.valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, true);
                    rows.forEach(function (item) {
                        linkedByName[item[sourceCol] + "," + item[targetCol]] = 1;
                        var source = nodes[item[sourceCol]] ||
                            (nodes[item[sourceCol]] = { name: item[sourceCol], image: sourceTypeCol > 0 ? item[sourceTypeCol] : '', adj: {} });
                        var target = nodes[item[targetCol]] ||
                            (nodes[item[targetCol]] = { name: item[targetCol], image: targetTypeCol > 0 ? item[targetTypeCol] : '', adj: {} });
                        source.adj[target.name] = 1;
                        target.adj[source.name] = 1;
                        tooltipInfo = [{
                                displayName: dataView.metadata.columns[0].displayName,
                                value: visuals.valueFormatter.format(source.name, categorySourceFormatString)
                            }, {
                                displayName: dataView.metadata.columns[1].displayName,
                                value: visuals.valueFormatter.format(target.name, categoryTargetFormatString)
                            }];
                        if (weightCol > 0)
                            tooltipInfo.push({
                                displayName: dataView.metadata.columns[2].displayName,
                                value: visuals.valueFormatter.format(item[weightCol], weightFormatString)
                            });
                        var link = {
                            source: source,
                            target: target,
                            filecount: weightCol > 0 ? item[weightCol] : 0,
                            type: linkTypeCol > 0 ? item[linkTypeCol] : '',
                            tooltipInfo: tooltipInfo,
                        };
                        if (linkTypeCol > 0) {
                            if (!linkDataPoints[item[linkTypeCol]]) {
                                linkDataPoints[item[linkTypeCol]] = {
                                    label: item[linkTypeCol],
                                    color: colors.getColorByIndex(linkTypeCount++).value,
                                };
                            }
                            ;
                        }
                        ;
                        if (link.filecount < minFiles) {
                            minFiles = link.filecount;
                        }
                        ;
                        if (link.filecount > maxFiles) {
                            maxFiles = link.filecount;
                        }
                        ;
                        links.push(link);
                    });
                    return {
                        nodes: nodes,
                        links: links,
                        minFiles: minFiles,
                        maxFiles: maxFiles,
                        linkedByName: linkedByName,
                        linkTypes: linkDataPoints,
                    };
                };
                ForceGraph.prototype.init = function (options) {
                    this.root = d3.select(options.element.get(0));
                    this.forceLayout = d3.layout.force();
                    this.colors = options.style.colorPalette.dataColors;
                    this.options = this.getDefaultOptions();
                };
                ForceGraph.prototype.update = function (options) {
                    var _this = this;
                    if (!options.dataViews || (options.dataViews.length < 1))
                        return;
                    this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors);
                    if (!this.data)
                        return;
                    if (options.dataViews[0].metadata && options.dataViews[0].metadata.objects)
                        this.updateOptions(options.dataViews[0].metadata.objects);
                    this.viewport = options.viewport;
                    var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
                    this.root.selectAll("svg").remove();
                    var svg = this.root
                        .append("svg")
                        .attr("width", this.viewport.width)
                        .attr("height", this.viewport.height)
                        .classed(ForceGraph.VisualClassName, true);
                    this.forceLayout
                        .gravity(100 * k)
                        .links(this.data.links)
                        .size([this.viewport.width, this.viewport.height])
                        .linkDistance(100)
                        .charge(this.options.charge / k)
                        .on("tick", this.tick());
                    this.updateNodes();
                    this.forceLayout.start();
                    // uncomment if we don't need the marker-end workaround
                    //if (this.options.showArrow) {
                    // build the arrow.
                    //function marker(d, i) {
                    //    let val = "mid_" + i;
                    //    svg.append("defs").selectAll("marker")
                    //        .data([val])      // Different link/path types can be defined here
                    //        .enter().append("marker")    // This section adds in the arrows
                    //        .attr("id", String)
                    //        .attr("viewBox", "0 -5 10 10")
                    //        .attr("refX", 10)
                    //        .attr("refY", 0)
                    //        .attr("markerWidth", 6)
                    //        .attr("markerHeight", 6)
                    //        .attr("orient", "auto")
                    //        .attr("markerUnits", "userSpaceOnUse")
                    //        .append("path")
                    //        .attr("d", "M0,-5L10,0L0,5")
                    //    //below works if no marker-end workaround needed
                    //        .style("fill", d => this.getLinkColor(d))
                    //    ;
                    //    return "url(#" + val + ")";
                    //}
                    //}
                    this.paths = svg.selectAll(".link")
                        .data(this.forceLayout.links())
                        .enter().append("path")
                        .attr("class", "link")
                        .attr("id", function (d, i) { return "linkid_" + i; })
                        .attr("stroke-width", function (d) { return _this.options.thickenLink ? _this.scale1to10(d.filecount) : _this.options.defaultLinkThickness; })
                        .style("stroke", function (d) { return _this.getLinkColor(d); })
                        .style("fill", function (d) { if (_this.options.showArrow)
                        return _this.getLinkColor(d); })
                        .on("mouseover", this.fadePath(.3, this.options.defaultLinkHighlightColor))
                        .on("mouseout", this.fadePath(1, this.options.defaultLinkColor));
                    visuals.TooltipManager.addTooltip(this.paths, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                    if (this.options.showLabel) {
                        svg.selectAll(".linklabelholder")
                            .data(this.forceLayout.links())
                            .enter().append("g")
                            .attr("class", "linklabelholder")
                            .append("text")
                            .attr("class", "linklabel")
                            .attr("y", "-12")
                            .attr("text-anchor", "middle")
                            .style("fill", "#000")
                            .append("textPath")
                            .attr("xlink:href", function (d, i) { return "#linkid_" + i; })
                            .attr("startOffset", "25%") //use "50%" if we don't need the marker-end workaround
                            .text(function (d) { return _this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount; });
                    }
                    // define the nodes
                    this.nodes = svg.selectAll(".node")
                        .data(this.forceLayout.nodes())
                        .enter().append("g")
                        .attr("class", "node")
                        .call(this.forceLayout.drag)
                        .on("mouseover", this.fadeNode(.3, this.options.defaultLinkHighlightColor))
                        .on("mouseout", this.fadeNode(1, this.options.defaultLinkColor))
                        .on("mousedown", function () { return d3.event.stopPropagation(); });
                    // add the nodes
                    if (this.options.displayImage) {
                        this.nodes.append("image")
                            .attr("xlink:href", function (d) {
                            return d.image && d.image !== '' ?
                                _this.options.imageUrl + d.image + _this.options.imageExt :
                                (_this.options.defaultImage && _this.options.defaultImage !== '' ?
                                    _this.options.imageUrl + _this.options.defaultImage + _this.options.imageExt :
                                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=');
                        })
                            .attr("x", "-12px")
                            .attr("y", "-12px")
                            .attr("width", "24px")
                            .attr("height", "24px");
                    }
                    else {
                        this.nodes.append("circle")
                            .attr("r", function (d) { return d.weight < 5 ? 5 : d.weight; });
                    }
                    // add the text
                    if (this.options.showDataLabels) {
                        this.nodes.append("text")
                            .attr({
                            x: 12,
                            dy: ".35em"
                        })
                            .style({
                            fill: this.options.labelColor,
                            'font-size': PixelConverter.fromPoint(this.options.fontSize)
                        })
                            .text(function (d) { return d.name ? (d.name.length > _this.options.nameMaxLength ? d.name.substr(0, _this.options.nameMaxLength) : d.name) : ''; });
                    }
                };
                ForceGraph.prototype.updateNodes = function () {
                    var oldNodes = this.forceLayout.nodes();
                    this.forceLayout.nodes(d3.values(this.data.nodes));
                    this.forceLayout.nodes().forEach(function (node, i) {
                        if (!oldNodes[i]) {
                            return;
                        }
                        node.x = oldNodes[i].x;
                        node.y = oldNodes[i].y;
                        node.px = oldNodes[i].px;
                        node.py = oldNodes[i].py;
                        node.weight = oldNodes[i].weight;
                    });
                };
                ForceGraph.prototype.tick = function () {
                    var _this = this;
                    var viewport = this.viewportIn;
                    // limitX and limitY is necessary when you minimize the graph and then resize it to normal.
                    //"width/height * 20" seems enough to move nodes freely by force layout.
                    var maxWidth = viewport.width * 20;
                    var maxHeight = viewport.height * 20;
                    var limitX = function (x) { return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x)); };
                    var limitY = function (y) { return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y)); };
                    //use this if we don't need the marker-end workaround
                    //path.attr("d", function (d) {
                    //    let dx = d.target.x - d.source.x,
                    //        dy = d.target.y - d.source.y,
                    //        dr = Math.sqrt(dx * dx + dy * dy);
                    //    // x and y distances from center to outside edge of target node
                    //    let offsetX = (dx * d.target.radius) / dr;
                    //    let offsetY = (dy * d.target.radius) / dr;
                    //    return "M" +
                    //        d.source.x + "," +
                    //        d.source.y + "A" +
                    //        dr + "," + dr + " 0 0,1 " +
                    //        (d.target.x - offsetX) + "," +
                    //        (d.target.y - offsetY);
                    //});
                    var getPath = this.options.showArrow ?
                        //this is for marker-end workaround, build the marker with the path
                        //this is for marker-end workaround, build the marker with the path
                        function (d) {
                            d.source.x = limitX(d.source.x);
                            d.source.y = limitY(d.source.y);
                            d.target.x = limitX(d.target.x);
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "A" +
                                dr + "," + dr + " 0 0 1," +
                                d.target.x + "," +
                                d.target.y +
                                "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
                        } :
                        function (d) {
                            d.source.x = limitX(d.source.x);
                            d.source.y = limitY(d.source.y);
                            d.target.x = limitX(d.target.x);
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "A" +
                                dr + "," + dr + " 0 0,1 " +
                                d.target.x + "," +
                                d.target.y;
                        };
                    return function () {
                        _this.paths.each(function () { this.parentNode.insertBefore(this, this); });
                        _this.paths.attr("d", getPath);
                        _this.nodes.attr("transform", function (d) { return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")"; });
                    };
                };
                ForceGraph.prototype.fadePath = function (opacity, highlight) {
                    var _this = this;
                    if (this.options.colorLink !== linkColorType.interactive)
                        return;
                    return function (d) {
                        _this.paths.style("stroke-opacity", function (o) { return o.source === d.source && o.target === d.target ? 1 : opacity; });
                        _this.paths.style("stroke", function (o) { return o.source === d.source && o.target === d.target ? highlight : _this.options.defaultLinkColor; });
                    };
                };
                ForceGraph.prototype.isReachable = function (a, b) {
                    if (a.name === b.name)
                        return true;
                    if (this.data.linkedByName[a.name + "," + b.name])
                        return true;
                    var visited = {};
                    for (var name_1 in this.data.nodes) {
                        visited[name_1] = false;
                    }
                    ;
                    visited[a.name] = true;
                    var stack = [];
                    stack.push(a.name);
                    while (stack.length > 0) {
                        var cur = stack.pop();
                        var node = this.data.nodes[cur];
                        for (var nb in node.adj) {
                            if (nb === b.name)
                                return true;
                            if (!visited[nb]) {
                                visited[nb] = true;
                                stack.push(nb);
                            }
                        }
                    }
                    ;
                    return false;
                };
                ForceGraph.prototype.fadeNode = function (opacity, highlight) {
                    var _this = this;
                    if (this.options.colorLink !== linkColorType.interactive)
                        return;
                    var isConnected = function (a, b) { return _this.data.linkedByName[a.name + "," + b.name] || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name; };
                    return function (d) {
                        var that = _this;
                        _this.nodes.style("stroke-opacity", function (o) {
                            var thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;
                            this.setAttribute('fill-opacity', thisOpacity);
                            return thisOpacity;
                        });
                        _this.paths.style("stroke-opacity", function (o) {
                            return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) :
                                (o.source === d || o.target === d)) ? 1 : opacity;
                        });
                        _this.paths.style("stroke", function (o) {
                            return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) :
                                (o.source === d || o.target === d)) ? highlight : _this.options.defaultLinkColor;
                        });
                    };
                };
                ForceGraph.prototype.destroy = function () {
                    this.root = null;
                };
                ForceGraph.VisualClassName = 'forceGraph';
                ForceGraph.capabilities = {
                    dataRoles: [
                        {
                            name: 'Source',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Source',
                        },
                        {
                            name: 'Target',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Target',
                        },
                        {
                            name: 'Weight',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Weight',
                        },
                        {
                            name: 'LinkType',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'LinkType',
                            description: 'Links can be colored by link types',
                        },
                        {
                            name: 'SourceType',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'SourceType',
                            description: 'Source type represents the image name for source entities',
                        },
                        {
                            name: 'TargetType',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'TargetType',
                            description: 'Target type represents the image name for target entities',
                        },
                    ],
                    objects: {
                        general: {
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                }
                            }
                        },
                        labels: {
                            displayName: 'Data labels',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        links: {
                            displayName: 'Links',
                            properties: {
                                showArrow: {
                                    type: { bool: true },
                                    displayName: 'Arrow'
                                },
                                showLabel: {
                                    type: { bool: true },
                                    displayName: 'Label',
                                    description: 'Displays weight on links',
                                },
                                colorLink: {
                                    type: { enumeration: linkColorType.type },
                                    displayName: 'Color',
                                },
                                thickenLink: {
                                    type: { bool: true },
                                    displayName: 'Thickness',
                                    description: 'Thickenss of links represents weight',
                                },
                            }
                        },
                        nodes: {
                            displayName: 'Nodes',
                            properties: {
                                displayImage: {
                                    type: { bool: true },
                                    displayName: 'Image',
                                    description: 'Images are loaded from image url + source or target type + image extension',
                                },
                                defaultImage: {
                                    type: { text: true },
                                    displayName: 'Default image'
                                },
                                imageUrl: {
                                    type: { text: true },
                                    displayName: 'Image url'
                                },
                                imageExt: {
                                    type: { text: true },
                                    displayName: 'Image extension'
                                },
                                nameMaxLength: {
                                    type: { numeric: true },
                                    displayName: 'Max name length',
                                    description: 'Max length of the name of entities displayed',
                                },
                                highlightReachableLinks: {
                                    type: { bool: true },
                                    displayName: 'Highlight all reachable links',
                                    description: "In interactive mode, whether a node's all reachable links will be highlighted",
                                },
                            }
                        },
                        size: {
                            displayName: 'Size',
                            properties: {
                                charge: {
                                    type: { numeric: true },
                                    displayName: 'Charge',
                                    description: 'The larger the negative charge the more apart the entities, must be negative but greater than -100',
                                },
                            }
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Source': { max: 1 }, 'Target': { max: 1 }, 'Weight': { max: 1 }, 'LinkType': { max: 1 }, 'SourceType': { max: 1 }, 'TargetType': { max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Source' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: 'Target' } },
                                        { bind: { to: 'Weight' } },
                                        { bind: { to: 'LinkType' } },
                                        { bind: { to: 'SourceType' } },
                                        { bind: { to: 'TargetType' } },
                                    ],
                                },
                                rowCount: { preferred: { min: 1 } }
                            },
                        }],
                    suppressDefaultTitle: true,
                };
                return ForceGraph;
            })();
            samples.ForceGraph = ForceGraph;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var SelectionManager = visuals.utility.SelectionManager;
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var Gantt = (function () {
                function Gantt() {
                    // Configuration
                    this.margin = {
                        top: 30,
                        right: 40,
                        bottom: 40,
                        left: 100
                    };
                }
                /**
                * Core: init, convert and update, destroy
                */
                Gantt.prototype.init = function (options) {
                    this.style = options.style;
                    var body = d3.select(options.element.get(0));
                    this.clearCatcher = visuals.appendClearCatcher(body);
                    this.ganttBody = this.clearCatcher
                        .append("div")
                        .classed(Gantt.ChartSelector.class, true)
                        .style({ "overflow": "auto" });
                    this.scrollContainer = this.ganttBody.append("div")
                        .classed(Gantt.BodySelector.class, true);
                    this.root = this.scrollContainer
                        .append("svg")
                        .classed(Gantt.ClassName, true);
                    this.yAxisGroup = this.root
                        .append("g")
                        .classed(Gantt.AxisGroupSelector.class, true);
                    this.lineGroup = this.root
                        .append("g")
                        .classed(Gantt.TaskLinesSelector.class, true);
                    this.chartGroup = this.root
                        .append("g")
                        .classed(Gantt.ChartSelector.class, true);
                    this.taskGroup = this.chartGroup
                        .append("g")
                        .classed(Gantt.TasksSelector.class, true);
                    this.milestoneGroup = this.chartGroup
                        .append("g")
                        .classed(Gantt.MilestonesSelector.class, true);
                    this.labelGroup = this.root
                        .append("g")
                        .classed(Gantt.TaskLabelsSelector.class, true);
                    this.xScale = d3.scale.linear();
                    this.yScale = d3.time.scale();
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                };
                Gantt.prototype.converter = function (dataView) {
                    if (!dataView ||
                        !dataView.matrix ||
                        !dataView.matrix.rows ||
                        !dataView.matrix.rows.root) {
                        return {
                            tasks: [],
                            fixedHeight: Gantt.FixedHeight,
                            paddingLines: Gantt.PaddingLines,
                            paddingTasks: Gantt.PaddingTasks
                        };
                    }
                    var tasks, columnSource = [], settings;
                    settings = this.parseSettings(dataView);
                    if (dataView.matrix.columns &&
                        dataView.matrix.columns.levels &&
                        dataView.matrix.columns.levels[0] &&
                        dataView.matrix.columns.levels[0].sources) {
                        columnSource = dataView.matrix.columns.levels[0].sources;
                    }
                    tasks = this.getTasks(columnSource, dataView.matrix.rows.root, settings);
                    return {
                        tasks: tasks,
                        fixedHeight: Gantt.FixedHeight,
                        paddingLines: Gantt.PaddingLines,
                        paddingTasks: Gantt.PaddingTasks
                    };
                };
                Gantt.prototype.parseSettings = function (dataView) {
                    var rolesFormats = Gantt.capabilities.dataRoles
                        .map(function (x) { return dataView.metadata.columns.filter(function (y) { return y.roles[x.name]; })[0]; })
                        .map(function (x) { return x ? x.format : undefined; });
                    return {
                        startDateFormatter: visuals.valueFormatter.create({ format: rolesFormats[1] }),
                        durationFormatter: visuals.valueFormatter.create({ format: rolesFormats[2] }),
                        completionFormatter: visuals.valueFormatter.create({ format: rolesFormats[3] })
                    };
                };
                Gantt.prototype.getTasks = function (columnSource, root, settings) {
                    var _this = this;
                    return root.children.map(function (child, index) {
                        var task = {}, durationAndCompletion;
                        task.index = index;
                        task.name = child.value;
                        task.start = _this.getStartDateOfTask(child);
                        task.resource = _this.getResource(child);
                        task.id = "ID" + index;
                        durationAndCompletion = _this.getDurationAndCompletion(columnSource, child);
                        task.duration = durationAndCompletion.duration;
                        task.completion = durationAndCompletion.completion * 100;
                        task.shape = "none";
                        task.color = "green";
                        task.group = null;
                        task.description = "";
                        task.end = d3.time.day.offset(task.start, task.duration);
                        task.selectionId = visuals.SelectionId.createWithId(child.identity);
                        task.tooltipInfo = _this.getTooltipInfo(task, settings);
                        return task;
                    });
                };
                Gantt.prototype.getTooltipInfo = function (task, settings) {
                    var result = [];
                    result.push({ displayName: Gantt.capabilities.dataRoles[0].name, value: task.name });
                    if (!isNaN(task.start.getDate())) {
                        result.push({ displayName: Gantt.capabilities.dataRoles[1].name, value: settings.startDateFormatter.format(task.start) });
                    }
                    result.push({ displayName: Gantt.capabilities.dataRoles[2].name, value: settings.durationFormatter.format(task.duration) });
                    result.push({ displayName: Gantt.capabilities.dataRoles[3].name, value: settings.completionFormatter.format(task.completion / 100) });
                    if (task.resource) {
                        result.push({ displayName: Gantt.capabilities.dataRoles[4].name, value: task.resource });
                    }
                    return result;
                };
                Gantt.prototype.getStartDateOfTask = function (child) {
                    if (!child || !child.children || !child.children[0]) {
                        return null;
                    }
                    return child.children[0].value;
                };
                Gantt.prototype.getResource = function (child) {
                    if (!child ||
                        !child.children ||
                        !child.children[0] ||
                        !child.children[0].children ||
                        !child.children[0].children[0]) {
                        return "";
                    }
                    return !child.children[0].children[0].value;
                };
                Gantt.prototype.getDurationAndCompletion = function (columnSource, child) {
                    if (!child || !columnSource || !(columnSource.length > 0)) {
                        return {
                            duration: 0,
                            completion: 0
                        };
                    }
                    if (child.values && child.values[0]) {
                        return {
                            duration: this.getValue(columnSource, "Duration", child.values),
                            completion: this.getValue(columnSource, "Completion", child.values)
                        };
                    }
                    else if (child.children) {
                        return this.getDurationAndCompletion(columnSource, child.children[0]);
                    }
                    else {
                        return this.getDurationAndCompletion([], null);
                    }
                };
                Gantt.prototype.getValue = function (columnSource, roleName, values) {
                    if (!columnSource[0] || !columnSource[0].roles) {
                        return 0;
                    }
                    var nodeValue = columnSource[0].roles[roleName] ? values[0] : values[1];
                    return nodeValue ? nodeValue.value || 0 : 0;
                };
                Gantt.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0]) {
                        return;
                    }
                    ;
                    var viewport = options.viewport, viewModel = this.converter(options.dataViews[0]), tasks = viewModel.tasks, width = viewport.width - this.margin.left - this.margin.right, height = viewport.height - this.margin.top - this.margin.bottom, taskSelection;
                    this.viewModel = viewModel;
                    // add changes for scrolling
                    this.ganttBody.style({
                        "height": viewport.height + "px",
                        "width": viewport.width + "px",
                    });
                    this.scrollContainer.style({
                        "height": (tasks.length * 45 + this.margin.top) + "px",
                        "width": "100%"
                    });
                    this.root
                        .attr("fill-opacity", 0.5)
                        .style({
                        "height": (tasks.length * 45 + this.margin.top) + "px",
                        "width": "100%",
                        "font-size": 10
                    });
                    this.yAxis = d3.svg.axis().orient("bottom");
                    this.updateMisc(viewModel.tasks, width, height);
                    this.updateNowLine(viewModel.tasks);
                    this.updateTaskLines(viewModel.tasks, width);
                    taskSelection = this.updateTasks(viewModel.tasks);
                    this.updateMilestoneShapes(viewModel.tasks);
                    this.updateLabels(viewModel.tasks);
                    this.bindSelectionHandler(taskSelection);
                };
                Gantt.prototype.updateLabels = function (tasks) {
                    var _this = this;
                    var labelSelection;
                    labelSelection = this.labelGroup
                        .selectAll(Gantt.LabelSelector.selector)
                        .data(tasks);
                    labelSelection
                        .enter()
                        .append("text");
                    labelSelection
                        .attr("x", 10)
                        .attr("y", function (task, i) { return _this.getLabelY(task.index); })
                        .attr("fill", "black")
                        .attr("stroke-width", 1)
                        .text(function (task) { return task.name; })
                        .classed(Gantt.LabelSelector.class, true);
                    labelSelection
                        .exit()
                        .remove();
                };
                Gantt.prototype.updateTaskLines = function (tasks, width) {
                    var _this = this;
                    var taskLinesSelection;
                    taskLinesSelection = this.lineGroup
                        .selectAll(Gantt.TaskLineSelector.selector)
                        .data(tasks);
                    taskLinesSelection
                        .enter()
                        .append("rect");
                    taskLinesSelection
                        .attr("x", 0)
                        .attr("y", function (task, i) { return _this.getBarLineY(task.index); })
                        .attr("width", width + this.margin.left + this.margin.right)
                        .attr("height", function () { return _this.getBarLineHeight(); })
                        .attr("fill", "black")
                        .attr("opacity", function (task, i) { return _this.getTasklineOpacity(i); })
                        .classed(Gantt.TaskLineSelector.class, true);
                    taskLinesSelection
                        .exit()
                        .remove();
                };
                Gantt.prototype.updateMilestoneShapes = function (tasks) {
                    var _this = this;
                    var milestoneSelection;
                    milestoneSelection = this.milestoneGroup
                        .selectAll(Gantt.MilestoneSelector.selector)
                        .data(tasks.filter(function (task) {
                        return task.shape !== "none";
                    }), function (task) { return task.index; });
                    milestoneSelection
                        .enter()
                        .append("path");
                    milestoneSelection
                        .attr("d", this.getMilestone())
                        .attr("transform", function (task, i) { return _this.getMilestonePos(task); })
                        .style("fill", "black")
                        .classed(Gantt.MilestoneSelector.class, true);
                    milestoneSelection
                        .exit()
                        .remove();
                };
                Gantt.prototype.updateTasks = function (tasks) {
                    var _this = this;
                    var taskSelection, taskEnterSelection;
                    taskSelection = this.taskGroup
                        .selectAll(Gantt.TaskSelector.selector)
                        .data(tasks.filter(function (task) { return task.shape === "none"; }), function (task) { return task.index; });
                    taskEnterSelection = taskSelection
                        .enter()
                        .append("g");
                    taskEnterSelection
                        .append("rect")
                        .classed(Gantt.TaskRectSelector.class, true);
                    taskEnterSelection
                        .append("rect")
                        .classed(Gantt.TaskProgressSelector.class, true);
                    taskSelection.classed(Gantt.TaskSelector.class, true);
                    taskSelection
                        .select(Gantt.TaskRectSelector.selector)
                        .attr("x", function (task, i) { return _this.yScale(task.start); })
                        .attr("y", function (task, i) { return _this.getBarY(task.index); })
                        .attr("width", function (task, i) { return _this.taskDurationToWidth(task); })
                        .attr("height", function () { return _this.getBarHeight(); });
                    taskSelection
                        .select(Gantt.TaskProgressSelector.selector)
                        .attr("x", function (task, i) { return _this.yScale(task.start); })
                        .attr("y", function (task, i) { return _this.getBarY(task.index); })
                        .attr("width", function (task, i) { return _this.taskProgress(task); })
                        .attr("height", function () { return _this.getBarHeight(); })
                        .style("fill", function (task, i) { return _this.getColorByIndex(i); });
                    taskSelection
                        .exit()
                        .remove();
                    this.updateTooltips(taskSelection);
                    return taskSelection;
                };
                Gantt.prototype.updateTooltips = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                };
                Gantt.prototype.bindSelectionHandler = function (taskSelection) {
                    var _this = this;
                    taskSelection.on("click", function (task) {
                        var isMultiSelect = d3.event.altKey || d3.event.ctrlKey;
                        _this.selectionManager.select(task.selectionId, isMultiSelect).then(function (selectionIds) {
                            _this.setSelection(taskSelection, selectionIds);
                        });
                        d3.event.stopPropagation();
                    });
                };
                Gantt.prototype.setSelection = function (taskSelection, selectionIds) {
                    taskSelection.style("opacity", null);
                    if (selectionIds.length === 0) {
                        return;
                    }
                    taskSelection.filter(function (task) {
                        return !selectionIds.some(function (selectionId) {
                            return task.selectionId === selectionId;
                        });
                    })
                        .style("opacity", Gantt.OpacityOfSelectionTask);
                };
                Gantt.prototype.getColorByIndex = function (index) {
                    return this.style.colorPalette.dataColors.getColorByIndex(index).value;
                };
                Gantt.prototype.getMilestone = function () {
                    return d3.svg.symbol().type("triangle-up").size(80);
                };
                Gantt.prototype.getLabelY = function (i) {
                    var m = this.viewModel, y = (m.fixedHeight * i) + (m.fixedHeight * m.paddingTasks) + this.getFontSize();
                    y = y - 16;
                    return y;
                };
                Gantt.prototype.getMilestonePos = function (task) {
                    return visuals.SVGUtil.translate(this.yScale(task.start), (task.index + 0.5) * this.viewModel.fixedHeight);
                };
                Gantt.prototype.taskProgress = function (task) {
                    var fraction = (task.completion / 100), y = this.yScale, progress = (y(task.end) - y(task.start)) * fraction;
                    return progress;
                };
                Gantt.prototype.getBarY = function (i) {
                    var m = this.viewModel, y = (m.fixedHeight * i) + (m.fixedHeight * m.paddingTasks);
                    return y;
                };
                Gantt.prototype.getBarHeight = function () {
                    return this.viewModel.fixedHeight - (this.viewModel.fixedHeight * this.viewModel.paddingTasks * 2);
                };
                Gantt.prototype.getBarLineY = function (i) {
                    var m = this.viewModel, y = (m.fixedHeight * i) + (m.fixedHeight * m.paddingLines);
                    return y;
                };
                Gantt.prototype.getBarLineHeight = function () {
                    var m = this.viewModel, height = m.fixedHeight - (m.fixedHeight * m.paddingLines * 2);
                    return height;
                };
                Gantt.prototype.taskDurationToWidth = function (task) {
                    return this.yScale(task.end) - this.yScale(task.start);
                };
                Gantt.prototype.getTasklineOpacity = function (i) {
                    var opacity;
                    if (i % 2) {
                        opacity = 0;
                    }
                    else {
                        opacity = 0.04;
                    }
                    return opacity;
                };
                Gantt.prototype.updateNowLine = function (tasks) {
                    var chartLineSelection, lines = [{
                            x1: this.yScale(Date.now()),
                            y1: 0,
                            x2: this.yScale(Date.now()),
                            y2: this.getNowlineY()
                        }];
                    chartLineSelection = this.chartGroup
                        .selectAll(Gantt.ChartLineSelector.selector)
                        .data(lines);
                    chartLineSelection
                        .enter()
                        .append("line");
                    chartLineSelection
                        .attr("x1", function (line) { return line.x1; })
                        .attr("y1", function (line) { return line.y1; })
                        .attr("x2", function (line) { return line.x2; })
                        .attr("y2", function (line) { return line.y2; })
                        .classed(Gantt.ChartLineSelector.class, true);
                    chartLineSelection
                        .exit()
                        .remove();
                };
                Gantt.prototype.updateMisc = function (tasks, width, height) {
                    var margin = this.margin, t1 = tasks[0].start, t2 = tasks[tasks.length - 1].end;
                    this.xScale = this.xScale.range([0, height]).domain([0, tasks.length]);
                    this.yScale = this.yScale.range([0, width]).domain([t1, t2]);
                    this.yAxis = this.yAxis.scale(this.yScale).tickPadding(10).tickFormat(function (x) {
                        if (x.getDate() === 1) {
                            if (x.getMonth() === 0) {
                                return ValueFormatter.format(x, "yyyy");
                            }
                            return ValueFormatter.format(x, "MMMM");
                        }
                        return ValueFormatter.format(x, "MMM d");
                    });
                    this.root.attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom);
                    this.yAxisGroup
                        .attr("transform", visuals.SVGUtil.translate(margin.left, 5))
                        .call(this.yAxis);
                    this.chartGroup.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top));
                    this.lineGroup.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                    this.labelGroup.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                };
                /**
                * Misc
                */
                Gantt.prototype.getNowlineY = function () {
                    var taskNumber = this.viewModel.tasks.length;
                    return taskNumber * this.viewModel.fixedHeight;
                };
                Gantt.prototype.getFontSize = function () {
                    var m = this.viewModel;
                    return (m.fixedHeight) - (m.fixedHeight * m.paddingTasks * 2);
                };
                Gantt.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    return instances;
                };
                Gantt.prototype.destroy = function () {
                    this.root = null;
                };
                Gantt.ClassName = "gantt";
                Gantt.ChartSelector = createClassAndSelector("chart");
                Gantt.ChartLineSelector = createClassAndSelector("chart-line");
                Gantt.BodySelector = createClassAndSelector("gantt-body");
                Gantt.AxisGroupSelector = createClassAndSelector("axis");
                Gantt.TasksSelector = createClassAndSelector("tasks");
                Gantt.TaskSelector = createClassAndSelector("task");
                Gantt.TaskRectSelector = createClassAndSelector("task-rect");
                Gantt.TaskProgressSelector = createClassAndSelector("task-progress");
                Gantt.MilestonesSelector = createClassAndSelector("milestones");
                Gantt.MilestoneSelector = createClassAndSelector("milestone");
                Gantt.TaskLabelsSelector = createClassAndSelector("task-labels");
                Gantt.TaskLinesSelector = createClassAndSelector("task-lines");
                Gantt.TaskLineSelector = createClassAndSelector("task-line");
                Gantt.LabelSelector = createClassAndSelector("label");
                Gantt.FixedHeight = 45;
                Gantt.PaddingLines = 0;
                Gantt.PaddingTasks = 0.15;
                Gantt.OpacityOfSelectionTask = 0.2;
                Gantt.capabilities = {
                    dataRoles: [
                        {
                            name: "Task",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Task"
                        }, {
                            name: "StartDate",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Start Date"
                        }, {
                            name: "Duration",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Duration",
                            requiredTypes: [{ numeric: true }, { integer: true }]
                        }, {
                            name: "Completion",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "% Completion",
                            requiredTypes: [{ numeric: true }, { integer: true }]
                        }, {
                            name: "Resource",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Resource"
                        }
                    ],
                    dataViewMappings: [{
                            conditions: [
                                {
                                    "Task": { min: 1, max: 1 },
                                    "StartDate": { min: 0, max: 0 },
                                    "Duration": { min: 0, max: 0 },
                                    "Completion": { min: 0, max: 0 },
                                    "Resource": { min: 0, max: 0 }
                                }, {
                                    "Task": { min: 1, max: 1 },
                                    "StartDate": { min: 1, max: 1 },
                                    "Duration": { min: 0, max: 0 },
                                    "Completion": { min: 0, max: 0 },
                                    "Resource": { min: 0, max: 0 }
                                }, {
                                    "Task": { min: 1, max: 1 },
                                    "StartDate": { min: 1, max: 1 },
                                    "Duration": { min: 0, max: 1 },
                                    "Completion": { min: 0, max: 1 },
                                    "Resource": { min: 0, max: 1 },
                                }
                            ],
                            matrix: {
                                rows: {
                                    select: [
                                        { for: { in: "Task" } },
                                        { for: { in: "StartDate" } },
                                        { for: { in: "Resource" } }
                                    ]
                                },
                                values: {
                                    select: [
                                        { bind: { to: "Duration" } },
                                        { bind: { to: "Completion" } }
                                    ]
                                }
                            }
                        }]
                };
                return Gantt;
            })();
            samples.Gantt = Gantt;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var THREE;
var WebGLHeatmap;
var GlobeMapCanvasLayers;
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var DataRoleHelper = powerbi.data.DataRoleHelper;
            var GlobeMap = (function () {
                function GlobeMap() {
                    this.renderData = [];
                    this.locationsToLoad = 0;
                    this.locationsLoaded = 0;
                    this.renderLoopEnabled = true;
                    this.needsRender = false;
                }
                GlobeMap.converter = function (dataView) {
                    return {};
                };
                GlobeMap.prototype.init = function (options) {
                    this.container = options.element;
                    this.viewport = options.viewport;
                    this.readyToRender = false;
                    if (!this.globeMapLocationCache)
                        this.globeMapLocationCache = {};
                    if (!THREE) {
                        loadGlobeMapLibs();
                    }
                    if (THREE) {
                        this.setup();
                    }
                };
                GlobeMap.prototype.setup = function () {
                    this.initSettings();
                    this.initTextures();
                    this.initMercartorSphere();
                    this.initZoomControl();
                    this.initScene();
                    this.initHeatmap();
                    this.readyToRender = true;
                    this.composeRenderData();
                    this.initRayCaster();
                };
                GlobeMap.prototype.initSettings = function () {
                    var settings = this.settings = {};
                    settings.autoRotate = false;
                    settings.earthRadius = 30;
                    settings.cameraRadius = 100;
                    settings.earthSegments = 100;
                    settings.heatmapSize = 1000;
                    settings.heatPointSize = 20;
                    settings.heatIntensity = 1;
                    settings.barWidth = 0.3;
                    settings.barHeight = 5;
                    settings.rotateSpeed = 0.5;
                    settings.zoomSpeed = 0.8;
                    settings.cameraAnimDuration = 1000; //ms
                    settings.clickInterval = 200; //ms
                };
                GlobeMap.prototype.initScene = function () {
                    var viewport = this.viewport;
                    var settings = this.settings;
                    var clock = new THREE.Clock();
                    var renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                    this.container.append(renderer.domElement);
                    this.domElement = renderer.domElement;
                    var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, 0.1, 10000);
                    var orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement);
                    var scene = this.scene = new THREE.Scene();
                    renderer.setSize(viewport.width, viewport.height);
                    renderer.setClearColor(0xbac4d2, 1);
                    camera.position.z = settings.cameraRadius;
                    orbitControls.maxDistance = settings.cameraRadius;
                    orbitControls.minDistance = settings.earthRadius + 1;
                    orbitControls.rotateSpeed = settings.rotateSpeed;
                    orbitControls.zoomSpeed = settings.zoomSpeed;
                    orbitControls.autoRotate = settings.autoRotate;
                    var ambientLight = new THREE.AmbientLight(0x000000);
                    var light1 = new THREE.DirectionalLight(0xffffff, 0.4);
                    var light2 = new THREE.DirectionalLight(0xffffff, 0.4);
                    var earth = this.earth = this.createEarth();
                    scene.add(ambientLight);
                    scene.add(light1);
                    scene.add(light2);
                    scene.add(earth);
                    light1.position.set(20, 20, 20);
                    light2.position.set(0, 0, -20);
                    var _zis = this;
                    requestAnimationFrame(function render() {
                        try {
                            if (_zis.renderLoopEnabled)
                                requestAnimationFrame(render);
                            if (!_zis.shouldRender())
                                return;
                            orbitControls.update(clock.getDelta());
                            _zis.setEarthTexture();
                            _zis.intersectBars();
                            _zis.heatmap.display(); // Needed for IE/Edge to behave nicely
                            renderer.render(scene, camera);
                            _zis.needsRender = false;
                        }
                        catch (e) {
                            console.error(e);
                        }
                    });
                };
                GlobeMap.prototype.shouldRender = function () {
                    return this.readyToRender && this.needsRender;
                };
                GlobeMap.prototype.createEarth = function () {
                    var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments);
                    var material = new THREE.MeshPhongMaterial({
                        map: this.mapTextures[0],
                        side: THREE.DoubleSide,
                        shininess: 1,
                        emissive: 0xaaaaaa,
                    });
                    return new THREE.Mesh(geometry, material);
                };
                GlobeMap.prototype.zoomClicked = function (zoomDirection) {
                    if (this.orbitControls.enabled === false || this.orbitControls.enableZoom === false)
                        return;
                    if (zoomDirection === -1)
                        this.orbitControls.constraint.dollyOut(Math.pow(0.95, this.settings.zoomSpeed));
                    else if (zoomDirection === 1)
                        this.orbitControls.constraint.dollyIn(Math.pow(0.95, this.settings.zoomSpeed));
                    this.orbitControls.update();
                    this.animateCamera(this.camera.position);
                };
                GlobeMap.prototype.rotateCam = function (deltaX, deltaY) {
                    if (this.orbitControls.enabled === false || this.orbitControls.enableRotate === false)
                        return;
                    this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed);
                    this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed);
                    this.orbitControls.update();
                    this.animateCamera(this.camera.position);
                };
                GlobeMap.prototype.initZoomControl = function () {
                    var _this = this;
                    var radius = 17;
                    var zoomControlWidth = radius * 8.5;
                    var zoomControlHeight = radius * 8.5;
                    var startX = radius * 3;
                    var startY = radius + 3;
                    var gap = radius * 2;
                    var zoomCss = {
                        'position': 'absolute',
                        'left': 'calc(100% - ' + zoomControlWidth + 'px)',
                        'top': 'calc(100% - ' + zoomControlHeight + 'px)',
                        'zIndex': '1000',
                    };
                    var zoomContainer = d3.select(this.container[0])
                        .append('div')
                        .style(zoomCss);
                    this.zoomControl = zoomContainer.append("svg")
                        .attr({
                        "width": zoomControlWidth,
                        "height": zoomControlHeight
                    });
                    var bottom = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(0, -5); });
                    bottom.append("circle").attr({
                        cx: startX + gap,
                        cy: startY + (2 * gap),
                        r: radius,
                        fill: "white",
                        opacity: 0.5,
                        stroke: 'gray',
                    });
                    bottom.append("path").attr({
                        d: "M" + (startX + (2 * radius)) + " " + (startY + (radius * 4.7)) + " l12 -20 a40,70 0 0,1 -24,0z",
                        fill: "gray",
                    });
                    var left = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(5, 0); });
                    left.append("circle").attr({
                        cx: startX,
                        cy: startY + gap,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    left.append("path").attr({
                        d: "M" + (startX - radius / 1.5) + " " + (startY + (radius * 2)) + " l20 -12 a70,40 0 0,0 0,24z",
                        fill: "gray",
                    });
                    var top = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(0, 5); });
                    top.append("circle").attr({
                        cx: startX + gap,
                        cy: startY,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    top.append("path").attr({
                        d: "M" + (startX + (2 * radius)) + " " + (startY - (radius / 1.5)) + " l12 20 a40,70 0 0,0 -24,0z",
                        fill: "gray",
                    });
                    var right = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(-5, 0); });
                    right.append("circle").attr({
                        cx: startX + (2 * gap),
                        cy: startY + gap,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    right.append("path").attr({
                        d: "M" + (startX + (4.7 * radius)) + " " + (startY + (radius * 2)) + " l-20 -12 a70,40 0 0,1 0,24z",
                        fill: "gray",
                    });
                    var zoomIn = this.zoomControl.append("g").on("click", function () { return _this.zoomClicked(-1); });
                    zoomIn.append("circle").attr({
                        cx: startX + 4 * radius,
                        cy: startY + 6 * radius,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    zoomIn.append("rect").attr({
                        x: startX + 3.5 * radius,
                        y: startY + 5.9 * radius,
                        width: radius,
                        height: radius / 3,
                        fill: "gray",
                    });
                    zoomIn.append("rect").attr({
                        x: startX + (4 * radius) - radius / 6,
                        y: startY + 5.55 * radius,
                        width: radius / 3,
                        height: radius,
                        fill: "gray",
                    });
                    var zoomOut = this.zoomControl.append("g").on("click", function () { return _this.zoomClicked(1); });
                    zoomOut.append("circle").attr({
                        cx: startX,
                        cy: startY + 6 * radius,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: "0.50",
                    });
                    zoomOut.append("rect").attr({
                        x: startX - (radius / 2),
                        y: startY + 5.9 * radius,
                        width: radius,
                        height: radius / 3,
                        fill: "gray",
                    });
                };
                GlobeMap.prototype.initTextures = function () {
                    var _this = this;
                    if (!GlobeMapCanvasLayers) {
                        // Initialize once, since this is a CPU + Network heavy operation.
                        GlobeMapCanvasLayers = [];
                        for (var level = 2; level <= 5; ++level) {
                            var canvas = this.getBingMapCanvas(level);
                            GlobeMapCanvasLayers.push(canvas);
                        }
                    }
                    // Can't execute in for loop because variable assignement gets overwritten
                    var createTexture = function (canvas) {
                        var texture = new THREE.Texture(canvas.get(0));
                        texture.needsUpdate = true;
                        canvas.on("ready", function (e, resolution) {
                            //console.log("level ready", resolution, texture)
                            texture.needsUpdate = true;
                            _this.needsRender = true;
                        });
                        return texture;
                    };
                    this.mapTextures = [];
                    for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) {
                        this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
                    }
                };
                GlobeMap.prototype.initHeatmap = function () {
                    var settings = this.settings;
                    //console.log("initHeatmap");
                    try {
                        var heatmap = this.heatmap = new WebGLHeatmap({ width: settings.heatmapSize, height: settings.heatmapSize });
                    }
                    catch (e) {
                        // IE & Edge will throw an error about texImage2D, we need to ignore it
                        console.error(e);
                    }
                    // canvas contents will be used for a texture
                    var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
                    texture.needsUpdate = true;
                    var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                    var geometry = new THREE.SphereGeometry(settings.earthRadius + 0.01, settings.earthSegments, settings.earthSegments);
                    var mesh = new THREE.Mesh(geometry, material);
                    window["heatmap"] = heatmap;
                    window["heatmapTexture"] = texture;
                    this.scene.add(mesh);
                };
                GlobeMap.prototype.setEarthTexture = function () {
                    //get distance as arbitrary value from 0-1
                    if (!this.camera)
                        return;
                    var maxDistance = this.settings.cameraRadius - this.settings.earthRadius;
                    var distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;
                    var texture;
                    if (distance <= 1 / 5) {
                        texture = this.mapTextures[3];
                    }
                    else if (distance <= 2 / 5) {
                        texture = this.mapTextures[2];
                    }
                    else if (distance <= 3 / 5) {
                        texture = this.mapTextures[1];
                    }
                    else {
                        texture = this.mapTextures[0];
                    }
                    if (this.earth.material.map !== texture) {
                        this.earth.material.map = texture;
                    }
                    if (this.selectedBar) {
                        this.orbitControls.rotateSpeed = this.settings.rotateSpeed;
                    }
                    else {
                        this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;
                    }
                    //console.log(distance, this.orbitControls.rotateSpeed);
                };
                GlobeMap.prototype.update = function (options) {
                    this.needsRender = true;
                    if (options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {
                        var viewport = this.viewport = options.viewport;
                        if (this.camera && this.renderer) {
                            this.camera.aspect = viewport.width / viewport.height;
                            this.camera.updateProjectionMatrix();
                            this.renderer.setSize(viewport.width, viewport.height);
                        }
                        return;
                    }
                    // PowerBI fires two update calls, one for size, one for data
                    if (options.dataViews[0] && options.dataViews[0].categorical) {
                        this.composeRenderData(options.dataViews[0].categorical);
                    }
                };
                GlobeMap.prototype.renderMagic = function () {
                    if (!this.readyToRender) {
                        //console.log("not ready to render");
                        this.defferedRender();
                        return;
                    }
                    var renderData = this.renderData;
                    var heatmap = this.heatmap;
                    var settings = this.settings;
                    heatmap.clear();
                    if (this.barsGroup) {
                        this.scene.remove(this.barsGroup);
                    }
                    this.barsGroup = new THREE.Object3D();
                    this.scene.add(this.barsGroup);
                    var barMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff00ff,
                        emissive: 0x550055,
                        side: THREE.DoubleSide,
                    });
                    this.averageBarVector = new THREE.Vector3();
                    for (var i = 0, len = renderData.length; i < len; ++i) {
                        var renderDatum = renderData[i];
                        if (!renderDatum.lat || !renderDatum.lng)
                            continue;
                        if (renderDatum.heat > 0.001) {
                            if (renderDatum.heat < 0.1)
                                renderDatum.heat = 0.1;
                            var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize;
                            var y = (1 - ((90 + renderDatum.lat) / 180)) * settings.heatmapSize;
                            heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);
                        }
                        if (renderDatum.height >= 0) {
                            if (renderDatum.height < 0.01)
                                renderDatum.height = 0.01;
                            var latRadians = renderDatum.lat / 180 * Math.PI; //radians
                            var lngRadians = renderDatum.lng / 180 * Math.PI;
                            var x = Math.cos(lngRadians) * Math.cos(latRadians);
                            var z = -Math.sin(lngRadians) * Math.cos(latRadians);
                            var y = Math.sin(latRadians);
                            var v = new THREE.Vector3(x, y, z);
                            this.averageBarVector.add(v);
                            var barHeight = settings.barHeight * renderDatum.height;
                            var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight);
                            var bar = new THREE.Mesh(geometry, barMaterial);
                            var position = v.clone().multiplyScalar(settings.earthRadius + barHeight / 2);
                            bar.position = position;
                            bar.lookAt(v);
                            bar.toolTipData = renderDatum.toolTipData;
                            this.barsGroup.add(bar);
                        }
                    }
                    if (this.barsGroup.children.length > 0 && this.camera) {
                        this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length);
                        if (this.locationsLoaded === this.locationsToLoad) {
                            this.animateCamera(this.averageBarVector);
                        }
                    }
                    heatmap.update();
                    heatmap.blur();
                    this.heatTexture.needsUpdate = true;
                    this.needsRender = true;
                    //console.log("renderMagic done! locations:", this.barsGroup.children.length, "toload/loaded", this.locationsToLoad, this.locationsLoaded)
                };
                GlobeMap.prototype.composeRenderData = function (categoricalView) {
                    // memoize last value
                    if (categoricalView) {
                        this.categoricalView = categoricalView;
                    }
                    else {
                        categoricalView = this.categoricalView;
                    }
                    this.renderData = [];
                    var locations = [];
                    var globeMapLocationCache = this.globeMapLocationCache;
                    //console.log("categoricalView", categoricalView)
                    if (!categoricalView)
                        return;
                    var categories = categoricalView.categories;
                    try {
                        var grouped = categoricalView.values.grouped();
                        var heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Height");
                        var intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Heat");
                        var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
                        var latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                    }
                    catch (e) { }
                    var locationType, heights, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;
                    if (categories && categories.length > 0 && categories[0].values) {
                        var locationCategory = categories[0];
                        locations = locationCategory.values;
                        locationDispName = locationCategory.source.displayName;
                        if (locationCategory.source.type.category) {
                            locationType = locationCategory.source.type.category.toLowerCase();
                        }
                        else {
                            locationType = "";
                        }
                    }
                    else {
                        locations = [];
                    }
                    // For debugging since devTools - salesByCountry isn't really sales by country
                    //var places = ["kenya", "india", "united states", "london", "australia", "canada"]
                    //heightIndex = 0;
                    if (heightIndex !== undefined && categoricalView.values[heightIndex]) {
                        heights = categoricalView.values[heightIndex].values;
                        heightDispName = categoricalView.values[heightIndex].source.displayName;
                        heightFormat = categoricalView.values[heightIndex].source.format;
                    }
                    else {
                        heights = new Array(locations.length);
                    }
                    if (intensityIndex !== undefined && categoricalView.values[intensityIndex]) {
                        heats = categoricalView.values[intensityIndex].values;
                        heatDispName = categoricalView.values[intensityIndex].source.displayName;
                        heatFormat = categoricalView.values[intensityIndex].source.format;
                    }
                    else {
                        heats = new Array(locations.length);
                    }
                    if (longitudeIndex !== undefined && categoricalView.values[longitudeIndex]
                        && latitudeIndex !== undefined && categoricalView.values[latitudeIndex]) {
                        longitudes = categoricalView.values[longitudeIndex].values;
                        latitudes = categoricalView.values[latitudeIndex].values;
                    }
                    else {
                        longitudes = null;
                        latitudes = null;
                    }
                    var maxHeight = Math.max.apply(null, heights) || 1;
                    var maxHeat = Math.max.apply(null, heats) || 1;
                    var heatFormatter = visuals.valueFormatter.create({ format: heatFormat, value: heats[0], value2: heats[1] });
                    var heightFormatter = visuals.valueFormatter.create({ format: heightFormat, value: heights[0], value2: heights[1] });
                    for (var i = 0, len = locations.length; i < len; ++i) {
                        var place = locations[i];
                        var lat, lng, latlng, height, heat;
                        //place = places[i];
                        if (place && typeof (place) === "string") {
                            place = place.toLowerCase();
                            var placeKey = place + "/" + locationType;
                            if (!longitudes && globeMapLocationCache[placeKey]) {
                                latlng = globeMapLocationCache[placeKey];
                                lat = latlng.latitude;
                                lng = latlng.longitude;
                            }
                            else if (longitudes) {
                                lat = latitudes[i];
                                lng = longitudes[i];
                            }
                            height = heights[i] / maxHeight;
                            heat = heats[i] / maxHeat;
                            var renderDatum = {
                                lat: lat,
                                lng: lng,
                                height: height || 0.01,
                                heat: heat || 0,
                                toolTipData: {
                                    location: { displayName: locationDispName, value: locations[i] },
                                    height: { displayName: heightDispName, value: heightFormatter.format(heights[i]) },
                                    heat: { displayName: heatDispName, value: heatFormatter.format(heats[i]) }
                                }
                            };
                            this.renderData.push(renderDatum);
                            if (!longitudes && !latlng) {
                                this.geocodeRenderDatum(renderDatum, place, locationType);
                            }
                        }
                    }
                    try {
                        this.renderMagic();
                    }
                    catch (e) {
                        console.error(e);
                    }
                };
                GlobeMap.prototype.geocodeRenderDatum = function (renderDatum, place, locationType) {
                    var _this = this;
                    var placeKey = place + "/" + locationType;
                    this.globeMapLocationCache[placeKey] = {}; //store empty object so we don't send AJAX request again
                    this.locationsToLoad++;
                    try {
                        var geocoder = powerbi.visuals["BI"].Services.GeocodingManager.geocode;
                    }
                    catch (e) {
                        geocoder = visuals.services.geocode;
                    }
                    if (geocoder) {
                        geocoder(place, locationType).always(function (latlng) {
                            // we use always because we want to cache unknown values. 
                            // No point asking bing again and again when it tells us it doesn't know about a location
                            _this.globeMapLocationCache[placeKey] = latlng;
                            _this.locationsLoaded++;
                            //console.log(place, latlng);
                            if (latlng.latitude && latlng.longitude) {
                                renderDatum.lat = latlng.latitude;
                                renderDatum.lng = latlng.longitude;
                                _this.defferedRender();
                            }
                        });
                    }
                };
                GlobeMap.prototype.defferedRender = function () {
                    var _this = this;
                    if (!this.deferredRenderTimerId) {
                        this.deferredRenderTimerId = setTimeout(function () {
                            _this.deferredRenderTimerId = null;
                            _this.composeRenderData();
                        }, 500);
                    }
                };
                GlobeMap.prototype.initRayCaster = function () {
                    var _this = this;
                    this.rayCaster = new THREE.Raycaster();
                    var settings = this.settings;
                    var mousePosNormalized = this.mousePosNormalized = new THREE.Vector2();
                    var mousePos = this.mousePos = new THREE.Vector2();
                    var element = this.container.get(0);
                    var mouseDownTime;
                    $(this.domElement).on("mousemove", function (event) {
                        // get coordinates in -1 to +1 space
                        var rect = element.getBoundingClientRect();
                        mousePos.x = event.clientX;
                        mousePos.y = event.clientY;
                        mousePosNormalized.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                        mousePosNormalized.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                        _this.needsRender = true;
                    }).on("mousedown", function (event) {
                        mouseDownTime = Date.now();
                    }).on("mouseup", function (event) {
                        // Debounce slow clicks
                        if ((Date.now() - mouseDownTime) > settings.clickInterval)
                            return;
                        if (_this.hoveredBar && event.shiftKey) {
                            _this.selectedBar = _this.hoveredBar;
                            _this.animateCamera(_this.selectedBar.position, function () {
                                if (!_this.selectedBar)
                                    return;
                                _this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius));
                                _this.orbitControls.minDistance = 1;
                            });
                        }
                        else {
                            if (_this.selectedBar) {
                                _this.animateCamera(_this.selectedBar.position, function () {
                                    _this.orbitControls.center.set(0, 0, 0);
                                    _this.orbitControls.minDistance = settings.earthRadius + 1;
                                });
                                _this.selectedBar = null;
                            }
                        }
                    }).on("mousewheel DOMMouseScroll", function () {
                        _this.needsRender = true;
                    });
                };
                GlobeMap.prototype.intersectBars = function () {
                    if (!this.rayCaster || !this.barsGroup)
                        return;
                    var rayCaster = this.rayCaster;
                    rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
                    var intersects = rayCaster.intersectObjects(this.barsGroup.children);
                    if (intersects && intersects.length > 0) {
                        //console.log(intersects[0], this.mousePos.x, this.mousePos.y);
                        var object = intersects[0].object;
                        if (!object || !object.toolTipData)
                            return;
                        var toolTipData = object.toolTipData;
                        var toolTipItems = [];
                        if (toolTipData.location.displayName)
                            toolTipItems.push(toolTipData.location);
                        if (toolTipData.height.displayName)
                            toolTipItems.push(toolTipData.height);
                        if (toolTipData.heat.displayName)
                            toolTipItems.push(toolTipData.heat);
                        this.hoveredBar = object;
                        visuals.TooltipManager.ToolTipInstance.show(toolTipItems, { x: this.mousePos.x, y: this.mousePos.y, width: 0, height: 0 });
                    }
                    else {
                        this.hoveredBar = null;
                        visuals.TooltipManager.ToolTipInstance.hide();
                    }
                };
                GlobeMap.prototype.animateCamera = function (to, done) {
                    var _this = this;
                    if (!this.camera)
                        return;
                    var startTime = Date.now();
                    var duration = this.settings.cameraAnimDuration;
                    var endTime = startTime + duration;
                    var startPos = this.camera.position.clone().normalize();
                    var endPos = to.clone().normalize();
                    var length = this.camera.position.length();
                    var easeInOut = function (t) {
                        t *= 2;
                        if (t < 1)
                            return (t * t * t) / 2;
                        t -= 2;
                        return (t * t * t + 2) / 2;
                    };
                    var onUpdate = function () {
                        var now = Date.now();
                        var t = (now - startTime) / duration;
                        if (t > 1)
                            t = 1;
                        t = easeInOut(t);
                        var pos = new THREE.Vector3()
                            .add(startPos.clone().multiplyScalar(1 - t))
                            .add(endPos.clone().multiplyScalar(t))
                            .normalize()
                            .multiplyScalar(length);
                        _this.camera.position = pos;
                        if (now < endTime) {
                            requestAnimationFrame(onUpdate);
                        }
                        else if (done) {
                            done();
                        }
                        _this.needsRender = true;
                    };
                    requestAnimationFrame(onUpdate);
                };
                GlobeMap.prototype.destroy = function () {
                    clearTimeout(this.deferredRenderTimerId);
                    this.renderLoopEnabled = false;
                    this.scene = null;
                    this.heatmap = null;
                    this.heatTexture = null;
                    this.camera = null;
                    if (this.renderer) {
                        if (this.renderer.context) {
                            var extension = this.renderer.context.getExtension('WEBGL_lose_context');
                            if (extension)
                                extension.loseContext();
                            this.renderer.context = null;
                        }
                        this.renderer.domElement = null;
                    }
                    this.renderer = null;
                    this.renderData = null;
                    this.barsGroup = null;
                    if (this.orbitControls)
                        this.orbitControls.dispose();
                    this.orbitControls = null;
                    if (this.domElement)
                        $(this.domElement)
                            .off("mousemove mouseup mousedown mousewheel DOMMouseScroll");
                    this.domElement = null;
                    if (this.container)
                        this.container.empty();
                };
                GlobeMap.prototype.initMercartorSphere = function () {
                    if (GlobeMap.MercartorSphere)
                        return;
                    var MercartorSphere = function (radius, widthSegments, heightSegments) {
                        THREE.Geometry.call(this);
                        this.radius = radius;
                        this.widthSegments = widthSegments;
                        this.heightSegments = heightSegments;
                        this.t = 0;
                        var x, y, vertices = [], uvs = [];
                        function interplolate(a, b, t) {
                            return (1 - t) * a + t * b;
                        }
                        // interpolates between sphere and plane
                        function interpolateVertex(u, v, t) {
                            var maxLng = Math.PI * 2;
                            var maxLat = Math.PI;
                            var radius = this.radius;
                            var sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat);
                            var sphereY = -radius * Math.cos(v * maxLat);
                            var sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat);
                            var planeX = u * radius * 2 - radius;
                            var planeY = v * radius * 2 - radius;
                            var planeZ = 0;
                            var x = interplolate(sphereX, planeX, t);
                            var y = interplolate(sphereY, planeY, t);
                            var z = interplolate(sphereZ, planeZ, t);
                            return new THREE.Vector3(x, y, z);
                        }
                        // http://mathworld.wolfram.com/MercatorProjection.html
                        // Mercator projection goes form +85.05 to -85.05 degrees
                        function interpolateUV(u, v, t) {
                            var lat = (v - 0.5) * 90 * 2 / 180 * Math.PI; //turn from 0-1 into lat in radians
                            var sin = Math.sin(lat);
                            var normalizedV = 0.5 + 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
                            return new THREE.Vector2(u, normalizedV); //interplolate(normalizedV1, v, t))
                        }
                        for (y = 0; y <= heightSegments; y++) {
                            var verticesRow = [];
                            var uvsRow = [];
                            for (x = 0; x <= widthSegments; x++) {
                                var u = x / widthSegments;
                                var v = y / heightSegments;
                                this.vertices.push(interpolateVertex.call(this, u, v, this.t));
                                uvsRow.push(interpolateUV.call(this, u, v, this.t));
                                verticesRow.push(this.vertices.length - 1);
                            }
                            vertices.push(verticesRow);
                            uvs.push(uvsRow);
                        }
                        //console.log(vertices, uvs);
                        for (y = 0; y < this.heightSegments; y++) {
                            for (x = 0; x < this.widthSegments; x++) {
                                var v1 = vertices[y][x + 1];
                                var v2 = vertices[y][x];
                                var v3 = vertices[y + 1][x];
                                var v4 = vertices[y + 1][x + 1];
                                var n1 = this.vertices[v1].clone().normalize();
                                var n2 = this.vertices[v2].clone().normalize();
                                var n3 = this.vertices[v3].clone().normalize();
                                var n4 = this.vertices[v4].clone().normalize();
                                var uv1 = uvs[y][x + 1].clone();
                                var uv2 = uvs[y][x].clone();
                                var uv3 = uvs[y + 1][x].clone();
                                var uv4 = uvs[y + 1][x + 1].clone();
                                var normals = [n1, n2, n3, n4];
                                this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals));
                                this.faceVertexUvs[0].push([uv1, uv2, uv3, uv4]);
                            }
                        }
                        this.computeCentroids();
                        this.computeFaceNormals();
                        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
                    };
                    MercartorSphere.prototype = Object.create(THREE.Geometry.prototype);
                    GlobeMap.MercartorSphere = MercartorSphere;
                };
                GlobeMap.prototype.getBingMapCanvas = function (resolution) {
                    var tileSize = 256;
                    var numSegments = Math.pow(2, resolution);
                    var numTiles = numSegments * numSegments;
                    var tilesLoaded = 0;
                    var canvasSize = tileSize * numSegments;
                    var canvas = $('<canvas/>').attr({ width: canvasSize, height: canvasSize });
                    var canvasElem = canvas.get(0);
                    var canvasContext = canvasElem.getContext("2d");
                    function generateQuads(res, quad) {
                        if (res <= resolution) {
                            if (res === resolution) {
                                loadTile(quad);
                            }
                            generateQuads(res + 1, quad + "0");
                            generateQuads(res + 1, quad + "1");
                            generateQuads(res + 1, quad + "2");
                            generateQuads(res + 1, quad + "3");
                        }
                    }
                    function loadTile(quad) {
                        var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}";
                        var numServers = 7;
                        var server = Math.round(Math.random() * numServers);
                        var language = (navigator["languages"] && navigator["languages"].length) ? navigator["languages"][0] : navigator.language;
                        var url = template.replace("{server}", server)
                            .replace("{quad}", quad)
                            .replace("{language}", language);
                        var coords = getCoords(quad);
                        //console.log(quad, coords.x, coords.y)
                        var tile = new Image();
                        tile.onload = function () {
                            tilesLoaded++;
                            canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize);
                            if (tilesLoaded === numTiles) {
                                canvas.trigger("ready", resolution);
                            }
                        };
                        // So the canvas doesn't get tainted
                        tile.crossOrigin = '';
                        tile.src = url;
                    }
                    function getCoords(quad) {
                        var x = 0;
                        var y = 0;
                        var last = quad.length - 1;
                        for (var i = last; i >= 0; i--) {
                            var chr = quad.charAt(i);
                            var pow = Math.pow(2, last - i);
                            if (chr === "1") {
                                x += pow;
                            }
                            else if (chr === "2") {
                                y += pow;
                            }
                            else if (chr === "3") {
                                x += pow;
                                y += pow;
                            }
                        }
                        return { x: x, y: y };
                    }
                    generateQuads(0, "");
                    return canvas;
                };
                GlobeMap.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                            preferredTypes: [
                                { geography: { address: true } },
                                { geography: { city: true } },
                                { geography: { continent: true } },
                                { geography: { country: true } },
                                { geography: { county: true } },
                                { geography: { place: true } },
                                { geography: { postalCode: true } },
                                { geography: { region: true } },
                                { geography: { stateOrProvince: true } },
                            ],
                        },
                        {
                            name: 'X',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Longitude',
                            description: 'Use to override the longitude of locations',
                            preferredTypes: [{ geography: { longitude: true } }],
                        },
                        {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Latitude',
                            description: 'Use to override the latitude of locations',
                            preferredTypes: [{ geography: { latitude: true } }],
                        },
                        {
                            name: 'Height',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Bar Height',
                        },
                        {
                            name: 'Heat',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Heat Intensity',
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    type: { formatting: { legendPosition: true } }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                                    type: { text: true }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                    type: { fillRule: {} },
                                    rule: {
                                        inputRole: 'Gradient',
                                        output: {
                                            property: 'fill',
                                            selector: ['Category'],
                                        },
                                    },
                                }
                            }
                        },
                        categoryLabels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                            },
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Height': { max: 1 }, 'Heat': { max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: 'Height' } },
                                        { bind: { to: 'Heat' } },
                                        { bind: { to: 'X' } },
                                        { bind: { to: 'Y' } },
                                    ]
                                },
                                rowCount: { preferred: { min: 2 } }
                            },
                        }],
                    sorting: {
                        custom: {},
                    }
                };
                return GlobeMap;
            })();
            samples.GlobeMap = GlobeMap;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
function loadGlobeMapLibs() {
    // include GlobeMapLibs.js
}
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var HelloIVisual = (function () {
                function HelloIVisual() {
                }
                HelloIVisual.converter = function (dataView) {
                    var viewModel = {
                        size: HelloIVisual.getSize(dataView),
                        color: HelloIVisual.getFill(dataView).solid.color,
                        text: HelloIVisual.DefaultText,
                        toolTipInfo: [{
                                displayName: 'Test',
                                value: '1...2....3... can you see me? I am sending random strings to the tooltip',
                            }],
                        selector: visuals.SelectionId.createNull()
                    };
                    var table = dataView.table;
                    if (!table)
                        return viewModel;
                    viewModel.text = table.rows[0][0];
                    if (dataView.categorical) {
                        viewModel.selector = dataView.categorical.categories[0].identity
                            ? visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[0])
                            : visuals.SelectionId.createNull();
                    }
                    return viewModel;
                };
                HelloIVisual.prototype.init = function (options) {
                    this.root = d3.select(options.element.get(0))
                        .append('svg')
                        .classed('hello', true);
                    this.svgText = this.root
                        .append('text')
                        .style('cursor', 'pointer')
                        .style('stroke', 'green')
                        .style('stroke-width', '0px')
                        .attr('text-anchor', 'middle');
                    this.selectiionManager = new SelectionManager({ hostServices: options.host });
                };
                HelloIVisual.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    var dataView = this.dataView = options.dataViews[0];
                    var viewport = options.viewport;
                    var viewModel = HelloIVisual.converter(dataView);
                    this.root.attr({
                        'height': viewport.height,
                        'width': viewport.width
                    });
                    var textProperties = {
                        fontFamily: 'tahoma',
                        fontSize: viewModel.size + 'px',
                        text: viewModel.text
                    };
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                    var selectionManager = this.selectiionManager;
                    this.svgText.style({
                        'fill': viewModel.color,
                        'font-size': textProperties.fontSize,
                        'font-family': textProperties.fontFamily,
                    }).attr({
                        'y': viewport.height / 2 + textHeight / 3 + 'px',
                        'x': viewport.width / 2,
                    }).text(viewModel.text)
                        .on('click', function () {
                        var _this = this;
                        selectionManager
                            .select(viewModel.selector)
                            .then(function (ids) { return d3.select(_this).style('stroke-width', ids.length > 0 ? '2px' : '0px'); });
                    })
                        .data([viewModel]);
                    visuals.TooltipManager.addTooltip(this.svgText, function (tooltipEvent) { return tooltipEvent.data.toolTipInfo; });
                };
                HelloIVisual.getFill = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                var fill = general['fill'];
                                if (fill)
                                    return fill;
                            }
                        }
                    }
                    return { solid: { color: 'red' } };
                };
                HelloIVisual.getSize = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                var size = general['size'];
                                if (size)
                                    return size;
                            }
                        }
                    }
                    return 100;
                };
                HelloIVisual.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    var dataView = this.dataView;
                    switch (options.objectName) {
                        case 'general':
                            var general = {
                                objectName: 'general',
                                displayName: 'General',
                                selector: null,
                                properties: {
                                    fill: HelloIVisual.getFill(dataView),
                                    size: HelloIVisual.getSize(dataView)
                                }
                            };
                            instances.push(general);
                            break;
                    }
                    return instances;
                };
                HelloIVisual.prototype.destroy = function () {
                    this.root = null;
                };
                HelloIVisual.capabilities = {
                    dataRoles: [{
                            name: 'Values',
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }],
                    dataViewMappings: [{
                            table: {
                                rows: {
                                    for: { in: 'Values' },
                                    dataReductionAlgorithm: { window: { count: 100 } }
                                },
                                rowCount: { preferred: { min: 1 } }
                            },
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                fill: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Fill'
                                },
                                size: {
                                    type: { numeric: true },
                                    displayName: 'Size'
                                }
                            },
                        }
                    },
                };
                HelloIVisual.DefaultText = 'Invalid DV';
                return HelloIVisual;
            })();
            samples.HelloIVisual = HelloIVisual;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            var HistogramChartWarning = (function () {
                function HistogramChartWarning(message) {
                    this.message = message;
                }
                Object.defineProperty(HistogramChartWarning.prototype, "code", {
                    get: function () {
                        return "BulletChartWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                HistogramChartWarning.prototype.getMessages = function (resourceProvider) {
                    return {
                        message: this.message,
                        title: resourceProvider.get(""),
                        detail: resourceProvider.get("")
                    };
                };
                HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big";
                return HistogramChartWarning;
            })();
            samples.HistogramChartWarning = HistogramChartWarning;
            var Histogram = (function () {
                function Histogram(histogramConstructorOptions) {
                    this.ColumnPadding = 1;
                    this.MinColumnHeight = 1;
                    this.MinOpacity = 0.3;
                    this.MaxOpacity = 1;
                    this.NumberOfLabelsOnAxisY = 5;
                    this.MinNumberOfBins = 0;
                    this.MaxNumberOfBins = 100;
                    this.MinPrecision = 0;
                    this.MaxPrecision = 17; // max number of decimals in float
                    this.TooltipDisplayName = "Range";
                    this.SeparatorNumbers = ", ";
                    this.LegendSize = 50;
                    this.AxisSize = 30;
                    this.ExcludeBrackets = {
                        left: "(",
                        right: ")"
                    };
                    this.IncludeBrackets = {
                        left: "[",
                        right: "]"
                    };
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    };
                    this.durationAnimations = 200;
                    if (histogramConstructorOptions) {
                        if (histogramConstructorOptions.svg) {
                            this.svg = histogramConstructorOptions.svg;
                        }
                        if (histogramConstructorOptions.animator) {
                            this.animator = histogramConstructorOptions.animator;
                        }
                        this.margin = histogramConstructorOptions.margin || this.margin;
                    }
                }
                Object.defineProperty(Histogram.prototype, "columnsSelection", {
                    get: function () {
                        return this.main.select(Histogram.Columns.selector)
                            .selectAll(Histogram.Column.selector);
                    },
                    enumerable: true,
                    configurable: true
                });
                Histogram.prototype.init = function (visualsOptions) {
                    this.hostService = visualsOptions.host;
                    if (this.svg) {
                        this.root = this.svg;
                    }
                    else {
                        this.root = d3.select(visualsOptions.element.get(0))
                            .append("svg");
                    }
                    var style = visualsOptions.style;
                    this.colors = style && style.colorPalette
                        ? style.colorPalette.dataColors
                        : new visuals.DataColorPalette();
                    this.root.classed(Histogram.ClassName, true);
                    this.main = this.root.append("g");
                    this.axes = this.main
                        .append("g")
                        .classed(Histogram.Axes["class"], true);
                    this.axisX = this.axes
                        .append("g")
                        .classed(Histogram.Axis["class"], true);
                    this.axisY = this.axes
                        .append("g")
                        .classed(Histogram.Axis["class"], true);
                    this.legend = this.main
                        .append("g")
                        .classed(Histogram.Legends["class"], true);
                    this.columns = this.main
                        .append("g")
                        .classed(Histogram.Columns["class"], true);
                    this.selectionManager = new SelectionManager({ hostServices: visualsOptions.host });
                };
                Histogram.prototype.converter = function (dataView) {
                    var _this = this;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !(dataView.categorical.categories[0].values.length > 0)) {
                        return null;
                    }
                    var settings, histogramLayout, values, numericalValues = [], data, xScale, yScale, valueFormatter, frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0;
                    if (dataView.categorical.values &&
                        dataView.categorical.values[0] &&
                        dataView.categorical.values[0].values) {
                        frequencies = dataView.categorical.values[0].values;
                    }
                    if (dataView.categorical.categories[0].identity
                        && dataView.categorical.categories[0].identity.length > 0) {
                        identities = dataView.categorical.categories[0].identity;
                    }
                    settings = this.parseSettings(dataView);
                    if (!settings) {
                        return null;
                    }
                    values = this.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities);
                    values.forEach(function (value) {
                        numericalValues.push(value.value);
                        sumFrequency += value.frequency;
                    });
                    histogramLayout = d3.layout.histogram();
                    if (settings.bins && settings.bins > this.MinNumberOfBins) {
                        histogramLayout = histogramLayout.bins(settings.bins);
                    }
                    data = histogramLayout.frequency(settings.frequency)(numericalValues);
                    data.forEach(function (bin, index) {
                        var filteredValues, frequency;
                        filteredValues = values.filter(function (value) {
                            return _this.isValueContainedInRange(value, bin, index);
                        });
                        frequency = filteredValues.reduce(function (previousValue, currentValue) {
                            return previousValue + currentValue.frequency;
                        }, 0);
                        bin.y = settings.frequency
                            ? frequency
                            : frequency / sumFrequency;
                        shiftByValues += bin.length;
                    });
                    xScale = d3.scale.linear()
                        .domain([
                        d3.min(data, function (item) { return d3.min(item); }),
                        d3.max(data, function (item) { return d3.max(item); })
                    ])
                        .range([0, this.viewport.width - this.LegendSize - this.AxisSize]);
                    yScale = d3.scale.linear()
                        .domain([
                        0,
                        d3.max(data, function (item) { return item.y; })
                    ])
                        .range([this.viewport.height - this.LegendSize, 0]);
                    valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties["general"]["formatString"]),
                        value: values[0].value,
                        value2: values[values.length - 1].value,
                        precision: settings.precision
                    });
                    return {
                        xScale: xScale,
                        yScale: yScale,
                        settings: settings,
                        data: this.getData(values, numericalValues, data, settings, valueFormatter),
                        formatter: valueFormatter
                    };
                };
                Histogram.prototype.getValuesByFrequencies = function (sourceValues, frequencies, identities) {
                    var values = [];
                    sourceValues.forEach(function (item, index) {
                        var frequency = 1, value = Number(item);
                        value = isNaN(value) ? 0 : value;
                        if (frequencies
                            && frequencies[index]
                            && !isNaN(frequencies[index])
                            && frequencies[index] > 1) {
                            frequency = frequencies[index];
                        }
                        values.push({
                            value: value,
                            frequency: frequency,
                            selectionId: visuals.SelectionId.createWithId(identities[index])
                        });
                    });
                    return values;
                };
                Histogram.prototype.getData = function (values, numericalValues, data, settings, valueFormatter) {
                    var _this = this;
                    var minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues);
                    return data.map(function (bin, index) {
                        bin.range = _this.getRange(minValue, maxValue, bin.dx, index);
                        bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, index === 0, valueFormatter);
                        bin.selectionIds = _this.getSelectionIds(values, bin, index);
                        return bin;
                    });
                };
                Histogram.prototype.getRange = function (minValue, maxValue, step, index) {
                    var leftBorder = minValue + index * step, rightBorder = leftBorder + step;
                    return [leftBorder, rightBorder];
                };
                Histogram.prototype.getTooltipData = function (value, range, settings, includeLeftBorder, valueFormatter) {
                    return [{
                            displayName: this.getLegendText(settings),
                            value: valueFormatter.format(value)
                        }, {
                            displayName: this.TooltipDisplayName,
                            value: this.rangeToString(range, includeLeftBorder, valueFormatter)
                        }];
                };
                Histogram.prototype.getSelectionIds = function (values, bin, index) {
                    var _this = this;
                    var selectionIds = [];
                    values.forEach(function (value) {
                        if (_this.isValueContainedInRange(value, bin, index)) {
                            selectionIds.push(value.selectionId);
                        }
                    });
                    return selectionIds;
                };
                Histogram.prototype.isValueContainedInRange = function (value, bin, index) {
                    return ((index === 0 && value.value >= bin.x) || (value.value > bin.x)) && value.value <= bin.x + bin.dx;
                };
                Histogram.prototype.parseSettings = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.columns[0]) {
                        return null;
                    }
                    var histogramSettings = {}, objects, colorHelper;
                    colorHelper = new visuals.ColorHelper(this.colors, Histogram.Properties["dataPoint"]["fill"], Histogram.DefaultHistogramSettings.fillColor);
                    histogramSettings.displayName = Histogram.DefaultHistogramSettings.displayName;
                    histogramSettings.fillColor = Histogram.DefaultHistogramSettings.fillColor;
                    histogramSettings.bins = Histogram.DefaultHistogramSettings.bins;
                    histogramSettings.frequency = Histogram.DefaultHistogramSettings.frequency;
                    histogramSettings.displayName =
                        dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName;
                    objects = this.getObjectsFromDataView(dataView);
                    if (objects) {
                        histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, "");
                        histogramSettings.bins = this.getBins(objects);
                        histogramSettings.frequency = this.getFrequency(objects);
                        histogramSettings.precision = this.getPrecision(objects);
                    }
                    return histogramSettings;
                };
                Histogram.prototype.getBins = function (objects) {
                    var binsNumber;
                    binsNumber = Number(powerbi.DataViewObjects.getValue(objects, Histogram.Properties["general"]["bins"], Histogram.DefaultHistogramSettings.bins));
                    if (!binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins) {
                        return Histogram.DefaultHistogramSettings.bins;
                    }
                    if (binsNumber > this.MaxNumberOfBins) {
                        return this.MaxNumberOfBins;
                    }
                    return binsNumber;
                };
                Histogram.prototype.getFrequency = function (objects) {
                    return powerbi.DataViewObjects.getValue(objects, Histogram.Properties["general"]["frequency"], Histogram.DefaultHistogramSettings.frequency);
                };
                Histogram.prototype.getPrecision = function (objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties["labels"]["labelPrecision"], Histogram.DefaultHistogramSettings.precision);
                    if (precision <= this.MinPrecision) {
                        return this.MinPrecision;
                    }
                    if (precision >= this.MaxPrecision) {
                        return this.MaxPrecision;
                    }
                    return precision;
                };
                Histogram.prototype.validateData = function (data) {
                    if (data && data.data.some(function (x) { return x.range.some(function (x) { return isNaN(x) || x === Infinity || x === -Infinity; }); })) {
                        this.hostService.setWarnings([new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues)]);
                        return false;
                    }
                    return true;
                };
                Histogram.prototype.update = function (visualUpdateOptions) {
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.dataViews ||
                        !visualUpdateOptions.dataViews[0]) {
                        return;
                    }
                    var dataView = visualUpdateOptions.dataViews[0];
                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
                    this.setSize(visualUpdateOptions.viewport);
                    this.histogramDataView = this.converter(dataView);
                    if (!this.validateData(this.histogramDataView)) {
                        this.histogramDataView.data = [];
                    }
                    this.render();
                };
                Histogram.prototype.setSize = function (viewport) {
                    var height, width;
                    height = viewport.height -
                        this.margin.top -
                        this.margin.bottom;
                    width = viewport.width -
                        this.margin.left -
                        this.margin.right;
                    this.viewport = {
                        height: height,
                        width: width
                    };
                    this.updateElements(viewport.height, viewport.width);
                };
                Histogram.prototype.updateElements = function (height, width) {
                    var shiftToRight = this.margin.left + this.LegendSize;
                    this.root.attr({
                        "height": height,
                        "width": width
                    });
                    this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.legend.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.columns.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0));
                    this.axes.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0));
                    this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.LegendSize));
                };
                Histogram.prototype.render = function () {
                    if (!this.histogramDataView || !this.histogramDataView.settings) {
                        return;
                    }
                    this.renderAxes();
                    var columnsSelection = this.renderColumns();
                    this.renderLegend();
                    this.bindSelectionHandler(columnsSelection);
                };
                Histogram.prototype.renderColumns = function () {
                    var _this = this;
                    var data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length, widthOfColumn, updateColumnsSelection;
                    widthOfColumn = countOfValues && ((this.viewport.width - this.AxisSize - this.LegendSize) / countOfValues - this.ColumnPadding);
                    if (widthOfColumn < 0) {
                        widthOfColumn = 0;
                    }
                    updateColumnsSelection = this.columnsSelection.data(data);
                    updateColumnsSelection
                        .enter()
                        .append("svg:rect");
                    updateColumnsSelection
                        .attr("x", this.ColumnPadding / 2)
                        .attr("width", widthOfColumn)
                        .attr("height", function (item) { return _this.getColumnHeight(item, yScale); })
                        .style("fill", this.histogramDataView.settings.fillColor)
                        .attr("class", Histogram.Column["class"])
                        .attr("transform", function (item, index) { return visuals.SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5); });
                    if (countOfValues) {
                        //if data is empty, it throws for some reason
                        updateColumnsSelection.classed(Histogram.Column["class"]);
                    }
                    updateColumnsSelection.exit().remove();
                    this.renderTooltip(updateColumnsSelection);
                    return updateColumnsSelection;
                };
                Histogram.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                };
                Histogram.prototype.getColumnHeight = function (column, y) {
                    var height = this.viewport.height - this.LegendSize - y(column.y);
                    return height > 0 ? height : this.MinColumnHeight;
                };
                Histogram.prototype.renderAxes = function () {
                    var xScale = this.histogramDataView.xScale, yScale = this.histogramDataView.yScale, valueFormatter = this.histogramDataView.formatter, xAxis, yAxis;
                    xAxis = d3.svg.axis()
                        .scale(xScale)
                        .orient("bottom")
                        .tickValues(this.rangesToArray(this.histogramDataView.data))
                        .tickFormat(function (item) { return valueFormatter.format(item); });
                    yAxis = d3.svg.axis()
                        .scale(yScale)
                        .orient("left")
                        .ticks(this.NumberOfLabelsOnAxisY);
                    this.axisX.call(xAxis);
                    this.axisY.call(yAxis);
                };
                Histogram.prototype.rangesToArray = function (data) {
                    return data.reduce(function (previousValue, currentValue, index) {
                        var range;
                        range = index === 0
                            ? currentValue.range
                            : currentValue.range.slice(1);
                        return previousValue.concat(range);
                    }, []);
                };
                Histogram.prototype.rangeToString = function (range, includeLeftBorder, valueFormatter) {
                    var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
                    leftBracket = includeLeftBorder
                        ? this.IncludeBrackets.left
                        : this.ExcludeBrackets.left;
                    return "" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;
                };
                Histogram.prototype.renderLegend = function () {
                    var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);
                    legendElements = this.main
                        .select(Histogram.Legends.selector)
                        .selectAll(Histogram.Legend.selector);
                    legendSelection = legendElements.data(datalegends);
                    legendSelection
                        .enter()
                        .append("svg:text");
                    legendSelection
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("dx", function (item) { return item.dx; })
                        .attr("dy", function (item) { return item.dy; })
                        .attr("transform", function (item) { return item.transform; })
                        .attr("class", Histogram.Legend["class"])
                        .text(function (item) { return item.text; })
                        .classed(Histogram.Legend["class"], true);
                    legendSelection
                        .exit()
                        .remove();
                };
                Histogram.prototype.getDataLegends = function (settings) {
                    var bottomLegendText = this.getLegendText(settings);
                    return [{
                            transform: visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
                            text: settings.displayName,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(0, this.viewport.height / 2, 0, 0, 270),
                            text: bottomLegendText,
                            dx: "3em"
                        }];
                };
                Histogram.prototype.getLegendText = function (settings) {
                    return settings.frequency
                        ? Histogram.FrequencyText
                        : Histogram.DensityText;
                };
                Histogram.prototype.bindSelectionHandler = function (columnsSelection) {
                    var _this = this;
                    this.setSelection(columnsSelection);
                    columnsSelection.on("click", function (data) {
                        _this.selectionManager.clear();
                        data.selectionIds.forEach(function (selectionId) {
                            _this.selectionManager.select(selectionId, true).then(function (selectionIds) {
                                if (selectionIds.length > 0) {
                                    _this.setSelection(columnsSelection, data);
                                }
                                else {
                                    _this.setSelection(columnsSelection);
                                }
                            });
                        });
                        d3.event.stopPropagation();
                    });
                    this.root.on("click", function () {
                        _this.selectionManager.clear();
                        _this.setSelection(columnsSelection);
                    });
                };
                Histogram.prototype.setSelection = function (columnsSelection, data) {
                    columnsSelection.transition()
                        .duration(this.durationAnimations)
                        .style("fill-opacity", this.MaxOpacity);
                    if (!data) {
                        return;
                    }
                    columnsSelection
                        .filter(function (columnSelection) {
                        return columnSelection !== data;
                    })
                        .transition()
                        .duration(this.durationAnimations)
                        .style("fill-opacity", this.MinOpacity);
                };
                Histogram.prototype.enumerateObjectInstances = function (options) {
                    var instances = [], settings;
                    if (!this.histogramDataView ||
                        !this.histogramDataView.settings) {
                        return instances;
                    }
                    settings = this.histogramDataView.settings;
                    switch (options.objectName) {
                        case "general": {
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    bins: settings.bins,
                                    frequency: settings.frequency
                                }
                            };
                            instances.push(general);
                            break;
                        }
                        case "dataPoint": {
                            var dataPoint = {
                                objectName: "dataPoint",
                                displayName: "dataPoint",
                                selector: null,
                                properties: {
                                    fill: settings.fillColor
                                }
                            };
                            instances.push(dataPoint);
                            break;
                        }
                        case "labels": {
                            var labels = {
                                objectName: "labels",
                                displayName: "labels",
                                selector: null,
                                properties: {
                                    labelPrecision: settings.precision
                                }
                            };
                            instances.push(labels);
                            break;
                        }
                    }
                    return instances;
                };
                Histogram.prototype.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                Histogram.prototype.destroy = function () {
                    this.root = null;
                };
                Histogram.ClassName = "histogram";
                Histogram.FrequencyText = "Frequency";
                Histogram.DensityText = "Density";
                Histogram.Properties = {
                    general: {
                        bins: {
                            objectName: "general",
                            propertyName: "bins"
                        },
                        frequency: {
                            objectName: "general",
                            propertyName: "frequency"
                        },
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    labels: {
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        }
                    }
                };
                Histogram.DefaultHistogramSettings = {
                    frequency: true,
                    displayName: "Histogram",
                    bins: null,
                    fillColor: "cadetblue",
                    precision: 2
                };
                Histogram.Axes = {
                    "class": "axes",
                    selector: ".axes"
                };
                Histogram.Axis = {
                    "class": "axis",
                    selector: ".axis"
                };
                Histogram.Columns = {
                    "class": "columns",
                    selector: ".columns"
                };
                Histogram.Column = {
                    "class": "column",
                    selector: ".column"
                };
                Histogram.Legends = {
                    "class": "legends",
                    selector: ".legends"
                };
                Histogram.Legend = {
                    "class": "legend",
                    selector: ".legend"
                };
                Histogram.capabilities = {
                    dataRoles: [{
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        }, {
                            name: "Frequency",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Frequency"
                        }],
                    dataViewMappings: [{
                            conditions: [{ "Values": { min: 1, max: 1 }, "Frequency": { min: 0, max: 1 } }],
                            categorical: {
                                categories: {
                                    bind: { to: "Values" },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: { for: { in: "Frequency" } }
                            }
                        }],
                    sorting: {
                        implicit: {
                            clauses: [{ role: "Values", direction: 1 /*SortDirection.Ascending*/ }] //Constant SortDirection.Ascending currently is not supported on the msit
                        }
                    },
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: { type: { formatting: { formatString: true } } },
                                bins: {
                                    displayName: "Bins",
                                    type: { numeric: true }
                                },
                                frequency: {
                                    displayName: "Frequency",
                                    type: { bool: true }
                                }
                            },
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            properties: {
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                return Histogram;
            })();
            samples.Histogram = Histogram;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var MekkoDataWrapper = (function () {
                function MekkoDataWrapper(columnChartData, isScalar) {
                    this.data = columnChartData;
                    this.isScalar = isScalar;
                }
                MekkoDataWrapper.prototype.lookupXValue = function (index, type) {
                    debug.assertValue(this.data, 'this.data');
                    var isDateTime = visuals.AxisHelper.isDateTime(type);
                    if (isDateTime && this.isScalar) {
                        return new Date(index);
                    }
                    var data = this.data;
                    if (type.text) {
                        debug.assert(index < data.categories.length, 'category index out of range');
                        return data.categories[index];
                    }
                    else {
                        var firstSeries = data.series[0];
                        if (firstSeries) {
                            var seriesValues = firstSeries.data;
                            if (seriesValues) {
                                if (this.data.hasHighlights) {
                                    index = index * 2;
                                }
                                var dataPoint = seriesValues[index];
                                if (dataPoint) {
                                    if (isDateTime) {
                                        return new Date(dataPoint.categoryValue);
                                    }
                                    return dataPoint.categoryValue;
                                }
                            }
                        }
                    }
                    return index;
                };
                return MekkoDataWrapper;
            })();
            samples.MekkoDataWrapper = MekkoDataWrapper;
            var MekkoColumnChartStrategy = (function () {
                function MekkoColumnChartStrategy() {
                }
                MekkoColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                    this.graphicsContext = columnChartProps;
                    this.margin = columnChartProps.margin;
                    this.width = this.graphicsContext.width;
                    this.height = this.graphicsContext.height;
                    this.categoryLayout = columnChartProps.layout;
                    this.animator = columnChartProps.animator;
                    this.interactivityService = columnChartProps.interactivityService;
                    this.viewportHeight = columnChartProps.viewportHeight;
                    this.viewportWidth = columnChartProps.viewportWidth;
                };
                MekkoColumnChartStrategy.prototype.setData = function (data) {
                    this.data = data;
                };
                MekkoColumnChartStrategy.createFormatter = function (scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                    if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
                    var formatter;
                    if (dataType.dateTime) {
                        if (isScalar) {
                            var value = new Date(scaleDomain[0]);
                            var value2 = new Date(scaleDomain[1]);
                            // datetime with only one value needs to pass the same value
                            // (from the original dataDomain value, not the adjusted scaleDomain)
                            // so formatting works correctly.
                            if (bestTickCount === 1)
                                value = value2 = new Date(dataDomain[0]);
                            formatter = visuals.valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });
                        }
                        else {
                            if (getValueFn == null) {
                                debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');
                            }
                            var minDate = getValueFn(0, dataType);
                            var maxDate = getValueFn(scaleDomain.length - 1, dataType);
                            formatter = visuals.valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });
                        }
                    }
                    else {
                        if (getValueFn == null && !isScalar) {
                            debug.assertFail('getValueFn must be supplied for ordinal tickValues');
                        }
                        if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                            var domainMin = tickValues[1] - tickValues[0];
                            var domainMax = 0; //force tickInterval to be used with display units
                            formatter = visuals.valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });
                        }
                        else {
                            // do not use display units, just the basic value formatter
                            // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
                            formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                        }
                    }
                    return formatter;
                };
                /**
                 * Format the linear tick labels or the category labels.
                 */
                MekkoColumnChartStrategy.formatAxisTickValues = function (axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                    var formattedTickValues = [];
                    if (formatter) {
                        // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.
                        if (getValueFn && !(dataType.numeric && isScalar)) {
                            axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
                            formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
                        }
                        else {
                            axis.tickFormat(function (d) { return formatter.format(d); });
                            formattedTickValues = tickValues.map(function (d) { return formatter.format(d); });
                        }
                    }
                    else {
                        formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
                    }
                    return formattedTickValues;
                };
                /**
                 * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
                 * @param options The properties used to create the axis.
                 */
                MekkoColumnChartStrategy.prototype.createAxis = function (options) {
                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
                    getValueFn = options.getValueFn, categoryThickness = options.categoryThickness;
                    var formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp);
                    var dataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
                    var isLogScaleAllowed = visuals.AxisHelper.isLogScalePossible(dataDomain, dataType);
                    var scale = d3.scale.linear();
                    var scaleDomain = [0, 1];
                    var bestTickCount = dataDomain.length || 1;
                    var borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings);
                    var chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
                    if (chartWidth < MekkoChart.MinOrdinalRectThickness) {
                        chartWidth = MekkoChart.MinOrdinalRectThickness;
                    }
                    scale.domain(scaleDomain)
                        .range([0, chartWidth]);
                    var tickValues = dataDomain;
                    var formatter = MekkoColumnChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits);
                    // sets default orientation only, cartesianChart will fix y2 for comboChart
                    // tickSize(pixelSpan) is used to create gridLines
                    var axis = d3.svg.axis()
                        .scale(scale)
                        .tickSize(6, 0)
                        .orient(isVertical ? 'left' : 'bottom')
                        .ticks(bestTickCount)
                        .tickValues(dataDomain);
                    var formattedTickValues = [];
                    if (metaDataColumn) {
                        formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);
                    }
                    var xLabelMaxWidth;
                    // Use category layout of labels if specified, otherwise use scalar layout of labels
                    if (!isScalar && categoryThickness) {
                        xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianChart.TickLabelPadding * 2);
                    }
                    else {
                        // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan
                        // When there is > 1 ticks then we need to +1 so that their widths don't overlap
                        // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.
                        var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                        xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;
                        xLabelMaxWidth = Math.max(1, xLabelMaxWidth - visuals.CartesianChart.TickLabelPadding * 2);
                    }
                    return {
                        scale: scale,
                        axis: axis,
                        formatter: formatter,
                        values: formattedTickValues,
                        axisType: dataType,
                        axisLabel: null,
                        isCategoryAxis: isCategoryAxis,
                        xLabelMaxWidth: xLabelMaxWidth,
                        categoryThickness: categoryThickness,
                        outerPadding: outerPadding,
                        usingDefaultDomain: false,
                        isLogScaleAllowed: isLogScaleAllowed
                    };
                };
                MekkoColumnChartStrategy.prototype.getCategoryAxis = function (data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
                    var categoryThickness = layout.categoryThickness;
                    var isScalar = layout.isScalar;
                    var outerPaddingRatio = layout.outerPaddingRatio;
                    var dw = new MekkoDataWrapper(data, isScalar);
                    var domain = [];
                    if (data.series &&
                        (data.series.length > 0) &&
                        data.series[0].data &&
                        (data.series[0].data.length > 0)) {
                        var domainDoubles = data.series[0].data.map(function (item) {
                            return item.originalPosition + (item.value / 2);
                        });
                        domain = domainDoubles.filter(function (item, pos) {
                            return domainDoubles.indexOf(item) === pos;
                        });
                    }
                    var axisProperties = this.createAxis({
                        pixelSpan: size,
                        dataDomain: domain,
                        metaDataColumn: data.categoryMetadata,
                        formatStringProp: visuals.columnChartProps.general.formatString,
                        outerPadding: categoryThickness * outerPaddingRatio,
                        isCategoryAxis: true,
                        isScalar: isScalar,
                        isVertical: isVertical,
                        categoryThickness: categoryThickness,
                        useTickIntervalForDisplayUnits: true,
                        getValueFn: function (index, type) {
                            var domainIndex = domain.indexOf(index);
                            var value = dw.lookupXValue(domainIndex, type);
                            return value;
                        },
                        scaleType: axisScaleType,
                        borderSettings: data.borderSettings
                    });
                    // intentionally updating the input layout by ref
                    layout.categoryThickness = axisProperties.categoryThickness;
                    return axisProperties;
                };
                MekkoColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
                    var width = this.width;
                    var forcedXMin, forcedXMax;
                    if (forcedXDomain && forcedXDomain.length === 2) {
                        forcedXMin = forcedXDomain[0];
                        forcedXMax = forcedXDomain[1];
                    }
                    var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType);
                    return props;
                };
                MekkoColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
                    var height = this.viewportHeight;
                    var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
                    var valueDomainArr = [valueDomain.min, valueDomain.max];
                    var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr);
                    var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
                    var metadataColumn = this.data.valuesMetadata[0];
                    var formatString = is100Pct ?
                        this.graphicsContext.hostService.getLocalizedString('Percentage')
                        : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                    var mekkoMekkoCreateAxisOptions = {
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: metadataColumn,
                        formatString: formatString,
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: true,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: false,
                        scaleType: axisScaleType,
                        axisDisplayUnits: 0,
                        axisPrecision: 0,
                        is100Pct: is100Pct,
                        shouldClamp: shouldClamp,
                        formatStringProp: undefined,
                    };
                    this.yProps = visuals.AxisHelper.createAxis(mekkoMekkoCreateAxisOptions);
                    return this.yProps;
                };
                MekkoColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                    var data = this.data;
                    debug.assertValue(data, 'data should not be null or undefined');
                    this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                    var axisOptions = {
                        columnWidth: 0,
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin,
                    };
                    var stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions);
                    //var dataLabelSettings = data.labelSettings;
                    var labelDataPoints = this.createMekkoLabelDataPoints();
                    var result;
                    var shapes;
                    var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    if (this.animator && useAnimation) {
                        result = this.animator.animate({
                            viewModel: data,
                            series: series,
                            layout: stackedColumnLayout,
                            itemCS: MekkoColumnChartStrategy.classes.item,
                            interactivityService: this.interactivityService,
                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                            viewPort: { height: this.height, width: this.width },
                        });
                        shapes = result.shapes;
                    }
                    if (!this.animator || !useAnimation || result.failed) {
                        shapes = MekkoColumnChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                    }
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                    return {
                        shapesSelection: shapes,
                        viewport: { height: this.height, width: this.width },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints,
                    };
                };
                MekkoColumnChartStrategy.drawDefaultShapes = function (data, series, layout, itemCS, filterZeros, hasSelection) {
                    // We filter out invisible (0, null, etc.) values from the dataset
                    // based on whether animations are enabled or not, Dashboard and
                    // Exploration mode, respectively.
                    var rectName = 'rect';
                    filterZeros = false;
                    var dataSelector;
                    if (filterZeros) {
                        dataSelector = function (d) {
                            var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
                            return filteredData;
                        };
                    }
                    else {
                        dataSelector = function (d) { return d.data; };
                    }
                    var shapeSelection = series.selectAll(itemCS.selector);
                    var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
                    shapes.enter()
                        .append(rectName)
                        .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                    shapes
                        .style("fill", function (d) { return d.color; })
                        .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })
                        .attr(layout.shapeLayout);
                    shapes
                        .exit()
                        .remove();
                    var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector);
                    var borders = borderSelection.data(dataSelector, function (d) { return d.key; });
                    var borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
                    borders.enter()
                        .append(rectName)
                        .classed(MekkoColumnChart.BorderClass.class, true);
                    borders
                        .style("fill", function (d) { return borderColor; })
                        .style("fill-opacity", function (d) {
                        return data.hasHighlights ? visuals.ColumnUtil.DimmedOpacity : visuals.ColumnUtil.DefaultOpacity;
                    })
                        .attr(layout.shapeBorder);
                    borders
                        .exit()
                        .remove();
                    return shapes;
                };
                MekkoColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                    this.moveHandle(selectedColumnIndex);
                };
                MekkoColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                };
                /**
                 * Get the chart's columns centers (x value).
                 */
                MekkoColumnChartStrategy.prototype.getColumnsCenters = function () {
                    var _this = this;
                    if (!this.columnsCenters) {
                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        // use the axis scale and first series data to get category centers
                        if (this.data.series.length > 0) {
                            var xScaleOffset = 0;
                            if (!this.categoryLayout.isScalar) {
                                xScaleOffset = categoryWidth / 2;
                            }
                            var firstSeries = this.data.series[0];
                            if (firstSeries &&
                                firstSeries.data) {
                                this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset; });
                            }
                        }
                    }
                    return this.columnsCenters;
                };
                MekkoColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                    var columnCenters = this.getColumnsCenters();
                    var x = columnCenters[selectedColumnIndex];
                    if (!this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                        handle.append('line')
                            .classed('interactive-hover-line', true)
                            .attr({
                            x1: x,
                            x2: x,
                            y1: 0,
                            y2: this.height,
                        });
                        handle.append('circle')
                            .attr({
                            cx: x,
                            cy: this.height,
                            r: '6px',
                        })
                            .classed('drag-handle', true);
                    }
                    else {
                        var handle = this.columnSelectionLineHandle;
                        handle.select('line').attr({ x1: x, x2: x });
                        handle.select('circle').attr({ cx: x });
                    }
                };
                MekkoColumnChartStrategy.getLayout = function (data, axisOptions) {
                    var xScale = axisOptions.xScale;
                    var yScale = axisOptions.yScale;
                    var scaledY0 = yScale(0);
                    var scaledX0 = xScale(0);
                    var borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings);
                    var columnWidthScale = function (d) {
                        var value = visuals.AxisHelper.diffScaled(xScale, d.value, 0);
                        return value;
                    };
                    var columnStart = function (d) {
                        var value = scaledX0 +
                            visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) +
                            borderWidth * d.categoryIndex;
                        return value;
                    };
                    var borderStart = function (d) {
                        var value = scaledX0 +
                            visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) +
                            visuals.AxisHelper.diffScaled(xScale, d.value, 0) +
                            borderWidth * d.categoryIndex;
                        return value;
                    };
                    return {
                        shapeLayout: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                        },
                        shapeBorder: {
                            width: function (d) { return borderWidth; },
                            x: borderStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute); }
                        },
                        zeroShapeLayout: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute); },
                            height: function (d) { return 0; }
                        },
                        shapeXAxis: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                        },
                    };
                };
                MekkoColumnChartStrategy.prototype.createMekkoLabelDataPoints = function () {
                    var labelDataPoints = [];
                    var data = this.data;
                    var series = data.series;
                    var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                    var shapeLayout = this.layout.shapeLayout;
                    for (var i = 0, ilen = series.length; i < ilen; i++) {
                        var currentSeries = series[i];
                        var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (!labelSettings.show) {
                            continue;
                        }
                        if (!currentSeries.data) {
                            continue;
                        }
                        var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                        for (var j = 0; j < currentSeries.data.length; j++) {
                            var dataPoint = currentSeries.data[j];
                            if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                                continue;
                            }
                            // Calculate parent rectangle
                            var parentRect = {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint),
                            };
                            // Calculate label text
                            var formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
                            var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                            var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.valueAbsolute));
                            // Calculate text size
                            var properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                            var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                            labelDataPoints.push({
                                isPreferred: true,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight,
                                },
                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                                insideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                                isParentRect: true,
                                parentShape: {
                                    rect: parentRect,
                                    orientation: 1,
                                    validPositions: MekkoColumnChartStrategy.validLabelPositions,
                                },
                                identity: dataPoint.identity,
                                parentType: 1,
                            });
                        }
                    }
                    return labelDataPoints;
                };
                MekkoColumnChartStrategy.classes = {
                    item: createClassAndSelector('column'),
                    highlightItem: createClassAndSelector('highlightColumn')
                };
                MekkoColumnChartStrategy.validLabelPositions = [1];
                return MekkoColumnChartStrategy;
            })();
            samples.MekkoColumnChartStrategy = MekkoColumnChartStrategy;
            /**
             * Renders a data series as a cartestian visual.
             */
            var MekkoChart = (function () {
                function MekkoChart(options) {
                    this.isScrollable = false;
                    if (options) {
                        this.type = options.chartType;
                        this.seriesLabelFormattingEnabled = options.seriesLabelFormattingEnabled;
                        if (options.isScrollable)
                            this.isScrollable = options.isScrollable;
                        this.animator = options.animator;
                        if (options.cartesianSmallViewPortProperties) {
                            this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
                        }
                        if (options.behavior) {
                            this.behavior = options.behavior;
                        }
                    }
                    else {
                        this.behavior = new MekkoChartBehavior([new visuals.ColumnChartWebBehavior()]);
                    }
                }
                MekkoChart.prototype.init = function (options) {
                    this.visualInitOptions = options;
                    this.layers = [];
                    var element = this.element = options.element;
                    var viewport = this.currentViewport = options.viewport;
                    this.hostServices = options.host;
                    this.brush = d3.svg.brush();
                    element.addClass(MekkoChart.ClassName);
                    this.margin = {
                        top: 1,
                        right: 1,
                        bottom: 1,
                        left: 1
                    };
                    this.yAxisOrientation = visuals.yAxisPosition.left;
                    this.adjustMargins(viewport);
                    this.sharedColorPalette = new visuals.SharedColorPalette(options.style.colorPalette.dataColors);
                    var showLinesOnX = true;
                    var showLinesOnY = true;
                    var svg = this.svg = d3.select(element.get(0)).append('svg');
                    svg.style('position', 'absolute');
                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                        .classed(MekkoChart.AxisGraphicsContextClassName, true);
                    this.svgScrollable = svg.append('svg')
                        .classed('svgScrollable', true)
                        .style('overflow', 'hidden');
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                        .classed(MekkoChart.AxisGraphicsContextClassName, true);
                    this.labelGraphicsContextScrollable = this.svgScrollable.append('g')
                        .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                    if (this.behavior) {
                        this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                    }
                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                    this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                    this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                    if (this.behavior) {
                        this.interactivityService = visuals.createInteractivityService(this.hostServices);
                    }
                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, true);
                };
                MekkoChart.prototype.renderAxesLabels = function (options) {
                    debug.assertValue(options, 'options');
                    debug.assertValue(options.viewport, 'options.viewport');
                    debug.assertValue(options.axisLabels, 'options.axisLabels');
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    var margin = this.margin;
                    var width = options.viewport.width - (margin.left + margin.right);
                    var height = options.viewport.height;
                    var fontSize = MekkoChart.FontSize;
                    var heightOffset = fontSize;
                    var showOnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                    if (!options.hideXAxisTitle) {
                        var xAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(options.axisLabels.x)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    "transform": visuals.SVGUtil.translate(width / 2, height - heightOffset)
                                });
                            });
                        });
                        xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!options.hideYAxisTitle) {
                        var yAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(options.axisLabels.y)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showOnRight ? width + margin.right - fontSize : -margin.left,
                                    "x": -((height - margin.top - options.legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                        var y2AxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(options.axisLabels.y2)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showOnRight ? -margin.left : width + margin.right - fontSize,
                                    "x": -((height - margin.top - options.legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                };
                MekkoChart.prototype.adjustMargins = function (viewport) {
                    var margin = this.margin;
                    var width = viewport.width - (margin.left + margin.right);
                    var height = viewport.height - (margin.top + margin.bottom);
                    // Adjust margins if ticks are not going to be shown on either axis
                    var xAxis = this.element.find('.x.axis');
                    if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
                        && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                        this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        };
                        xAxis.hide();
                    }
                    else {
                        xAxis.show();
                    }
                };
                MekkoChart.prototype.translateAxes = function (viewport) {
                    this.adjustMargins(viewport);
                    var margin = this.margin;
                    var width = viewport.width - (margin.left + margin.right);
                    var height = viewport.height - (margin.top + margin.bottom);
                    var showY1OnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                    this.xAxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(0, height));
                    this.y1AxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));
                    this.y2AxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));
                    this.svg.attr({
                        'width': viewport.width,
                        'height': viewport.height
                    });
                    this.svg.style('top', this.legend.isVisible() ? this.legend.getMargins().height + 'px' : 0);
                    this.svgScrollable.attr({
                        'width': viewport.width,
                        'height': viewport.height
                    });
                    this.svgScrollable.attr({
                        'x': 0
                    });
                    this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                    this.labelGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                    if (this.isXScrollBarVisible) {
                        this.svgScrollable.attr({
                            'x': this.margin.left
                        });
                        this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                        this.labelGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                        this.svgScrollable.attr('width', width);
                        this.svg.attr('width', viewport.width)
                            .attr('height', viewport.height + MekkoChart.ScrollBarWidth);
                    }
                    else if (this.isYScrollBarVisible) {
                        this.svgScrollable.attr('height', height + margin.top);
                        this.svg.attr('width', viewport.width + MekkoChart.ScrollBarWidth)
                            .attr('height', viewport.height);
                    }
                };
                MekkoChart.getIsScalar = function (objects, propertyId, type) {
                    var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                    if (!objects || axisTypeValue === undefined) {
                        // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time.
                        // If we have the property, it will override the type.
                        return !visuals.AxisHelper.isOrdinal(type);
                    }
                    // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.
                    return (axisTypeValue === visuals.axisType.scalar) && !visuals.AxisHelper.isOrdinal(type);
                };
                MekkoChart.prototype.populateObjectProperties = function (dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata) {
                            this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                            this.borderObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'columnBorder', {});
                        }
                        else {
                            this.legendObjectProperties = {};
                            this.borderObjectProperties = {};
                        }
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                        if (dataViews[0].metadata &&
                            dataViews[0].metadata.objects &&
                            dataViews[0].metadata.objects['categoryAxis'] &&
                            dataViews[0].metadata.objects['categoryAxis']['showBorder']) {
                            this.categoryAxisProperties['showBorder'] = dataViews[0].metadata.objects['categoryAxis']['showBorder'];
                        }
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                        var axisPosition = this.valueAxisProperties['position'];
                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                    }
                };
                MekkoChart.prototype.update = function (options) {
                    debug.assertValue(options, 'options');
                    var dataViews = this.dataViews = options.dataViews;
                    this.currentViewport = options.viewport;
                    if (!dataViews) {
                        return;
                    }
                    if ((this.currentViewport.width < MekkoChart.MinWidth) ||
                        (this.currentViewport.height < MekkoChart.MinHeight)) {
                        return;
                    }
                    if (this.layers.length === 0) {
                        // Lazily instantiate the chart layers on the first data load.
                        this.layers = this.createAndInitLayers(dataViews);
                        debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');
                    }
                    var layers = this.layers;
                    if (dataViews && dataViews.length > 0) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                        if (warnings && warnings.length > 0) {
                            this.hostServices.setWarnings(warnings);
                        }
                        this.populateObjectProperties(dataViews);
                    }
                    this.sharedColorPalette.clearPreferredScale();
                    for (var i = 0, len = layers.length; i < len; i++) {
                        layers[i].setData(getLayerData(dataViews, i, len));
                        if (len > 1) {
                            this.sharedColorPalette.rotateScale();
                        }
                    }
                    // Note: interactive legend shouldn't be rendered explicitly here
                    // The interactive legend is being rendered in the render method of ICartesianVisual
                    if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
                        this.renderLegend();
                    }
                    this.render(!this.hasSetData || options.suppressAnimations);
                    this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
                };
                MekkoChart.parseBorderSettings = function (objects) {
                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);
                    var color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);
                    var width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);
                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                    if (width > maxWidth) {
                        width = maxWidth;
                    }
                    else if (width < 0) {
                        width = 0;
                    }
                    if (!show) {
                        width = 0;
                    }
                    return {
                        show: show,
                        color: color,
                        width: width,
                    };
                };
                MekkoChart.prototype.enumerateBorder = function (enumeration) {
                    var objects = {
                        columnBorder: this.borderObjectProperties
                    };
                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);
                    var color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);
                    var width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);
                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                    if (width > maxWidth) {
                        width = maxWidth;
                    }
                    else if (width < 0) {
                        width = 0;
                    }
                    var instance = {
                        objectName: 'columnBorder',
                        selector: null,
                        properties: {
                            show: show,
                            color: color,
                            width: width,
                        },
                    };
                    enumeration
                        .pushInstance(instance);
                };
                MekkoChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    var layersLength = this.layers ? this.layers.length : 0;
                    if (options.objectName === 'columnBorder') {
                        this.enumerateBorder(enumeration);
                    }
                    else if (options.objectName === 'legend') {
                        if (!this.shouldShowLegendCard()) {
                            return;
                        }
                        var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                        var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                        var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : '');
                        var fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: show,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                fontSize: fontSize
                            },
                            objectName: options.objectName
                        });
                    }
                    else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {
                        this.getCategoryAxisValues(enumeration);
                    }
                    else if (options.objectName === 'valueAxis') {
                        this.getValueAxisValues(enumeration);
                    }
                    for (var i = 0, len = layersLength; i < len; i++) {
                        var layer = this.layers[i];
                        if (layer.enumerateObjectInstances) {
                            layer.enumerateObjectInstances(enumeration, options);
                        }
                    }
                    return enumeration.complete();
                };
                MekkoChart.prototype.shouldShowLegendCard = function () {
                    var layers = this.layers;
                    var dataViews = this.dataViews;
                    if (layers && dataViews) {
                        var layersLength = layers.length;
                        var layersWithValuesCtr = 0;
                        for (var i = 0; i < layersLength; i++) {
                            if (layers[i].hasLegend()) {
                                return true;
                            }
                            // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)
                            var dataView = dataViews[i];
                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {
                                layersWithValuesCtr++;
                                if (layersWithValuesCtr > 1) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                MekkoChart.prototype.getCategoryAxisValues = function (enumeration) {
                    var supportedType = visuals.axisType.both;
                    var isScalar = false;
                    var logPossible = !!this.axes.x.isLogScaleAllowed;
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
                        supportedType = this.layers[0].getSupportedCategoryAxisType();
                        if (supportedType === visuals.axisType.scalar) {
                            isScalar = true;
                        }
                        else {
                            isScalar = visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties);
                        }
                    }
                    if (!isScalar) {
                        if (this.categoryAxisProperties) {
                            this.categoryAxisProperties['start'] = null;
                            this.categoryAxisProperties['end'] = null;
                        }
                    }
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'categoryAxis',
                        validValues: {
                            axisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                    if (this.yAxisIsCategorical)
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    if (supportedType === visuals.axisType.both) {
                        instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
                    }
                    if (isScalar) {
                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : visuals.axisScale.linear;
                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;
                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;
                    }
                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                    instance.properties['showBorder'] = this.categoryAxisProperties && this.categoryAxisProperties['showBorder'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null
                        },
                        objectName: 'categoryAxis',
                        validValues: {
                            axisStyle: this.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        }
                    });
                };
                //todo: wrap all these object getters and other related stuff into an interface
                MekkoChart.prototype.getValueAxisValues = function (enumeration) {
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    var logPossible = !!this.axes.y1.isLogScaleAllowed;
                    //var secLogPossible = this.axes.y2 != null && this.axes.y2.isLogScaleAllowed;
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis',
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                    if (!this.yAxisIsCategorical) {
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    }
                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : visuals.axisScale.linear;
                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;
                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;
                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null
                        },
                        objectName: 'valueAxis',
                        validValues: {
                            axisStyle: this.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        },
                    });
                    if (this.layers.length === 2) {
                        instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.y2AxisExists;
                        if (instance.properties['secShow']) {
                            instance.properties['axisLabel'] = ''; //this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made
                        }
                    }
                };
                MekkoChart.prototype.onClearSelection = function () {
                    if (this.hasSetData) {
                        for (var i = 0, len = this.layers.length; i < len; i++) {
                            var layer = this.layers[i];
                            layer.onClearSelection();
                            layer.render(true /* suppressAnimations */);
                        }
                    }
                };
                MekkoChart.prototype.createAndInitLayers = function (dataViews) {
                    var _this = this;
                    var objects;
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata)
                            objects = dataViewMetadata.objects;
                    }
                    // Create the layers
                    var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable, this.seriesLabelFormattingEnabled);
                    // Initialize the layers
                    var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                    cartesianOptions.svg = this.axisGraphicsContextScrollable;
                    cartesianOptions.cartesianHost = {
                        updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
                        getSharedColors: function () { return _this.sharedColorPalette; },
                        triggerRender: undefined,
                    };
                    for (var i = 0, len = layers.length; i < len; i++) {
                        layers[i].init(cartesianOptions);
                    }
                    return layers;
                };
                MekkoChart.prototype.renderLegend = function () {
                    var layers = this.layers;
                    var legendData = { title: "", dataPoints: [] };
                    for (var i = 0, len = layers.length; i < len; i++) {
                        this.layerLegendData = layers[i].calculateLegend();
                        if (this.layerLegendData) {
                            legendData.title = i === 0 ? this.layerLegendData.title || ""
                                : legendData.title;
                            legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                            if (this.layerLegendData.grouped) {
                                legendData.grouped = true;
                            }
                        }
                    }
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        if (!legendProperties['fontSize']) {
                            legendProperties['fontSize'] = visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt;
                        }
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        if (position) {
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                    }
                    else {
                        this.legend.changeOrientation(visuals.LegendPosition.Top);
                    }
                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                        legendData.dataPoints = [];
                    }
                    this.legend.drawLegend(legendData, this.currentViewport);
                };
                MekkoChart.prototype.hideLegends = function () {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                            return true;
                        }
                    }
                    return false;
                };
                MekkoChart.prototype.addUnitTypeToAxisLabel = function (axes) {
                    var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.x; });
                    if (axes.x.isCategoryAxis) {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    if (axes.x.axisLabel && unitType) {
                        if (axes.x.isCategoryAxis) {
                            axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);
                        }
                        else {
                            axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);
                        }
                    }
                    unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y1; });
                    if (!axes.y1.isCategoryAxis) {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    if (axes.y1.axisLabel && unitType) {
                        if (!axes.y1.isCategoryAxis) {
                            axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);
                        }
                        else {
                            axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);
                        }
                    }
                    if (axes.y2) {
                        var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y2; });
                        this.secValueAxisHasUnitType = unitType !== null;
                        if (axes.y2.axisLabel && unitType) {
                            if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {
                                if (this.valueAxisProperties['secAxisStyle'] === visuals.axisStyle.showBoth) {
                                    axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';
                                }
                                else if (this.valueAxisProperties['secAxisStyle'] === visuals.axisStyle.showUnitOnly) {
                                    axes.y2.axisLabel = unitType;
                                }
                            }
                        }
                    }
                };
                MekkoChart.prototype.shouldRenderSecondaryAxis = function (axisProperties) {
                    if (!axisProperties) {
                        return false;
                    }
                    if (!this.valueAxisProperties || this.valueAxisProperties["secShow"] == null || this.valueAxisProperties["secShow"]) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    return false;
                };
                MekkoChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {
                    if (propertyName === void 0) { propertyName = "show"; }
                    if (!axisProperties) {
                        return false;
                    }
                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    return false;
                };
                MekkoChart.prototype.render = function (suppressAnimations) {
                    var legendMargins = this.legendMargins = this.legend.getMargins();
                    var viewport = {
                        height: this.currentViewport.height - legendMargins.height,
                        width: this.currentViewport.width - legendMargins.width
                    };
                    var maxMarginFactor = this.getMaxMarginFactor();
                    var leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
                    var bottomMarginLimit = this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
                    var margin = this.margin;
                    // reset defaults
                    margin.top = MekkoChart.TopMargin;
                    margin.bottom = MekkoChart.MinBottomMargin;
                    margin.right = 0;
                    var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, MekkoChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                    this.y2AxisExists = axes.y2 != null;
                    this.yAxisIsCategorical = axes.y1.isCategoryAxis;
                    this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                    var renderXAxis = this.shouldRenderAxis(axes.x);
                    var renderY1Axis = this.shouldRenderAxis(axes.y1);
                    var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);
                    var width = viewport.width - (margin.left + margin.right);
                    var isScalar = false;
                    var mainAxisScale;
                    var preferredViewport;
                    this.isXScrollBarVisible = false;
                    this.isYScrollBarVisible = false;
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    if (this.layers) {
                        if (this.layers[0].getVisualCategoryAxisIsScalar) {
                            isScalar = this.layers[0].getVisualCategoryAxisIsScalar();
                        }
                        if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {
                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;
                            var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                            if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {
                                this.isXScrollBarVisible = true;
                                viewport.height -= MekkoChart.ScrollBarWidth;
                            }
                            if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {
                                this.isYScrollBarVisible = true;
                                viewport.width -= MekkoChart.ScrollBarWidth;
                                width = viewport.width - (margin.left + margin.right);
                            }
                        }
                    }
                    // Only create the g tag where there is a scrollbar
                    if (this.isXScrollBarVisible || this.isYScrollBarVisible) {
                        if (!this.brushGraphicsContext) {
                            this.brushGraphicsContext = this.svg.append("g")
                                .classed('x brush', true);
                        }
                    }
                    else {
                        // clear any existing brush if no scrollbar is shown
                        this.svg.selectAll('.brush').remove();
                        this.brushGraphicsContext = undefined;
                    }
                    // Recalculate axes now that scrollbar visible variables have been set
                    axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, MekkoChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                    // we need to make two passes because the margin changes affect the chosen tick values, which then affect the margins again.
                    // after the second pass the margins are correct.
                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;
                    var tickLabelMargins = undefined;
                    var chartHasAxisLabels = undefined;
                    var axisLabels = undefined;
                    while (!doneWithMargins && numIterations < maxIterations) {
                        numIterations++;
                        tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: width, height: viewport.height }, leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, bottomMarginLimit, MekkoChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                        maxMainYaxisSide += MekkoChart.LeftPadding;
                        if ((renderY2Axis && !showY1OnRight) || (showY1OnRight && renderY1Axis))
                            maxSecondYaxisSide += MekkoChart.RightPadding;
                        xMax += MekkoChart.BottomPadding;
                        if (this.hideAxisLabels(legendMargins)) {
                            axes.x.axisLabel = null;
                            axes.y1.axisLabel = null;
                            if (axes.y2) {
                                axes.y2.axisLabel = null;
                            }
                        }
                        this.addUnitTypeToAxisLabel(axes);
                        axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                        if (axisLabels.x != null) {
                            xMax += MekkoChart.XAxisLabelPadding;
                        }
                        if (axisLabels.y != null) {
                            maxMainYaxisSide += MekkoChart.YAxisLabelPadding;
                        }
                        if (axisLabels.y2 != null) {
                            maxSecondYaxisSide += MekkoChart.YAxisLabelPadding;
                        }
                        margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                        margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                        margin.bottom = xMax;
                        this.margin = margin;
                        width = viewport.width - (margin.left + margin.right);
                        // re-calculate the axes with the new margins
                        var previousTickCountY1 = axes.y1.values.length;
                        var previousTickCountY2 = axes.y2 && axes.y2.values.length;
                        axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, MekkoChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes);
                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
                        if (axes.y1.values.length === previousTickCountY1 && (!axes.y2 || axes.y2.values.length === previousTickCountY2))
                            doneWithMargins = true;
                    }
                    this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
                };
                MekkoChart.prototype.hideAxisLabels = function (legendMargins) {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
                            return true;
                        }
                    }
                    return false;
                };
                MekkoChart.getUnitType = function (axis, axisPropertiesLookup) {
                    if (axisPropertiesLookup(axis).formatter &&
                        axisPropertiesLookup(axis).formatter.displayUnit &&
                        axisPropertiesLookup(axis).formatter.displayUnit.value > 1) {
                        return axisPropertiesLookup(axis).formatter.displayUnit.title;
                    }
                    return null;
                };
                MekkoChart.prototype.getMaxMarginFactor = function () {
                    return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
                };
                MekkoChart.getChartViewport = function (viewport, margin) {
                    return {
                        width: viewport.width - margin.left - margin.right,
                        height: viewport.height - margin.top - margin.bottom,
                    };
                };
                MekkoChart.wordBreak = function (text, axisProperties, columnsWidth, maxHeight, borderWidth) {
                    //var allowedLength = axisProperties.xLabelMaxWidth;
                    text.each(function (data, index) {
                        var width, allowedLength;
                        var node = d3.select(this);
                        if (columnsWidth.length >= index) {
                            width = columnsWidth[index];
                            allowedLength = axisProperties.scale(width);
                        }
                        else {
                            allowedLength = axisProperties.xLabelMaxWidth;
                        }
                        // Reset style of text node
                        node
                            .style('text-anchor', 'middle')
                            .attr({
                            'dx': '0em',
                            'dy': '1em',
                            'transform': 'rotate(0)'
                        });
                        powerbi.TextMeasurementService.wordBreak(this, allowedLength, maxHeight);
                    });
                };
                MekkoChart.prototype.renderChart = function (mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
                    var bottomMarginLimit = this.bottomMarginLimit;
                    var leftRightMarginLimit = this.leftRightMarginLimit;
                    var layers = this.layers;
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    var chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
                    debug.assertValue(layers, 'layers');
                    var xLabelColor;
                    var yLabelColor;
                    var y2LabelColor;
                    //hide show x-axis here
                    if (this.shouldRenderAxis(axes.x)) {
                        if (axes.x.isCategoryAxis) {
                            xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                        }
                        else {
                            xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                        }
                        axes.x.axis.orient("bottom");
                        if (!axes.x.willLabelsFit) {
                            axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
                        }
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        if (duration) {
                            xAxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(axes.x.axis);
                        }
                        else {
                            xAxisGraphicsElement
                                .call(axes.x.axis);
                        }
                        xAxisGraphicsElement
                            .call(MekkoChart.darkenZeroLine)
                            .call(MekkoChart.setAxisLabelColor, xLabelColor);
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                        var columnWidth = [];
                        var borderWidth = 0;
                        if (this.layers && this.layers.length) {
                            columnWidth = this.layers[0].getColumnsWidth();
                            borderWidth = this.layers[0].getBorderWidth();
                        }
                        xAxisGraphicsElement
                            .call(MekkoChart.moveBorder, axes.x.scale, borderWidth);
                        xAxisTextNodes
                            .call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
                    }
                    else {
                        this.xAxisGraphicsContext.selectAll('*').remove();
                    }
                    if (this.shouldRenderAxis(axes.y1)) {
                        if (axes.y1.isCategoryAxis) {
                            yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                        }
                        else {
                            yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                        }
                        var yAxisOrientation = this.yAxisOrientation;
                        var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        axes.y1.axis
                            .tickSize(-width)
                            .tickPadding(MekkoChart.TickPaddingY)
                            .orient(yAxisOrientation.toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        if (duration) {
                            y1AxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(axes.y1.axis);
                        }
                        else {
                            y1AxisGraphicsElement
                                .call(axes.y1.axis);
                        }
                        y1AxisGraphicsElement
                            .call(MekkoChart.darkenZeroLine)
                            .call(MekkoChart.setAxisLabelColor, yLabelColor);
                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
                            y1AxisGraphicsElement.selectAll('text')
                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                            leftRightMarginLimit - MekkoChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
                            y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;
                            axes.y2.axis
                                .tickPadding(MekkoChart.TickPaddingY)
                                .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                            if (duration) {
                                this.y2AxisGraphicsContext
                                    .transition()
                                    .duration(duration)
                                    .call(axes.y2.axis);
                            }
                            else {
                                this.y2AxisGraphicsContext
                                    .call(axes.y2.axis);
                            }
                            this.y2AxisGraphicsContext
                                .call(MekkoChart.darkenZeroLine)
                                .call(MekkoChart.setAxisLabelColor, y2LabelColor);
                            if (tickLabelMargins.yRight >= leftRightMarginLimit) {
                                this.y2AxisGraphicsContext.selectAll('text')
                                    .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                                // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                                leftRightMarginLimit - MekkoChart.RightPadding, powerbi.TextMeasurementService.svgEllipsis);
                            }
                        }
                        else {
                            this.y2AxisGraphicsContext.selectAll('*').remove();
                        }
                    }
                    else {
                        this.y1AxisGraphicsContext.selectAll('*').remove();
                        this.y2AxisGraphicsContext.selectAll('*').remove();
                    }
                    // Axis labels
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle");
                        var hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle");
                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
                        var renderAxisOptions = {
                            axisLabels: axisLabels,
                            legendMargin: this.legendMargins.height,
                            viewport: viewport,
                            hideXAxisTitle: hideXAxisTitle,
                            hideYAxisTitle: hideYAxisTitle,
                            hideY2AxisTitle: hideY2AxisTitle,
                            xLabelColor: xLabelColor,
                            yLabelColor: yLabelColor,
                            y2LabelColor: y2LabelColor,
                            margin: undefined,
                        };
                        this.renderAxesLabels(renderAxisOptions);
                    }
                    else {
                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    }
                    this.translateAxes(viewport);
                    var dataPoints = [];
                    var layerBehaviorOptions = [];
                    var labelDataPointsGroup = [];
                    //Render chart columns
                    if (this.behavior) {
                        for (var i = 0, len = layers.length; i < len; i++) {
                            var result = layers[i].render(suppressAnimations);
                            if (result) {
                                dataPoints = dataPoints.concat(result.dataPoints);
                                layerBehaviorOptions.push(result.behaviorOptions);
                                if (result.labelDataPointGroups) {
                                    var resultLabelDataPointsGroups = result.labelDataPointGroups;
                                    for (var j = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {
                                        var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
                                        labelDataPointsGroup.push({
                                            labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
                                            maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,
                                        });
                                    }
                                }
                                else {
                                    var resultsLabelDataPoints = result.labelDataPoints;
                                    var reducedDataPoints = resultsLabelDataPoints;
                                    labelDataPointsGroup.push({
                                        labelDataPoints: reducedDataPoints,
                                        maxNumberOfLabels: reducedDataPoints.length,
                                    });
                                }
                            }
                        }
                        var labelLayoutOptions = {
                            maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                            startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                        };
                        var labelLayout = new powerbi.LabelLayout(labelLayoutOptions);
                        var dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
                        if (layers.length > 1) {
                            visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", 0.7);
                        }
                        if (this.animator && !suppressAnimations) {
                            visuals.NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration());
                        }
                        else {
                            visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels);
                        }
                        this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none");
                        if (this.interactivityService) {
                            var behaviorOptions = {
                                layerOptions: layerBehaviorOptions,
                                clearCatcher: this.clearCatcher,
                            };
                            this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                        }
                    }
                };
                /**
                 * Within the context of the given selection (g), find the offset of
                 * the zero tick using the d3 attached datum of g.tick elements.
                 * 'Classed' is undefined for transition selections
                 */
                MekkoChart.darkenZeroLine = function (g) {
                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
                    if (zeroTick) {
                        d3.select(zeroTick).select('line').classed('zero-line', true);
                    }
                };
                MekkoChart.setAxisLabelColor = function (g, fill) {
                    g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
                };
                MekkoChart.moveBorder = function (g, scale, borderWidth) {
                    g.selectAll('g.tick')
                        .attr("transform", function (value, index) {
                        return visuals.SVGUtil.translate(scale(value) + (borderWidth * index), 0);
                    });
                };
                MekkoChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category',
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Series',
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y Axis',
                        }, {
                            name: 'Width',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Axis width',
                        }
                    ],
                    objects: {
                        columnBorder: {
                            displayName: 'Border',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                width: {
                                    displayName: 'Width',
                                    type: { numeric: true }
                                },
                            },
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                showSeries: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                                    type: { formatting: { labelDisplayUnits: true } },
                                    suppressFormatPainterCopy: true
                                },
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                                    placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                    type: { numeric: true },
                                    suppressFormatPainterCopy: true
                                },
                                showAll: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_ShowAll'),
                                    type: { bool: true }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    type: { formatting: { legendPosition: true } }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Title text',
                                    type: { text: true }
                                },
                                fontSize: {
                                    displayName: 'Text size',
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        },
                        categoryAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                    type: { formatting: { yAxisPosition: true } }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                /*start: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },*/
                                axisType: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                                    type: { formatting: { axisType: true } }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                            }
                        },
                        valueAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                    type: { formatting: { yAxisPosition: true } }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                /*start: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },*/
                                intersection: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),
                                    type: { numeric: true }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                    type: { fillRule: {} },
                                    rule: {
                                        inputRole: 'Gradient',
                                        output: {
                                            property: 'fill',
                                            selector: ['Category'],
                                        },
                                    },
                                }
                            }
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { min: 0, max: 1 }, 'Series': { min: 0, max: 1 }, 'Y': { min: 0, max: 1 }, 'Width': { min: 0, max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [{ for: { in: 'Y' } }, { for: { in: 'Width' } }],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                rowCount: { preferred: { min: 1, max: 1 }, supported: { min: 0 } }
                            },
                        }],
                    supportsHighlight: true,
                    sorting: {
                        default: {},
                    },
                    drilldown: {
                        roles: ['Category']
                    },
                };
                MekkoChart.properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    columnBorder: {
                        show: { objectName: 'columnBorder', propertyName: 'show', },
                        color: { objectName: 'columnBorder', propertyName: 'color' },
                        width: { objectName: 'columnBorder', propertyName: 'width' },
                    },
                };
                MekkoChart.DefaultSettings = {
                    columnBorder: {
                        show: true,
                        color: '#fff',
                        width: 2,
                        maxWidth: 5,
                    }
                };
                MekkoChart.MekkoChartMinWidth = 50;
                MekkoChart.MinOrdinalRectThickness = 20;
                MekkoChart.MinScalarRectThickness = 2;
                MekkoChart.OuterPaddingRatio = 0.4;
                MekkoChart.InnerPaddingRatio = 0.2;
                MekkoChart.TickLabelPadding = 2;
                MekkoChart.ClassName = 'cartesianChart';
                MekkoChart.AxisGraphicsContextClassName = 'axisGraphicsContext';
                MekkoChart.MaxMarginFactor = 0.25;
                MekkoChart.MinBottomMargin = 25;
                MekkoChart.TopMargin = 8;
                MekkoChart.LeftPadding = 10;
                MekkoChart.RightPadding = 15;
                MekkoChart.BottomPadding = 12;
                MekkoChart.YAxisLabelPadding = 20;
                MekkoChart.XAxisLabelPadding = 18;
                MekkoChart.TickPaddingY = 10;
                MekkoChart.TickPaddingRotatedX = 5;
                MekkoChart.FontSize = 11;
                MekkoChart.FontSizeString = jsCommon.PixelConverter.toString(MekkoChart.FontSize);
                MekkoChart.TextProperties = {
                    fontFamily: 'wf_segoe-ui_normal',
                    fontSize: MekkoChart.FontSizeString,
                };
                MekkoChart.MaxNumberOfLabels = 100;
                MekkoChart.MinWidth = 100;
                MekkoChart.MinHeight = 100;
                MekkoChart.ScrollBarWidth = 10;
                return MekkoChart;
            })();
            samples.MekkoChart = MekkoChart;
            function getLayerData(dataViews, currentIdx, totalLayers) {
                if (totalLayers > 1) {
                    if (dataViews && dataViews.length > currentIdx)
                        return [dataViews[currentIdx]];
                    return [];
                }
                return dataViews;
            }
            /**
             * Returns a boolean, that indicates if y axis title should be displayed.
             * @return True if y axis title should be displayed,
             * otherwise false.
             */
            function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||
                    (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
            }
            /**
             * Computes the Cartesian Chart axes from the set of layers.
             */
            function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible, existingAxisProperties) {
                debug.assertValue(layers, 'layers');
                var visualOptions = {
                    viewport: viewport,
                    margin: margin,
                    forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                    forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
                    showCategoryAxisLabel: false,
                    showValueAxisLabel: false,
                    categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : visuals.axisScale.linear,
                    valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : visuals.axisScale.linear,
                    trimOrdinalDataOnOverflow: false
                };
                var yAxisWillMerge = false;
                if (valueAxisProperties) {
                    visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
                }
                var result;
                for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                    var currentlayer = layers[layerNumber];
                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']); //here
                    //visualOptions.showBorder = (!!categoryAxisProperties && !!categoryAxisProperties['showBorder']);//here
                    visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                    var axes = currentlayer.calculateAxesProperties(visualOptions);
                    if (layerNumber === 0) {
                        result = {
                            x: axes[0],
                            y1: axes[1]
                        };
                    }
                    result.x.willLabelsFit = false;
                    result.x.willLabelsWordBreak = false;
                }
                return result;
            }
            function createLayers(type, objects, interactivityService, animator, isScrollable, seriesLabelFormattingEnabled) {
                if (isScrollable === void 0) { isScrollable = true; }
                if (seriesLabelFormattingEnabled === void 0) { seriesLabelFormattingEnabled = true; }
                var layers = [];
                var cartesianOptions = {
                    isScrollable: isScrollable,
                    animator: animator,
                    interactivityService: interactivityService,
                    seriesLabelFormattingEnabled: seriesLabelFormattingEnabled,
                };
                layers.push(createMekkoChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
                return layers;
            }
            samples.createLayers = createLayers;
            function createMekkoChartLayer(type, defaultOptions) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    seriesLabelFormattingEnabled: defaultOptions.seriesLabelFormattingEnabled,
                    chartType: type
                };
                return new MekkoColumnChart(options);
            }
            var EnumExtensions = jsCommon.EnumExtensions;
            var ArrayExtensions = jsCommon.ArrayExtensions;
            var flagBar = 1 << 1;
            //var flagColumn: number = 1 << 2;
            var flagStacked = 1 << 4;
            var RoleNames = {
                category: 'Category',
                series: 'Series',
                y: 'Y',
                width: 'Width'
            };
            var MekkoColumnChart = (function () {
                function MekkoColumnChart(options) {
                    debug.assertValue(options, 'options');
                    var chartType = options.chartType;
                    debug.assertValue(chartType, 'chartType');
                    this.chartType = chartType;
                    this.categoryAxisType = null;
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable;
                    this.interactivityService = options.interactivityService;
                    this.seriesLabelFormattingEnabled = options.seriesLabelFormattingEnabled;
                }
                MekkoColumnChart.prototype.init = function (options) {
                    this.svg = options.svg;
                    this.mainGraphicsContext = this.svg.append('g').classed('columnChartMainGraphicsContext', true);
                    this.labelGraphicsContext = this.svg.append('g').classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                    this.style = options.style;
                    this.currentViewport = options.viewport;
                    this.hostService = options.host;
                    this.interactivity = options.interactivity;
                    this.colors = this.style.colorPalette.dataColors;
                    this.cartesianVisualHost = options.cartesianHost;
                    this.options = options;
                    this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                    var element = this.element = options.element;
                    element.addClass(MekkoColumnChart.ColumnChartClassName);
                    this.columnChart = new MekkoColumnChartStrategy();
                };
                MekkoColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
                    var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                    var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                    var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                    var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                    return visuals.CartesianChart.getLayout(this.data, {
                        availableWidth: availableWidth,
                        categoryCount: numCategoryValues,
                        domain: domain,
                        isScalar: isScalar,
                        isScrollable: this.isScrollable,
                        trimOrdinalDataOnOverflow: false
                    });
                };
                MekkoColumnChart.getBorderWidth = function (border) {
                    if (!border ||
                        !border.show ||
                        !border.width) {
                        return 0;
                    }
                    var width = border.width;
                    if (width < 0) {
                        return 0;
                    }
                    if (width > border.maxWidth) {
                        return border.maxWidth;
                    }
                    return width;
                };
                MekkoColumnChart.getBorderColor = function (border) {
                    if (!border) {
                        return MekkoChart.DefaultSettings.columnBorder.color;
                    }
                    return border.color;
                };
                MekkoColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                    if (isScalar === void 0) { isScalar = false; }
                    if (supportsOverflow === void 0) { supportsOverflow = false; }
                    if (dataViewMetadata === void 0) { dataViewMetadata = null; }
                    debug.assertValue(dataView, 'dataView');
                    debug.assertValue(colors, 'colors');
                    var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                    dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                    var converterStrategy = new ColumnChartConverterHelper(dataView);
                    var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString);
                    var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                    //labelFormatString: string = dataView.values && dataView.values[0] ? valueFormatter.getFormatString(dataView.values[0].source, columnChartProps.general.formatString) : undefined;
                    var borderSettings = MekkoChart.DefaultSettings.columnBorder;
                    var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(true);
                    var defaultDataPointColor = undefined;
                    var showAllDataPoints = undefined;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                        var labelsObj = objects['labels'];
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                        borderSettings = MekkoChart.parseBorderSettings(objects);
                    }
                    // Allocate colors
                    var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);
                    var legend = legendAndSeriesInfo.legend.dataPoints;
                    var seriesSources = legendAndSeriesInfo.seriesSources;
                    // Determine data points
                    var result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata);
                    var columnSeries = result.series;
                    var valuesMetadata = [];
                    for (var j = 0, jlen = legend.length; j < jlen; j++) {
                        valuesMetadata.push(seriesSources[j]);
                    }
                    var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                    return {
                        categories: categories,
                        categoriesWidth: result.categoriesWidth,
                        categoryFormatter: categoryFormatter,
                        series: columnSeries,
                        valuesMetadata: valuesMetadata,
                        legendData: legendAndSeriesInfo.legend,
                        hasHighlights: result.hasHighlights,
                        categoryMetadata: categoryMetadata,
                        scalarCategoryAxis: isScalar,
                        borderSettings: borderSettings,
                        labelSettings: labelSettings,
                        axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
                        hasDynamicSeries: result.hasDynamicSeries,
                        defaultDataPointColor: defaultDataPointColor,
                        showAllDataPoints: showAllDataPoints,
                        isMultiMeasure: false,
                    };
                };
                MekkoColumnChart.getStackedMultiplier = function (rawValues, rowIdx, seriesCount, categoryCount) {
                    var pos = 0, neg = 0;
                    for (var i = 0; i < seriesCount; i++) {
                        var value = rawValues[i][rowIdx];
                        value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                        if (value > 0) {
                            pos += value;
                        }
                        else if (value < 0) {
                            neg -= value;
                        }
                    }
                    var absTotal = pos + neg;
                    return {
                        pos: pos ? (pos / absTotal) / pos : 1,
                        neg: neg ? (neg / absTotal) / neg : 1,
                    };
                };
                MekkoColumnChart.createDataPoints = function (dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                    if (isScalar === void 0) { isScalar = false; }
                    if (supportsOverflow === void 0) { supportsOverflow = false; }
                    var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
                    var categoryCount = categories.length;
                    var seriesCount = legend.length;
                    var columnSeries = [];
                    if (seriesCount < 1 || categoryCount < 1 || categories[0] === null) {
                        return { series: columnSeries,
                            hasHighlights: false,
                            hasDynamicSeries: false,
                            categoriesWidth: [],
                        };
                    }
                    var dvCategories = dataViewCat.categories;
                    categoryMetadata = (dvCategories && dvCategories.length > 0)
                        ? dvCategories[0].source
                        : null;
                    var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                    var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                    var baseValuesPos = [], baseValuesNeg = [];
                    var rawValues = [];
                    var rawHighlightValues = [];
                    var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
                    var widthColumns = [];
                    var widthIndex = -1;
                    var seriesIndex = 0;
                    var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
                    var hasHighlights = converterStrategy.hasHighlightValues(0);
                    for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {
                        if (dataViewCat.values[seriesIndex].source.roles &&
                            dataViewCat.values[seriesIndex].source.roles[RoleNames.width] &&
                            !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
                            widthIndex = seriesIndex;
                            var widthValues = dataViewCat.values[seriesIndex].values;
                            for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {
                                widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);
                            }
                            continue;
                        }
                        var seriesValues = [];
                        var seriesHighlightValues = [];
                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                            var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesValues[categoryIndex] = value;
                            if (hasHighlights) {
                                var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                seriesHighlightValues[categoryIndex] = highlightValue;
                                // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
                                if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||
                                    (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
                                    highlightsOverflow = true;
                                }
                            }
                        }
                        rawValues.push(seriesValues);
                        if (hasHighlights) {
                            rawHighlightValues.push(seriesHighlightValues);
                        }
                    }
                    //console.log(dataViewCat);
                    if (highlightsOverflow && !supportsOverflow) {
                        highlightsOverflow = false;
                        hasHighlights = false;
                        rawValues = rawHighlightValues;
                    }
                    if (widthColumns.length < 1) {
                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {
                            if (dataViewCat.values[seriesIndex].source.roles &&
                                dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
                                widthIndex = seriesIndex;
                                var widthValues = dataViewCat.values[seriesIndex].values;
                                for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {
                                    widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);
                                }
                                continue;
                            }
                        }
                    }
                    if (widthColumns.length < 1) {
                        for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {
                            widthColumns.push(1);
                        }
                    }
                    var totalSum = d3.sum(widthColumns);
                    var linearScale = d3.scale.linear()
                        .domain([0, totalSum])
                        .range([0, 1]);
                    var columnStartX = [0];
                    var columnWidth = [];
                    for (seriesIndex = 0; seriesIndex < (categoryCount - 1); seriesIndex++) {
                        var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
                        columnStartX.push(stepWidth);
                    }
                    for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {
                        columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]);
                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
                    }
                    var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                    for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                        var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings;
                        if (!hasDynamicSeries) {
                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                            var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                            if (labelObjects) {
                                seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
                            }
                        }
                        var series = {
                            displayName: legendItem.label,
                            key: 'series' + seriesIndex,
                            index: seriesIndex,
                            data: seriesDataPoints,
                            identity: legendItem.identity,
                            color: legendItem.color,
                            labelSettings: seriesLabelSettings,
                        };
                        if (seriesCount > 1) {
                            dataPointObjects = seriesObjectsList[seriesIndex];
                        }
                        var metadata = dataViewCat.values[seriesIndex].source;
                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                            if (seriesIndex === 0) {
                                baseValuesPos.push(0);
                                baseValuesNeg.push(0);
                            }
                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                            if (value == null) {
                                // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
                                // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
                                if (seriesIndex > 0) {
                                    continue;
                                }
                            }
                            var originalValue = value;
                            var categoryValue = categories[categoryIndex];
                            if (isDateTime && categoryValue) {
                                categoryValue = categoryValue.getTime();
                            }
                            if (isScalar && (categoryValue == null || isNaN(categoryValue))) {
                                continue;
                            }
                            var multipliers;
                            if (is100PercentStacked) {
                                //multipliers = StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
                                multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount);
                            }
                            var unadjustedValue = value, isNegative = value < 0;
                            if (multipliers) {
                                if (isNegative) {
                                    value *= multipliers.neg;
                                }
                                else {
                                    value *= multipliers.pos;
                                }
                            }
                            var valueAbsolute = Math.abs(value);
                            var position;
                            if (isNegative) {
                                position = baseValuesNeg[categoryIndex];
                                if (!isNaN(valueAbsolute)) {
                                    baseValuesNeg[categoryIndex] -= valueAbsolute;
                                }
                            }
                            else {
                                if (!isNaN(valueAbsolute)) {
                                    baseValuesPos[categoryIndex] += valueAbsolute;
                                }
                                position = baseValuesPos[categoryIndex];
                            }
                            var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null;
                            var seriesGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex].values[0] : null;
                            var category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(category, categoryIndex)
                                .withSeries(dataViewCat.values, seriesGroup)
                                .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))
                                .createSelectionId();
                            var rawCategoryValue = categories[categoryIndex];
                            var color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
                            var seriesData = [];
                            if (columnGroup) {
                                var seriesValueColumn = {
                                    values: [],
                                    source: dataViewCat.values.source,
                                };
                                seriesData.push({
                                    value: columnGroup.name,
                                    metadata: seriesValueColumn,
                                });
                                for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
                                    var columnValues = columnGroup.values[columnIndex];
                                    seriesData.push({
                                        value: columnValues.values[categoryIndex],
                                        metadata: columnValues,
                                    });
                                }
                            }
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null /*dataViewCat*/, rawCategoryValue, originalValue, [category], seriesData, null /*seriesIndex*/, categoryIndex);
                            var dataPointLabelSettings = (series && series.labelSettings) ? series.labelSettings : defaultLabelSettings;
                            var labelColor = dataPointLabelSettings.labelColor;
                            var lastValue = undefined;
                            //Stacked column/bar label color is white by default (except last series)
                            if ((EnumExtensions.hasFlag(chartType, flagStacked))) {
                                lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
                                labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor;
                            }
                            value = columnWidth[categoryIndex];
                            var originalPosition = columnStartX[categoryIndex];
                            var dataPoint = {
                                categoryValue: categoryValue,
                                value: value,
                                position: position,
                                valueAbsolute: valueAbsolute,
                                valueOriginal: unadjustedValue,
                                seriesIndex: seriesIndex,
                                labelSettings: dataPointLabelSettings,
                                categoryIndex: categoryIndex,
                                color: color,
                                selected: false,
                                originalValue: value,
                                originalPosition: originalPosition,
                                originalValueAbsolute: valueAbsolute,
                                identity: identity,
                                key: identity.getKey(),
                                tooltipInfo: tooltipInfo,
                                labelFill: labelColor,
                                labelFormatString: metadata.format,
                                lastSeries: lastValue,
                                chartType: chartType,
                            };
                            seriesDataPoints.push(dataPoint);
                            if (hasHighlights) {
                                var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
                                var unadjustedValueHighlight = valueHighlight;
                                var highlightedTooltip = true;
                                if (valueHighlight === null) {
                                    valueHighlight = 0;
                                    highlightedTooltip = false;
                                }
                                if (is100PercentStacked) {
                                    valueHighlight *= multipliers.pos;
                                }
                                var absoluteValueHighlight = Math.abs(valueHighlight);
                                var highlightPosition = position;
                                if (valueHighlight > 0) {
                                    highlightPosition -= valueAbsolute - absoluteValueHighlight;
                                }
                                else if (valueHighlight === 0 && value > 0) {
                                    highlightPosition -= valueAbsolute;
                                }
                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                                var rawCategoryValue = categories[categoryIndex];
                                //var highlightedValue: number = highlightedTooltip ? valueHighlight : undefined;
                                //var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue);
                                if (highlightedTooltip) {
                                    // Override non highlighted data point
                                    dataPoint.tooltipInfo = tooltipInfo;
                                }
                                var highlightDataPoint = {
                                    categoryValue: categoryValue,
                                    value: value,
                                    position: highlightPosition,
                                    valueAbsolute: absoluteValueHighlight,
                                    valueOriginal: unadjustedValueHighlight,
                                    seriesIndex: seriesIndex,
                                    labelSettings: dataPointLabelSettings,
                                    categoryIndex: categoryIndex,
                                    color: color,
                                    selected: false,
                                    highlight: true,
                                    originalValue: value,
                                    originalPosition: originalPosition,
                                    originalValueAbsolute: valueAbsolute,
                                    drawThinner: highlightsOverflow,
                                    identity: highlightIdentity,
                                    key: highlightIdentity.getKey(),
                                    tooltipInfo: tooltipInfo,
                                    labelFormatString: metadata.format,
                                    labelFill: labelColor,
                                    lastSeries: lastValue,
                                    chartType: chartType,
                                };
                                seriesDataPoints.push(highlightDataPoint);
                            }
                        }
                        columnSeries.push(series);
                    }
                    return {
                        series: columnSeries,
                        categoriesWidth: columnWidth,
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: hasDynamicSeries,
                    };
                };
                MekkoColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
                    debug.assertValue(legendItem, 'legendItem');
                    debug.assertValue(categoryIndex, 'categoryIndex');
                    debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
                    if (dataPointObjects) {
                        var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                        if (colorOverride) {
                            return colorOverride;
                        }
                    }
                    return legendItem.color;
                };
                MekkoColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                    var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
                    //run for the next series and check if current series is last
                    for (var i = seriesIndex + 1; i < seriesCount; i++) {
                        var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                        if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
                            lastValue = false;
                            break;
                        }
                    }
                    return lastValue;
                };
                MekkoColumnChart.sliceSeries = function (series, endIndex, startIndex) {
                    if (startIndex === void 0) { startIndex = 0; }
                    var newSeries = [];
                    if (series && series.length > 0) {
                        for (var i = 0, len = series.length; i < len; i++) {
                            var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                            iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
                        }
                    }
                    return newSeries;
                };
                MekkoColumnChart.getInteractiveColumnChartDomElement = function (element) {
                    return element.children("svg").get(0);
                };
                MekkoColumnChart.prototype.getColumnsWidth = function () {
                    var data = this.data;
                    if (!data ||
                        !data.series ||
                        !data.series[0] ||
                        !data.series[0].data) {
                        return [];
                    }
                    return data.categoriesWidth;
                };
                MekkoColumnChart.prototype.getBorderWidth = function () {
                    return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
                };
                MekkoColumnChart.prototype.setData = function (dataViews) {
                    debug.assertValue(dataViews, "dataViews");
                    var is100PctStacked = true;
                    this.data = {
                        categories: [],
                        categoriesWidth: [],
                        categoryFormatter: null,
                        series: [],
                        valuesMetadata: [],
                        legendData: null,
                        hasHighlights: false,
                        categoryMetadata: null,
                        scalarCategoryAxis: false,
                        borderSettings: null,
                        labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                        axesLabels: { x: null, y: null },
                        hasDynamicSeries: false,
                        defaultDataPointColor: null,
                        isMultiMeasure: false,
                    };
                    if (dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView && dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            /*
                            var dvCategories = dataViewCat.categories;
                            var categoryMetadata = (dvCategories && dvCategories.length > 0)
                                ? dvCategories[0].source
                                : null;
                            var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);
                            */
                            this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), true, //s100PctStacked,
                            false, //CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, columnChartProps.categoryAxis.axisType, categoryType),
                            this.supportsOverflow, dataView.metadata, this.chartType);
                            var series = this.data.series;
                            for (var i = 0, ilen = series.length; i < ilen; i++) {
                                var currentSeries = series[i];
                                if (this.interactivityService) {
                                    this.interactivityService.applySelectionStateToData(currentSeries.data);
                                }
                            }
                        }
                    }
                };
                MekkoColumnChart.prototype.calculateLegend = function () {
                    // if we're in interactive mode, return the interactive legend
                    if (this.interactivity && this.interactivity.isInteractiveLegend) {
                        return this.createInteractiveMekkoLegendDataPoints(0);
                    }
                    var legendData = this.data ? this.data.legendData : null;
                    var MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
                    if (ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints))
                        return null;
                    return legendData;
                };
                MekkoColumnChart.prototype.hasLegend = function () {
                    return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
                };
                MekkoColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                    switch (options.objectName) {
                        case 'dataPoint':
                            if (!visuals.GradientUtils.hasGradientRole(this.dataViewCat))
                                this.enumerateDataPoints(enumeration);
                            break;
                        case 'labels':
                            this.enumerateDataLabels(enumeration);
                            break;
                    }
                };
                MekkoColumnChart.prototype.enumerateDataLabels = function (enumeration) {
                    var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
                    //Draw default settings
                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, false));
                    if (seriesCount === 0) {
                        return;
                    }
                    //Draw series settings
                    if (!data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata) && this.seriesLabelFormattingEnabled) {
                        for (var i = 0; i < seriesCount; i++) {
                            var series = data.series[i], labelSettings = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;
                            //enumeration.pushContainer({ displayName: series.displayName });
                            visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, true, series));
                        }
                    }
                };
                MekkoColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, isSeries, series) {
                    var is100PctStacked = true;
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !isSeries,
                        displayUnits: is100PctStacked,
                        precision: true,
                        selector: series && series.identity ? series.identity.getSelector() : null
                    };
                };
                MekkoColumnChart.prototype.enumerateDataPoints = function (enumeration) {
                    var data = this.data;
                    if (!data || !data.series) {
                        return;
                    }
                    var seriesCount = data.series.length;
                    if (seriesCount === 0) {
                        return;
                    }
                    if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {
                        for (var i = 0; i < seriesCount; i++) {
                            var series = data.series[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: series.displayName,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: { solid: { color: series.color } }
                                },
                            });
                        }
                    }
                    else {
                        // For single-category, single-measure column charts, the user can color the individual bars.
                        var singleSeriesData = data.series[0].data;
                        var categoryFormatter = data.categoryFormatter;
                        // Add default color and show all slices
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                            }
                        }).pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                showAllDataPoints: !!data.showAllDataPoints
                            }
                        });
                        for (var i = 0; i < singleSeriesData.length; i++) {
                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                                properties: {
                                    fill: { solid: { color: singleSeriesDataPoints.color } }
                                },
                            });
                        }
                    }
                };
                MekkoColumnChart.prototype.calculateAxesProperties = function (options) {
                    var data = this.data;
                    this.currentViewport = options.viewport;
                    var margin = this.margin = options.margin;
                    var origCatgSize = (data && data.categories) ? data.categories.length : 0;
                    var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                        categoryCount: 0,
                        categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                        outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                        isScalar: false
                    };
                    this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null;
                    this.columnChart.setData(data);
                    var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                    /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.
                     In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */
                    if (preferredPlotArea.width === this.currentViewport.width) {
                        preferredPlotArea.width -= (margin.left + margin.right);
                    }
                    preferredPlotArea.height -= (margin.top + margin.bottom);
                    var is100Pct = true;
                    // When the category axis is scrollable the height of the category axis and value axis will be different
                    // The height of the value axis would be same as viewportHeight
                    var chartContext = {
                        height: preferredPlotArea.height,
                        width: preferredPlotArea.width,
                        duration: 0,
                        hostService: this.hostService,
                        mainGraphicsContext: this.mainGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        margin: this.margin,
                        layout: chartLayout,
                        animator: this.animator,
                        interactivityService: this.interactivityService,
                        viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                        viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                        is100Pct: is100Pct,
                        isComboChart: true,
                    };
                    this.ApplyInteractivity(chartContext);
                    this.columnChart.setupVisualProps(chartContext);
                    var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                    if (isBarChart) {
                        var temp = options.forcedXDomain;
                        options.forcedXDomain = options.forcedYDomain;
                        options.forcedYDomain = temp;
                    }
                    this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType);
                    this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType);
                    if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {
                        this.xAxisProperties.axisLabel = data.axesLabels.x;
                    }
                    else {
                        this.xAxisProperties.axisLabel = null;
                    }
                    if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {
                        this.yAxisProperties.axisLabel = data.axesLabels.y;
                    }
                    else {
                        this.yAxisProperties.axisLabel = null;
                    }
                    return [this.xAxisProperties, this.yAxisProperties];
                };
                MekkoColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                    var viewport = {
                        height: this.currentViewport.height,
                        width: this.currentViewport.width
                    };
                    if (this.isScrollable && !isScalar) {
                        var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                        if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                            viewport.height = Math.max(preferredWidth, viewport.height);
                        }
                        else
                            viewport.width = Math.max(preferredWidth, viewport.width);
                    }
                    return viewport;
                };
                MekkoColumnChart.prototype.ApplyInteractivity = function (chartContext) {
                    var _this = this;
                    var interactivity = this.interactivity;
                    if (interactivity) {
                        if (interactivity.dragDataPoint) {
                            chartContext.onDragStart = function (datum) {
                                if (!datum.identity)
                                    return;
                                _this.hostService.onDragStart({
                                    event: d3.event,
                                    data: {
                                        data: datum.identity.getSelector()
                                    }
                                });
                            };
                        }
                        if (interactivity.isInteractiveLegend) {
                            var dragMove = function () {
                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
                                var x = mousePoint[0];
                                var y = mousePoint[1];
                                var index = _this.columnChart.getClosestColumnIndex(x, y);
                                _this.selectColumn(index);
                            };
                            var ColumnChartSvg = visuals.ColumnChart.getInteractiveColumnChartDomElement(this.element);
                            //set click interaction on the visual
                            this.svg.on('click', dragMove);
                            //set click interaction on the background
                            d3.select(ColumnChartSvg).on('click', dragMove);
                            var drag = d3.behavior.drag()
                                .origin(Object)
                                .on("drag", dragMove);
                            //set drag interaction on the visual
                            this.svg.call(drag);
                            //set drag interaction on the background
                            d3.select(ColumnChartSvg).call(drag);
                        }
                    }
                };
                MekkoColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
                    if (force === void 0) { force = false; }
                    if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
                        return; // same column, nothing to do here
                    var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected);
                    var MekkoLegendDataPoints = legendData.dataPoints;
                    this.cartesianVisualHost.updateLegend(legendData);
                    if (MekkoLegendDataPoints.length > 0) {
                        this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
                    }
                    this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                };
                MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function (columnIndex) {
                    var data = this.data;
                    if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) {
                        return { dataPoints: [] };
                    }
                    var formatStringProp = visuals.columnChartProps.general.formatString;
                    var MekkoLegendDataPoints = [];
                    var category = data.categories && data.categories[columnIndex];
                    var allSeries = data.series;
                    var dataPoints = data.legendData && data.legendData.dataPoints;
                    var converterStrategy = new ColumnChartConverterHelper(this.dataViewCat);
                    for (var i = 0, len = allSeries.length; i < len; i++) {
                        var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);
                        var valueMetadata = data.valuesMetadata[i];
                        var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                        var dataPointColor;
                        if (allSeries.length === 1) {
                            var series = allSeries[0];
                            dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                        }
                        else {
                            dataPointColor = dataPoints.length > i && dataPoints[i].color;
                        }
                        MekkoLegendDataPoints.push({
                            color: dataPointColor,
                            icon: visuals.LegendIcon.Box,
                            label: formattedLabel,
                            category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                            identity: visuals.SelectionId.createNull(),
                            selected: false,
                        });
                    }
                    return { dataPoints: MekkoLegendDataPoints };
                };
                MekkoColumnChart.prototype.overrideXScale = function (xProperties) {
                    this.xAxisProperties = xProperties;
                };
                MekkoColumnChart.prototype.render = function (suppressAnimations) {
                    var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);
                    var data = this.data;
                    visuals.TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    var allDataPoints = [];
                    var behaviorOptions = undefined;
                    if (this.interactivityService) {
                        for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                            allDataPoints = allDataPoints.concat(data.series[i].data);
                        }
                        behaviorOptions = {
                            datapoints: allDataPoints,
                            bars: MekkoColumnChartDrawInfo.shapesSelection,
                            hasHighlights: data.hasHighlights,
                            eventGroup: this.mainGraphicsContext,
                            mainGraphicsContext: this.mainGraphicsContext,
                            viewport: MekkoColumnChartDrawInfo.viewport,
                            axisOptions: MekkoColumnChartDrawInfo.axisOptions,
                            showLabel: data.labelSettings.show
                        };
                    }
                    if (this.interactivity && this.interactivity.isInteractiveLegend) {
                        if (this.data.series.length > 0) {
                            this.selectColumn(0, true); // start with the first column
                        }
                    }
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                    return {
                        dataPoints: allDataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
                        labelsAreNumeric: true
                    };
                };
                MekkoColumnChart.prototype.onClearSelection = function () {
                    if (this.interactivityService) {
                        this.interactivityService.clearSelection();
                    }
                };
                MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
                    return this.data ? this.data.scalarCategoryAxis : false;
                };
                MekkoColumnChart.prototype.getSupportedCategoryAxisType = function () {
                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                    var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                    var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                    return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                };
                MekkoColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
                    var data = powerbi.Prototype.inherit(this.data);
                    data.series = visuals.ColumnChart.sliceSeries(data.series, endIndex, startIndex);
                    data.categories = data.categories.slice(startIndex, endIndex);
                    this.columnChart.setData(data);
                    return data;
                };
                MekkoColumnChart.ColumnChartClassName = 'columnChart';
                MekkoColumnChart.SeriesClasses = createClassAndSelector("series");
                MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder");
                return MekkoColumnChart;
            })();
            samples.MekkoColumnChart = MekkoColumnChart;
            var ColumnChartConverterHelper = (function () {
                function ColumnChartConverterHelper(dataView) {
                    this.dataView = dataView;
                }
                ColumnChartConverterHelper.hasRole = function (column, name) {
                    var roles = column.roles;
                    return roles && roles[name];
                };
                ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultColor) {
                    var legend = [];
                    var seriesSources = [];
                    var seriesObjects = [];
                    var grouped = false;
                    var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
                    var legendTitle = undefined;
                    if (this.dataView && this.dataView.values) {
                        var allValues = this.dataView.values;
                        var valueGroups = allValues.grouped();
                        var hasDynamicSeries = !!(allValues && allValues.source);
                        var formatStringProp = visuals.columnChartProps.general.formatString;
                        for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
                            var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
                            for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                                var series = values[valueIndex];
                                var source = series.source;
                                // Gradient measures do not create series.
                                if (ColumnChartConverterHelper.hasRole(source, 'Width') && !ColumnChartConverterHelper.hasRole(source, 'Y')) {
                                    continue;
                                }
                                seriesSources.push(source);
                                seriesObjects.push(series.objects);
                                var selectionId = series.identity ?
                                    visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :
                                    visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
                                var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
                                var color = hasDynamicSeries
                                    ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)
                                    : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                                legend.push({
                                    icon: visuals.LegendIcon.Box,
                                    color: color,
                                    label: label,
                                    identity: selectionId,
                                    selected: false,
                                });
                                if (series.identity && source.groupName !== undefined) {
                                    grouped = true;
                                }
                            }
                        }
                        var dvValues = this.dataView.values;
                        legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                    }
                    var legendData = {
                        title: legendTitle,
                        dataPoints: legend,
                        grouped: grouped,
                    };
                    return {
                        legend: legendData,
                        seriesSources: seriesSources,
                        seriesObjects: seriesObjects,
                    };
                };
                ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
                    return this.dataView.values[series].values[category];
                };
                ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
                    return this.dataView.values[index].source.queryName;
                };
                ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {
                    var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
                    return column && !!column.highlights;
                };
                ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
                    return this.dataView.values[series].highlights[category];
                };
                return ColumnChartConverterHelper;
            })();
            var MekkoChartBehavior = (function () {
                function MekkoChartBehavior(behaviors) {
                    this.behaviors = behaviors;
                }
                MekkoChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    var behaviors = this.behaviors;
                    for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
                        behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                    }
                    options.clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                MekkoChartBehavior.prototype.renderSelection = function (hasSelection) {
                    for (var i = 0; i < this.behaviors.length; i++) {
                        this.behaviors[i].renderSelection(hasSelection);
                    }
                };
                return MekkoChartBehavior;
            })();
            samples.MekkoChartBehavior = MekkoChartBehavior;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            /**
             * RadarChartBehavior
             */
            var RadarChartWebBehavior = (function () {
                function RadarChartWebBehavior() {
                }
                RadarChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    var selection = this.selection = options.selection;
                    var clearCatcher = options.clearCatcher;
                    selection.on('click', function (d) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        d3.event.stopPropagation();
                    });
                    clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                RadarChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                    this.selection.style("opacity", function (d) { return (hasSelection && !d.selected) ? RadarChart.DimmedAreaFillOpacity : RadarChart.AreaFillOpacity; });
                };
                return RadarChartWebBehavior;
            })();
            samples.RadarChartWebBehavior = RadarChartWebBehavior;
            var RadarChart = (function () {
                function RadarChart(options) {
                    if (options) {
                        if (options.svg)
                            this.svg = options.svg;
                        if (options.animator)
                            this.animator = options.animator;
                        if (options.margin)
                            this.margin = options.margin;
                    }
                }
                RadarChart.converter = function (dataView, colors) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !(dataView.categorical.categories.length > 0) ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.values ||
                        !(dataView.categorical.values.length > 0)) {
                        return {
                            legendData: {
                                dataPoints: []
                            },
                            settings: {
                                showLegend: true
                            },
                            series: []
                        };
                    }
                    var catDv = dataView.categorical;
                    var values = catDv.values;
                    var series = [];
                    var colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill);
                    var legendData = {
                        fontSize: 8.25,
                        dataPoints: [],
                        title: ""
                    };
                    for (var i = 0, iLen = values.length; i < iLen; i++) {
                        var color = colors.getColorByIndex(i).value, serieIdentity = void 0, queryName = void 0, displayName = void 0, dataPoints = [];
                        if (values[i].source) {
                            if (values[i].source.queryName) {
                                queryName = values[i].source.queryName;
                                serieIdentity = visuals.SelectionId.createWithMeasure(queryName);
                            }
                            if (values[i].source.displayName)
                                displayName = values[i].source.displayName;
                            if (values[i].source.objects) {
                                var objects = values[i].source.objects;
                                color = colorHelper.getColorForMeasure(objects, queryName);
                            }
                        }
                        legendData.dataPoints.push({
                            label: values[i].source.displayName,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            selected: false,
                            identity: serieIdentity
                        });
                        for (var k = 0, kLen = values[i].values.length; k < kLen; k++) {
                            // Check if the point has empty data
                            if (values[i].values[k] == null)
                                continue;
                            var dataPointIdentity = visuals.SelectionIdBuilder
                                .builder()
                                .withMeasure(queryName)
                                .withCategory(catDv.categories[0], k)
                                .withSeries(dataView.categorical.values, dataView.categorical.values[i])
                                .createSelectionId();
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i);
                            dataPoints.push({
                                x: k,
                                y: values[i].values[k],
                                color: color,
                                identity: dataPointIdentity,
                                selected: false,
                                tooltipInfo: tooltipInfo
                            });
                        }
                        if (dataPoints.length > 0)
                            series.push({
                                fill: color,
                                name: displayName,
                                data: dataPoints,
                                identity: serieIdentity,
                            });
                    }
                    //Parse legend settings          
                    var legendSettings = RadarChart.parseSettings(dataView);
                    return {
                        legendData: legendData,
                        settings: legendSettings,
                        series: series
                    };
                };
                RadarChart.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    if (!this.svg) {
                        this.svg = d3.select(element.get(0)).append('svg');
                        this.svg.style('position', 'absolute');
                    }
                    if (!this.margin)
                        this.margin = RadarChart.DefaultMargin;
                    this.svg.classed(RadarChart.VisualClassName, true);
                    this.interactivityService = visuals.createInteractivityService(options.host);
                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                    this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, true, visuals.LegendPosition.Top);
                    this.colors = options.style.colorPalette.dataColors;
                    this.mainGroupElement = this.svg.append('g');
                    this.segments = this.mainGroupElement
                        .append('g')
                        .classed(RadarChart.Segments.class, true);
                    this.axis = this.mainGroupElement
                        .append('g')
                        .classed(RadarChart.Axis.class, true);
                    this.chart = this.mainGroupElement
                        .append('g')
                        .classed(RadarChart.Chart.class, true);
                };
                RadarChart.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    var dataView = options.dataViews[0];
                    this.radarChartData = RadarChart.converter(dataView, this.colors);
                    var categories = [], series = this.radarChartData.series, dataViewMetadataColumn, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
                    if (dataView.categorical &&
                        dataView.categorical.categories &&
                        dataView.categorical.categories[0] &&
                        dataView.categorical.categories[0].values)
                        categories = dataView.categorical.categories[0].values;
                    if (dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0)
                        dataViewMetadataColumn = dataView.metadata.columns[0];
                    this.viewport = {
                        height: options.viewport.height > 0 ? options.viewport.height : 0,
                        width: options.viewport.width > 0 ? options.viewport.width : 0
                    };
                    this.parseLegendProperties(dataView);
                    this.renderLegend(this.radarChartData);
                    this.updateViewport();
                    this.svg
                        .attr({
                        'height': this.viewport.height,
                        'width': this.viewport.width
                    });
                    var mainGroup = this.mainGroupElement;
                    mainGroup.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                    var width = this.viewport.width - this.margin.left - this.margin.right;
                    var height = this.viewport.height - this.margin.top - this.margin.bottom;
                    this.angle = RadarChart.Radians / categories.length;
                    this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2;
                    this.drawCircularSegments(categories);
                    this.drawAxes(categories);
                    this.drawAxesLabels(categories, dataViewMetadataColumn);
                    this.drawChart(series, duration);
                };
                RadarChart.prototype.drawCircularSegments = function (values) {
                    var data = [];
                    var angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius;
                    for (var level = 0; level < levels - 1; level++) {
                        var levelFactor = radius * ((level + 1) / levels);
                        var transform = -1 * levelFactor;
                        for (var i = 0; i < values.length; i++)
                            data.push({
                                x1: levelFactor * (1 - factor * Math.sin(i * angle)),
                                y1: levelFactor * (1 - factor * Math.cos(i * angle)),
                                x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
                                y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
                                translate: visuals.SVGUtil.translate(transform, transform)
                            });
                    }
                    var selection = this.mainGroupElement
                        .select(RadarChart.Segments.selector)
                        .selectAll(RadarChart.SegmentNode.selector)
                        .data(data);
                    selection
                        .enter()
                        .append('svg:line')
                        .classed(RadarChart.SegmentNode.class, true);
                    selection
                        .attr({ 'x1': function (item) { return item.x1; },
                        'y1': function (item) { return item.y1; },
                        'x2': function (item) { return item.x2; },
                        'y2': function (item) { return item.y2; },
                        'transform': function (item) { return item.translate; } });
                    selection.exit().remove();
                };
                RadarChart.prototype.drawAxes = function (values) {
                    var angle = this.angle, radius = -1 * this.radius;
                    var selection = this.mainGroupElement
                        .select(RadarChart.Axis.selector)
                        .selectAll(RadarChart.AxisNode.selector);
                    var axis = selection.data(values);
                    axis
                        .enter()
                        .append('svg:line');
                    axis
                        .attr({ 'x1': 0,
                        'y1': 0,
                        'x2': function (name, i) { return radius * Math.sin(i * angle); },
                        'y2': function (name, i) { return radius * Math.cos(i * angle); } })
                        .classed(RadarChart.AxisNode.class, true);
                    axis.exit().remove();
                };
                RadarChart.prototype.drawAxesLabels = function (values, dataViewMetadataColumn) {
                    var angle = this.angle, radius = -1 * this.radius, length = values.length;
                    var formatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, true),
                        value: values[0],
                        value2: values[length - 1],
                    });
                    var selection = this.mainGroupElement
                        .select(RadarChart.Axis.selector)
                        .selectAll(RadarChart.AxisLabel.selector);
                    var labels = selection.data(values);
                    labels
                        .enter()
                        .append('svg:text');
                    labels
                        .attr({ 'text-anchor': 'middle',
                        'dy': '1.5em',
                        'transform': visuals.SVGUtil.translate(0, -10),
                        'x': function (name, i) { return (radius - 20) * Math.sin(i * angle); },
                        'y': function (name, i) { return (radius - 10) * Math.cos(i * angle); } })
                        .text(function (item) { return formatter.format(item); })
                        .classed(RadarChart.AxisLabel.class, true);
                    labels.exit().remove();
                };
                RadarChart.prototype.drawChart = function (series, duration) {
                    var angle = this.angle, radius = this.radius, dotRadius = 5, dataPoints = this.getDataPoints(series);
                    var stack = d3.layout.stack();
                    var layers = stack(dataPoints);
                    var y = d3.scale.linear()
                        .domain([0, d3.max(layers, function (layer) {
                            return d3.max(layer, function (d) {
                                return d.y0 + d.y;
                            });
                        })]).range([0, radius]);
                    var calculatePoints = function (points) {
                        return points.map(function (value) {
                            var x1 = -1 * y(value.y) * Math.sin(value.x * angle);
                            var y1 = -1 * y(value.y) * Math.cos(value.x * angle);
                            return x1 + "," + y1;
                        }).join(' ');
                    };
                    var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
                    selection
                        .enter()
                        .append('g')
                        .classed(RadarChart.ChartNode.class, true);
                    var polygon = selection.selectAll(RadarChart.ChartPolygon.selector).data(function (d) {
                        if (d && d.length > 0) {
                            return [d];
                        }
                        return [];
                    });
                    polygon
                        .enter()
                        .append('polygon')
                        .classed(RadarChart.ChartPolygon.class, true);
                    polygon
                        .style('fill', function (d) { return d[0].color; })
                        .style('opacity', RadarChart.DimmedAreaFillOpacity)
                        .on('mouseover', function (d) {
                        d3.select(this).transition()
                            .duration(duration)
                            .style('opacity', RadarChart.AreaFillOpacity);
                    })
                        .on('mouseout', function (d) {
                        d3.select(this).transition()
                            .duration(duration)
                            .style('opacity', RadarChart.DimmedAreaFillOpacity);
                    })
                        .attr('points', calculatePoints);
                    polygon.exit().remove();
                    var dots = selection.selectAll(RadarChart.ChartDot.selector).data(function (d) { return d; });
                    dots.enter()
                        .append('svg:circle')
                        .classed(RadarChart.ChartDot.class, true);
                    dots.attr('r', dotRadius)
                        .attr({
                        'cx': function (value) { return -1 * y(value.y) * Math.sin(value.x * angle); },
                        'cy': function (value) { return -1 * y(value.y) * Math.cos(value.x * angle); }
                    })
                        .style('fill', function (d) { return d.color; });
                    dots.exit().remove();
                    visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    selection.exit().remove();
                    var behaviorOptions = undefined;
                    if (this.interactivityService) {
                        // Register interactivity
                        var dataPointsToBind = this.getAllDataPointsList(series);
                        behaviorOptions = { selection: dots, clearCatcher: this.svg };
                        this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);
                    }
                };
                RadarChart.prototype.renderLegend = function (radarChartData) {
                    if (!radarChartData.legendData)
                        return;
                    var legendData = {
                        title: radarChartData.legendData.title,
                        dataPoints: radarChartData.legendData.dataPoints,
                        fontSize: radarChartData.legendData.fontSize
                    };
                    if (this.legendObjectProperties) {
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        var position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    else
                        this.legend.changeOrientation(visuals.LegendPosition.Top);
                    var viewport = this.viewport;
                    this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                };
                RadarChart.prototype.getDataPoints = function (series) {
                    var dataPoints = [];
                    for (var _i = 0; _i < series.length; _i++) {
                        var serie = series[_i];
                        dataPoints.push(serie.data);
                    }
                    return dataPoints;
                };
                RadarChart.prototype.getAllDataPointsList = function (series) {
                    var dataPoints = [];
                    for (var _i = 0; _i < series.length; _i++) {
                        var serie = series[_i];
                        dataPoints = dataPoints.concat(serie.data);
                    }
                    return dataPoints;
                };
                RadarChart.prototype.parseLegendProperties = function (dataView) {
                    if (!dataView || !dataView.metadata) {
                        this.legendObjectProperties = {};
                        return;
                    }
                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {});
                };
                RadarChart.parseSettings = function (dataView) {
                    var objects;
                    if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.objects)
                        objects = null;
                    else
                        objects = dataView.metadata.objects;
                    return {
                        showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, true)
                    };
                };
                // This function returns the values to be displayed in the property pane for each object.
                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
                // validation and return other values/defaults
                RadarChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    var settings;
                    if (!this.radarChartData || !this.radarChartData.settings)
                        return [];
                    settings = this.radarChartData.settings;
                    switch (options.objectName) {
                        case "legend":
                            enumeration.pushInstance(this.enumerateLegend(settings));
                            break;
                        case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;
                    }
                    return enumeration.complete();
                };
                RadarChart.prototype.enumerateLegend = function (settings) {
                    var showTitle = true, titleText = "", legend, labelColor, fontSize = 8;
                    showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);
                    titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);
                    labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor);
                    fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize);
                    legend = {
                        objectName: "legend",
                        displayName: "legend",
                        selector: null,
                        properties: {
                            show: settings.showLegend,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: fontSize,
                        }
                    };
                    return legend;
                };
                RadarChart.prototype.enumerateDataPoint = function (enumeration) {
                    if (!this.radarChartData || !this.radarChartData.series)
                        return;
                    var series = this.radarChartData.series;
                    for (var _i = 0; _i < series.length; _i++) {
                        var serie = series[_i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: serie.name,
                            selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), false),
                            properties: {
                                fill: { solid: { color: serie.fill } }
                            }
                        });
                    }
                };
                RadarChart.prototype.updateViewport = function () {
                    var legendMargins = this.legend.getMargins(), legendPosition;
                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                            break;
                    }
                };
                RadarChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                        },
                        {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [{ 'Category': { min: 1, max: 1 } }],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [{ bind: { to: 'Y' } }]
                                }
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                    type: { text: true },
                                    suppressFormatPainterCopy: true
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        label: {
                            displayName: 'Label',
                            properties: {
                                fill: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    }
                };
                /** Note: Public for testability */
                RadarChart.formatStringProp = {
                    objectName: 'general',
                    propertyName: 'formatString',
                };
                RadarChart.Properties = {
                    legend: {
                        show: { objectName: 'legend', propertyName: 'show' }
                    },
                    dataPoint: {
                        fill: { objectName: 'dataPoint', propertyName: 'fill' }
                    }
                };
                RadarChart.VisualClassName = 'radarChart';
                RadarChart.Segments = CreateClassAndSelector('segments');
                RadarChart.SegmentNode = CreateClassAndSelector('segmentNode');
                RadarChart.Axis = CreateClassAndSelector('axis');
                RadarChart.AxisNode = CreateClassAndSelector('axisNode');
                RadarChart.AxisLabel = CreateClassAndSelector('axisLabel');
                RadarChart.Chart = CreateClassAndSelector('chart');
                RadarChart.ChartNode = CreateClassAndSelector('chartNode');
                RadarChart.ChartPolygon = CreateClassAndSelector('chartPolygon');
                RadarChart.ChartDot = CreateClassAndSelector('chartDot');
                RadarChart.DefaultMargin = {
                    top: 50,
                    bottom: 50,
                    right: 100,
                    left: 100
                };
                RadarChart.SegmentLevels = 6;
                RadarChart.SegmentFactor = 1;
                RadarChart.Radians = 2 * Math.PI;
                RadarChart.Scale = 1;
                RadarChart.AreaFillOpacity = 1;
                RadarChart.DimmedAreaFillOpacity = 0.4;
                return RadarChart;
            })();
            samples.RadarChart = RadarChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var SankeyDiagram = (function () {
                function SankeyDiagram(constructorOptions) {
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    };
                    this.nodeWidth = 21.5;
                    this.curvatureOfLinks = 0.5;
                    if (constructorOptions) {
                        this.svg = constructorOptions.svg;
                        this.margin = constructorOptions.margin || this.margin;
                        this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks;
                    }
                }
                SankeyDiagram.prototype.init = function (visualsInitOptions) {
                    if (this.svg) {
                        this.root = this.svg;
                    }
                    else {
                        this.root = d3.select(visualsInitOptions.element.get(0))
                            .append("svg");
                    }
                    this.selectionManager = new SelectionManager({ hostServices: visualsInitOptions.host });
                    var style = visualsInitOptions.style;
                    this.colours = style && style.colorPalette
                        ? style.colorPalette.dataColors
                        : new visuals.DataColorPalette();
                    this.root.classed(SankeyDiagram.ClassName, true);
                    this.main = this.root.append("g");
                    this.links = this.main
                        .append("g")
                        .classed(SankeyDiagram.Links["class"], true);
                    this.nodes = this.main
                        .append("g")
                        .classed(SankeyDiagram.Nodes["class"], true);
                    this.textProperties = {
                        fontFamily: this.root.style("font-family"),
                        fontSize: this.root.style("font-size")
                    };
                };
                SankeyDiagram.prototype.update = function (visualUpdateOptions) {
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.dataViews) {
                        return;
                    }
                    var dataView = visualUpdateOptions.dataViews[0], sankeyDiagramDataView;
                    this.updateViewport(visualUpdateOptions.viewport);
                    sankeyDiagramDataView = this.converter(dataView);
                    this.findNodePosition(sankeyDiagramDataView);
                    this.dataView = sankeyDiagramDataView;
                    this.render(sankeyDiagramDataView);
                };
                SankeyDiagram.prototype.updateViewport = function (viewport) {
                    var height, width;
                    height = this.getPositiveNumber(viewport.height);
                    width = this.getPositiveNumber(viewport.width);
                    this.viewport = {
                        height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
                        width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
                    };
                    this.updateElements(height, width);
                };
                SankeyDiagram.prototype.getPositiveNumber = function (value) {
                    return value < 0 || isNaN(value) || value === Infinity || value === -Infinity
                        ? 0
                        : value;
                };
                SankeyDiagram.prototype.updateElements = function (height, width) {
                    this.root.attr({
                        "height": height,
                        "width": width
                    });
                    this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                };
                SankeyDiagram.prototype.converter = function (dataView) {
                    var _this = this;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[1] ||
                        !dataView.categorical.categories[0].values ||
                        !dataView.categorical.categories[1].values) {
                        return {
                            nodes: [],
                            links: [],
                            settings: {
                                scale: { x: 1, y: 1 },
                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels
                            }
                        };
                    }
                    var nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumns = dataView.categorical.values, values = [], allCategories, valueFormatterForCategories, formatOfWeigth = "g", valuesFormatterForWeigth, objects, linksObjects = dataView.categorical.categories[0].objects || [], labelColour, settings, shiftOfColour, identities = [];
                    if (dataView.categorical.categories[0].identity) {
                        identities = identities.concat(dataView.categorical.categories[0].identity);
                    }
                    if (dataView.categorical.categories[1].identity) {
                        identities = identities.concat(dataView.categorical.categories[1].identity);
                    }
                    objects = this.getObjectsFromDataView(dataView);
                    labelColour = this.getColour(SankeyDiagram.Properties["labels"]["fill"], SankeyDiagram.DefaultSettings.colourOfLabels, objects);
                    if (valuesColumns &&
                        valuesColumns[0] &&
                        valuesColumns[0].values &&
                        valuesColumns[0].values.length > 0) {
                        values = valuesColumns[0].values;
                        formatOfWeigth = ValueFormatter.getFormatString(valuesColumns[0].source, SankeyDiagram.Properties["general"]["formatString"]);
                    }
                    dataPoints = categories.map(function (item, index) {
                        var weigth = values[index] || 1;
                        return {
                            source: item,
                            destination: secondCategories[index],
                            weigth: weigth
                        };
                    });
                    allCategories = categories.concat(secondCategories);
                    valueFormatterForCategories = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties["general"]["formatString"]),
                        value: allCategories[0],
                        value2: allCategories[allCategories.length - 1]
                    });
                    valuesFormatterForWeigth = ValueFormatter.create({
                        format: formatOfWeigth,
                        value: values[0] || 1,
                        value2: d3.max(values) || 1
                    });
                    allCategories.forEach(function (item, index) {
                        if (!nodes.some(function (node) {
                            if (item === node.label.name) {
                                node.selectionIds.push(visuals.SelectionId.createWithId(identities[index]));
                                return true;
                            }
                            return false;
                        })) {
                            var formattedValue = valueFormatterForCategories.format(item), label, selectionId, textProperties = {
                                text: formattedValue,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            };
                            label = {
                                name: item,
                                formattedName: valueFormatterForCategories.format(item),
                                width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                                height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
                                colour: labelColour
                            };
                            selectionId = visuals.SelectionId.createWithId(identities[index]);
                            nodes.push({
                                label: label,
                                links: [],
                                weigth: 0,
                                width: _this.nodeWidth,
                                height: 0,
                                colour: SankeyDiagram.DefaultColourOfNode,
                                tooltipData: [],
                                selectionIds: [selectionId]
                            });
                        }
                    });
                    shiftOfColour = this.colours.getAllColors().length / nodes.length;
                    nodes.forEach(function (node, index) {
                        node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
                    });
                    dataPoints.forEach(function (dataPoint, index) {
                        var sourceNode, destinationNode, link, linkColour;
                        if (dataPoint.source === dataPoint.destination) {
                            return;
                        }
                        nodes.forEach(function (node) {
                            if (node.label.name === dataPoint.source) {
                                sourceNode = node;
                            }
                            if (node.label.name === dataPoint.destination) {
                                destinationNode = node;
                            }
                        });
                        linkColour = _this.getColour(SankeyDiagram.Properties["links"]["fill"], SankeyDiagram.DefaultColourOfLink, linksObjects[index]);
                        link = {
                            source: sourceNode,
                            destination: destinationNode,
                            weigth: dataPoint.weigth,
                            height: dataPoint.weigth,
                            colour: linkColour,
                            tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
                            selectionId: visuals.SelectionId.createWithId(identities[index])
                        };
                        links.push(link);
                        sourceNode.links.push(link);
                        destinationNode.links.push(link);
                        _this.updateValueOfNode(sourceNode);
                        _this.updateValueOfNode(destinationNode);
                        sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.weigth);
                        destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.weigth);
                    });
                    settings = this.parseSettings(objects);
                    settings.colourOfLabels = labelColour;
                    return {
                        nodes: nodes,
                        links: links,
                        settings: settings
                    };
                };
                SankeyDiagram.prototype.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                SankeyDiagram.prototype.getColour = function (properties, defaultColor, objects) {
                    var colorHelper;
                    colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor);
                    return colorHelper.getColorForMeasure(objects, "");
                };
                SankeyDiagram.prototype.getTooltipDataForLink = function (valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
                    var formattedLinkWeight;
                    if (valueFormatter && valueFormatter.format) {
                        formattedLinkWeight = valueFormatter.format(linkWeight);
                    }
                    else {
                        formattedLinkWeight = linkWeight.toString();
                    }
                    return [{
                            displayName: SankeyDiagram.RoleNames.rows,
                            value: sourceNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.columns,
                            value: destinationNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedLinkWeight
                        }];
                };
                SankeyDiagram.prototype.updateValueOfNode = function (node) {
                    node.weigth = node.links.reduce(function (previousValue, currentValue) {
                        return previousValue + currentValue.weigth;
                    }, 0);
                };
                SankeyDiagram.prototype.getTooltipForNode = function (valueFormatter, nodeName, nodeWeight) {
                    var formattedNodeWeigth;
                    if (valueFormatter && valueFormatter.format) {
                        formattedNodeWeigth = valueFormatter.format(nodeWeight);
                    }
                    else {
                        formattedNodeWeigth = nodeWeight.toString();
                    }
                    return [{
                            displayName: "Name",
                            value: nodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedNodeWeigth
                        }];
                };
                SankeyDiagram.prototype.parseSettings = function (objects) {
                    var isVisibleLabels = false;
                    isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties["labels"]["show"], SankeyDiagram.DefaultSettings.isVisibleLabels);
                    return {
                        isVisibleLabels: isVisibleLabels,
                        scale: {
                            x: SankeyDiagram.DefaultSettings.scale.x,
                            y: SankeyDiagram.DefaultSettings.scale.y
                        },
                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels
                    };
                };
                SankeyDiagram.prototype.findNodePosition = function (sankeyDiagramDataView) {
                    this.findNodePositionByX(sankeyDiagramDataView);
                    this.findNodePositionByY(sankeyDiagramDataView);
                };
                SankeyDiagram.prototype.findNodePositionByX = function (sankeyDiagramDataView) {
                    var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = false;
                    while (nodes.length > 0) {
                        nextNodes = [];
                        nodes.forEach(function (node) {
                            node.x = x;
                            node.links.forEach(function (link) {
                                if (node === link.source && node !== link.destination) {
                                    if (nextNodes.every(function (item) {
                                        return item !== link.destination;
                                    })) {
                                        nextNodes.push(link.destination);
                                    }
                                }
                            });
                        });
                        isRecursiveDependencies = nextNodes.length === previousNodes.length &&
                            previousNodes.every(function (previousNode) {
                                return nextNodes.some(function (nextNode) {
                                    return nextNode === previousNode;
                                });
                            });
                        if (isRecursiveDependencies) {
                            previousNodes.forEach(function (element) {
                                element.x = x;
                                x++;
                            });
                            nodes = [];
                        }
                        else {
                            nodes = nextNodes;
                            previousNodes = nodes;
                            x++;
                        }
                    }
                    sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1);
                    this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);
                };
                SankeyDiagram.prototype.scaleByAxisX = function (nodes, scale) {
                    nodes.forEach(function (node) {
                        node.x *= scale;
                    });
                };
                SankeyDiagram.prototype.getScaleByAxisX = function (numberOfColumns) {
                    if (numberOfColumns === void 0) { numberOfColumns = 1; }
                    return this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
                };
                SankeyDiagram.prototype.findNodePositionByY = function (sankeyDiagramDataView) {
                    var nodes = sankeyDiagramDataView.nodes, links = sankeyDiagramDataView.links, currentX = 0, index = 0, maxIndex = 0, sumValueOfNodes = 0, maxValueOfNodes = 0;
                    nodes = nodes.sort(function (firstNode, secondNode) {
                        return firstNode.x - secondNode.x;
                    });
                    nodes.forEach(function (node) {
                        var sumWeightOfLeftNodes = 0, sumWeightOfRightNodes = 0;
                        node.links.forEach(function (link) {
                            if (link.destination.x > node.x || link.source.x > node.x) {
                                sumWeightOfRightNodes += link.weigth;
                            }
                            else if (link.destination.x < node.x || link.source.x < node.x) {
                                sumWeightOfLeftNodes += link.weigth;
                            }
                        });
                        node.weigth = Math.max(sumWeightOfLeftNodes, sumWeightOfRightNodes);
                        if (currentX !== node.x) {
                            index = 0;
                            currentX = node.x;
                            sumValueOfNodes = 0;
                        }
                        sumValueOfNodes += node.weigth;
                        if (sumValueOfNodes > maxValueOfNodes) {
                            maxValueOfNodes = sumValueOfNodes;
                        }
                        if (index > maxIndex) {
                            maxIndex = index;
                        }
                        index++;
                    });
                    sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes);
                    this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);
                };
                SankeyDiagram.prototype.getScaleByAxisY = function (numberOfRows, sumValueOfNodes) {
                    return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);
                };
                SankeyDiagram.prototype.scaleByAxisY = function (nodes, links, scale) {
                    var shiftByAxisY = 0, currentX = 0, index = 0;
                    nodes.forEach(function (node) {
                        if (currentX !== node.x) {
                            currentX = node.x;
                            shiftByAxisY = 0;
                            index = 0;
                        }
                        node.height = node.weigth * scale;
                        node.y = shiftByAxisY + SankeyDiagram.NodePadding * index;
                        shiftByAxisY += node.height;
                        index++;
                    });
                    nodes.forEach(function (node) {
                        node.links = node.links.sort(function (firstLink, secondLink) {
                            var firstY, secondY;
                            firstY = firstLink.source === node
                                ? firstLink.destination.y
                                : firstLink.source.y;
                            secondY = secondLink.source === node
                                ? secondLink.destination.y
                                : secondLink.source.y;
                            return firstY - secondY;
                        });
                        var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
                        node.links.forEach(function (link) {
                            var shiftByAxisY = 0;
                            link.height = link.weigth * scale;
                            if (link.source.x < node.x || link.destination.x < node.x) {
                                shiftByAxisY = shiftByAxisYOfLeftLink;
                                shiftByAxisYOfLeftLink += link.height;
                            }
                            else if (link.source.x > node.x || link.destination.x > node.x) {
                                shiftByAxisY = shiftByAxisYOfRightLink;
                                shiftByAxisYOfRightLink += link.height;
                            }
                            if (link.source === node) {
                                link.dySource = shiftByAxisY;
                            }
                            else if (link.destination === node) {
                                link.dyDestination = shiftByAxisY;
                            }
                        });
                    });
                };
                SankeyDiagram.prototype.render = function (sankeyDiagramDataView) {
                    var nodesSelection, linksSelection;
                    linksSelection = this.renderLinks(sankeyDiagramDataView);
                    nodesSelection = this.renderNodes(sankeyDiagramDataView);
                    this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
                };
                SankeyDiagram.prototype.renderNodes = function (sankeyDiagramDataView) {
                    var _this = this;
                    var nodesEnterSelection, nodesSelection, nodeElements;
                    nodeElements = this.main
                        .select(SankeyDiagram.Nodes.selector)
                        .selectAll(SankeyDiagram.Node.selector);
                    nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes);
                    nodesEnterSelection = nodesSelection
                        .enter()
                        .append("g");
                    nodesSelection
                        .attr("transform", function (node) {
                        return visuals.SVGUtil.translate(node.x, node.y);
                    })
                        .classed(SankeyDiagram.Node["class"], true);
                    nodesEnterSelection
                        .append("rect")
                        .classed(SankeyDiagram.NodeRect["class"], true);
                    nodesEnterSelection
                        .append("text")
                        .classed(SankeyDiagram.NodeLabel["class"], true);
                    nodesSelection
                        .select(SankeyDiagram.NodeRect.selector)
                        .style({
                        "fill": function (node) { return node.colour; },
                        "stroke": function (node) { return d3.rgb(node.colour).darker(1.5); }
                    })
                        .attr({
                        x: 0,
                        y: 0,
                        height: function (node) { return node.height; },
                        width: function (node) { return node.width; }
                    });
                    nodesSelection
                        .select(SankeyDiagram.NodeLabel.selector)
                        .attr({
                        x: function (node) { return _this.getLabelPositionByAxisX(node); },
                        y: function (node) { return node.height / 2; },
                        dy: "0.35em"
                    })
                        .style("fill", function (node) { return node.label.colour; })
                        .style("display", function (node) {
                        var isNotVisibleLabel = false, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
                        isNotVisibleLabel =
                            labelPositionByAxisX >= _this.viewport.width ||
                                labelPositionByAxisX <= 0 ||
                                (node.height + SankeyDiagram.NodePadding) < node.label.height;
                        if (isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels
                            || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel) {
                            return "none";
                        }
                        return null;
                    })
                        .style("text-anchor", function (node) {
                        if (_this.isLabelLargerWidth(node)) {
                            return "end";
                        }
                        return null;
                    })
                        .text(function (node) {
                        var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;
                        if (_this.getCurrentPositionOfLabelByAxisX(node) > maxWidth) {
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault({
                                text: node.label.formattedName,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            }, maxWidth);
                        }
                        return node.label.formattedName;
                    });
                    nodesSelection
                        .exit()
                        .remove();
                    this.renderTooltip(nodesSelection);
                    return nodesSelection;
                };
                SankeyDiagram.prototype.getLabelPositionByAxisX = function (node) {
                    if (this.isLabelLargerWidth(node)) {
                        return -(SankeyDiagram.LabelPadding);
                    }
                    return node.width + SankeyDiagram.LabelPadding;
                };
                SankeyDiagram.prototype.isLabelLargerWidth = function (node) {
                    var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelPadding;
                    return shiftByAxisX + node.label.width > this.viewport.width;
                };
                SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function (node) {
                    var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
                    labelPositionByAxisX = labelPositionByAxisX > 0
                        ? labelPositionByAxisX + node.x + node.label.width + node.width
                        : node.x + labelPositionByAxisX - node.label.width - node.width;
                    return labelPositionByAxisX;
                };
                SankeyDiagram.prototype.renderLinks = function (sankeyDiagramDataView) {
                    var _this = this;
                    var linksSelection, linksElements;
                    linksElements = this.main
                        .select(SankeyDiagram.Links.selector)
                        .selectAll(SankeyDiagram.Link.selector);
                    linksSelection = linksElements.data(sankeyDiagramDataView.links);
                    linksSelection
                        .enter()
                        .append("path")
                        .classed(SankeyDiagram.Link["class"], true);
                    linksSelection
                        .attr("d", function (link) {
                        return _this.getSvgPath(link);
                    })
                        .style({
                        "stroke-width": function (link) { return link.height; },
                        "stroke": function (link) { return link.colour; }
                    });
                    linksSelection
                        .exit()
                        .remove();
                    this.renderTooltip(linksSelection);
                    return linksSelection;
                };
                SankeyDiagram.prototype.getSvgPath = function (link) {
                    var x0, x1, xi, x2, x3, y0, y1;
                    if (link.destination.x < link.source.x) {
                        x0 = link.source.x;
                        x1 = link.destination.x + link.destination.width;
                    }
                    else {
                        x0 = link.source.x + link.source.width;
                        x1 = link.destination.x;
                    }
                    xi = d3.interpolateNumber(x0, x1);
                    x2 = xi(this.curvatureOfLinks);
                    x3 = xi(1 - this.curvatureOfLinks);
                    y0 = link.source.y + link.dySource + link.height / 2;
                    y1 = link.destination.y + link.dyDestination + link.height / 2;
                    return "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
                };
                SankeyDiagram.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipData;
                    });
                };
                SankeyDiagram.prototype.bindSelectionHandler = function (sankeyDiagramDataView, nodesSelection, linksSelection) {
                    var _this = this;
                    nodesSelection.on("click", function (node) {
                        _this.selectionManager.clear();
                        node.selectionIds.forEach(function (selectionId) {
                            _this.selectionManager.select(selectionId, true).then(function (selectionIds) {
                                if (selectionIds.length > 0) {
                                    _this.setSelection(nodesSelection, linksSelection, [node], node.links);
                                }
                                else {
                                    _this.setSelection(nodesSelection, linksSelection);
                                }
                            });
                        });
                        d3.event.stopPropagation();
                    });
                    linksSelection.on("click", function (link) {
                        _this.selectionManager.clear();
                        _this.selectionManager.select(link.selectionId).then(function (selectionIds) {
                            if (selectionIds.length > 0) {
                                _this.setSelection(nodesSelection, linksSelection, [link.source, link.destination], [link]);
                            }
                            else {
                                _this.setSelection(nodesSelection, linksSelection);
                            }
                        });
                        d3.event.stopPropagation();
                    });
                    this.root.on("click", function () {
                        _this.selectionManager.clear();
                        _this.setSelection(nodesSelection, linksSelection);
                    });
                };
                SankeyDiagram.prototype.setSelection = function (nodes, links, selectedNodes, selectedLinks) {
                    if (selectedNodes === void 0) { selectedNodes = []; }
                    if (selectedLinks === void 0) { selectedLinks = []; }
                    nodes.style("opacity", null);
                    links.style("stroke-opacity", null);
                    if (selectedNodes.length === 0) {
                        return;
                    }
                    nodes.filter(function (node) {
                        return !selectedNodes.some(function (selectedNode) {
                            return node === selectedNode;
                        });
                    })
                        .style("opacity", SankeyDiagram.OpacityOfSelectionNode);
                    links.filter(function (link) {
                        return selectedLinks.some(function (linkOfSelection) {
                            return link === linkOfSelection;
                        });
                    })
                        .style("stroke-opacity", SankeyDiagram.OpacityOfSelectionLink);
                };
                SankeyDiagram.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    if (!this.dataView) {
                        return [];
                    }
                    switch (options.objectName) {
                        case "labels": {
                            this.enumerateLabels(enumeration);
                            break;
                        }
                        case "links": {
                            this.enumerateLinks(enumeration);
                            break;
                        }
                    }
                    return enumeration.complete();
                };
                SankeyDiagram.prototype.enumerateLabels = function (enumeration) {
                    var settings = this.dataView.settings, labels;
                    if (!settings) {
                        return;
                    }
                    labels = {
                        objectName: "labels",
                        displayName: "labels",
                        selector: null,
                        properties: {
                            show: settings.isVisibleLabels,
                            fill: settings.colourOfLabels
                        }
                    };
                    enumeration.pushInstance(labels);
                };
                SankeyDiagram.prototype.enumerateLinks = function (enumeration) {
                    var links = this.dataView.links;
                    if (!links || !(links.length > 0)) {
                        return;
                    }
                    links.forEach(function (link) {
                        enumeration.pushInstance({
                            objectName: "links",
                            displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
                            selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), false),
                            properties: {
                                fill: { solid: { color: link.colour } }
                            }
                        });
                    });
                };
                SankeyDiagram.ClassName = "sankeyDiagram";
                SankeyDiagram.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        fill: {
                            objectName: "labels",
                            propertyName: "fill"
                        }
                    },
                    links: {
                        fill: {
                            objectName: "links",
                            propertyName: "fill"
                        }
                    }
                };
                SankeyDiagram.Nodes = {
                    "class": "nodes",
                    selector: ".nodes"
                };
                SankeyDiagram.Node = {
                    "class": "node",
                    selector: ".node"
                };
                SankeyDiagram.NodeRect = {
                    "class": "nodeRect",
                    selector: ".nodeRect"
                };
                SankeyDiagram.NodeLabel = {
                    "class": "nodeLabel",
                    selector: ".nodeLabel"
                };
                SankeyDiagram.Links = {
                    "class": "links",
                    selector: ".links"
                };
                SankeyDiagram.Link = {
                    "class": "link",
                    selector: ".link"
                };
                SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)";
                SankeyDiagram.DefaultColourOfLink = "black";
                SankeyDiagram.DefaultSettings = {
                    isVisibleLabels: true,
                    scale: { x: 1, y: 1 },
                    colourOfLabels: "black"
                };
                SankeyDiagram.MinWidthOfLabel = 35;
                SankeyDiagram.NodePadding = 5;
                SankeyDiagram.LabelPadding = 4;
                SankeyDiagram.OpacityOfSelectionNode = 0.3;
                SankeyDiagram.OpacityOfSelectionLink = 0.5;
                SankeyDiagram.RoleNames = {
                    rows: "Source",
                    columns: "Destination",
                    values: "Weight"
                };
                SankeyDiagram.capabilities = {
                    dataRoles: [{
                            name: SankeyDiagram.RoleNames.rows,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.rows
                        }, {
                            name: SankeyDiagram.RoleNames.columns,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.columns
                        }, {
                            name: SankeyDiagram.RoleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: SankeyDiagram.RoleNames.values
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { "Source": { min: 0, max: 1 }, "Destination": { min: 0, max: 1 }, "Weight": { min: 0, max: 0 } },
                                { "Source": { min: 0, max: 1 }, "Destination": { min: 0, max: 1 }, "Weight": { min: 1, max: 1 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: SankeyDiagram.RoleNames.rows },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: SankeyDiagram.RoleNames.columns } },
                                        { bind: { to: SankeyDiagram.RoleNames.values } }
                                    ]
                                }
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: { type: { formatting: { formatString: true } } }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        links: {
                            displayName: "Links",
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    }
                };
                return SankeyDiagram;
            })();
            samples.SankeyDiagram = SankeyDiagram;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var SelectionManager = visuals.utility.SelectionManager;
            var StreamGraph = (function () {
                function StreamGraph() {
                    this.margin = { left: 45, right: 30, bottom: 25, top: 25 };
                }
                StreamGraph.prototype.converter = function (dataView, colors) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.values ||
                        !dataView.categorical.categories) {
                        return null;
                    }
                    var catDv = dataView.categorical, values = catDv.values, dataPoints = [], legendData = {
                        dataPoints: [],
                        title: values[0].source.displayName,
                        fontSize: parseInt(this.fontSize, 10) * 3 / 4
                    }, categoriesValues = [], value = 0, valueFormatter;
                    for (var i = 0, iLen = values.length; i < iLen; i++) {
                        dataPoints.push([]);
                        if (values[i].source.groupName) {
                            legendData.dataPoints.push({
                                label: values[i].source.groupName,
                                color: colors.getColorByIndex(i).value,
                                icon: visuals.LegendIcon.Box,
                                selected: false,
                                identity: visuals.SelectionId.createWithId(values[i].identity)
                            });
                        }
                        for (var k = 0, kLen = values[i].values.length; k < kLen; k++) {
                            var id = visuals.SelectionIdBuilder
                                .builder()
                                .withSeries(dataView.categorical.values, dataView.categorical.values[i])
                                .createSelectionId(), y = values[i].values[k];
                            if (y > value) {
                                value = y;
                            }
                            dataPoints[i].push({
                                x: k,
                                y: y,
                                identity: id
                            });
                        }
                    }
                    valueFormatter = ValueFormatter.create({
                        format: "g",
                        value: value
                    });
                    if (catDv.categories &&
                        catDv.categories[0] &&
                        catDv.categories[0].values) {
                        categoriesValues = catDv.categories[0].values;
                    }
                    return {
                        dataPoints: dataPoints,
                        legendData: legendData,
                        valueFormatter: valueFormatter,
                        axisXData: this.parseAxisXData(catDv.categories[0].source, categoriesValues)
                    };
                };
                StreamGraph.prototype.parseAxisXData = function (source, values) {
                    var maxNumverOfValues = StreamGraph.MaxNumberOfAxisXValues;
                    if (!values || !(values.length > 0)) {
                        return {
                            valueFormatter: null,
                            values: [],
                            maxNumverOfValues: maxNumverOfValues
                        };
                    }
                    var scale, valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(source, StreamGraph.Properties["general"]["formatString"]),
                        value: values[0]
                    }), range = [this.margin.left, this.viewport.width - this.margin.right], filteredValues = values;
                    if (source.type.dateTime) {
                        scale = d3.time.scale();
                        scale.domain([values[0], values[values.length - 1]]);
                        scale.range(range);
                    }
                    else if (source.type.numeric) {
                        scale = d3.scale.linear();
                        scale.domain([values[0], values[values.length - 1]]);
                        scale.range(range);
                    }
                    else {
                        scale = d3.scale.ordinal();
                        scale.domain(values);
                        scale.rangePoints(range);
                    }
                    return {
                        valueFormatter: valueFormatter,
                        values: filteredValues,
                        maxNumverOfValues: maxNumverOfValues,
                        scale: scale
                    };
                };
                StreamGraph.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.svg = d3.select(element.get(0))
                        .append('svg')
                        .classed(StreamGraph.VisualClassName, true);
                    this.xAxis = this.svg.append("g");
                    this.yAxis = this.svg.append("g");
                    this.colors = options.style.colorPalette.dataColors;
                    this.legend = visuals.createLegend(element, false, null, true);
                };
                StreamGraph.prototype.update = function (options) {
                    var _this = this;
                    if (!options.dataViews || !options.dataViews[0]) {
                        return;
                    }
                    ;
                    this.viewport = {
                        width: Math.max(0, options.viewport.width),
                        height: Math.max(0, options.viewport.height)
                    };
                    var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.converter(dataView, this.colors);
                    if (!data || !data.dataPoints || !data.dataPoints.length) {
                        this.svg.selectAll(StreamGraph.Layer.selector).remove();
                        return;
                    }
                    var dataPoints = data.dataPoints;
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                    this.legend.drawLegend(data.legendData, this.viewport);
                    var height = Math.max(0, options.viewport.height - this.margin.top);
                    this.svg.attr({
                        'width': this.viewport.width,
                        'height': height
                    });
                    var stack = d3.layout.stack();
                    if (this.getWiggle(dataView)) {
                        stack.offset('wiggle');
                    }
                    var layers = stack(dataPoints);
                    var xScale = d3.scale.linear()
                        .domain([0, dataPoints[0].length - 1])
                        .range([this.margin.left, this.viewport.width - this.margin.right]);
                    var yScale = d3.scale.linear()
                        .domain([0, d3.max(layers, function (layer) {
                            return d3.max(layer, function (d) {
                                return d.y0 + d.y;
                            });
                        })])
                        .range([height - this.margin.bottom, this.margin.top]);
                    var area = d3.svg.area()
                        .interpolate('basis')
                        .x(function (d) { return xScale(d.x); })
                        .y0(function (d) { return yScale(d.y0); })
                        .y1(function (d) { return yScale(d.y0 + d.y); });
                    var selectionManager = this.selectionManager;
                    var selection = this.svg.selectAll(StreamGraph.Layer.selector)
                        .data(layers);
                    selection.enter()
                        .append('path')
                        .classed(StreamGraph.Layer["class"], true);
                    selection
                        .style("fill", function (d, i) { return _this.colors.getColorByIndex(i).value; })
                        .on('click', function (d) {
                        var _this = this;
                        selectionManager.select(d[0].identity).then(function (ids) {
                            if (ids.length > 0) {
                                selection.style('opacity', 0.5);
                                d3.select(_this).style('opacity', 1);
                            }
                            else {
                                selection.style('opacity', 1);
                            }
                        });
                    })
                        .transition()
                        .duration(duration)
                        .attr("d", area);
                    selection.exit().remove();
                    this.drawAxis(data, yScale);
                };
                StreamGraph.prototype.drawAxis = function (data, yScale) {
                    var _this = this;
                    var shiftY = this.viewport.height - this.margin.bottom - this.margin.top, shiftX = this.viewport.width - this.margin.left - this.margin.right, textPropertiesFunction = this.getTextPropertiesFunction(), xAxis = d3.svg.axis();
                    xAxis.scale(data.axisXData.scale)
                        .orient("bottom")
                        .tickFormat((function (item, index) {
                        if (data.axisXData.valueFormatter) {
                            item = data.axisXData.valueFormatter.format(item);
                        }
                        if (index != null && xAxis.tickValues() &&
                            (index === 0 || index === xAxis.tickValues().length - 1)) {
                            item = powerbi.TextMeasurementService.getTailoredTextOrDefault(textPropertiesFunction(item), (index ? _this.margin.right : _this.margin.left) * 2);
                        }
                        return item;
                    }).bind(xAxis));
                    var yAxis = d3.svg.axis()
                        .scale(yScale)
                        .orient("left")
                        .tickFormat(function (item) {
                        if (data.valueFormatter) {
                            return data.valueFormatter.format(item);
                        }
                        return item;
                    });
                    this.setMaxTicks(xAxis, shiftX, data.axisXData.maxNumverOfValues);
                    this.setMaxTicks(yAxis, shiftY);
                    this.xAxis.attr("class", "x axis")
                        .attr("transform", visuals.SVGUtil.translate(0, shiftY))
                        .call(xAxis);
                    this.yAxis.attr("class", "y axis")
                        .attr("transform", visuals.SVGUtil.translate(this.margin.left, 0))
                        .call(yAxis);
                };
                StreamGraph.prototype.setMaxTicks = function (axis, maxSize, maxValue) {
                    var maxTicks = maxValue === undefined
                        ? this.getTicksByAxis(axis).length
                        : Math.min(maxValue, this.getTicksByAxis(axis).length);
                    if (axis.scale().domain.toString() === d3.scale.linear().domain.toString()) {
                        axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks));
                    }
                    else {
                        axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
                    }
                };
                StreamGraph.prototype.getFittedTickLength = function (axis, maxSize, maxTicks) {
                    for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([maxTicks]).length > maxTicks); maxTicks--, ticks = this.getTicksByAxis(axis)) {
                        axis.ticks(maxTicks);
                    }
                    return maxTicks;
                };
                StreamGraph.prototype.getFittedTickValues = function (axis, maxSize, maxTicks) {
                    var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks);
                    for (var currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, indexes = []) {
                        switch (currentMaxTicks) {
                            case 0:
                                return [];
                            case 1:
                                indexes = [0];
                                break;
                            case 2:
                                indexes = [0, ticks.length - 1];
                                break;
                            default:
                                var takeEvery = ticks.length / (currentMaxTicks - 1);
                                for (var i = 0; i < currentMaxTicks - 1; i++) {
                                    indexes.push(Math.round(takeEvery * i));
                                }
                                indexes.push(ticks.length - 1);
                                break;
                        }
                        var ticksIndexes = indexes.map(function (x) { return [ticks[x], x]; }), maxWidthOf2Ticks = (maxSize / ticks.length) * 2, tickPairsWidths = [];
                        ticksIndexes.reduce(function (a, b) {
                            tickPairsWidths.push([measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks]);
                            return b;
                        });
                        if (!tickPairsWidths.some(function (x) { return x[0] > x[1]; })) {
                            return ticksIndexes.map(function (x) { return x[0]; });
                        }
                    }
                    return [];
                };
                StreamGraph.prototype.measureTicks = function (ticks, measureTickFunction) {
                    return ticks.map(function (x) { return measureTickFunction(x); }).reduce(function (a, b) { return a + b; });
                };
                StreamGraph.prototype.getTicksByAxis = function (axis) {
                    var scale = axis.scale();
                    var result = axis.tickValues() === null
                        ? scale.ticks
                            ? scale.ticks.apply(scale, axis.ticks())
                            : scale.domain()
                        : axis.tickValues();
                    return result.length === undefined ? [result] : result;
                };
                StreamGraph.prototype.getMeasureTickFunction = function (axis, ticks) {
                    var measureFunction = axis.orient() === "top" || axis.orient() === "bottom"
                        ? powerbi.TextMeasurementService.measureSvgTextWidth
                        : powerbi.TextMeasurementService.measureSvgTextHeight;
                    var textPropertiesFunction = this.getTextPropertiesFunction(), cache = {};
                    return function (x) {
                        return cache[x]
                            ? cache[x]
                            : cache[x] = measureFunction(textPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
                    };
                };
                StreamGraph.prototype.getTextPropertiesFunction = function () {
                    var fontFamily = this.fontFamily, fontSize = this.fontSize, fontWeight = this.fontWeight;
                    return function (text) {
                        return { text: text, fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight };
                    };
                };
                Object.defineProperty(StreamGraph.prototype, "fontSize", {
                    get: function () {
                        return this.svg.style('font-size');
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StreamGraph.prototype, "fontFamily", {
                    get: function () {
                        return this.svg.style('font-family');
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StreamGraph.prototype, "fontWeight", {
                    get: function () {
                        return this.svg.style('font-weight');
                    },
                    enumerable: true,
                    configurable: true
                });
                StreamGraph.prototype.getWiggle = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                return general['wiggle'];
                            }
                        }
                    }
                    return true;
                };
                StreamGraph.prototype.enumerateObjectInstances = function (options) {
                    var instances = [], dataView = this.dataView;
                    switch (options.objectName) {
                        case 'general':
                            var general = {
                                objectName: 'general',
                                displayName: 'General',
                                selector: null,
                                properties: {
                                    wiggle: this.getWiggle(dataView)
                                }
                            };
                            instances.push(general);
                            break;
                    }
                    return instances;
                };
                StreamGraph.VisualClassName = 'streamGraph';
                StreamGraph.Properties = {
                    general: {
                        formatString: {
                            objectName: 'general',
                            propertyName: 'formatString'
                        }
                    }
                };
                StreamGraph.Layer = {
                    'class': 'layer',
                    selector: '.layer'
                };
                StreamGraph.MaxNumberOfAxisXValues = 5;
                StreamGraph.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category',
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Series',
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Series': { max: 0 } },
                                { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { bottom: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [{ for: { in: 'Y' } }],
                                        dataReductionAlgorithm: { bottom: {} }
                                    }
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: 'General',
                            properties: {
                                formatString: { type: { formatting: { formatString: true } } },
                                wiggle: {
                                    type: { bool: true },
                                    displayName: 'Wiggle'
                                }
                            }
                        }
                    }
                };
                return StreamGraph;
            })();
            samples.StreamGraph = StreamGraph;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            samples.sunburstRoleNames = {
                nodes: 'Nodes',
                values: 'Values',
            };
            var Sunburst = (function () {
                function Sunburst() {
                    this.total = 0;
                }
                Sunburst.prototype.init = function (options) {
                    var _this = this;
                    this.arc = d3.svg.arc()
                        .startAngle(function (d) { return d.x; })
                        .endAngle(function (d) { return d.x + d.dx; })
                        .innerRadius(function (d) { return Math.sqrt(d.y); })
                        .outerRadius(function (d) { return Math.sqrt(d.y + d.dy); });
                    this.colors = options.style.colorPalette.dataColors;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.svg = d3.select(options.element.get(0)).append('svg');
                    this.svg.classed('mainDrawArea', true);
                    this.g = this.svg.append('g');
                    this.g.classed("container", true);
                    this.svg.append("text")
                        .classed("sunBurstPercentageFixed", true);
                    this.svg.on('mousedown', function (d) {
                        _this.svg.selectAll("path").style("opacity", 1);
                        _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0);
                        _this.selectionManager.clear();
                    });
                };
                Sunburst.setAllUnhide = function (selection) {
                    selection.attr("setUnHide", "true");
                };
                Sunburst.prototype.update = function (options) {
                    if (options.dataViews.length > 0) {
                        var data = this.converter(options.dataViews[0], this.colors);
                        this.viewport = options.viewport;
                        this.updateInternal(data);
                    }
                };
                Sunburst.prototype.updateInternal = function (dataRootNode) {
                    var _this = this;
                    this.svg.attr({
                        'height': this.viewport.height,
                        'width': this.viewport.width
                    });
                    this.g.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                    var radius = Math.min(this.viewport.width, this.viewport.height) / 2;
                    var partition = d3.layout.partition()
                        .size([2 * Math.PI, radius * radius])
                        .value(function (d) { return d.value; });
                    var path = this.g.datum(dataRootNode).selectAll("path")
                        .data(partition.nodes);
                    path.enter().append("path");
                    path.attr("display", function (d) { return d.depth ? null : "none"; })
                        .attr("d", this.arc)
                        .style("stroke", "#fff")
                        .style("fill", function (d) { return d.color; })
                        .style("fill-rule", "evenodd")
                        .on("mousedown", function (d) {
                        if (d.selector) {
                            _this.selectionManager.select(d.selector);
                        }
                        d3.selectAll("path").call(Sunburst.setAllUnhide).attr('setUnHide', null);
                        _this.highlightPath(d, _this, true);
                        var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed");
                        var percentage = _this.total === 0 ? 0 : (100 * d.total / _this.total).toPrecision(3);
                        percentageFixedText.text(d ? percentage + "%" : "");
                        percentageFixedText.style("fill", d.color);
                        _this.onResize();
                        event.stopPropagation();
                    });
                    this.renderTooltip(path);
                    path.exit().remove();
                    this.onResize();
                };
                // Get all parents of the node
                Sunburst.getTreePath = function (node) {
                    var path = [];
                    var current = node;
                    while (current.parent) {
                        path.unshift(current);
                        current = current.parent;
                    }
                    return path;
                };
                Sunburst.prototype.onResize = function () {
                    var width = this.viewport.width;
                    var height = this.viewport.height;
                    var percentageFixedText = this.svg.select(".sunBurstPercentageFixed");
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
                    percentageFixedText.style("opacity", 1);
                    percentageFixedText.attr("y", (height / 2 + 4));
                    percentageFixedText.attr("x", ((width / 2) - (textWidth / 2)));
                };
                Sunburst.prototype.highlightPath = function (d, sunBurst, setUnhide) {
                    var parentsArray = d ? Sunburst.getTreePath(d) : [];
                    // Set opacity for all the segments.
                    sunBurst.svg.selectAll("path").each(function () {
                        if (d3.select(this).attr('setUnHide') !== 'true') {
                            d3.select(this).style("opacity", Sunburst.minOpacity);
                        }
                    });
                    // Highlight only ancestors of the current segment.
                    sunBurst.svg.selectAll("path")
                        .filter(function (node) {
                        return (parentsArray.indexOf(node) >= 0);
                    }).each(function () {
                        d3.select(this).style("opacity", 1);
                        if (setUnhide === true) {
                            d3.select(this).attr('setUnHide', 'true');
                        }
                    });
                };
                Sunburst.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                };
                Sunburst.getTooltipData = function (displayName, value) {
                    return [{
                            displayName: displayName,
                            value: value < 0 ? "" : value.toString()
                        }];
                };
                Sunburst.prototype.covertTreeNodeToSunBurstNode = function (originParentNode, sunburstParentNode, colors, pathIdentity, color) {
                    var selector;
                    if (originParentNode.identity) {
                        pathIdentity = pathIdentity.concat([originParentNode.identity]);
                        selector = { data: pathIdentity, };
                    }
                    var selectionId = pathIdentity.length === 0 ? null : new visuals.SelectionId(selector, false);
                    var valueToSet = originParentNode.values ? originParentNode.values[0].value : 0;
                    var newSunNode = {
                        name: originParentNode.name,
                        value: Math.max(valueToSet, 0),
                        selector: selectionId,
                        key: selectionId ? selectionId.getKey() : null,
                        total: valueToSet
                    };
                    if (originParentNode.value) {
                        newSunNode.color = color ? color : colors.getColor(originParentNode.value).value;
                    }
                    this.total += newSunNode.value;
                    if (originParentNode.children && originParentNode.children.length > 0) {
                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1);
                        newSunNode.children = [];
                        for (var i = 0; i < originParentNode.children.length; i++) {
                            var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
                            newSunNode.children.push(newChild);
                            newSunNode.total += newChild.total;
                        }
                    }
                    else {
                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
                    }
                    if (sunburstParentNode) {
                        newSunNode.parent = sunburstParentNode;
                    }
                    return newSunNode;
                };
                Sunburst.prototype.converter = function (dataView, colors) {
                    var colorScale = colors.getNewColorScale();
                    this.total = 0;
                    var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], undefined);
                    return root;
                };
                Sunburst.minOpacity = 0.2;
                Sunburst.roleNames = {
                    nodes: 'Nodes',
                    values: 'Values',
                };
                Sunburst.capabilities = {
                    dataRoles: [
                        {
                            name: Sunburst.roleNames.nodes,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Groups'
                        }, {
                            name: Sunburst.roleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Values'
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Groups': { min: 0 }, 'Values': { max: 1 } },
                            ],
                            matrix: {
                                rows: {
                                    for: { in: Sunburst.roleNames.nodes },
                                },
                                values: {
                                    for: { in: Sunburst.roleNames.values }
                                },
                            }
                        }],
                };
                return Sunburst;
            })();
            samples.Sunburst = Sunburst;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
 *  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var SelectionManager = visuals.utility.SelectionManager;
            var PixelConverter = jsCommon.PixelConverter;
            (function (GranularityType) {
                GranularityType[GranularityType["year"] = 0] = "year";
                GranularityType[GranularityType["quarter"] = 1] = "quarter";
                GranularityType[GranularityType["month"] = 2] = "month";
                GranularityType[GranularityType["day"] = 3] = "day";
            })(samples.GranularityType || (samples.GranularityType = {}));
            var GranularityType = samples.GranularityType;
            var SelectedCellColorProp = { objectName: 'cells', propertyName: 'fillSelected' };
            var UnselectedCellColorProp = { objectName: 'cells', propertyName: 'fillUnselected' };
            var TimeRangeColorProp = { objectName: 'rangeHeader', propertyName: 'fontColor' };
            var TimeRangeSizeProp = { objectName: 'rangeHeader', propertyName: 'textSize' };
            var TimeRangeShowProp = { objectName: 'rangeHeader', propertyName: 'show' };
            var LabelsColorProp = { objectName: 'labels', propertyName: 'fontColor' };
            var LabelsSizeProp = { objectName: 'labels', propertyName: 'textSize' };
            var LabelsShowProp = { objectName: 'labels', propertyName: 'show' };
            var GranularityNames = [
                {
                    granularityType: GranularityType.year,
                    name: "year"
                }, {
                    granularityType: GranularityType.quarter,
                    name: "quarter"
                }, {
                    granularityType: GranularityType.month,
                    name: "month"
                }, {
                    granularityType: GranularityType.day,
                    name: "day"
                }];
            var DayGranularity = (function () {
                function DayGranularity() {
                }
                DayGranularity.prototype.getType = function () {
                    return GranularityType.day;
                };
                DayGranularity.prototype.resetDatePeriods = function () {
                    DayGranularity.datePeriods = [];
                };
                DayGranularity.prototype.getEnumType = function () {
                    return GranularityType.day;
                };
                DayGranularity.prototype.splitDate = function (date) {
                    return [Utils.shortMonthName(date), date.getDate(), date.getFullYear()];
                };
                DayGranularity.prototype.getDatePeriods = function () {
                    return DayGranularity.datePeriods;
                };
                DayGranularity.prototype.prefixDisplay = function (date) {
                    return Utils.shortMonthName(date) + ' ' + date.getFullYear();
                };
                DayGranularity.prototype.getLabel = function (date) {
                    return date.getDate().toString();
                };
                DayGranularity.prototype.isFirst = function (date) {
                    return date.getDate() === 1;
                };
                DayGranularity.datePeriods = [];
                return DayGranularity;
            })();
            samples.DayGranularity = DayGranularity;
            var MonthGranularity = (function () {
                function MonthGranularity() {
                }
                MonthGranularity.prototype.getType = function () {
                    return GranularityType.month;
                };
                MonthGranularity.prototype.resetDatePeriods = function () {
                    MonthGranularity.datePeriods = [];
                };
                MonthGranularity.prototype.getEnumType = function () {
                    return GranularityType.month;
                };
                MonthGranularity.prototype.splitDate = function (date) {
                    return [Utils.shortMonthName(date), date.getFullYear()];
                };
                MonthGranularity.prototype.getDatePeriods = function () {
                    return MonthGranularity.datePeriods;
                };
                MonthGranularity.prototype.prefixDisplay = function (date) {
                    return date.getFullYear().toString();
                };
                MonthGranularity.prototype.getLabel = function (date) {
                    return Utils.shortMonthName(date);
                };
                MonthGranularity.prototype.isFirst = function (date) {
                    return date.getMonth() === 0;
                };
                MonthGranularity.datePeriods = [];
                return MonthGranularity;
            })();
            samples.MonthGranularity = MonthGranularity;
            var QuarterGranularity = (function () {
                function QuarterGranularity() {
                }
                QuarterGranularity.prototype.getType = function () {
                    return GranularityType.quarter;
                };
                QuarterGranularity.prototype.resetDatePeriods = function () {
                    QuarterGranularity.datePeriods = [];
                };
                QuarterGranularity.prototype.getEnumType = function () {
                    return GranularityType.quarter;
                };
                QuarterGranularity.prototype.splitDate = function (date) {
                    return [Utils.quarterText(date), date.getFullYear()];
                };
                QuarterGranularity.prototype.getDatePeriods = function () {
                    return QuarterGranularity.datePeriods;
                };
                QuarterGranularity.prototype.prefixDisplay = function (date) {
                    return date.getFullYear().toString();
                };
                QuarterGranularity.prototype.getLabel = function (date) {
                    return Utils.quarterText(date);
                };
                QuarterGranularity.prototype.isFirst = function (date) {
                    return date.getMonth() === 0;
                };
                QuarterGranularity.datePeriods = [];
                return QuarterGranularity;
            })();
            samples.QuarterGranularity = QuarterGranularity;
            var YearGranularity = (function () {
                function YearGranularity() {
                }
                YearGranularity.prototype.getType = function () {
                    return GranularityType.year;
                };
                YearGranularity.prototype.resetDatePeriods = function () {
                    YearGranularity.datePeriods = [];
                };
                YearGranularity.prototype.getEnumType = function () {
                    return GranularityType.year;
                };
                YearGranularity.prototype.splitDate = function (date) {
                    return [date.getFullYear()];
                };
                YearGranularity.prototype.getDatePeriods = function () {
                    return YearGranularity.datePeriods;
                };
                YearGranularity.prototype.prefixDisplay = function (date) {
                    return "";
                };
                YearGranularity.prototype.getLabel = function (date) {
                    return date.getFullYear().toString();
                };
                YearGranularity.prototype.isFirst = function (date) {
                    return false;
                };
                YearGranularity.datePeriods = [];
                return YearGranularity;
            })();
            samples.YearGranularity = YearGranularity;
            var TimelineGranularityData = (function () {
                function TimelineGranularityData(startDate, endDate) {
                    this.granularities = [];
                    this.setDatesRange(startDate, endDate);
                    var lastDate = this.dates[this.dates.length - 1];
                    this.endingDate = TimelineGranularityData.nextDay(lastDate);
                }
                /**
                 * Returns the date of the next day
                 * @param date The previous date
                 */
                TimelineGranularityData.nextDay = function (date) {
                    var nextDay = new Date(date.getTime());
                    nextDay.setDate(nextDay.getDate() + 1);
                    return nextDay;
                };
                /**
                * Returns an array of dates with all the days between the start date and the end date
                */
                TimelineGranularityData.prototype.setDatesRange = function (startDate, endDate) {
                    this.dates = [];
                    var date = startDate;
                    while (date <= endDate) {
                        this.dates.push(date);
                        date = TimelineGranularityData.nextDay(date);
                    }
                };
                /**
                * Adds the new date into the given datePeriods array
                * If the date corresponds to the last date period, given the current granularity,
                * it will be added to that date period. Otherwise, a new date period will be added to the array.
                * i.e. using Month granularity, Feb 2 2015 corresponds to Feb 3 2015.
                * It is assumed that the given date does not correspond to previous date periods, other than the last date period
                */
                TimelineGranularityData.addDate = function (granularity, date) {
                    var datePeriods = granularity.getDatePeriods();
                    var newIdentifierArray = granularity.splitDate(date);
                    var lastDatePeriod = datePeriods[datePeriods.length - 1];
                    if (datePeriods.length === 0 || !_.isEqual(lastDatePeriod.identifierArray, newIdentifierArray)) {
                        if (datePeriods.length > 0)
                            lastDatePeriod.endDate = date;
                        datePeriods.push({
                            identifierArray: newIdentifierArray,
                            startDate: date,
                            endDate: date,
                            isFirst: granularity.isFirst(date),
                            fraction: 1,
                            index: datePeriods.length
                        });
                    }
                    else
                        lastDatePeriod.endDate = date;
                };
                /**
                 * Adds a new granularity to the array of granularities.
                 * Resets the new granularity, adds all dates to it, and then edits the last date period with the ending date.
                 * @param granularity The new granularity to be added
                 */
                TimelineGranularityData.prototype.addGranularity = function (granularity) {
                    granularity.resetDatePeriods();
                    this.dates.forEach(function (x) { return TimelineGranularityData.addDate(granularity, x); });
                    Utils.setNewEndDate(granularity, this.endingDate);
                    this.granularities.push(granularity);
                };
                /**
                 * Returns a specific granularity from the array of granularities
                 * @param index The index of the requested granularity
                 */
                TimelineGranularityData.prototype.getGranularity = function (index) {
                    return this.granularities[index];
                };
                return TimelineGranularityData;
            })();
            samples.TimelineGranularityData = TimelineGranularityData;
            var Utils = (function () {
                function Utils() {
                }
                /**
                 * Returns the date of the start of the selection
                 * @param timelineData The TimelineData which contains all the date periods
                 */
                Utils.getStartSelectionDate = function (timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
                };
                /**
                 * Returns the date of the end of the selection
                 * @param timelineData The TimelineData which contains all the date periods
                 */
                Utils.getEndSelectionDate = function (timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
                };
                /**
                 * Returns the date period of the end of the selection
                 * @param timelineData The TimelineData which contains all the date periods
                 */
                Utils.getEndSelectionPeriod = function (timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
                };
                /**
                 * Returns the color of a cell, depending on whether its date period is between the selected date periods
                 * @param d The TimelineDataPoint of the cell
                 * @param timelineData The TimelineData with the selected date periods
                 * @param timelineFormat The TimelineFormat with the chosen colors
                 */
                Utils.getCellColor = function (d, timelineData, cellFormat) {
                    var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
                    return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;
                };
                /**
                 * Returns a value of a label, either from the metadata, or from a default value
                 * @param defaultValue The default value to be returned if label was not found it metadata
                 * @param dataView The DataView which contains the metadata
                 * @param ObjectName The name of the requested label
                 * @param valueName The name of the requested value
                 */
                Utils.getObjectValue = function (defaultValue, dataView, ObjectName, valueName) {
                    if (dataView && dataView.metadata && dataView.metadata.objects) {
                        var object = dataView.metadata.objects[ObjectName];
                        if (object)
                            return object[valueName];
                    }
                    return defaultValue;
                };
                /**
                 * Returns the granularity type of the given granularity name
                 * @param granularityName The name of the granularity
                 */
                Utils.getGranularityType = function (granularityName) {
                    var index = _.findIndex(GranularityNames, function (x) { return x.name === granularityName; });
                    return GranularityNames[index].granularityType;
                };
                /**
                 * Returns the name of the granularity type
                 * @param granularity The type of granularity
                 */
                Utils.getGranularityName = function (granularity) {
                    var index = _.findIndex(GranularityNames, function (x) { return x.granularityType === granularity; });
                    return GranularityNames[index].name;
                };
                /**
                 * Splits the date periods of the current granularity, in case the stard and end of the selection is in between a date period.
                 * i.e. for a quarter granularity and a selection between Feb 6 and Dec 23, the date periods for Q1 and Q4 will be split accordingly
                 * @param timelineData The TimelineData that contains the date periods
                 * @param startDate The starting date of the selection
                 * @param endDate The ending date of the selection
                 */
                Utils.separateSelection = function (timelineData, startDate, endDate) {
                    var datePeriods = timelineData.currentGranularity.getDatePeriods();
                    var startDateIndex = _.findIndex(datePeriods, function (x) { return startDate < x.endDate; });
                    var endDateIndex = _.findIndex(datePeriods, function (x) { return endDate <= x.endDate; });
                    timelineData.selectionStartIndex = startDateIndex;
                    timelineData.selectionEndIndex = endDateIndex;
                    var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, true);
                    var endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, false);
                    if (endRatio > 0)
                        Utils.splitPeriod(datePeriods, endDateIndex, endRatio, endDate);
                    if (startRatio > 0) {
                        var startFration = datePeriods[startDateIndex].fraction - startRatio;
                        Utils.splitPeriod(datePeriods, startDateIndex, startFration, startDate);
                        timelineData.selectionStartIndex++;
                        timelineData.selectionEndIndex++;
                    }
                };
                /**
                 * Splits a given period into two periods.
                 * The new period is added after the index of the old one, while the old one is simply updated.
                 * @param datePeriods The DatePeriods that contain the date period to be split
                 * @param index The index of the date priod to be split
                 * @param newFraction The fraction value of the new date period
                 * @param newDate The date in which the date period is split
                 */
                Utils.splitPeriod = function (datePeriods, index, newFraction, newDate) {
                    var oldDatePeriod = datePeriods[index];
                    oldDatePeriod.fraction -= newFraction;
                    var newDateObject = {
                        identifierArray: oldDatePeriod.identifierArray,
                        startDate: newDate,
                        endDate: oldDatePeriod.endDate,
                        isFirst: false,
                        fraction: newFraction,
                        index: oldDatePeriod.index + oldDatePeriod.fraction
                    };
                    oldDatePeriod.endDate = newDate;
                    datePeriods.splice(index + 1, 0, newDateObject);
                };
                /**
                 * Returns the ratio of the given date compared to the whole date period.
                 * The ratio is calculated either from the start or the end of the date period.
                 * i.e. the ratio of Feb 7 2016 compared to the month of Feb 2016,
                 * is 0.2142 from the start of the month, or 0.7857 from the end of the month.
                 * @param datePeriod The date period that contain the specified date
                 * @param date The date
                 * @param fromStart Whether to calculater the ratio from the start of the date period.
                 */
                Utils.getDateRatio = function (datePeriod, date, fromStart) {
                    var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime();
                    var periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
                    return periodDifference === 0 ? 0 : dateDifference / periodDifference;
                };
                /**
                 * Returns the date's quarter name (e.g. Q1, Q2, Q3, Q4)
                 * @param date A date
                 */
                Utils.quarterText = function (date) {
                    return 'Q' + Math.floor(date.getMonth() / 3 + 1);
                };
                /**
                * Returns the time range text, depending on the given granularity (e.g. "Feb 3 2014 - Apr 5 2015", "Q1 2014 - Q2 2015")
                */
                Utils.timeRangeText = function (timelineData) {
                    var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData));
                    var endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
                    return startSelectionDateArray.join(' ') + ' - ' + endSelectionDateArray.join(' ');
                };
                /**
                * Returns the short month name of the given date (e.g. Jan, Feb, Mar)
                */
                Utils.shortMonthName = function (date) {
                    return date.toString().split(' ')[1];
                };
                /**
                 * Combines the first two partial date periods, into a single date period.
                 * Returns whether a partial date period was found.
                 * i.e. combines "Feb 1 2016 - Feb 5 2016" with "Feb 5 2016 - Feb 29 2016" into "Feb 1 2016 - Feb 29 2016"
                 * @param datePeriods The list of date periods
                 */
                Utils.unseparateSelection = function (datePeriods) {
                    var separationIndex = _.findIndex(datePeriods, function (x) { return x.fraction < 1; });
                    if (separationIndex >= 0) {
                        datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate;
                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction;
                        datePeriods.splice(separationIndex + 1, 1);
                        return true;
                    }
                    return false;
                };
                Utils.addDay = function (date) {
                    var newDate = new Date(date.valueOf());
                    newDate.setDate(newDate.getDate() + 1);
                    return newDate;
                };
                /**
                * Returns an array of dates with all the days between the start date and the end date
                */
                Utils.getDatesRange = function (startDate, endDate) {
                    var dates = [];
                    for (var day = startDate; day <= endDate; day = Utils.addDay(day))
                        dates.push(day);
                    return dates;
                };
                Utils.setNewEndDate = function (granularity, date) {
                    var datePeriods = granularity.getDatePeriods();
                    datePeriods[datePeriods.length - 1].endDate = date;
                };
                return Utils;
            })();
            samples.Utils = Utils;
            var Timeline = (function () {
                function Timeline() {
                    var _this = this;
                    this.requiresNoUpdate = false;
                    this.selector = ['Y', 'Q', 'M', 'D'];
                    this.timelineMargins = {
                        LeftMargin: 15,
                        RightMargin: 15,
                        TopMargin: 15,
                        BottomMargin: 10,
                        CellWidth: 40,
                        CellHeight: 25,
                        StartXpoint: 10,
                        StartYpoint: 20,
                        ElementWidth: 30
                    };
                    this.defaultTimelineProperties = {
                        DefaultLabelsShow: true,
                        TimeLineDefaultTextSize: 9,
                        TimeLineDefaultCellColor: "#ADD8E6",
                        TimeLineDefaultCellColorOut: "#A4C7F2",
                        TimeLineDefaultTimeRangeShow: true,
                        DefaultTimeRangeColor: "#777777",
                        DefaultLabelColor: "#777777",
                        DefaultGranularity: GranularityType.month
                    };
                    this.timelineSelector = {
                        TimelineVisual: createClassAndSelector('Timeline'),
                        SelectionRangeContainer: createClassAndSelector('selectionRangeContainer'),
                        LowerTextCell: createClassAndSelector('lowerTextCell'),
                        UpperTextCell: createClassAndSelector('upperTextCell'),
                        UpperTextArea: createClassAndSelector('upperTextArea'),
                        LowerTextArea: createClassAndSelector('lowerTextArea'),
                        RangeTextArea: createClassAndSelector('rangeTextArea'),
                        CellsArea: createClassAndSelector('cellsArea'),
                        CursorsArea: createClassAndSelector('cursorsArea'),
                        MainArea: createClassAndSelector('mainArea'),
                        SelectionCursor: createClassAndSelector('selectionCursor'),
                        Cell: createClassAndSelector('cell'),
                        CellRect: createClassAndSelector('cellRect'),
                        VertLine: createClassAndSelector('timelineVertLine'),
                        TimelineSlicer: createClassAndSelector('timelineSlicer'),
                        PeriodSlicerGranularities: createClassAndSelector('periodSlicerGranularities'),
                        PeriodSlicerSelection: createClassAndSelector('periodSlicerSelection'),
                        PeriodSlicerSelectionRect: createClassAndSelector('periodSlicerSelectionRect'),
                        PeriodSlicerRect: createClassAndSelector('periodSlicerRect')
                    };
                    this.drag = d3.behavior.drag()
                        .origin(function (d) {
                        return d;
                    })
                        .on("dragstart", function (d) { _this.dragstarted(d, _this); })
                        .on("drag", function (d) { _this.dragged(d, _this); })
                        .on("dragend", function (d) { _this.dragended(d, _this); });
                }
                /**
                 * Changes the current granularity depending on the given granularity type
                 * Separates the new granularity's date periods which contain the start/end selection
                 * Unseparates the date periods of the previous granularity.
                 * @param granularity The new granularity type
                 */
                Timeline.prototype.changeGranularity = function (granularity, startDate, endDate) {
                    if (Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()))
                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods());
                    this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity);
                    Utils.separateSelection(this.timelineData, startDate, endDate);
                };
                Timeline.prototype.init = function (options) {
                    this.hostServices = options.host;
                    this.initialized = false;
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.timeLineProperties = {
                        element: element,
                        textYPosition: 40 + PixelConverter.fromPointToPixel(50),
                        cellsYPosition: this.timelineMargins.TopMargin * 3 + PixelConverter.fromPointToPixel(50),
                        topMargin: this.timelineMargins.TopMargin,
                        bottomMargin: this.timelineMargins.BottomMargin,
                        leftMargin: this.timelineMargins.LeftMargin,
                        startXpoint: this.timelineMargins.StartXpoint,
                        startYpoint: this.timelineMargins.StartYpoint,
                        cellWidth: this.timelineMargins.CellWidth,
                        cellHeight: this.timelineMargins.CellHeight,
                        elementWidth: this.timelineMargins.ElementWidth,
                        rightMargin: this.timelineMargins.RightMargin
                    };
                    this.body = d3.select(element.get(0));
                    this.timelineDiv = this.body.append('div');
                    this.svg = this.timelineDiv.append('svg').attr('width', PixelConverter.toString(options.viewport.width)).classed(this.timelineSelector.TimelineVisual.class, true);
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                    this.clearCatcher.data([this]).on("click", function (timeline) { return timeline.clear(); });
                    this.rangeText = this.svg.append('g').classed(this.timelineSelector.RangeTextArea.class, true).append('text');
                    this.mainGroupElement = this.svg.append('g').classed(this.timelineSelector.MainArea.class, true);
                    this.upperLabelsElement = this.mainGroupElement.append('g').classed(this.timelineSelector.UpperTextArea.class, true);
                    this.lowerLabelsElement = this.mainGroupElement.append('g').classed(this.timelineSelector.LowerTextArea.class, true);
                    this.cellsElement = this.mainGroupElement.append('g').classed(this.timelineSelector.CellsArea.class, true);
                    this.cursorGroupElement = this.svg.append('g').classed(this.timelineSelector.CursorsArea.class, true);
                    this.drawGranular(this.timeLineProperties);
                };
                Timeline.prototype.clear = function () {
                    this.selectionManager.clear();
                    if (this.timelineData) {
                        this.timelineData.selectionStartIndex = 0;
                        this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1;
                        Timeline.updateCursors(this.timelineData, this.timeLineProperties.cellWidth);
                        this.fillCells(this.timelineFormat.cellFormat);
                        this.renderCursors(this.timelineData, this.timelineFormat, this.timeLineProperties.cellHeight, this.timeLineProperties.cellsYPosition);
                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
                        this.setSelection(this.timelineData);
                    }
                };
                Timeline.prototype.drawGranular = function (timeLineProperties) {
                    var _this = this;
                    this.selectorContainer = this.svg.append('g').classed(this.timelineSelector.TimelineSlicer.class, true);
                    var dragPeriodRectState = false;
                    var startXpoint = timeLineProperties.startXpoint;
                    var startYpoint = timeLineProperties.startYpoint;
                    var elementWidth = timeLineProperties.elementWidth;
                    this.selectorContainer.on('mouseleave', function (d) { return dragPeriodRectState = false; });
                    var fillRect = this.selectorContainer.append('rect');
                    var selectorPeriods = this.selector;
                    fillRect.attr({
                        height: PixelConverter.toString(1),
                        x: PixelConverter.toString(startXpoint),
                        y: PixelConverter.toString(startYpoint + 2),
                        width: PixelConverter.toString((selectorPeriods.length - 1) * elementWidth)
                    });
                    var fillVertLine = this.selectorContainer.selectAll("vertLines")
                        .data(selectorPeriods).enter().append('rect');
                    fillVertLine
                        .classed(this.timelineSelector.VertLine.class, true)
                        .attr({
                        x: function (d, index) { return PixelConverter.toString(startXpoint + index * elementWidth); },
                        y: PixelConverter.toString(startYpoint),
                        width: PixelConverter.toString(2),
                        height: PixelConverter.toString(3)
                    })
                        .style({ 'cursor': 'pointer' });
                    var text = this.selectorContainer.selectAll(this.timelineSelector.PeriodSlicerGranularities.selector)
                        .data(selectorPeriods)
                        .enter()
                        .append("text")
                        .classed(this.timelineSelector.PeriodSlicerGranularities.class, true);
                    //Add SVG Text Element Attributes
                    var textLabels;
                    textLabels = text.text(function (d) { return d; })
                        .attr({
                        x: function (d, index) { return PixelConverter.toString(startXpoint - 3 + index * elementWidth); },
                        y: PixelConverter.toString(startYpoint - 3)
                    });
                    this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelector.PeriodSlicerSelection.class, true);
                    this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity))
                        .attr({
                        x: PixelConverter.toString(startXpoint + 35),
                        y: PixelConverter.toString(startYpoint + 17),
                    });
                    var selRects = this.selectorContainer.selectAll(this.timelineSelector.PeriodSlicerSelectionRect.selector)
                        .data(selectorPeriods).enter().append('rect').classed(this.timelineSelector.PeriodSlicerSelectionRect.class, true);
                    selRects.attr({
                        x: function (d, index) { return PixelConverter.toString(startXpoint - elementWidth / 2 + index * elementWidth); },
                        y: PixelConverter.toString(3),
                        width: PixelConverter.toString(elementWidth),
                        height: PixelConverter.toString(23)
                    })
                        .style({ 'cursor': 'pointer' })
                        .on('mousedown', function (d, index) {
                        _this.selectPeriod(index);
                        dragPeriodRectState = true;
                    })
                        .on('mouseup', function (d) { return dragPeriodRectState = false; })
                        .on("mouseover", function (d, index) {
                        if (dragPeriodRectState) {
                            _this.selectPeriod(index);
                        }
                    });
                    var dragPeriodRect = d3.behavior.drag()
                        .on("dragstart", function (e, b) {
                        dragPeriodRectState = true;
                    })
                        .on("dragend", function (e, b) {
                        dragPeriodRectState = false;
                    });
                    this.periodSlicerRect = this.selectorContainer
                        .append('rect').classed(this.timelineSelector.PeriodSlicerRect.class, true)
                        .attr({
                        x: PixelConverter.toString(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),
                        y: PixelConverter.toString(startYpoint - 16),
                        rx: PixelConverter.toString(4),
                        width: PixelConverter.toString(15),
                        height: PixelConverter.toString(23)
                    })
                        .on('mouseup', function (d) { return dragPeriodRectState = false; });
                    this.periodSlicerRect.call(dragPeriodRect);
                };
                Timeline.prototype.redrawPeriod = function (granularity) {
                    var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;
                    this.periodSlicerRect.transition().attr("x", PixelConverter.toString(dx - 7));
                    this.selectedText.text(Utils.getGranularityName(granularity));
                    var startDate = Utils.getStartSelectionDate(this.timelineData);
                    var endDate = Utils.getEndSelectionDate(this.timelineData);
                    this.changeGranularity(granularity, startDate, endDate);
                };
                Timeline.prototype.update = function (options) {
                    if (this.requiresNoUpdate) {
                        this.requiresNoUpdate = false;
                        return;
                    }
                    this.options = options;
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    var dataView = options.dataViews[0];
                    this.dataView = dataView;
                    if (!dataView.categorical
                        || !dataView.metadata
                        || !dataView.categorical.categories
                        || dataView.categorical.categories.length !== 1
                        || !dataView.categorical.categories[0].values
                        || dataView.categorical.categories[0].values.length === 0
                        || _.any(dataView.categorical.categories[0].values, function (x) { return !x.getTime; })) {
                        this.clearData();
                        return;
                    }
                    var timesLine = dataView.categorical.categories[0].values;
                    var startDate = timesLine.reduce(function (prev, curr) { return (curr < prev) ? curr : prev; }, timesLine[0]);
                    var endDate = timesLine.reduce(function (prev, curr) { return (curr > prev) ? curr : prev; }, timesLine[0]);
                    var newGranularity = this.defaultTimelineProperties.DefaultGranularity;
                    if (this.initialized) {
                        var daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods();
                        var prevStartDate = daysPeriods[0].startDate;
                        var prevEndDate = daysPeriods[daysPeriods.length - 1].startDate;
                        var changedSelection = startDate.getTime() !== prevStartDate.getTime() || endDate.getTime() !== prevEndDate.getTime();
                        newGranularity = this.timelineData.currentGranularity.getType();
                        if (changedSelection)
                            this.changeGranularity(newGranularity, startDate, endDate);
                        this.timelineFormat = Timeline.fillTimelineFormat(options.dataViews[0].metadata.objects, this.defaultTimelineProperties);
                    }
                    else {
                        this.timelineGranularityData = new TimelineGranularityData(startDate, endDate);
                        this.timelineData = {
                            elementsCount: 0,
                            timelineDatapoints: [],
                            cursorDataPoints: new Array()
                        };
                    }
                    this.timelineFormat = Timeline.converter(this.timelineData, this.timeLineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, newGranularity);
                    this.render(this.timelineData, this.timelineFormat, this.timeLineProperties, options);
                    this.initialized = true;
                };
                Timeline.prototype.selectPeriod = function (periodNameIndex) {
                    this.redrawPeriod(periodNameIndex);
                    this.requiresNoUpdate = false;
                    this.update(this.options);
                };
                Timeline.isDataNotMatch = function (dataView) {
                    if (dataView.categorical.categories.length <= 0 ||
                        dataView.categorical.categories[0] === undefined ||
                        dataView.categorical.categories[0].identityFields === undefined ||
                        dataView.categorical.categories[0].identityFields.length <= 0)
                        return true;
                    return false;
                };
                Timeline.converter = function (timelineData, timeLineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType) {
                    if (!initialized) {
                        timelineGranularityData.addGranularity(new YearGranularity());
                        timelineGranularityData.addGranularity(new QuarterGranularity());
                        timelineGranularityData.addGranularity(new MonthGranularity());
                        timelineGranularityData.addGranularity(new DayGranularity());
                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType);
                        timelineData.cursorDataPoints.push({ dx: 0, cursorIndex: 0 });
                        timelineData.cursorDataPoints.push({ dx: 0, cursorIndex: 1 });
                        timelineData.selectionStartIndex = 0;
                        timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1;
                    }
                    timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName;
                    timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0];
                    if (this.isDataNotMatch(dataView))
                        return;
                    var timelineElements = timelineData.currentGranularity.getDatePeriods();
                    timelineData.elementsCount = timelineElements.length;
                    timelineData.timelineDatapoints = [];
                    for (var _i = 0; _i < timelineElements.length; _i++) {
                        var elment = timelineElements[_i];
                        var currentTimePeriod = elment;
                        var datapoint = {
                            label: timelineData.currentGranularity.getLabel(currentTimePeriod.startDate),
                            index: currentTimePeriod.index,
                            datePeriod: currentTimePeriod
                        };
                        timelineData.timelineDatapoints.push(datapoint);
                    }
                    ;
                    var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
                    Timeline.updateCursors(timelineData, timeLineProperties.cellWidth);
                    return timelineFormat;
                };
                Timeline.prototype.render = function (timelineData, timelineFormat, timeLineProperties, options) {
                    this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);
                    var timelineDatapointsCount = timelineData.timelineDatapoints;
                    var svgWidth = timeLineProperties.leftMargin + timeLineProperties.cellWidth * timelineDatapointsCount.length + timeLineProperties.rightMargin;
                    if (options.viewport.width > svgWidth)
                        svgWidth = options.viewport.width;
                    this.timelineDiv.attr({
                        height: options.viewport.height,
                        width: options.viewport.width,
                        'drag-resize-disabled': true
                    }).style({
                        'overflow-x': 'auto',
                        'overflow-y': 'auto'
                    });
                    this.svg.attr({
                        height: options.viewport.height - this.timelineMargins.TopMargin,
                        width: svgWidth,
                    });
                    var labelSize = PixelConverter.fromPointToPixel(timelineFormat.labelFormat.sizeProperty);
                    var translateString = visuals.SVGUtil.translate(timeLineProperties.leftMargin, timeLineProperties.topMargin);
                    this.mainGroupElement.attr('transform', translateString);
                    this.selectorContainer.attr('transform', translateString);
                    this.cursorGroupElement.attr('transform', translateString);
                    var upperTextFunc = function (d) { return timelineData.currentGranularity.prefixDisplay(d.datePeriod.startDate); };
                    var lowerTextFunc = function (d) { return d.label; };
                    var upperTextData = timelineData.timelineDatapoints.filter(function (d) { return d.datePeriod.isFirst; });
                    var lowerTextData = timelineData.timelineDatapoints.filter(function (d) { return d.index % 1 === 0; });
                    this.renderCellLabels(upperTextData, timelineFormat.labelFormat, timeLineProperties.textYPosition - labelSize * 1.2, this.timelineSelector.UpperTextCell, upperTextFunc, this.upperLabelsElement, this.timeLineProperties.cellWidth);
                    this.renderCellLabels(lowerTextData, timelineFormat.labelFormat, timeLineProperties.textYPosition, this.timelineSelector.LowerTextCell, lowerTextFunc, this.lowerLabelsElement, this.timeLineProperties.cellWidth);
                    this.renderCells(timelineData, timelineFormat, timeLineProperties, options.suppressAnimations);
                    this.renderCursors(timelineData, timelineFormat, timeLineProperties.cellHeight, timeLineProperties.cellsYPosition);
                };
                Timeline.prototype.clearData = function () {
                    this.mainGroupElement.selectAll(this.timelineSelector.CellRect.selector).remove();
                    this.mainGroupElement.selectAll(this.timelineSelector.UpperTextCell.selector).remove();
                    this.mainGroupElement.selectAll(this.timelineSelector.LowerTextCell.selector).remove();
                    this.rangeText.text("");
                    this.cursorGroupElement.selectAll(this.timelineSelector.SelectionCursor.selector).remove();
                };
                Timeline.updateCursors = function (timelineData, cellWidth) {
                    var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;
                    timelineData.cursorDataPoints[0].dx = startDate.index * cellWidth;
                    var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
                    timelineData.cursorDataPoints[1].dx = (endDate.index + endDate.fraction) * cellWidth;
                };
                Timeline.fillTimelineFormat = function (objects, timelineProperties) {
                    var timelineFormat = {
                        rangeTextFormat: {
                            showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimeLineDefaultTimeRangeShow),
                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
                            sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimeLineDefaultTextSize)
                        },
                        cellFormat: {
                            colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimeLineDefaultCellColor),
                            colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimeLineDefaultCellColorOut)
                        },
                        labelFormat: {
                            showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
                            sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimeLineDefaultTextSize)
                        }
                    };
                    return timelineFormat;
                };
                Timeline.prototype.fillCells = function (cellFormat) {
                    var _this = this;
                    var dataPoints = this.timelineData.timelineDatapoints;
                    var cellSelection = this.mainGroupElement.selectAll(this.timelineSelector.CellRect.selector).data(dataPoints);
                    cellSelection.attr('fill', function (d) { return Utils.getCellColor(d, _this.timelineData, cellFormat); });
                };
                Timeline.prototype.cellMouseOver = function (datapoint, index) {
                    this.currentlyMouseOverElement = datapoint;
                    this.currentlyMouseOverElementIndex = index;
                };
                Timeline.prototype.renderCells = function (timelineData, timelineFormat, timeLineProperties, suppressAnimations) {
                    var _this = this;
                    var duration = suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                    var allDataPoints = timelineData.timelineDatapoints;
                    var totalX = 0;
                    var cellsSelection = this.cellsElement.selectAll(this.timelineSelector.CellRect.selector).data(allDataPoints);
                    cellsSelection.enter().append('rect').classed(this.timelineSelector.CellRect.class, true);
                    cellsSelection.transition().duration(duration)
                        .attr({
                        height: PixelConverter.toString(timeLineProperties.cellHeight),
                        width: function (d) { return PixelConverter.toString(d.datePeriod.fraction * timeLineProperties.cellWidth); },
                        x: function (d) {
                            var value = totalX;
                            totalX += d.datePeriod.fraction * timeLineProperties.cellWidth;
                            return PixelConverter.toString(value);
                        },
                        y: PixelConverter.toString(timeLineProperties.cellsYPosition),
                        id: function (d) { return d.index; }
                    });
                    cellsSelection.on('click', function (d, index) {
                        d3.event.preventDefault();
                        var width = timeLineProperties.cellWidth;
                        var cursorDataPoints = _this.timelineData.cursorDataPoints;
                        var keyEvent = d3.event;
                        if (keyEvent.altKey || keyEvent.shiftKey) {
                            if (_this.timelineData.selectionEndIndex < index) {
                                cursorDataPoints[1].dx = (d.datePeriod.index + d.datePeriod.fraction) * width;
                                timelineData.selectionEndIndex = index;
                            }
                            else {
                                cursorDataPoints[0].dx = d.datePeriod.index * width;
                                timelineData.selectionStartIndex = index;
                            }
                        }
                        else {
                            timelineData.selectionStartIndex = index;
                            timelineData.selectionEndIndex = index;
                            cursorDataPoints[0].dx = d.datePeriod.index * width;
                            cursorDataPoints[1].dx = (d.datePeriod.index + d.datePeriod.fraction) * width;
                        }
                        _this.fillCells(timelineFormat.cellFormat);
                        _this.renderCursors(timelineData, timelineFormat, timeLineProperties.cellHeight, timeLineProperties.cellsYPosition);
                        _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);
                        _this.setSelection(timelineData);
                    });
                    cellsSelection.on("mouseover", function (d, index) { _this.cellMouseOver(d, index); });
                    this.fillCells(timelineFormat.cellFormat);
                    cellsSelection.exit().remove();
                };
                Timeline.prototype.dragstarted = function (d, that) {
                    that.timelineData.dragging = true;
                };
                Timeline.prototype.dragged = function (d, that) {
                    if (that.timelineData.dragging === true) {
                        var xScale = 1;
                        var width = that.timeLineProperties.cellWidth;
                        var container = d3.select(that.timelineSelector.TimelineVisual.selector);
                        if (container) {
                            var transform = container.style("transform");
                            if (transform !== undefined && transform !== 'none') {
                                var str = transform.split("(")[1];
                                xScale = Number(str.split(", ")[0]);
                            }
                        }
                        var exactDataPoint = that.currentlyMouseOverElement;
                        if (d.cursorIndex === 0 && that.currentlyMouseOverElementIndex <= that.timelineData.selectionEndIndex) {
                            that.timelineData.selectionStartIndex = that.currentlyMouseOverElementIndex;
                            that.timelineData.cursorDataPoints[0].dx = exactDataPoint.datePeriod.index * width;
                        }
                        if (d.cursorIndex === 1 && that.currentlyMouseOverElementIndex >= that.timelineData.selectionStartIndex) {
                            that.timelineData.selectionEndIndex = that.currentlyMouseOverElementIndex;
                            that.timelineData.cursorDataPoints[1].dx = (exactDataPoint.datePeriod.index + exactDataPoint.datePeriod.fraction) * width;
                        }
                        that.fillCells(that.timelineFormat.cellFormat);
                        that.renderCursors(that.timelineData, that.timelineFormat, that.timeLineProperties.cellHeight, that.timeLineProperties.cellsYPosition);
                        that.renderTimeRangeText(that.timelineData, that.timelineFormat.rangeTextFormat);
                    }
                };
                Timeline.prototype.dragended = function (d, that) {
                    this.setSelection(that.timelineData);
                };
                Timeline.prototype.renderCursors = function (timelineData, timelineFormat, cellHeight, cellsYPosition) {
                    var cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelector.SelectionCursor.selector).data(timelineData.cursorDataPoints);
                    cursorSelection.enter().append('path').classed(this.timelineSelector.SelectionCursor.class, true)
                        .attr({
                        d: d3.svg.arc()
                            .innerRadius(0)
                            .outerRadius(cellHeight / 2)
                            .startAngle(function (d) { return d.cursorIndex * Math.PI + Math.PI; }) //converting from degs to radians
                            .endAngle(function (d) { return d.cursorIndex * Math.PI + 2 * Math.PI; })
                    });
                    cursorSelection.attr("transform", function (d) { return visuals.SVGUtil.translate(d.dx, cellHeight / 2 + cellsYPosition); })
                        .call(this.drag);
                    cursorSelection.exit().remove();
                    return cursorSelection;
                };
                Timeline.prototype.renderCellLabels = function (dataPoints, labelFormat, textYPosition, identifier, textFunc, selection, maxSize) {
                    var _this = this;
                    if (labelFormat.showProperty) {
                        var textCellSelection = selection.selectAll(identifier.selector).data(dataPoints);
                        textCellSelection.enter().append('text').classed(identifier.class, true);
                        textCellSelection.text(function (d) {
                            var labelFormattedTextOptions = {
                                label: textFunc(d),
                                maxWidth: maxSize,
                                fontSize: labelFormat.sizeProperty
                            };
                            return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                        })
                            .style('font-size', PixelConverter.fromPoint(labelFormat.sizeProperty))
                            .attr({
                            x: function (d) { return (d.datePeriod.index + 0.5) * _this.timelineMargins.CellWidth; },
                            y: textYPosition,
                            fill: labelFormat.colorProperty
                        })
                            .append('title').text(textFunc);
                        textCellSelection.exit().remove();
                    }
                    else {
                        selection.selectAll(identifier.selector).remove();
                    }
                };
                Timeline.prototype.renderTimeRangeText = function (timelineData, timeRangeFormat) {
                    if (timeRangeFormat.showProperty) {
                        var timeRangeText = Utils.timeRangeText(timelineData);
                        this.rangeText.classed(this.timelineSelector.SelectionRangeContainer.class, true);
                        this.rangeText.attr({
                            x: 150,
                            y: 40,
                            fill: timeRangeFormat.colorProperty
                        })
                            .style({
                            'font-size': PixelConverter.fromPoint(timeRangeFormat.sizeProperty)
                        }).text(timeRangeText)
                            .append('title').text(timeRangeText);
                        ;
                    }
                    else
                        this.rangeText.text("");
                };
                Timeline.prototype.setSelection = function (timelineData) {
                    this.requiresNoUpdate = true;
                    var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData));
                    var upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1));
                    var filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper);
                    var filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr);
                    var objects = {
                        merge: [
                            {
                                objectName: "general",
                                selector: undefined,
                                properties: {
                                    "filter": filter,
                                }
                            }
                        ]
                    };
                    this.hostServices.persistProperties(objects);
                    this.hostServices.onSelect({ data: [] });
                };
                // This function retruns the values to be displayed in the property pane for each object.
                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
                // validation and return other values/defaults 
                Timeline.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'rangeHeader':
                            this.enumerateRangeHeader(enumeration, this.dataView);
                            break;
                        case 'cells':
                            this.enumerateCells(enumeration, this.dataView);
                            break;
                        case 'labels':
                            this.enumerateLabels(enumeration, this.dataView);
                            break;
                    }
                    return enumeration.complete();
                };
                Timeline.prototype.enumerateRangeHeader = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'rangeHeader',
                        displayName: 'Selection Color',
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimeLineDefaultTimeRangeShow),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
                            textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimeLineDefaultTextSize)
                        }
                    });
                };
                Timeline.prototype.enumerateCells = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'cells',
                        selector: null,
                        properties: {
                            fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimeLineDefaultCellColor),
                            fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimeLineDefaultCellColorOut)
                        }
                    });
                };
                Timeline.prototype.enumerateLabels = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'labels',
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
                            textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimeLineDefaultTextSize)
                        }
                    });
                };
                Timeline.capabilities = {
                    dataRoles: [{
                            name: 'Time',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Time',
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { 'Time': { max: 1 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Time' },
                                    dataReductionAlgorithm: { sample: {} }
                                },
                                values: {
                                    select: []
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: 'General',
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    },
                                },
                                selected: {
                                    type: { bool: true }
                                },
                                filter: {
                                    type: { filter: {} },
                                    rule: {
                                        output: {
                                            property: 'selected',
                                            selector: ['Time'],
                                        }
                                    }
                                },
                            },
                        },
                        rangeHeader: {
                            displayName: 'Range Header',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                fontColor: {
                                    displayName: 'Font color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                textSize: {
                                    displayName: 'Text Size',
                                    type: { numeric: true }
                                }
                            }
                        },
                        cells: {
                            displayName: 'Cells',
                            properties: {
                                fillSelected: {
                                    displayName: 'Selected cell color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillUnselected: {
                                    displayName: 'Unselected cell color',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: 'Labels',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                fontColor: {
                                    displayName: 'Font color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                textSize: {
                                    displayName: 'Text Size',
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                return Timeline;
            })();
            samples.Timeline = Timeline;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            var PixelConverter = jsCommon.PixelConverter;
            var TornadoChartScrolling = (function () {
                function TornadoChartScrolling(getRoot, getViewport, getMargin, isScrollable) {
                    this.scrollYBrush = d3.svg.brush();
                    this.getRoot = getRoot;
                    this.getViewport = getViewport;
                    this.getMargin = getMargin;
                    this.isScrollable = isScrollable;
                }
                Object.defineProperty(TornadoChartScrolling.prototype, "root", {
                    get: function () {
                        return this.getRoot();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
                    get: function () {
                        return this.getViewport();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TornadoChartScrolling.prototype, "margin", {
                    get: function () {
                        return this.getMargin();
                    },
                    enumerable: true,
                    configurable: true
                });
                TornadoChartScrolling.prototype.renderY = function (data, prefferedHeight, onScroll) {
                    var _this = this;
                    this.isYScrollBarVisible = prefferedHeight > this.viewport.height
                        && this.viewport.height > 0
                        && this.viewport.width > 0;
                    this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, 'y brush');
                    this.updateScrollViewport();
                    if (!this.isYScrollBarVisible) {
                        onScroll.call(this, jQuery.extend(true, {}, data), 0, 1);
                        return;
                    }
                    var scrollSpaceLength = this.viewport.height;
                    var extentData = this.getExtentData(prefferedHeight, scrollSpaceLength);
                    var onRender = function () {
                        var scrollPosition = extentData.toScrollPosition(_this.scrollYBrush.extent(), scrollSpaceLength);
                        onScroll.call(_this, jQuery.extend(true, {}, data), scrollPosition[0], scrollPosition[1]);
                        _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], true);
                    };
                    var scrollYScale = d3.scale.ordinal().rangeBands([0, scrollSpaceLength]);
                    this.scrollYBrush.y(scrollYScale).extent(extentData.value);
                    this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, this.margin.top, onRender);
                    onRender();
                };
                TornadoChartScrolling.prototype.updateScrollViewport = function () {
                    this.scrollViewport = { height: this.viewport.height, width: this.viewport.width };
                    if (this.isYScrollBarVisible && this.isScrollable) {
                        this.scrollViewport.width -= TornadoChartScrolling.ScrollBarWidth;
                    }
                };
                TornadoChartScrolling.prototype.createOrRemoveScrollbar = function (isVisible, brushGraphicsContext, brushClass) {
                    if (isVisible && this.isScrollable) {
                        return brushGraphicsContext || this.root.append("g").classed(brushClass, true);
                    }
                    return brushGraphicsContext ? void brushGraphicsContext.remove() : undefined;
                };
                TornadoChartScrolling.prototype.renderScrollbar = function (brush, brushGraphicsContext, brushX, brushY, onRender) {
                    brush.on("brush", function () { return window.requestAnimationFrame(function () { return onRender(); }); });
                    brushGraphicsContext.attr({
                        "transform": visuals.SVGUtil.translate(brushX, brushY),
                        "drag-resize-disabled": "true" /*disables resizing of the visual when dragging the scrollbar in edit mode*/
                    });
                    brushGraphicsContext.call(brush); /*call the brush function, causing it to create the rectangles   */
                    /* Disabling the zooming feature */
                    brushGraphicsContext.selectAll(".resize rect").remove();
                    brushGraphicsContext.select(".background").remove();
                    brushGraphicsContext.selectAll(".extent").style({
                        "fill-opacity": 0.125,
                        "cursor": "default",
                    });
                };
                TornadoChartScrolling.prototype.setScrollBarSize = function (brushGraphicsContext, minExtent, isVertical) {
                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChartScrolling.ScrollBarWidth);
                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
                };
                TornadoChartScrolling.prototype.getExtentData = function (svgLength, scrollSpaceLength) {
                    var value = scrollSpaceLength * scrollSpaceLength / svgLength;
                    var scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value
                        ? 1
                        : value / TornadoChartScrolling.ScrollBarMinLength;
                    value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
                    var toScrollPosition = function (extent, scrollSpaceLength) {
                        var scrollSize = extent[1] - extent[0];
                        var scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
                        scrollSize *= scaleMultipler;
                        var start = (scrollPosition * (scrollSpaceLength - scrollSize));
                        var end = (start + scrollSize);
                        return [start / scrollSpaceLength, end / scrollSpaceLength];
                    };
                    return { value: [0, value], toScrollPosition: toScrollPosition };
                };
                TornadoChartScrolling.ScrollBarWidth = 10;
                TornadoChartScrolling.ScrollBarMinLength = 15;
                return TornadoChartScrolling;
            })();
            var TornadoChartWarning = (function () {
                function TornadoChartWarning() {
                }
                Object.defineProperty(TornadoChartWarning.prototype, "code", {
                    get: function () {
                        return "TornadoChartWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                TornadoChartWarning.prototype.getMessages = function (resourceProvider) {
                    var message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "", visualMessage;
                    visualMessage = {
                        message: message,
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                };
                return TornadoChartWarning;
            })();
            samples.TornadoChartWarning = TornadoChartWarning;
            function getTornadoChartWarning() {
                return new TornadoChartWarning();
            }
            samples.getTornadoChartWarning = getTornadoChartWarning;
            var TornadoChart = (function () {
                function TornadoChart(tornadoChartConstructorOptions) {
                    this.DefaultTornadoChartSettings = {
                        labelOutsideFillColor: visuals.dataLabelUtils.defaultLabelColor,
                        labelSettings: {
                            show: true,
                            precision: 2,
                            fontSize: TornadoChart.DefaultFontSize,
                            displayUnits: 0,
                            labelColor: visuals.dataLabelUtils.defaultInsideLabelColor,
                        },
                        showCategories: true,
                        showLegend: true,
                        legendFontSize: TornadoChart.DefaultLegendFontSize,
                        legendColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        categoriesFillColor: "#777"
                    };
                    this.DefaultFillColors = [
                        "purple", "teal"
                    ];
                    this.columnPadding = 5;
                    this.leftLabelMargin = 4;
                    this.durationAnimations = 200;
                    this.InnerTextHeightDelta = 2;
                    this.textOptions = {};
                    this.sections = {
                        left: 75,
                        right: 0,
                        isPercent: false
                    };
                    this.currentSections = _.clone(this.sections);
                    this.margin = {
                        top: 10,
                        right: 5,
                        bottom: 10,
                        left: 10
                    };
                    this.heightColumn = 0;
                    this.widthLeftSection = 0;
                    this.widthRightSection = 0;
                    if (tornadoChartConstructorOptions) {
                        this.svg = tornadoChartConstructorOptions.svg || this.svg;
                        this.margin = tornadoChartConstructorOptions.margin || this.margin;
                        this.sections = tornadoChartConstructorOptions.sections || this.sections;
                        this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding;
                        this.currentSections = _.clone(this.sections);
                        if (tornadoChartConstructorOptions.animator) {
                            this.animator = tornadoChartConstructorOptions.animator;
                        }
                    }
                }
                TornadoChart.prototype.init = function (visualInitOptions) {
                    var _this = this;
                    var style = visualInitOptions.style, fontSize;
                    this.hostService = visualInitOptions.host;
                    this.selectionManager = new SelectionManager({ hostServices: this.hostService });
                    this.element = visualInitOptions.element;
                    this.colors = style.colorPalette.dataColors;
                    var root;
                    if (this.svg)
                        this.root = root = this.svg;
                    else
                        this.root = root = d3.select(this.element.get(0))
                            .append("svg");
                    root
                        .classed(TornadoChart.ClassName, true)
                        .style('position', 'absolute');
                    fontSize = root.style("font-size");
                    this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2);
                    this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2));
                    this.textOptions.fontFamily = root.style("font-family");
                    this.scrolling = new TornadoChartScrolling(function () { return root; }, function () { return _this.viewport; }, function () { return _this.margin; }, true);
                    this.main = root.append("g");
                    this.columns = this.main
                        .append("g")
                        .classed(TornadoChart.Columns["class"], true);
                    this.axes = this.main
                        .append("g")
                        .classed(TornadoChart.Axes["class"], true);
                    this.labels = this.main
                        .append("g")
                        .classed(TornadoChart.Labels["class"], true);
                    this.categories = this.main
                        .append("g")
                        .classed(TornadoChart.Categories["class"], true);
                    this.legend = visuals.createLegend(this.element, false, null);
                };
                TornadoChart.prototype.update = function (visualUpdateOptions) {
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.dataViews ||
                        !visualUpdateOptions.dataViews[0]) {
                        return;
                    }
                    this.dataView = visualUpdateOptions.dataViews[0];
                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
                    this.tornadoChartDataView = this.converter(this.dataView);
                    this.viewport = {
                        height: visualUpdateOptions.viewport.height,
                        width: visualUpdateOptions.viewport.width
                    };
                    this.render();
                };
                TornadoChart.prototype.subtractMargin = function (viewport) {
                    return {
                        height: viewport.height - this.margin.top - this.margin.bottom,
                        width: viewport.width - this.margin.left - this.margin.right
                    };
                };
                TornadoChart.prototype.updateElements = function () {
                    var elementsTranslate = visuals.SVGUtil.translate(this.widthLeftSection, 0);
                    this.root.attr({
                        "height": this.viewport.height,
                        "width": this.viewport.width
                    });
                    this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.columns
                        .attr("transform", elementsTranslate);
                    this.labels
                        .attr("transform", elementsTranslate);
                    this.axes
                        .attr("transform", elementsTranslate);
                };
                TornadoChart.prototype.getValueByPercent = function (percent, maxValue, isPrecent) {
                    if (isPrecent === void 0) { isPrecent = true; }
                    return isPrecent
                        ? (percent * maxValue) / 100
                        : percent;
                };
                TornadoChart.prototype.converter = function (dataView) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].source ||
                        !dataView.categorical.values ||
                        !dataView.categorical.values[0]) {
                        return null;
                    }
                    var categories, values = dataView.categorical.values, series, displayName, objects, settings;
                    categories = this.parseCategories(dataView);
                    displayName = dataView.categorical.categories[0].source.displayName;
                    objects = this.getObjectsFromDataView(dataView);
                    settings = this.parseSettings(dataView, objects, values[0].values[0]);
                    this.labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight({
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize),
                    });
                    series = this.parseSeries(values);
                    if (series.length === 0) {
                        categories = [];
                    }
                    return {
                        displayName: displayName,
                        categories: categories,
                        series: series,
                        settings: settings,
                        legend: this.getLegendData(series)
                    };
                };
                TornadoChart.prototype.parseSettings = function (dataView, objects, value) {
                    var valueFormatter, tooltipFormatter, precision, displayUnits;
                    precision = this.getPrecision(objects);
                    displayUnits = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, this.DefaultTornadoChartSettings.labelSettings.displayUnits);
                    valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, TornadoChart.Properties.general.formatString),
                        precision: precision,
                        value: (displayUnits === 0) && (value != null) ? value : displayUnits,
                    });
                    tooltipFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, TornadoChart.Properties.general.formatString),
                        precision: precision,
                        value: 0
                    });
                    this.parseLegendProperties(dataView);
                    var labelSettings = this.DefaultTornadoChartSettings.labelSettings;
                    return {
                        labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),
                        labelSettings: {
                            show: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
                            precision: precision,
                            fontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
                            displayUnits: displayUnits,
                            labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects),
                        },
                        formatter: valueFormatter,
                        showCategories: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),
                        showLegend: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),
                        legendFontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),
                        legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),
                        categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),
                        tooltipFormatter: tooltipFormatter,
                    };
                };
                TornadoChart.prototype.parseLegendProperties = function (dataView) {
                    if (!dataView || !dataView.metadata) {
                        this.legendObjectProperties = {};
                        return;
                    }
                    this.legendObjectProperties =
                        powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {});
                };
                TornadoChart.prototype.getColor = function (properties, defaultColor, objects) {
                    var colorHelper;
                    colorHelper = new visuals.ColorHelper(this.colors, properties, defaultColor);
                    return colorHelper.getColorForMeasure(objects, "");
                };
                TornadoChart.prototype.getPrecision = function (objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, this.DefaultTornadoChartSettings.labelSettings.precision);
                    if (precision <= TornadoChart.MinPrecision) {
                        return TornadoChart.MinPrecision;
                    }
                    if (precision >= TornadoChart.MaxPrecision) {
                        return TornadoChart.MaxPrecision;
                    }
                    return precision;
                };
                TornadoChart.prototype.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                TornadoChart.prototype.parseCategories = function (dataView) {
                    return dataView.categorical.categories[0].values.map(function (x, i) { return {
                        value: x,
                        selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i])
                    }; });
                };
                TornadoChart.prototype.parseSeries = function (dataViewValueColumns) {
                    var _this = this;
                    if (dataViewValueColumns.length > TornadoChart.MaxSeries) {
                        this.hostService.setWarnings([getTornadoChartWarning()]);
                        return [];
                    }
                    var isGrouped = !!dataViewValueColumns.source, grouped = [];
                    if (dataViewValueColumns.grouped) {
                        grouped = dataViewValueColumns.grouped();
                    }
                    return dataViewValueColumns.map(function (dataViewValueColumn, index) {
                        var displayName = "", color, selectionId, objects, categoryAxisObject;
                        if (isGrouped && grouped[index]) {
                            selectionId = visuals.SelectionId.createWithIdAndMeasure(dataViewValueColumn.identity, dataViewValueColumn.source.queryName);
                            objects = grouped[index].objects;
                        }
                        else {
                            selectionId = visuals.SelectionId.createWithMeasure(dataViewValueColumn.source.queryName);
                            objects = dataViewValueColumn.source.objects;
                        }
                        categoryAxisObject = dataViewValueColumn.source && dataViewValueColumn.source.objects ? dataViewValueColumn.source.objects['categoryAxis'] : null;
                        if (dataViewValueColumn.source.groupName) {
                            displayName = dataViewValueColumn.source.groupName;
                        }
                        else if (dataViewValueColumn.source.displayName) {
                            displayName = dataViewValueColumn.source.displayName;
                        }
                        color = _this.getColor(TornadoChart.Properties.dataPoint.fill, _this.DefaultFillColors[index], objects);
                        var categoryAxisEnd = categoryAxisObject ? categoryAxisObject['end'] : null;
                        return {
                            fill: color,
                            name: displayName,
                            values: dataViewValueColumn.values,
                            selectionId: selectionId,
                            categoryAxisEnd: categoryAxisEnd,
                        };
                    });
                };
                TornadoChart.prototype.getLegendData = function (series) {
                    var legendDataPoints;
                    legendDataPoints = series.map(function (item) {
                        return {
                            label: item.name,
                            color: item.fill,
                            icon: visuals.LegendIcon.Box,
                            selected: false,
                            identity: item.selectionId
                        };
                    });
                    return {
                        dataPoints: legendDataPoints
                    };
                };
                TornadoChart.prototype.updateSections = function () {
                    var dataView = this.tornadoChartDataView;
                    if (!dataView ||
                        !dataView.settings) {
                        return;
                    }
                    var settings = dataView.settings;
                    this.currentSections.left = settings.showCategories
                        ? this.sections.left
                        : 0;
                    this.currentSections.right = this.currentSections.isPercent
                        ? TornadoChart.MaxSizeSections - this.currentSections.left
                        : this.scrolling.scrollViewport.width - this.currentSections.left;
                };
                TornadoChart.prototype.clearData = function () {
                    this.columns.selectAll("*").remove();
                    this.axes.selectAll("*").remove();
                    this.labels.selectAll("*").remove();
                    this.categories.selectAll("*").remove();
                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);
                };
                TornadoChart.prototype.render = function () {
                    var tornadoChartDataView = this.tornadoChartDataView;
                    if (!tornadoChartDataView ||
                        !tornadoChartDataView.settings) {
                        this.clearData();
                        return;
                    }
                    this.renderLegend();
                    this.updateViewport();
                    var viewport = this.subtractMargin(this.viewport);
                    if (viewport.width <= 0 || viewport.height <= 0) {
                        return;
                    }
                    this.widthLeftSection = this.getValueByPercent(this.currentSections.left, this.viewport.width, this.currentSections.isPercent);
                    this.updateElements();
                    this.viewport = viewport;
                    this.scrolling.renderY(tornadoChartDataView, tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight, this.renderWithScrolling.bind(this));
                };
                TornadoChart.prototype.renderWithScrolling = function (tornadoChartDataView, scrollStart, scrollEnd) {
                    var categoriesLength = tornadoChartDataView.categories.length;
                    var startIndex = scrollStart * categoriesLength;
                    var endIndex = scrollEnd * categoriesLength;
                    var startIndexRound = Math.floor(startIndex);
                    var endIndexRound = Math.floor(endIndex);
                    var maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
                    if (scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound) {
                        if (startIndex - startIndexRound > endIndex - endIndexRound) {
                            startIndexRound++;
                        }
                        else {
                            endIndex--;
                        }
                    }
                    tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound);
                    for (var _i = 0, _a = tornadoChartDataView.series; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.values = item.values.slice(startIndexRound, endIndexRound);
                    }
                    this.tornadoChartDataView = tornadoChartDataView;
                    this.updateSections();
                    this.widthRightSection = this.getValueByPercent(this.currentSections.right, this.viewport.width, this.currentSections.isPercent);
                    this.computeHeightColumn();
                    this.renderMiddleSection();
                    this.renderAxes();
                    this.renderCategories();
                };
                TornadoChart.prototype.updateViewport = function () {
                    var legendMargins = this.legend.getMargins(), legendPosition;
                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter: {
                            this.viewport.height -= legendMargins.height;
                            break;
                        }
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter: {
                            this.viewport.width -= legendMargins.width;
                            break;
                        }
                    }
                };
                TornadoChart.prototype.computeHeightColumn = function () {
                    var length = this.tornadoChartDataView.categories.length;
                    this.heightColumn = (this.scrolling.scrollViewport.height - ((length - 1) * this.columnPadding)) / length;
                };
                TornadoChart.prototype.renderMiddleSection = function () {
                    var columnsData = this.generateColumnDataBySeries();
                    var tornadoChartDataView = this.tornadoChartDataView;
                    this.renderColumns(columnsData, tornadoChartDataView.series.length === 2);
                    this.renderLabels(columnsData, tornadoChartDataView.settings);
                };
                TornadoChart.prototype.renderColumns = function (columnsData, selectSecondSeries) {
                    var _this = this;
                    if (selectSecondSeries === void 0) { selectSecondSeries = false; }
                    var columnsSelection, columnElements = this.main
                        .select(TornadoChart.Columns.selector)
                        .selectAll(TornadoChart.Column.selector);
                    columnsSelection = columnElements.data(columnsData);
                    columnsSelection
                        .enter()
                        .append("svg:rect");
                    columnsSelection
                        .attr("x", function (item) { return item.x; })
                        .attr("y", function (item) { return item.y; })
                        .on("click", function (item, index) {
                        _this.selectionManager
                            .select(item.selectionId, false)
                            .then(function () { return _this.setSelection(columnsSelection, selectSecondSeries); });
                        d3.event.stopPropagation();
                    });
                    this.setSelection(columnsSelection, selectSecondSeries);
                    (columnElements[0] && columnElements[0].length === columnsData.length
                        ? this.animation(columnsSelection)
                        : columnsSelection)
                        .attr("width", function (item) { return Math.max(item.width, 0); })
                        .attr("height", function (item) { return Math.max(item.height, 0); })
                        .style("fill", function (item) { return item.color; })
                        .attr("transform", function (item) { return visuals.SVGUtil.translateAndRotate(item.dx, item.dy, item.px, item.py, item.angle); });
                    columnsSelection.classed(TornadoChart.Column["class"], true);
                    columnsSelection
                        .exit()
                        .remove();
                    this.renderTooltip(columnsSelection);
                    this.root.on("click", function () {
                        var mousePosition = d3.mouse(_this.root.node());
                        var rect = _this.root.node().getBoundingClientRect();
                        var scrollWidth = {
                            x: _this.viewport.height - _this.scrolling.scrollViewport.height,
                            y: _this.viewport.width - _this.scrolling.scrollViewport.width
                        };
                        if ((!scrollWidth.y || (rect.width -
                            (_this.viewport.width - _this.scrolling.scrollViewport.width) - _this.margin.right > mousePosition[0]))
                            && (!scrollWidth.x || (rect.height -
                                (_this.viewport.height - _this.scrolling.scrollViewport.height) - _this.margin.bottom > mousePosition[1]))) {
                            _this.selectionManager.clear();
                            _this.setSelection(columnsSelection, selectSecondSeries);
                        }
                    });
                };
                TornadoChart.prototype.setSelection = function (columns, selectSecondSeries) {
                    if (selectSecondSeries === void 0) { selectSecondSeries = false; }
                    var selectionIds = this.selectionManager.getSelectionIds();
                    if (!selectionIds.length) {
                        this.setOpacity(columns, TornadoChart.MaxOpacity);
                        return;
                    }
                    var selectedColumns = columns.filter(function (x) {
                        return selectionIds.some(function (y) { return y.getKey() === x.selectionId.getKey(); });
                    });
                    this.setOpacity(columns, TornadoChart.MinColumnOpacity);
                    this.setOpacity(selectedColumns, TornadoChart.MaxOpacity);
                };
                TornadoChart.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipData;
                    });
                };
                TornadoChart.prototype.generateColumnDataBySeries = function () {
                    var _this = this;
                    var categories = this.tornadoChartDataView.categories, series = this.tornadoChartDataView.series, width, minValue, maxValue;
                    width = this.widthRightSection;
                    if (series && series.length === 0) {
                        return [];
                    }
                    minValue = Math.min(d3.min(series[0].values), 0);
                    maxValue = d3.max(series[0].values);
                    if (series.length === TornadoChart.MaxSeries) {
                        minValue = d3.min([minValue, d3.min(series[1].values)]);
                        maxValue = d3.max([maxValue, d3.max(series[1].values)]);
                        width = width / TornadoChart.MaxSeries;
                    }
                    return series.reduce(function (previousValue, currentValue, index) {
                        var shiftToMiddle = index === 0 && series.length === TornadoChart.MaxSeries, shiftToRight = index === 1, seriesName = currentValue.name;
                        return previousValue.concat(_this.generateColumnDataByValues(currentValue, minValue, maxValue, width, shiftToRight, shiftToMiddle, categories, seriesName));
                    }, []);
                };
                TornadoChart.prototype.generateColumnDataByValues = function (tornadoChartSeries, minValue, maxValue, maxWidth, shiftToRight, shiftToMiddle, categories, seriesName) {
                    var _this = this;
                    return tornadoChartSeries.values.map(function (value, index) {
                        return _this.generateColumnData(value ? value : 0, minValue, maxValue, maxWidth, shiftToMiddle, shiftToRight, tornadoChartSeries.fill, index, categories[index], seriesName, tornadoChartSeries.categoryAxisEnd);
                    });
                };
                TornadoChart.prototype.generateColumnData = function (value, minValue, maxValue, width, shiftToMiddle, shiftToRight, color, index, categoryValue, seriesName, categoryAxisEnd) {
                    var x = 0, y = 0, widthOfColumn, shift = 0, dy, dx, label, angle = 0;
                    // Limit maximum value with what the user choose
                    maxValue = categoryAxisEnd ? Math.min(categoryAxisEnd, maxValue) : maxValue;
                    widthOfColumn = this.getColumnWidth(value, minValue, maxValue, width);
                    shift = width - widthOfColumn;
                    dx = shift * Number(shiftToMiddle) + width * Number(shiftToRight);
                    dy = (this.heightColumn + this.columnPadding) * index;
                    label = this.getLabelData(value, x, y, dx, dy, widthOfColumn, shiftToMiddle);
                    if (shiftToMiddle) {
                        angle = 180;
                    }
                    return {
                        x: x,
                        y: y,
                        dx: dx,
                        dy: dy,
                        px: widthOfColumn / 2,
                        py: this.heightColumn / 2,
                        angle: angle,
                        width: widthOfColumn,
                        height: this.heightColumn,
                        label: label,
                        color: color,
                        selectionId: categoryValue.selectionId,
                        tooltipData: this.getTooltipData(this.tornadoChartDataView.displayName, categoryValue.value, seriesName, this.tornadoChartDataView.settings.tooltipFormatter.format(value))
                    };
                };
                TornadoChart.prototype.getColumnWidth = function (value, minValue, maxValue, width) {
                    if (minValue === maxValue) {
                        return width;
                    }
                    var columnWidth = width * (value - minValue) / (maxValue - minValue);
                    // In case the user specifies a custom category axis end we limit the
                    // column width to the maximum available width
                    return Math.min(width, columnWidth);
                };
                TornadoChart.prototype.getLabelData = function (value, xColumn, yColumn, dxColumn, dyColumn, columnWidth, isColumnPositionLeft) {
                    var dx, valueAfterValueFormatter, textDataAfterValueFormatter, tornadoChartSettings = this.tornadoChartDataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor;
                    var maxOutsideLabelWidth = isColumnPositionLeft
                        ? dxColumn - this.leftLabelMargin
                        : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin + this.margin.right);
                    var maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin);
                    var textProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize),
                        text: tornadoChartSettings.formatter.format(value),
                    };
                    valueAfterValueFormatter = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth);
                    textDataAfterValueFormatter = this.getTextData(valueAfterValueFormatter, true, false, fontSize);
                    if (columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding) {
                        dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2;
                    }
                    else {
                        if (isColumnPositionLeft) {
                            dx = dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width;
                        }
                        else {
                            dx = dxColumn + columnWidth + this.leftLabelMargin;
                        }
                        color = tornadoChartSettings.labelOutsideFillColor;
                    }
                    return {
                        x: xColumn,
                        y: yColumn,
                        dx: dx,
                        dy: dyColumn + this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta,
                        source: value,
                        value: valueAfterValueFormatter,
                        color: color,
                        width: textDataAfterValueFormatter.width
                    };
                };
                TornadoChart.prototype.getTooltipData = function (displayName, categoryValue, seriesName, value) {
                    return [{
                            displayName: displayName,
                            value: categoryValue
                        }, {
                            displayName: seriesName,
                            value: value
                        }];
                };
                TornadoChart.prototype.renderAxes = function () {
                    var linesData, axesSelection, axesElements = this.main
                        .select(TornadoChart.Axes.selector)
                        .selectAll(TornadoChart.Axis.selector);
                    if (this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries) {
                        axesElements.remove();
                        return;
                    }
                    linesData = this.generateAxesData();
                    axesSelection = axesElements.data(linesData);
                    axesSelection
                        .enter()
                        .append("svg:line")
                        .classed(TornadoChart.Axis["class"], true);
                    this.animation(axesSelection)
                        .attr("x1", function (item) { return item.x1; })
                        .attr("y1", function (item) { return item.y1; })
                        .attr("x2", function (item) { return item.x2; })
                        .attr("y2", function (item) { return item.y2; });
                    axesSelection
                        .exit()
                        .remove();
                };
                TornadoChart.prototype.generateAxesData = function () {
                    var x, y1, y2;
                    x = this.widthRightSection / 2;
                    y1 = 0;
                    y2 = this.scrolling.scrollViewport.height;
                    return [{
                            x1: x,
                            y1: y1,
                            x2: x,
                            y2: y2
                        }];
                };
                TornadoChart.prototype.renderLabels = function (columnsData, settings) {
                    var _this = this;
                    var labelEnterSelection, labelSelection, labelSelectionAnimation, labelElements = this.main
                        .select(TornadoChart.Labels.selector)
                        .selectAll(TornadoChart.Label.selector);
                    labelSelection = labelElements.data(columnsData);
                    labelEnterSelection = labelSelection
                        .enter()
                        .append("g");
                    labelEnterSelection
                        .append("svg:title")
                        .classed(TornadoChart.LabelTitle["class"], true);
                    labelEnterSelection
                        .append("svg:text")
                        .attr("dy", visuals.dataLabelUtils.DefaultDy)
                        .classed(TornadoChart.LabelText["class"], true);
                    labelSelection
                        .attr("x", function (item) { return item.label.x; })
                        .attr("y", function (item) { return item.label.y; })
                        .attr("display", function (item) {
                        var leftBorder = 0, rightBorder = _this.currentSections.right, x = item.label.x + item.label.dx;
                        if (leftBorder < x &&
                            rightBorder > x + item.label.width) {
                            return null;
                        }
                        else {
                            return "none";
                        }
                    })
                        .attr("pointer-events", "none")
                        .classed(TornadoChart.Label["class"], true);
                    labelSelection
                        .select(TornadoChart.LabelTitle.selector)
                        .text(function (item) { return item.label.source; });
                    labelSelectionAnimation = labelElements[0] && labelElements[0].length === columnsData.length
                        ? this.animation(labelSelection)
                        : labelSelection;
                    labelSelectionAnimation
                        .attr("transform", function (item) { return visuals.SVGUtil.translate(item.label.dx, item.label.dy); });
                    this.animation(labelSelection
                        .select(TornadoChart.LabelText.selector))
                        .attr("fill", function (item) { return item.label.color; })
                        .attr("font-size", function (item) { return PixelConverter.fromPoint(settings.labelSettings.fontSize); })
                        .text(function (item) { return item.label.value; });
                    if (!settings.labelSettings.show || this.labelHeight > this.heightColumn) {
                        this.setOpacity(labelSelectionAnimation);
                    }
                    else {
                        this.setOpacity(labelSelectionAnimation, TornadoChart.MaxOpacity);
                    }
                    labelSelection
                        .exit()
                        .remove();
                };
                TornadoChart.prototype.renderCategories = function () {
                    var _this = this;
                    var settings = this.tornadoChartDataView.settings, color = settings.categoriesFillColor, categoriesEnterSelection, categoriesSelection, categoryElements = this.main
                        .select(TornadoChart.Categories.selector)
                        .selectAll(TornadoChart.Category.selector), self = this;
                    if (!settings.showCategories) {
                        categoryElements.remove();
                        return;
                    }
                    categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories);
                    categoriesEnterSelection = categoriesSelection
                        .enter()
                        .append("g");
                    categoriesEnterSelection
                        .append("svg:title")
                        .classed(TornadoChart.CategoryTitle["class"], true);
                    categoriesEnterSelection
                        .append("svg:text")
                        .classed(TornadoChart.CategoryText["class"], true);
                    categoriesSelection
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("transform", function (item, index) {
                        var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = _this.getTextData(item, false, true);
                        shift = shift + textData.height / 2 - _this.InnerTextHeightDelta;
                        return visuals.SVGUtil.translate(0, shift);
                    })
                        .classed(TornadoChart.Category["class"], true);
                    categoriesSelection
                        .select(TornadoChart.CategoryTitle.selector)
                        .text(function (item) { return item.value; });
                    categoriesSelection
                        .select(TornadoChart.CategoryText.selector)
                        .attr("fill", color)
                        .text(function (item) {
                        var textData = self.getTextData(item.value);
                        return powerbi.TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);
                    });
                    categoriesSelection
                        .exit()
                        .remove();
                };
                TornadoChart.prototype.renderLegend = function () {
                    var legend = this.tornadoChartDataView.legend;
                    if (!legend) {
                        return;
                    }
                    var settings = this.tornadoChartDataView.settings;
                    var legendData = {
                        title: legend.title,
                        dataPoints: legend.dataPoints,
                        fontSize: settings.legendFontSize,
                        labelColor: settings.legendColor,
                    };
                    if (this.legendObjectProperties) {
                        var position;
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position) {
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                    }
                    this.legend.drawLegend(legendData, this.viewport);
                    visuals.Legend.positionChartArea(this.root, this.legend);
                };
                TornadoChart.prototype.getTextData = function (text, measureWidth, measureHeight, overrideFontSize) {
                    if (measureWidth === void 0) { measureWidth = false; }
                    if (measureHeight === void 0) { measureHeight = false; }
                    var width = 0, height = 0, fontSize, textProperties;
                    text = text || "";
                    fontSize = overrideFontSize
                        ? PixelConverter.fromPoint(overrideFontSize)
                        : "" + this.textOptions.fontSize + this.textOptions.sizeUnit;
                    textProperties = {
                        text: text,
                        fontFamily: this.textOptions.fontFamily,
                        fontSize: fontSize
                    };
                    if (measureWidth) {
                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    }
                    if (measureHeight) {
                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                    }
                    return {
                        text: text,
                        options: this.textOptions,
                        width: width,
                        height: height,
                        textProperties: textProperties
                    };
                };
                TornadoChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), settings;
                    if (!this.tornadoChartDataView ||
                        !this.tornadoChartDataView.settings) {
                        return [];
                    }
                    settings = this.tornadoChartDataView.settings;
                    switch (options.objectName) {
                        case "dataPoint": {
                            this.enumerateDataPoint(enumeration);
                            break;
                        }
                        case "categoryAxis": {
                            this.enumerateCategoryAxis(enumeration);
                            break;
                        }
                        case "labels": {
                            var labelSettings = settings.labelSettings;
                            var labels = {
                                objectName: "labels",
                                displayName: "labels",
                                selector: null,
                                properties: {
                                    show: labelSettings.show,
                                    fontSize: labelSettings.fontSize,
                                    labelPrecision: labelSettings.precision,
                                    labelDisplayUnits: labelSettings.displayUnits,
                                    insideFill: labelSettings.labelColor,
                                    outsideFill: settings.labelOutsideFillColor
                                }
                            };
                            enumeration.pushInstance(labels);
                            break;
                        }
                        case "legend": {
                            var showTitle = true, titleText = "", legend;
                            showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);
                            titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);
                            legend = {
                                objectName: "legend",
                                displayName: "legend",
                                selector: null,
                                properties: {
                                    show: settings.showLegend,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    fontSize: settings.legendFontSize,
                                    labelColor: settings.legendColor,
                                }
                            };
                            enumeration.pushInstance(legend);
                            break;
                        }
                        case "categories": {
                            var categories = {
                                objectName: "categories",
                                displayName: "categories",
                                selector: null,
                                properties: {
                                    show: settings.showCategories,
                                    fill: settings.categoriesFillColor
                                }
                            };
                            enumeration.pushInstance(categories);
                            break;
                        }
                    }
                    return enumeration.complete();
                };
                TornadoChart.prototype.enumerateDataPoint = function (enumeration) {
                    if (!this.tornadoChartDataView ||
                        !this.tornadoChartDataView.series) {
                        return;
                    }
                    var series = this.tornadoChartDataView.series;
                    for (var _i = 0; _i < series.length; _i++) {
                        var item = series[_i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: item.name,
                            selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), false),
                            properties: {
                                fill: { solid: { color: item.fill } }
                            }
                        });
                    }
                };
                TornadoChart.prototype.enumerateCategoryAxis = function (enumeration) {
                    if (!this.tornadoChartDataView || !this.tornadoChartDataView.series)
                        return;
                    var series = this.tornadoChartDataView.series;
                    for (var _i = 0; _i < series.length; _i++) {
                        var item = series[_i];
                        enumeration.pushInstance({
                            objectName: "categoryAxis",
                            displayName: item.name,
                            selector: item.selectionId ? item.selectionId.getSelector() : null,
                            properties: {
                                end: item.categoryAxisEnd,
                            }
                        });
                    }
                };
                TornadoChart.prototype.setOpacity = function (element, opacityValue, disableAnimation) {
                    if (opacityValue === void 0) { opacityValue = TornadoChart.MinOpacity; }
                    if (disableAnimation === void 0) { disableAnimation = false; }
                    var elementAnimation = disableAnimation
                        ? element
                        : this.animation(element);
                    return elementAnimation.style("fill-opacity", opacityValue);
                };
                TornadoChart.prototype.animation = function (element) {
                    if (!this.durationAnimations) {
                        return element;
                    }
                    return element
                        .transition()
                        .duration(this.durationAnimations);
                };
                TornadoChart.prototype.destroy = function () {
                    this.root = null;
                };
                TornadoChart.ClassName = "tornado-chart";
                TornadoChart.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        labelDisplayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        insideFill: {
                            objectName: "labels",
                            propertyName: "insideFill"
                        },
                        outsideFill: {
                            objectName: "labels",
                            propertyName: "outsideFill"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        },
                        labelColor: {
                            objectName: "legend",
                            propertyName: "labelColor"
                        },
                        fontSize: {
                            objectName: "legend",
                            propertyName: "fontSize"
                        },
                    },
                    categories: {
                        show: {
                            objectName: "categories",
                            propertyName: "show"
                        },
                        fill: {
                            objectName: "categories",
                            propertyName: "fill"
                        }
                    }
                };
                TornadoChart.Columns = {
                    "class": "columns",
                    selector: ".columns"
                };
                TornadoChart.Column = {
                    "class": "column",
                    selector: ".column"
                };
                TornadoChart.Axes = {
                    "class": "axes",
                    selector: ".axes"
                };
                TornadoChart.Axis = {
                    "class": "axis",
                    selector: ".axis"
                };
                TornadoChart.Labels = {
                    "class": "labels",
                    selector: ".labels"
                };
                TornadoChart.Label = {
                    "class": "label",
                    selector: ".label"
                };
                TornadoChart.LabelTitle = {
                    "class": "label-title",
                    selector: ".label-title"
                };
                TornadoChart.LabelText = {
                    "class": "label-text",
                    selector: ".label-text"
                };
                TornadoChart.Categories = {
                    "class": "categories",
                    selector: ".categories"
                };
                TornadoChart.Category = {
                    "class": "category",
                    selector: ".category"
                };
                TornadoChart.CategoryTitle = {
                    "class": "category-title",
                    selector: ".category-title"
                };
                TornadoChart.CategoryText = {
                    "class": "category-text",
                    selector: ".category-text"
                };
                TornadoChart.MaxSeries = 2;
                TornadoChart.MinPrecision = 0;
                TornadoChart.MaxPrecision = 17; // max number of decimals in float
                TornadoChart.MinOpacity = 0;
                TornadoChart.MinColumnOpacity = 0.2;
                TornadoChart.MaxOpacity = 1;
                TornadoChart.MaxSizeSections = 100;
                TornadoChart.LabelPadding = 2.5;
                TornadoChart.CategoryMinHeight = 25;
                TornadoChart.DefaultFontSize = 9;
                TornadoChart.DefaultLegendFontSize = 8;
                TornadoChart.capabilities = {
                    dataRoles: [{
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend')
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { "Category": { max: 1 }, "Values": { min: 0, max: 1 }, "Series": { min: 0, max: 1 } },
                                { "Category": { max: 1 }, "Values": { min: 2, max: 2 }, "Series": { max: 0 } }
                            ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [{ for: { in: "Values" } }],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                }
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    },
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: 'X-Axis',
                            properties: {
                                end: {
                                    displayName: 'End',
                                    type: { numeric: true },
                                    suppressFormatPainterCopy: true,
                                },
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: { bool: true }
                                },
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                    type: { numeric: true }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                                labelDisplayUnits: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                    type: { formatting: { labelDisplayUnits: true } },
                                },
                                insideFill: {
                                    displayName: "Inside fill",
                                    type: { fill: { solid: { color: true } } }
                                },
                                outsideFill: {
                                    displayName: "Outside fill",
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                    type: { text: true }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        },
                        categories: {
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group"),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    }
                };
                return TornadoChart;
            })();
            samples.TornadoChart = TornadoChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/ https://github.com/jasondavies/d3-cloud
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            (function (WordCloudScaleType) {
                WordCloudScaleType[WordCloudScaleType["logn"] = 0] = "logn";
                WordCloudScaleType[WordCloudScaleType["sqrt"] = 1] = "sqrt";
                WordCloudScaleType[WordCloudScaleType["value"] = 2] = "value";
            })(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
            var WordCloudScaleType = samples.WordCloudScaleType;
            ;
            var VisualLayout = (function () {
                function VisualLayout(defaultViewport, defaultMargin) {
                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
                }
                Object.defineProperty(VisualLayout.prototype, "margin", {
                    get: function () {
                        return this.marginValue || (this.margin = this.defaultMargin);
                    },
                    set: function (value) {
                        this.marginValue = VisualLayout.restrictToMinMax(value);
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewport", {
                    get: function () {
                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
                    },
                    set: function (value) {
                        this.viewportValue = VisualLayout.restrictToMinMax(value);
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                    get: function () {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                    get: function () {
                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                VisualLayout.prototype.update = function () {
                    this.viewportInValue = VisualLayout.restrictToMinMax({
                        width: this.viewport.width - (this.margin.left + this.margin.right),
                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
                    });
                };
                VisualLayout.restrictToMinMax = function (value) {
                    var result = $.extend({}, value);
                    d3.keys(value).forEach(function (x) { return result[x] = Math.max(0, value[x]); });
                    return result;
                };
                return VisualLayout;
            })();
            var WordCloud = (function () {
                function WordCloud(options) {
                    this.durationAnimations = 500;
                    this.fakeViewport = {
                        width: 1500,
                        height: 1000
                    };
                    this.canvasViewport = {
                        width: 128,
                        height: 2048
                    };
                    if (options) {
                        this.svg = options.svg || this.svg;
                        this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin);
                        if (options.animator)
                            this.animator = options.animator;
                    }
                }
                WordCloud.prototype.init = function (options) {
                    var _this = this;
                    if (this.svg)
                        this.root = this.svg;
                    else
                        this.root = d3.select(options.element.get(0)).append("svg");
                    WordCloud.colors = options.style.colorPalette.dataColors;
                    this.hostService = options.host;
                    this.selectionManager = new visuals.utility.SelectionManager({ hostServices: this.hostService });
                    if (!this.layout)
                        this.layout = new VisualLayout(null, WordCloud.DefaultMargin);
                    this.root.classed(WordCloud.ClassName, true);
                    this.root.on("click", function () {
                        _this.selectionManager.clear();
                        _this.setSelection(_this.wordsSelection);
                    });
                    this.fontFamily = this.root.style("font-family");
                    this.main = this.root.append("g");
                    this.wordsContainerSelection = this.main
                        .append("g")
                        .classed(WordCloud.Words["class"], true);
                    this.canvas = document.createElement("canvas");
                };
                WordCloud.prototype.converter = function (dataView) {
                    var _this = this;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !dataView.categorical.categories[0].values.length ||
                        !(dataView.categorical.categories[0].values.length > 0))
                        return null;
                    var categories = dataView.categorical.categories[0].values, settings = WordCloud.parseSettings(dataView, categories[0]), frequencies, texts;
                    if (!settings)
                        return null;
                    if (!_.isEmpty(dataView.categorical.values) &&
                        !_.isEmpty(dataView.categorical.values[0]) &&
                        !_.isEmpty(dataView.categorical.values[0].values))
                        frequencies = dataView.categorical.values[0].values;
                    texts = categories.map(function (item, index) {
                        var color, categoryObject = dataView.categorical.categories[0];
                        if (categoryObject.objects && categoryObject.objects[index])
                            color = _this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]);
                        else {
                            if (_this.wordCloudTexts && _this.wordCloudTexts[index])
                                color = _this.wordCloudTexts[index].color;
                            else
                                color = explore.util.getRandomColor();
                        }
                        return {
                            text: item,
                            count: (frequencies && frequencies[index] && !isNaN(frequencies[index])) ? frequencies[index] : 1,
                            index: index,
                            selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),
                            color: color,
                        };
                    });
                    return {
                        settings: settings,
                        texts: texts
                    };
                };
                WordCloud.prototype.getColor = function (properties, defaultColor, objects) {
                    var colorHelper;
                    colorHelper = new visuals.ColorHelper(WordCloud.colors, properties, defaultColor);
                    return explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, ""));
                };
                WordCloud.parseSettings = function (dataView, value) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.columns[0])
                        return null;
                    var objects = dataView.metadata.objects, valueFormatter, minFontSize, maxFontSize, minAngle, maxAngle, maxNumberOfOrientations, isRotateText = false, isBrokenText = true, isRemoveStopWords = true, stopWords, stopWordsArray, isDefaultStopWords = false, maxNumberOfWords;
                    maxNumberOfWords = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords);
                    minFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.minFontSize, WordCloud.DefaultSettings.minFontSize);
                    maxFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxFontSize, WordCloud.DefaultSettings.maxFontSize);
                    minAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.minAngle, WordCloud.DefaultSettings.minAngle);
                    maxAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxAngle, WordCloud.DefaultSettings.maxAngle);
                    isRotateText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.rotateText.show, WordCloud.DefaultSettings.isRotateText);
                    maxNumberOfOrientations = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxNumberOfOrientations, WordCloud.DefaultSettings.maxNumberOfOrientations);
                    valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, WordCloud.Properties.general.formatString),
                        value: value
                    });
                    isBrokenText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.general.isBrokenText, WordCloud.DefaultSettings.isBrokenText);
                    isRemoveStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.show, WordCloud.DefaultSettings.isRemoveStopWords);
                    stopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.words, WordCloud.DefaultSettings.stopWords);
                    if (typeof stopWords === "string")
                        stopWordsArray = stopWords.split(WordCloud.StopWordsDelemiter);
                    else
                        stopWordsArray = WordCloud.DefaultSettings.stopWordsArray;
                    isDefaultStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.isDefaultStopWords, WordCloud.DefaultSettings.isDefaultStopWords);
                    return {
                        minFontSize: minFontSize,
                        maxFontSize: maxFontSize,
                        minAngle: minAngle,
                        maxAngle: maxAngle,
                        maxNumberOfOrientations: maxNumberOfOrientations,
                        valueFormatter: valueFormatter,
                        isRotateText: isRotateText,
                        isBrokenText: isBrokenText,
                        isRemoveStopWords: isRemoveStopWords,
                        stopWords: stopWords,
                        stopWordsArray: stopWordsArray,
                        isDefaultStopWords: isDefaultStopWords,
                        maxNumberOfWords: maxNumberOfWords
                    };
                };
                WordCloud.getNumberFromObjects = function (objects, properties, defaultValue) {
                    return objects ? powerbi.DataViewObjects.getValue(objects, properties, defaultValue) : defaultValue;
                };
                WordCloud.prototype.parseNumber = function (value, defaultValue, minValue, maxValue) {
                    if (defaultValue === void 0) { defaultValue = 0; }
                    if (minValue === void 0) { minValue = -Number.MAX_VALUE; }
                    if (maxValue === void 0) { maxValue = Number.MAX_VALUE; }
                    var parsedValue = Number(value);
                    if (isNaN(parsedValue) || (typeof value === "string" && value.length === 0))
                        return defaultValue;
                    if (parsedValue < minValue)
                        return minValue;
                    if (parsedValue > maxValue)
                        return maxValue;
                    return parsedValue;
                };
                WordCloud.prototype.computePositions = function (words, onPositionsComputed) {
                    var _this = this;
                    var context = this.getCanvasContext(), surface = [], borders = null, maxNumberOfWords;
                    if (!words || !(words.length > 0))
                        return null;
                    maxNumberOfWords = Math.abs(this.parseNumber(this.settings.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords, words.length * -1, words.length));
                    if (words.length > maxNumberOfWords)
                        words = words.slice(0, maxNumberOfWords);
                    for (var i = void 0; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) {
                        surface[i] = 0;
                    }
                    setTimeout(function () { return _this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0); }, 0);
                };
                WordCloud.prototype.computeCycle = function (words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
                    if (wordsForDraw === void 0) { wordsForDraw = []; }
                    if (index === void 0) { index = 0; }
                    var word = words[index], ratio = 1;
                    if (words.length <= 10)
                        ratio = 5;
                    else if (words.length <= 25)
                        ratio = 3;
                    else if (words.length <= 75)
                        ratio = 1.5;
                    else if (words.length <= 100)
                        ratio = 1.25;
                    word.x = (this.specialViewport.width / ratio * (Math.random() + 0.5)) >> 1;
                    word.y = (this.specialViewport.height / ratio * (Math.random() + 0.5)) >> 1;
                    this.generateSprites(context, word, words, index);
                    if (word.sprite && this.findPosition(surface, word, borders)) {
                        wordsForDraw.push(word);
                        borders = this.updateBorders(word, borders);
                        word.x -= this.specialViewport.width >> 1;
                        word.y -= this.specialViewport.height >> 1;
                    }
                    if (++index < words.length && this.root)
                        this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index);
                    else {
                        onPositionsComputed({
                            data: wordsForDraw,
                            leftBorder: borders && borders[0],
                            rightBorder: borders && borders[1]
                        });
                    }
                };
                WordCloud.prototype.updateBorders = function (word, borders) {
                    if (borders && borders.length === 2) {
                        var leftBorder = borders[0], rightBorder = borders[1];
                        if (word.x + word.x0 < leftBorder.x)
                            leftBorder.x = word.x + word.x0;
                        if (word.y + word.y0 < leftBorder.y)
                            leftBorder.y = word.y + word.y0;
                        if (word.x + word.x1 > rightBorder.x)
                            rightBorder.x = word.x + word.x1;
                        if (word.y + word.y1 > rightBorder.y)
                            rightBorder.y = word.y + word.y1;
                    }
                    else {
                        borders = [
                            {
                                x: word.x + word.x0,
                                y: word.y + word.y0
                            }, {
                                x: word.x + word.x1,
                                y: word.y + word.y1
                            }
                        ];
                    }
                    return borders;
                };
                WordCloud.prototype.generateSprites = function (context, currentWord, words, index) {
                    if (currentWord.sprite)
                        return;
                    context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
                    var x = 0, y = 0, maxHeight = 0, quantityOfWords = words.length, pixels, sprite = [];
                    for (var i = index; i < quantityOfWords; i++) {
                        var currentWordData = words[i], widthOfWord = 0, heightOfWord = 0;
                        context.save();
                        context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily;
                        widthOfWord = context.measureText(currentWordData.text + "m").width;
                        heightOfWord = currentWordData.size << 1;
                        if (currentWordData.rotate) {
                            var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
                            widthOfWord = (Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31) >> 5 << 5;
                            heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
                        }
                        else
                            widthOfWord = (widthOfWord + 31) >> 5 << 5;
                        if (heightOfWord > maxHeight)
                            maxHeight = heightOfWord;
                        if (x + widthOfWord >= (this.canvasViewport.width << 5)) {
                            x = 0;
                            y += maxHeight;
                            maxHeight = 0;
                        }
                        context.translate((x + (widthOfWord >> 1)), (y + (heightOfWord >> 1)));
                        if (currentWordData.rotate)
                            context.rotate(currentWordData.rotate * WordCloud.Radians);
                        context.fillText(currentWordData.text, 0, 0);
                        if (currentWordData.padding) {
                            context.lineWidth = 2 * currentWordData.padding;
                            context.strokeText(currentWordData.text, 0, 0);
                        }
                        context.restore();
                        currentWordData.width = widthOfWord;
                        currentWordData.height = heightOfWord;
                        currentWordData.xOff = x;
                        currentWordData.yOff = y;
                        currentWordData.x1 = widthOfWord >> 1;
                        currentWordData.y1 = heightOfWord >> 1;
                        currentWordData.x0 = -currentWordData.x1;
                        currentWordData.y0 = -currentWordData.y1;
                        x += widthOfWord;
                    }
                    pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data;
                    sprite = [];
                    for (var i = quantityOfWords - 1; i >= 0; i--) {
                        var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x_1 = 0, y_1 = 0, seen = 0, seenRow = 0;
                        if (currentWordData.xOff + width >= (this.canvasViewport.width << 5) ||
                            currentWordData.yOff + height >= this.canvasViewport.height) {
                            currentWordData.sprite = null;
                            continue;
                        }
                        for (var j = 0; j < height * width32; j++) {
                            sprite[j] = 0;
                        }
                        if (currentWordData.xOff !== null)
                            x_1 = currentWordData.xOff;
                        else
                            return;
                        y_1 = currentWordData.yOff;
                        seen = 0;
                        seenRow = -1;
                        for (var j = 0; j < height; j++) {
                            for (var k = 0; k < width; k++) {
                                var l = width32 * j + (k >> 5), index_1 = ((y_1 + j) * (this.canvasViewport.width << 5) + (x_1 + k)) << 2, m = pixels[index_1]
                                    ? 1 << (31 - (k % 32))
                                    : 0;
                                sprite[l] |= m;
                                seen |= m;
                            }
                            if (seen)
                                seenRow = j;
                            else {
                                currentWordData.y0++;
                                height--;
                                j--;
                                y_1++;
                            }
                        }
                        currentWordData.y1 = currentWordData.y0 + seenRow;
                        currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
                    }
                };
                WordCloud.prototype.findPosition = function (surface, word, borders) {
                    var startPoint = { x: word.x, y: word.y }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), point, dt = Math.random() < 0.5 ? 1 : -1, shift = -dt, dx, dy;
                    while (true) {
                        shift += dt;
                        point = this.archimedeanSpiral(shift);
                        dx = Math.floor(point.x);
                        dy = Math.floor(point.y);
                        if (Math.min(Math.abs(dx), Math.abs(dy)) >= delta)
                            break;
                        word.x = startPoint.x + dx;
                        word.y = startPoint.y + dy;
                        if (word.x + word.x0 < 0 ||
                            word.y + word.y0 < 0 ||
                            word.x + word.x1 > this.specialViewport.width ||
                            word.y + word.y1 > this.specialViewport.height)
                            continue;
                        if (!borders || !this.checkIntersect(word, surface)) {
                            if (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1])) {
                                var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = lx & 127, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);
                                for (var i = 0; i < height; i++) {
                                    var lastSprite = 0;
                                    for (var j = 0; j <= width; j++) {
                                        var leftMask = lastSprite << msx, rightMask = void 0;
                                        if (j < width)
                                            lastSprite = sprite[i * width + j];
                                        rightMask = j < width
                                            ? lastSprite >>> sx
                                            : 0;
                                        surface[x + j] |= leftMask | rightMask;
                                    }
                                    x += shiftWidth;
                                }
                                word.sprite = null;
                                return true;
                            }
                        }
                    }
                    return false;
                };
                WordCloud.prototype.archimedeanSpiral = function (value) {
                    var ratio = this.specialViewport.width / this.specialViewport.height;
                    value = value * 0.1;
                    return {
                        x: ratio * value * Math.cos(value),
                        y: value * Math.sin(value)
                    };
                };
                WordCloud.prototype.checkIntersect = function (word, surface) {
                    var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = lx & 127, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);
                    for (var i = 0; i < heightOfWord; i++) {
                        var lastSprite = 0;
                        for (var j = 0; j <= widthOfWord; j++) {
                            var mask = 0, leftMask = void 0, intersectMask = 0;
                            leftMask = lastSprite << msx;
                            if (j < widthOfWord)
                                lastSprite = sprite[i * widthOfWord + j];
                            mask = j < widthOfWord
                                ? lastSprite >>> sx
                                : 0;
                            intersectMask = (leftMask | mask) & surface[x + j];
                            if (intersectMask)
                                return true;
                        }
                        x += shiftWidth;
                    }
                    return false;
                };
                WordCloud.prototype.checkIntersectOfRectangles = function (word, leftBorder, rightBorder) {
                    return (word.x + word.x1) > leftBorder.x &&
                        (word.x + word.x0) < rightBorder.x &&
                        (word.y + word.y1) > leftBorder.y &&
                        (word.y + word.y0) < rightBorder.y;
                };
                WordCloud.prototype.getCanvasContext = function () {
                    if (!this.canvasViewport)
                        return null;
                    this.canvas.width = 1;
                    this.canvas.height = 1;
                    var context = this.canvas.getContext("2d");
                    this.canvas.width = this.canvasViewport.width << 5;
                    this.canvas.height = this.canvasViewport.height;
                    context = this.canvas.getContext("2d");
                    context.fillStyle = context.strokeStyle = "red";
                    context.textAlign = "center";
                    return context;
                };
                WordCloud.prototype.getReducedText = function (texts) {
                    var brokenStrings = [];
                    brokenStrings = this.getBrokenWords(texts);
                    return brokenStrings.reduce(function (previousValue, currentValue) {
                        if (!previousValue.some(function (value) {
                            if (value.index !== currentValue.index && value.text === currentValue.text) {
                                value.count += currentValue.count;
                                return true;
                            }
                            return false;
                        })) {
                            previousValue.push(currentValue);
                        }
                        return previousValue;
                    }, []);
                };
                WordCloud.prototype.getBrokenWords = function (words) {
                    var _this = this;
                    var brokenStrings = [], whiteSpaceRegExp = /\s/, punctuatuinRegExp;
                    if (!this.settings.isBrokenText)
                        return words;
                    punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim");
                    words.forEach(function (item) {
                        if (typeof item.text === "string") {
                            var words_1;
                            words_1 = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp);
                            if (_this.settings.isRemoveStopWords) {
                                var stopWords = _this.settings.stopWordsArray;
                                if (_this.settings.isDefaultStopWords)
                                    stopWords = stopWords.concat(WordCloud.StopWords);
                                words_1 = words_1.filter(function (value) {
                                    return value.length > 0 && !stopWords.some(function (removeWord) {
                                        return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
                                    });
                                });
                            }
                            words_1.forEach(function (element) {
                                if (element.length > 0 && !whiteSpaceRegExp.test(element)) {
                                    brokenStrings.push({
                                        text: element,
                                        count: item.count,
                                        index: item.index,
                                        selectionId: item.selectionId,
                                        color: item.color
                                    });
                                }
                            });
                        }
                        else
                            brokenStrings.push(item);
                    });
                    return brokenStrings;
                };
                WordCloud.prototype.getWords = function (values) {
                    var _this = this;
                    var sortedValues, minValue = 0, maxValue = 0, valueFormatter = this.settings.valueFormatter;
                    if (!values || !(values.length >= 1))
                        return [];
                    sortedValues = values.sort(function (a, b) {
                        return b.count - a.count;
                    });
                    minValue = sortedValues[sortedValues.length - 1].count;
                    maxValue = sortedValues[0].count;
                    var returnValues = values.map(function (value) {
                        return {
                            text: valueFormatter.format(value.text),
                            size: _this.getFontSize(value.count, minValue, maxValue),
                            x: 0,
                            y: 0,
                            rotate: _this.getAngle(),
                            padding: 1,
                            width: 0,
                            height: 0,
                            xOff: 0,
                            yOff: 0,
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            color: value.color,
                            selectionId: value.selectionId,
                            wordIndex: value.index
                        };
                    });
                    this.dataBeforeRender = returnValues;
                    return returnValues;
                };
                WordCloud.prototype.getFontSize = function (value, minValue, maxValue, scaleType) {
                    if (scaleType === void 0) { scaleType = WordCloudScaleType.value; }
                    var weight, fontSize, maxFontSize, minFontSize;
                    minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize));
                    maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize));
                    if (minFontSize > maxFontSize) {
                        var buffer = minFontSize;
                        minFontSize = maxFontSize;
                        maxFontSize = buffer;
                    }
                    switch (scaleType) {
                        case WordCloudScaleType.logn: {
                            weight = Math.log(value);
                        }
                        case WordCloudScaleType.sqrt: {
                            weight = Math.sqrt(value);
                        }
                        case WordCloudScaleType.value: {
                            weight = value;
                        }
                    }
                    fontSize = weight > minValue
                        ? (maxFontSize * (weight - minValue)) / (maxValue - minValue)
                        : 0;
                    fontSize = (fontSize * 100) / maxFontSize;
                    fontSize = (fontSize * (maxFontSize - minFontSize)) / 100 + minFontSize;
                    return fontSize;
                };
                WordCloud.prototype.getAngle = function () {
                    if (!this.settings ||
                        !this.settings.isRotateText)
                        return 0;
                    var minAngle, maxAngle, maxNumberOfOrientations, angle;
                    maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0));
                    minAngle = this.parseNumber(this.settings.minAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle);
                    maxAngle = this.parseNumber(this.settings.maxAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle);
                    if (minAngle > maxAngle) {
                        var buffer = minAngle;
                        minAngle = maxAngle;
                        maxAngle = buffer;
                    }
                    angle = Math.abs(((maxAngle - minAngle) / maxNumberOfOrientations) * Math.floor(Math.random() * maxNumberOfOrientations));
                    return maxNumberOfOrientations !== 0 ? minAngle + angle : 0;
                };
                WordCloud.prototype.update = function (visualUpdateOptions) {
                    var _this = this;
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.viewport ||
                        !visualUpdateOptions.dataViews ||
                        !visualUpdateOptions.dataViews[0] ||
                        !visualUpdateOptions.viewport ||
                        !(visualUpdateOptions.viewport.height >= 0) ||
                        !(visualUpdateOptions.viewport.width >= 0))
                        return;
                    this.visualUpdateOptions = visualUpdateOptions;
                    this.layout.viewport = this.visualUpdateOptions.viewport;
                    var dataView = visualUpdateOptions.dataViews[0];
                    if (this.layout.viewportInIsZero)
                        return;
                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
                    this.UpdateSize();
                    this.data = this.converter(dataView);
                    if (!this.data)
                        return;
                    this.settings = this.data.settings;
                    this.wordCloudTexts = this.data.texts;
                    this.computePositions(this.getWords(this.getReducedText(this.data.texts)), function (wordCloudDataView) { return _this.render(wordCloudDataView); });
                    if (visualUpdateOptions !== this.visualUpdateOptions)
                        this.update(this.visualUpdateOptions);
                };
                WordCloud.prototype.UpdateSize = function () {
                    var fakeWidth, fakeHeight, ratio;
                    ratio = Math.sqrt((this.fakeViewport.width * this.fakeViewport.height)
                        / (this.layout.viewportIn.width * this.layout.viewportIn.height));
                    if (isNaN(ratio))
                        fakeHeight = fakeWidth = 1;
                    else {
                        fakeHeight = this.layout.viewportIn.height * ratio;
                        fakeWidth = this.layout.viewportIn.width * ratio;
                    }
                    this.specialViewport = {
                        height: fakeHeight,
                        width: fakeWidth
                    };
                    this.root.attr({
                        "height": this.layout.viewport.height,
                        "width": this.layout.viewport.width
                    });
                };
                WordCloud.prototype.render = function (wordCloudDataView) {
                    var _this = this;
                    if (!wordCloudDataView ||
                        !wordCloudDataView.data)
                        return;
                    this.wordCloudDataView = wordCloudDataView;
                    var animatedWordSelection, wordElements = this.main
                        .select(WordCloud.Words.selector)
                        .selectAll(WordCloud.Word.selector);
                    this.wordsSelection = wordElements.data(wordCloudDataView.data);
                    this.animation(this.wordsSelection, this.durationAnimations)
                        .attr("transform", function (item) { return (visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")"); })
                        .style({
                        "font-size": (function (item) { return ("" + item.size + WordCloud.Size); }),
                        "fill": (function (item) { return item.color; }),
                    });
                    animatedWordSelection = this.wordsSelection
                        .enter()
                        .append("svg:text")
                        .attr("transform", function (item) { return (visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")"); })
                        .style("font-size", "1px");
                    this.wordsSelection.on("click", function (item) {
                        _this.selectionManager
                            .select(item.selectionId, d3.event.ctrlKey)
                            .then(function () { return _this.setSelection(_this.wordsSelection); });
                        d3.event.stopPropagation();
                    });
                    this.animation(animatedWordSelection, this.durationAnimations)
                        .style({
                        "font-size": (function (item) { return ("" + item.size + WordCloud.Size); }),
                        "fill": (function (item) { return item.color; }),
                    });
                    this.wordsSelection
                        .text(function (item) { return item.text; })
                        .classed(WordCloud.Word["class"], true);
                    this.wordsSelection.exit().remove();
                    this.setSelection(this.wordsSelection);
                    setTimeout(function () {
                        if (_this.root)
                            _this.scaleMainView(wordCloudDataView, wordElements[0].length && _this.durationAnimations);
                    }, this.durationAnimations + WordCloud.RenderDelay);
                };
                WordCloud.prototype.setSelection = function (selection) {
                    var selectionIds = this.selectionManager.getSelectionIds();
                    if (selectionIds.some(function (x) { return !selection.data().some(function (d) { return d.selectionId.getKey() === x.getKey(); }); })) {
                        this.selectionManager.clear();
                        selectionIds = [];
                    }
                    if (!selectionIds.length) {
                        this.setOpacity(selection, WordCloud.MaxOpacity, true);
                        return;
                    }
                    var selectedColumns = selection.filter(function (x) {
                        return selectionIds.some(function (y) { return y.getKey() === x.selectionId.getKey(); });
                    });
                    this.setOpacity(selection, WordCloud.MinOpacity);
                    this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
                };
                WordCloud.prototype.setOpacity = function (element, opacityValue, disableAnimation) {
                    if (disableAnimation === void 0) { disableAnimation = false; }
                    var elementAnimation = disableAnimation ? element : this.animation(element);
                    elementAnimation.style("fill-opacity", opacityValue);
                };
                WordCloud.prototype.scaleMainView = function (wordCloudDataView, durationAnimation) {
                    if (durationAnimation === void 0) { durationAnimation = 0; }
                    if (!wordCloudDataView ||
                        !wordCloudDataView.leftBorder ||
                        !wordCloudDataView.rightBorder)
                        return;
                    var scale = 1, mainSVGRect = this.main.node()["getBBox"](), leftBorder = wordCloudDataView.leftBorder, rightBorder = wordCloudDataView.rightBorder, width2, height2, scaleByX, scaleByY;
                    scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x);
                    scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y);
                    scale = Math.min(scaleByX, scaleByY);
                    width2 = this.layout.margin.left + (mainSVGRect.x * scale * -1)
                        + (this.layout.viewportIn.width - (mainSVGRect.width * scale)) / 2;
                    height2 = this.layout.margin.top + (mainSVGRect.y * scale * -1)
                        + (this.layout.viewportIn.height - (mainSVGRect.height * scale)) / 2;
                    this.animation(this.main, durationAnimation)
                        .attr("transform", visuals.SVGUtil.translate(width2, height2) + "scale(" + scale + ")");
                };
                WordCloud.prototype.enumerateObjectInstances = function (options) {
                    var _this = this;
                    var instances = [];
                    if (!this.settings)
                        return instances;
                    switch (options.objectName) {
                        case "general": {
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    maxNumberOfWords: this.settings.maxNumberOfWords,
                                    minFontSize: this.settings.minFontSize,
                                    maxFontSize: this.settings.maxFontSize,
                                    isBrokenText: this.settings.isBrokenText
                                }
                            };
                            instances.push(general);
                            break;
                        }
                        case "dataPoint": {
                            if (!this.wordCloudDataView ||
                                !this.wordCloudDataView.data)
                                return;
                            var dataPoints = this.dataBeforeRender;
                            var wordCategoriesIndex = [];
                            dataPoints.forEach(function (item) {
                                if (wordCategoriesIndex.indexOf(item.wordIndex) === -1) {
                                    wordCategoriesIndex.push(item.wordIndex);
                                    instances.push({
                                        objectName: "dataPoint",
                                        displayName: _this.data.texts[item.wordIndex].text,
                                        selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), false),
                                        properties: {
                                            fill: { solid: { color: item.color } }
                                        }
                                    });
                                }
                            });
                            break;
                        }
                        case "rotateText": {
                            var rotateText = {
                                objectName: "rotateText",
                                displayName: "Rotate Text",
                                selector: null,
                                properties: {
                                    show: this.settings.isRotateText,
                                    minAngle: this.settings.minAngle,
                                    maxAngle: this.settings.maxAngle,
                                    maxNumberOfOrientations: this.settings.maxNumberOfOrientations
                                }
                            };
                            instances.push(rotateText);
                            break;
                        }
                        case "stopWords": {
                            var stopWords = {
                                objectName: "stopWords",
                                displayName: "Stop Words",
                                selector: null,
                                properties: {
                                    show: this.settings.isRemoveStopWords,
                                    isDefaultStopWords: this.settings.isDefaultStopWords,
                                    words: this.settings.stopWords ||
                                        this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)
                                }
                            };
                            instances.push(stopWords);
                            break;
                        }
                    }
                    return instances;
                };
                WordCloud.prototype.animation = function (element, duration, callback) {
                    if (duration === void 0) { duration = 0; }
                    return element
                        .transition()
                        .duration(duration)
                        .each("end", callback);
                };
                WordCloud.prototype.destroy = function () {
                    this.root = null;
                    this.canvas = null;
                };
                WordCloud.ClassName = "wordCloud";
                WordCloud.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        },
                        maxNumberOfWords: {
                            objectName: "general",
                            propertyName: "maxNumberOfWords"
                        },
                        minFontSize: {
                            objectName: "general",
                            propertyName: "minFontSize"
                        },
                        maxFontSize: {
                            objectName: "general",
                            propertyName: "maxFontSize"
                        },
                        isBrokenText: {
                            objectName: "general",
                            propertyName: "isBrokenText"
                        },
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    stopWords: {
                        show: {
                            objectName: "stopWords",
                            propertyName: "show"
                        },
                        isDefaultStopWords: {
                            objectName: "stopWords",
                            propertyName: "isDefaultStopWords"
                        },
                        words: {
                            objectName: "stopWords",
                            propertyName: "words"
                        },
                    },
                    rotateText: {
                        show: {
                            objectName: "rotateText",
                            propertyName: "show"
                        },
                        minAngle: {
                            objectName: "rotateText",
                            propertyName: "minAngle"
                        },
                        maxAngle: {
                            objectName: "rotateText",
                            propertyName: "maxAngle"
                        },
                        maxNumberOfOrientations: {
                            objectName: "rotateText",
                            propertyName: "maxNumberOfOrientations"
                        }
                    }
                };
                WordCloud.Words = {
                    "class": "words",
                    selector: ".words"
                };
                WordCloud.Word = {
                    "class": "word",
                    selector: ".word"
                };
                WordCloud.Size = "px";
                WordCloud.StopWordsDelemiter = " ";
                WordCloud.Radians = Math.PI / 180;
                WordCloud.MinAngle = -180;
                WordCloud.MaxAngle = 180;
                WordCloud.MaxNumberOfWords = 2500;
                WordCloud.MinOpacity = 0.2;
                WordCloud.MaxOpacity = 1;
                WordCloud.capabilities = {
                    dataRoles: [{
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        }],
                    dataViewMappings: [{
                            conditions: [{
                                    "Category": {
                                        min: 1,
                                        max: 1
                                    },
                                    "Values": {
                                        min: 0,
                                        max: 1
                                    }
                                }],
                            categorical: {
                                categories: {
                                    for: { in: "Category" },
                                    dataReductionAlgorithm: { top: { count: WordCloud.MaxNumberOfWords } }
                                },
                                values: {
                                    for: { in: "Values" }
                                }
                            }
                        }],
                    sorting: {
                        implicit: {
                            clauses: [{
                                    role: "Values",
                                    direction: 2 /*SortDirection.Descending*/ //Constant SortDirection.Descending currently is not supported on the msit
                                }]
                        }
                    },
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    }
                                },
                                maxNumberOfWords: {
                                    displayName: "Max number of words",
                                    type: { numeric: true }
                                },
                                minFontSize: {
                                    displayName: "Min Font",
                                    type: { numeric: true }
                                },
                                maxFontSize: {
                                    displayName: "Max Font",
                                    type: { numeric: true }
                                },
                                isBrokenText: {
                                    displayName: "Word-breaking",
                                    type: { bool: true }
                                },
                                isRemoveStopWords: {
                                    displayName: "Stop Words",
                                    type: { bool: true }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: "Data colors",
                            properties: {
                                fill: {
                                    displayName: "Fill",
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        stopWords: {
                            displayName: "Stop Words",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                isDefaultStopWords: {
                                    displayName: "Default Stop Words",
                                    type: { bool: true }
                                },
                                words: {
                                    displayName: "Words",
                                    type: { text: true }
                                }
                            }
                        },
                        rotateText: {
                            displayName: "Rotate Text",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                minAngle: {
                                    displayName: "Min Angle",
                                    type: { numeric: true }
                                },
                                maxAngle: {
                                    displayName: "Max Angle",
                                    type: { numeric: true }
                                },
                                maxNumberOfOrientations: {
                                    displayName: "Max number of orientations",
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                WordCloud.Punctuation = [
                    "!", ".", ":", "'", ";", ",", "!",
                    "@", "#", "$", "%", "^", "&", "*",
                    "(", ")", "[", "]", "\"", "\\", "/",
                    "-", "_", "+", "="
                ];
                WordCloud.StopWords = [
                    "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an",
                    "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot",
                    "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get",
                    "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i",
                    "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may",
                    "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often",
                    "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should",
                    "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these",
                    "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what",
                    "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet",
                    "you", "your"
                ];
                WordCloud.DefaultSettings = {
                    minFontSize: 20,
                    maxFontSize: 100,
                    minAngle: -60,
                    maxAngle: 90,
                    maxNumberOfOrientations: 2,
                    isRotateText: false,
                    isBrokenText: true,
                    isRemoveStopWords: false,
                    stopWordsArray: [],
                    stopWords: undefined,
                    isDefaultStopWords: false,
                    maxNumberOfWords: 200
                };
                WordCloud.RenderDelay = 50;
                WordCloud.DefaultMargin = {
                    top: 10,
                    right: 10,
                    bottom: 10,
                    left: 10
                };
                return WordCloud;
            })();
            samples.WordCloud = WordCloud;
            var explore;
            (function (explore) {
                var util;
                (function (util) {
                    function hexToRgb(hex) {
                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                            return r + r + g + g + b + b;
                        });
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
                    }
                    util.hexToRgb = hexToRgb;
                    function getRandomColor() {
                        var red = Math.floor(Math.random() * 255), green = Math.floor(Math.random() * 255), blue = Math.floor(Math.random() * 255);
                        return "rgb(" + red + "," + green + "," + blue + ")";
                    }
                    util.getRandomColor = getRandomColor;
                })(util = explore.util || (explore.util = {}));
            })(explore || (explore = {}));
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            samples.consoleWriterCapabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                    },
                    {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                    },
                ],
                dataViewMappings: [{
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                        },
                    }],
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
            };
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            plugins.sunburst = {
                name: 'sunburst',
                watermarkKey: 'defaultWatermark',
                capabilities: visuals.samples.Sunburst.capabilities,
                create: function () { return new visuals.samples.Sunburst(); }
            };
            plugins.consoleWriter = {
                name: 'consoleWriter',
                capabilities: visuals.samples.consoleWriterCapabilities,
                create: function () { return new visuals.samples.ConsoleWriter(); }
            };
            plugins.helloIVisual = {
                name: 'helloIVisual',
                capabilities: visuals.samples.HelloIVisual.capabilities,
                create: function () { return new visuals.samples.HelloIVisual(); }
            };
            plugins.asterPlot = {
                name: 'asterPlot',
                capabilities: visuals.samples.AsterPlot.capabilities,
                create: function () { return new visuals.samples.AsterPlot(); }
            };
            plugins.streamGraph = {
                name: 'streamGraph',
                watermarkKey: 'lineChart',
                capabilities: visuals.samples.StreamGraph.capabilities,
                create: function () { return new visuals.samples.StreamGraph(); }
            };
            plugins.radarChart = {
                name: 'radarChart',
                capabilities: visuals.samples.RadarChart.capabilities,
                create: function () { return new visuals.samples.RadarChart(); }
            };
            plugins.dotPlot = {
                name: 'dotPlot',
                capabilities: visuals.samples.DotPlot.capabilities,
                create: function () { return new visuals.samples.DotPlot(); }
            };
            plugins.histogram = {
                name: "histogram",
                capabilities: visuals.samples.Histogram.capabilities,
                create: function () { return new visuals.samples.Histogram(); }
            };
            plugins.areaRangeChart = {
                name: 'areaRangeChart',
                capabilities: visuals.samples.AreaRangeChart.capabilities,
                create: function () { return new visuals.samples.AreaRangeChart(); }
            };
            plugins.chicletSlicer = {
                name: 'chicletSlicer',
                capabilities: visuals.samples.ChicletSlicer.capabilities,
                create: function () { return new visuals.samples.ChicletSlicer(); }
            };
            plugins.timeline = {
                name: 'timeline',
                capabilities: visuals.samples.Timeline.capabilities,
                create: function () { return new visuals.samples.Timeline(); }
            };
            plugins.tornadoChart = {
                name: "tornadoChart",
                capabilities: visuals.samples.TornadoChart.capabilities,
                create: function () { return new visuals.samples.TornadoChart(); }
            };
            plugins.sankeyDiagram = {
                name: "sankeyDiagram",
                capabilities: visuals.samples.SankeyDiagram.capabilities,
                create: function () { return new visuals.samples.SankeyDiagram(); }
            };
            plugins.wordCloud = {
                name: "wordCloud",
                capabilities: visuals.samples.WordCloud.capabilities,
                create: function () { return new visuals.samples.WordCloud(); }
            };
            plugins.enhancedScatterChart = {
                name: 'enhancedScatterChart',
                capabilities: visuals.samples.EnhancedScatterChart.capabilities,
                create: function () { return new visuals.samples.EnhancedScatterChart(); }
            };
            plugins.bulletChart = {
                name: "bulletChart",
                capabilities: visuals.samples.BulletChart.capabilities,
                create: function () { return new visuals.samples.BulletChart(); }
            };
            plugins.forceGraph = {
                name: "forceGraph",
                capabilities: visuals.samples.ForceGraph.capabilities,
                create: function () { return new visuals.samples.ForceGraph(); }
            };
            plugins.chordChart = {
                name: "chordChart",
                capabilities: visuals.samples.ChordChart.capabilities,
                create: function () { return new visuals.samples.ChordChart(); }
            };
            plugins.mekkoChart = {
                name: 'mekkoChart',
                watermarkKey: 'mekko',
                capabilities: visuals.samples.MekkoChart.capabilities,
                create: function () { return new visuals.samples.MekkoChart({ chartType: 0 /* HundredPercentStackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualPluginFactory;
        (function (visualPluginFactory) {
            var CustomVisualPluginService = (function (_super) {
                __extends(CustomVisualPluginService, _super);
                function CustomVisualPluginService() {
                    _super.call(this, {});
                    this.initCustomVisualPlugins();
                }
                CustomVisualPluginService.prototype.getVisuals = function () {
                    var registry = this.customVisualPlugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                CustomVisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return null;
                    }
                    var plugin = this.customVisualPlugins[type];
                    if (!plugin) {
                        return null;
                    }
                    return plugin;
                };
                CustomVisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin) {
                        return plugin.capabilities;
                    }
                    return {};
                };
                CustomVisualPluginService.prototype.initCustomVisualPlugins = function () {
                    // Radar Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, function () { return new visuals.samples.RadarChart({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // DotPlot
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, function () { return new visuals.samples.DotPlot({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Histogram
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, function () { return new visuals.samples.Histogram({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Area Range Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.areaRangeChart, function () { return new visuals.samples.AreaRangeChart({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Chiclet Slicer
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, function () { return new visuals.samples.ChicletSlicer({
                        behavior: new visuals.samples.ChicletSlicerWebBehavior()
                    }); });
                    // Tornado Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, function () { return new visuals.samples.TornadoChart({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Sankey Diagram
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, function () { return new visuals.samples.SankeyDiagram(); });
                    // Word Cloud
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, function () { return new visuals.samples.WordCloud({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Enhanced Scatter Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, function () { return new visuals.samples.EnhancedScatterChart(); });
                    // Bullet Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, function () { return new visuals.samples.BulletChart(); });
                    // Force Graph
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, function () { return new visuals.samples.ForceGraph(); });
                    // Mekko Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, function () { return new visuals.samples.MekkoChart({
                        chartType: 0 /* HundredPercentStackedColumn */,
                        isScrollable: true,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    }); });
                };
                return CustomVisualPluginService;
            })(visualPluginFactory.VisualPluginService);
            visualPluginFactory.CustomVisualPluginService = CustomVisualPluginService;
            function createCustomVisualPluginService() {
                return new CustomVisualPluginService();
            }
            visualPluginFactory.createCustomVisualPluginService = createCustomVisualPluginService;
        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

//# sourceMappingURL=CustomVisuals.js.map
